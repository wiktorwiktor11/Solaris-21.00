#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EntityActor

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "EntityCore_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "EntityActor_structs.hpp"


namespace SDK
{

// Class EntityActor.EntityDynamicActivationComponent
// 0x0038 (0x00B8 - 0x0080)
class UEntityDynamicActivationComponent : public UEntityEnableableComponent
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionTargetTime;                              // 0x0088(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTargetState;                                      // 0x008C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEntityComponent*>               LinkedComponents;                                  // 0x0090(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnabledChanged(bool bIsEnabled);
	void OnRep_TransitionTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityDynamicActivationComponent">();
	}
	static class UEntityDynamicActivationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityDynamicActivationComponent>();
	}
};
static_assert(alignof(UEntityDynamicActivationComponent) == 0x000008, "Wrong alignment on UEntityDynamicActivationComponent");
static_assert(sizeof(UEntityDynamicActivationComponent) == 0x0000B8, "Wrong size on UEntityDynamicActivationComponent");
static_assert(offsetof(UEntityDynamicActivationComponent, TransitionTargetTime) == 0x000088, "Member 'UEntityDynamicActivationComponent::TransitionTargetTime' has a wrong offset!");
static_assert(offsetof(UEntityDynamicActivationComponent, bTargetState) == 0x00008C, "Member 'UEntityDynamicActivationComponent::bTargetState' has a wrong offset!");
static_assert(offsetof(UEntityDynamicActivationComponent, LinkedComponents) == 0x000090, "Member 'UEntityDynamicActivationComponent::LinkedComponents' has a wrong offset!");

// Class EntityActor.EntityActorPlayerComponent
// 0x0078 (0x00E0 - 0x0068)
class UEntityActorPlayerComponent : public UEntityDataBackedComponent
{
public:
	TSoftObjectPtr<class APlayerController>       PlayerControllerCache;                             // 0x0068(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class APlayerState>            PlayerStateCache;                                  // 0x0090(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x00B8(0x0028)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorPlayerComponent">();
	}
	static class UEntityActorPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorPlayerComponent>();
	}
};
static_assert(alignof(UEntityActorPlayerComponent) == 0x000008, "Wrong alignment on UEntityActorPlayerComponent");
static_assert(sizeof(UEntityActorPlayerComponent) == 0x0000E0, "Wrong size on UEntityActorPlayerComponent");
static_assert(offsetof(UEntityActorPlayerComponent, PlayerControllerCache) == 0x000068, "Member 'UEntityActorPlayerComponent::PlayerControllerCache' has a wrong offset!");
static_assert(offsetof(UEntityActorPlayerComponent, PlayerStateCache) == 0x000090, "Member 'UEntityActorPlayerComponent::PlayerStateCache' has a wrong offset!");
static_assert(offsetof(UEntityActorPlayerComponent, PlayerId) == 0x0000B8, "Member 'UEntityActorPlayerComponent::PlayerId' has a wrong offset!");

// Class EntityActor.EntityActorPositionComponent
// 0x0020 (0x0088 - 0x0068)
class UEntityActorPositionComponent : public UEntityPositionComponent
{
public:
	struct FVector                                ShadowVar_Location;                                // 0x0068(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRootComponentChanged(class USceneComponent* InRootComponent, bool bIsRootComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorPositionComponent">();
	}
	static class UEntityActorPositionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorPositionComponent>();
	}
};
static_assert(alignof(UEntityActorPositionComponent) == 0x000008, "Wrong alignment on UEntityActorPositionComponent");
static_assert(sizeof(UEntityActorPositionComponent) == 0x000088, "Wrong size on UEntityActorPositionComponent");
static_assert(offsetof(UEntityActorPositionComponent, ShadowVar_Location) == 0x000068, "Member 'UEntityActorPositionComponent::ShadowVar_Location' has a wrong offset!");

// Class EntityActor.ActorToEntityAdapterComponent
// 0x0020 (0x00C0 - 0x00A0)
class UActorToEntityAdapterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEntityComponent*>               SerializedComponents;                              // 0x00A8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorToEntityAdapterComponent">();
	}
	static class UActorToEntityAdapterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorToEntityAdapterComponent>();
	}
};
static_assert(alignof(UActorToEntityAdapterComponent) == 0x000008, "Wrong alignment on UActorToEntityAdapterComponent");
static_assert(sizeof(UActorToEntityAdapterComponent) == 0x0000C0, "Wrong size on UActorToEntityAdapterComponent");
static_assert(offsetof(UActorToEntityAdapterComponent, SerializedComponents) == 0x0000A8, "Member 'UActorToEntityAdapterComponent::SerializedComponents' has a wrong offset!");

// Class EntityActor.EntityAbilityInterface
// 0x0000 (0x0028 - 0x0028)
class IEntityAbilityInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityAbilityInterface">();
	}
	static class IEntityAbilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEntityAbilityInterface>();
	}
};
static_assert(alignof(IEntityAbilityInterface) == 0x000008, "Wrong alignment on IEntityAbilityInterface");
static_assert(sizeof(IEntityAbilityInterface) == 0x000028, "Wrong size on IEntityAbilityInterface");

// Class EntityActor.EntityActorCollisionComponent
// 0x0080 (0x0100 - 0x0080)
class UEntityActorCollisionComponent : public UEntityEnableableComponent
{
public:
	uint8                                         Pad_80[0x48];                                      // 0x0080(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ShadowVar_CollisionProfileName;                    // 0x00C8(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPrimitiveComponent>     PrimitiveComponentCache;                           // 0x00D0(0x0028)(ExportObject, Net, Transient, InstancedReference, RepNotify, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x2];                                       // 0x00F8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionShapeMode                           CollisionShapeMode;                                // 0x00FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FB[0x5];                                       // 0x00FB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnabledChanged(bool bIsEnabled);
	void OnNativeComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnNativeComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnNativeComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_CollisionProfileName();
	void OnRep_PrimitiveComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorCollisionComponent">();
	}
	static class UEntityActorCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorCollisionComponent>();
	}
};
static_assert(alignof(UEntityActorCollisionComponent) == 0x000008, "Wrong alignment on UEntityActorCollisionComponent");
static_assert(sizeof(UEntityActorCollisionComponent) == 0x000100, "Wrong size on UEntityActorCollisionComponent");
static_assert(offsetof(UEntityActorCollisionComponent, ShadowVar_CollisionProfileName) == 0x0000C8, "Member 'UEntityActorCollisionComponent::ShadowVar_CollisionProfileName' has a wrong offset!");
static_assert(offsetof(UEntityActorCollisionComponent, PrimitiveComponentCache) == 0x0000D0, "Member 'UEntityActorCollisionComponent::PrimitiveComponentCache' has a wrong offset!");
static_assert(offsetof(UEntityActorCollisionComponent, CollisionShapeMode) == 0x0000FA, "Member 'UEntityActorCollisionComponent::CollisionShapeMode' has a wrong offset!");

// Class EntityActor.EntityActorComponent
// 0x0030 (0x0090 - 0x0060)
class UEntityActorComponent : public UEntityComponent
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        ActorComponent;                                    // 0x0068(0x0008)(Edit, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCreatedActorComponent;                            // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x1F];                                      // 0x0071(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActorComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorComponent">();
	}
	static class UEntityActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorComponent>();
	}
};
static_assert(alignof(UEntityActorComponent) == 0x000008, "Wrong alignment on UEntityActorComponent");
static_assert(sizeof(UEntityActorComponent) == 0x000090, "Wrong size on UEntityActorComponent");
static_assert(offsetof(UEntityActorComponent, ActorComponent) == 0x000068, "Member 'UEntityActorComponent::ActorComponent' has a wrong offset!");
static_assert(offsetof(UEntityActorComponent, bCreatedActorComponent) == 0x000070, "Member 'UEntityActorComponent::bCreatedActorComponent' has a wrong offset!");

// Class EntityActor.EntityActorCustomReplicationComponent
// 0x0008 (0x0068 - 0x0060)
class UEntityActorCustomReplicationComponent final : public UEntityComponent
{
public:
	EEntityActorReplicationOverrideType           ReplicationOverride;                               // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEntityActorReplicationRelevancyBucketType    ReplicationRelevancyBucketType;                    // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomReplicationRelevancyRange;                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorCustomReplicationComponent">();
	}
	static class UEntityActorCustomReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorCustomReplicationComponent>();
	}
};
static_assert(alignof(UEntityActorCustomReplicationComponent) == 0x000008, "Wrong alignment on UEntityActorCustomReplicationComponent");
static_assert(sizeof(UEntityActorCustomReplicationComponent) == 0x000068, "Wrong size on UEntityActorCustomReplicationComponent");
static_assert(offsetof(UEntityActorCustomReplicationComponent, ReplicationOverride) == 0x000060, "Member 'UEntityActorCustomReplicationComponent::ReplicationOverride' has a wrong offset!");
static_assert(offsetof(UEntityActorCustomReplicationComponent, ReplicationRelevancyBucketType) == 0x000061, "Member 'UEntityActorCustomReplicationComponent::ReplicationRelevancyBucketType' has a wrong offset!");
static_assert(offsetof(UEntityActorCustomReplicationComponent, CustomReplicationRelevancyRange) == 0x000064, "Member 'UEntityActorCustomReplicationComponent::CustomReplicationRelevancyRange' has a wrong offset!");

// Class EntityActor.EntityActorLocalInputComponent
// 0x0008 (0x0068 - 0x0060)
class UEntityActorLocalInputComponent final : public UEntityComponent
{
public:
	EAutoReceiveInput                             AutoReceiveControllerInput;                        // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorLocalInputComponent">();
	}
	static class UEntityActorLocalInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorLocalInputComponent>();
	}
};
static_assert(alignof(UEntityActorLocalInputComponent) == 0x000008, "Wrong alignment on UEntityActorLocalInputComponent");
static_assert(sizeof(UEntityActorLocalInputComponent) == 0x000068, "Wrong size on UEntityActorLocalInputComponent");
static_assert(offsetof(UEntityActorLocalInputComponent, AutoReceiveControllerInput) == 0x000060, "Member 'UEntityActorLocalInputComponent::AutoReceiveControllerInput' has a wrong offset!");

// Class EntityActor.EntityActorRotationComponent
// 0x0028 (0x0090 - 0x0068)
class UEntityActorRotationComponent : public UEntityRotationComponent
{
public:
	struct FRotator                               ShadowVar_Rotation;                                // 0x0068(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRootComponentChanged(class USceneComponent* InRootComponent, bool bIsRootComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorRotationComponent">();
	}
	static class UEntityActorRotationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorRotationComponent>();
	}
};
static_assert(alignof(UEntityActorRotationComponent) == 0x000008, "Wrong alignment on UEntityActorRotationComponent");
static_assert(sizeof(UEntityActorRotationComponent) == 0x000090, "Wrong size on UEntityActorRotationComponent");
static_assert(offsetof(UEntityActorRotationComponent, ShadowVar_Rotation) == 0x000068, "Member 'UEntityActorRotationComponent::ShadowVar_Rotation' has a wrong offset!");

// Class EntityActor.EntityActorScaleComponent
// 0x0020 (0x0088 - 0x0068)
class UEntityActorScaleComponent : public UEntityScaleComponent
{
public:
	struct FVector                                ShadowVar_Scale;                                   // 0x0068(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRootComponentChanged(class USceneComponent* InRootComponent, bool bIsRootComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorScaleComponent">();
	}
	static class UEntityActorScaleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorScaleComponent>();
	}
};
static_assert(alignof(UEntityActorScaleComponent) == 0x000008, "Wrong alignment on UEntityActorScaleComponent");
static_assert(sizeof(UEntityActorScaleComponent) == 0x000088, "Wrong size on UEntityActorScaleComponent");
static_assert(offsetof(UEntityActorScaleComponent, ShadowVar_Scale) == 0x000068, "Member 'UEntityActorScaleComponent::ShadowVar_Scale' has a wrong offset!");

// Class EntityActor.EntityActorSkeletalMeshRenderComponent
// 0x0020 (0x0080 - 0x0060)
class UEntityActorSkeletalMeshRenderComponent : public UEntityComponent
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAddedMeshRenderComponent;                         // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          ShadowVar_SkeletalMesh;                            // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionEnabled                             ShadowVar_EnableCollision;                         // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorSkeletalMeshRenderComponent">();
	}
	static class UEntityActorSkeletalMeshRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorSkeletalMeshRenderComponent>();
	}
};
static_assert(alignof(UEntityActorSkeletalMeshRenderComponent) == 0x000008, "Wrong alignment on UEntityActorSkeletalMeshRenderComponent");
static_assert(sizeof(UEntityActorSkeletalMeshRenderComponent) == 0x000080, "Wrong size on UEntityActorSkeletalMeshRenderComponent");
static_assert(offsetof(UEntityActorSkeletalMeshRenderComponent, bAddedMeshRenderComponent) == 0x000068, "Member 'UEntityActorSkeletalMeshRenderComponent::bAddedMeshRenderComponent' has a wrong offset!");
static_assert(offsetof(UEntityActorSkeletalMeshRenderComponent, ShadowVar_SkeletalMesh) == 0x000070, "Member 'UEntityActorSkeletalMeshRenderComponent::ShadowVar_SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UEntityActorSkeletalMeshRenderComponent, ShadowVar_EnableCollision) == 0x000078, "Member 'UEntityActorSkeletalMeshRenderComponent::ShadowVar_EnableCollision' has a wrong offset!");

// Class EntityActor.EntityActorStaticMeshRenderComponent
// 0x0018 (0x00A8 - 0x0090)
class UEntityActorStaticMeshRenderComponent : public UEntityActorComponent
{
public:
	TArray<class UMaterialInterface*>             ShadowVar_MeshMaterials;                           // 0x0090(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	ECollisionEnabled                             ShadowVar_EnableCollision;                         // 0x00A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShadowVar_MaxDrawDistance;                         // 0x00A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_EnableCollision();
	void OnRep_MaxDrawDistance();
	void OnRep_MeshMaterials();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorStaticMeshRenderComponent">();
	}
	static class UEntityActorStaticMeshRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorStaticMeshRenderComponent>();
	}
};
static_assert(alignof(UEntityActorStaticMeshRenderComponent) == 0x000008, "Wrong alignment on UEntityActorStaticMeshRenderComponent");
static_assert(sizeof(UEntityActorStaticMeshRenderComponent) == 0x0000A8, "Wrong size on UEntityActorStaticMeshRenderComponent");
static_assert(offsetof(UEntityActorStaticMeshRenderComponent, ShadowVar_MeshMaterials) == 0x000090, "Member 'UEntityActorStaticMeshRenderComponent::ShadowVar_MeshMaterials' has a wrong offset!");
static_assert(offsetof(UEntityActorStaticMeshRenderComponent, ShadowVar_EnableCollision) == 0x0000A0, "Member 'UEntityActorStaticMeshRenderComponent::ShadowVar_EnableCollision' has a wrong offset!");
static_assert(offsetof(UEntityActorStaticMeshRenderComponent, ShadowVar_MaxDrawDistance) == 0x0000A4, "Member 'UEntityActorStaticMeshRenderComponent::ShadowVar_MaxDrawDistance' has a wrong offset!");

// Class EntityActor.EntityActorSubsystem
// 0x0038 (0x0068 - 0x0030)
class UEntityActorSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorSubsystem">();
	}
	static class UEntityActorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorSubsystem>();
	}
};
static_assert(alignof(UEntityActorSubsystem) == 0x000008, "Wrong alignment on UEntityActorSubsystem");
static_assert(sizeof(UEntityActorSubsystem) == 0x000068, "Wrong size on UEntityActorSubsystem");

// Class EntityActor.EntityActorTextDisplayComponent
// 0x0028 (0x00B8 - 0x0090)
class UEntityActorTextDisplayComponent final : public UEntityActorComponent
{
public:
	class FText                                   DisplayText;                                       // 0x0090(0x0018)(Edit, Net, RepNotify, NativeAccessSpecifierPrivate)
	float                                         ShadowVar_WorldSize;                               // 0x00A8(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FColor                                 ShadowVar_TextRenderColor;                         // 0x00AC(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAddedTextRenderComponent;                         // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EHorizTextAligment GetHorizontalAlignment();
	struct FVector GetRelativeLocation();
	EVerticalTextAligment GetVerticalAlignment();
	void OnRep_DisplayText();
	void OnRep_TextRenderColor();
	void OnRep_WorldSize();
	void SetHorizontalAlignment(EHorizTextAligment Value);
	void SetRelativeLocation(const struct FVector& RelativeLocation);
	void SetRelativeRotation(const struct FRotator& RelativeRotation);
	void SetRelativeScale(const struct FVector& RelativeScale);
	void SetText(const class FText& Text);
	void SetTextRenderColor(const struct FColor& Value);
	void SetVerticalAlignment(EVerticalTextAligment Value);
	void SetWorldSize(float Value);

	class FText GetText() const;
	struct FColor GetTextRenderColor() const;
	float GetWorldSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorTextDisplayComponent">();
	}
	static class UEntityActorTextDisplayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorTextDisplayComponent>();
	}
};
static_assert(alignof(UEntityActorTextDisplayComponent) == 0x000008, "Wrong alignment on UEntityActorTextDisplayComponent");
static_assert(sizeof(UEntityActorTextDisplayComponent) == 0x0000B8, "Wrong size on UEntityActorTextDisplayComponent");
static_assert(offsetof(UEntityActorTextDisplayComponent, DisplayText) == 0x000090, "Member 'UEntityActorTextDisplayComponent::DisplayText' has a wrong offset!");
static_assert(offsetof(UEntityActorTextDisplayComponent, ShadowVar_WorldSize) == 0x0000A8, "Member 'UEntityActorTextDisplayComponent::ShadowVar_WorldSize' has a wrong offset!");
static_assert(offsetof(UEntityActorTextDisplayComponent, ShadowVar_TextRenderColor) == 0x0000AC, "Member 'UEntityActorTextDisplayComponent::ShadowVar_TextRenderColor' has a wrong offset!");
static_assert(offsetof(UEntityActorTextDisplayComponent, bAddedTextRenderComponent) == 0x0000B0, "Member 'UEntityActorTextDisplayComponent::bAddedTextRenderComponent' has a wrong offset!");

// Class EntityActor.EntityToActorAdapterComponent
// 0x0008 (0x0068 - 0x0060)
class UEntityToActorAdapterComponent final : public UEntityComponent
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityToActorAdapterComponent">();
	}
	static class UEntityToActorAdapterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityToActorAdapterComponent>();
	}
};
static_assert(alignof(UEntityToActorAdapterComponent) == 0x000008, "Wrong alignment on UEntityToActorAdapterComponent");
static_assert(sizeof(UEntityToActorAdapterComponent) == 0x000068, "Wrong size on UEntityToActorAdapterComponent");

// Class EntityActor.SimObject
// 0x0008 (0x0278 - 0x0270)
class ASimObject final : public AActor
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimObject">();
	}
	static class ASimObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASimObject>();
	}
};
static_assert(alignof(ASimObject) == 0x000008, "Wrong alignment on ASimObject");
static_assert(sizeof(ASimObject) == 0x000278, "Wrong size on ASimObject");

}

