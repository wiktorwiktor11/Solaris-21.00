#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Solaris

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "SolarisInterop_classes.hpp"


namespace SDK
{

// Class Solaris.SolarisGeneratedStruct
// 0x0010 (0x00D0 - 0x00C0)
class USolarisGeneratedStruct final : public UScriptStruct
{
public:
	class UFunction*                              InitFunction;                                      // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ModuleClass;                                       // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisGeneratedStruct">();
	}
	static class USolarisGeneratedStruct* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisGeneratedStruct>();
	}
};
static_assert(alignof(USolarisGeneratedStruct) == 0x000008, "Wrong alignment on USolarisGeneratedStruct");
static_assert(sizeof(USolarisGeneratedStruct) == 0x0000D0, "Wrong size on USolarisGeneratedStruct");
static_assert(offsetof(USolarisGeneratedStruct, InitFunction) == 0x0000C0, "Member 'USolarisGeneratedStruct::InitFunction' has a wrong offset!");
static_assert(offsetof(USolarisGeneratedStruct, ModuleClass) == 0x0000C8, "Member 'USolarisGeneratedStruct::ModuleClass' has a wrong offset!");

// Class Solaris.SolarisArrayLibrary
// 0x0000 (0x0028 - 0x0028)
class USolarisArrayLibrary final : public UObject
{
public:
	static int64 Add(const TArray<struct FGenericElementType>& Array, const struct FGenericElementType& new_item);
	static void Call(const TArray<struct FGenericElementType>& Array, int64 Index_0);
	static TArray<struct FGenericElementType> Concat(const TArray<struct FGenericElementType>& Lhs, const TArray<struct FGenericElementType>& Rhs);
	static TArray<struct FGenericElementType> ConcatEquals(TArray<struct FGenericElementType>* Lhs, const TArray<struct FGenericElementType>& Rhs);
	static void Empty(const TArray<struct FGenericElementType>& Array);
	static int64 Length(const TArray<struct FGenericElementType>& Array);
	static void Move(const TArray<struct FGenericElementType>& Target, const TArray<struct FGenericElementType>& Source);
	static void RefCall(const TArray<struct FGenericElementType>& Array, int64 Index_0);
	static void UnsafeCall(const TArray<struct FGenericElementType>& Array, int64 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisArrayLibrary">();
	}
	static class USolarisArrayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisArrayLibrary>();
	}
};
static_assert(alignof(USolarisArrayLibrary) == 0x000008, "Wrong alignment on USolarisArrayLibrary");
static_assert(sizeof(USolarisArrayLibrary) == 0x000028, "Wrong size on USolarisArrayLibrary");

// Class Solaris.SolarisMapLibrary
// 0x0000 (0x0028 - 0x0028)
class USolarisMapLibrary final : public UObject
{
public:
	static void Call(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, const struct FGenericKeyType& Key);
	static TMap<struct FGenericKeyType, int64> Concatenate(const TMap<struct FGenericKeyType, int64>& Lhs, const TMap<struct FGenericKeyType, int64>& Rhs);
	static int64 Count(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map);
	static struct FGenericKeyType GetKeyByIndex(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, int64 Index_0);
	static int64 GetNextValidIndex(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, int64 InitialIndex);
	static struct FGenericValueType GetValueByIndex(const TMap<struct FGenericKeyType, struct FGenericValueType>& Map, int64 Index_0);
	static void InitMap(TMap<struct FGenericKeyType, struct FGenericValueType>* Map);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisMapLibrary">();
	}
	static class USolarisMapLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisMapLibrary>();
	}
};
static_assert(alignof(USolarisMapLibrary) == 0x000008, "Wrong alignment on USolarisMapLibrary");
static_assert(sizeof(USolarisMapLibrary) == 0x000028, "Wrong size on USolarisMapLibrary");

// Class Solaris.SolarisCoroutineLibrary
// 0x0000 (0x0028 - 0x0028)
class USolarisCoroutineLibrary final : public UObject
{
public:
	static void TaskCancel(class UObject* task);
	static void TaskFree(class UObject* task);
	static void TaskGetReturnProperty(class UObject* task);
	static int64 TaskGetState(class UObject* task);
	static class UObject* TaskMake(class UClass* Type, class UObject* Caller, int64 CallerResumeState, int64 CallerCancelState, class UObject* OwnerInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisCoroutineLibrary">();
	}
	static class USolarisCoroutineLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisCoroutineLibrary>();
	}
};
static_assert(alignof(USolarisCoroutineLibrary) == 0x000008, "Wrong alignment on USolarisCoroutineLibrary");
static_assert(sizeof(USolarisCoroutineLibrary) == 0x000028, "Wrong size on USolarisCoroutineLibrary");

// Class Solaris.SolarisDebugData
// 0x0010 (0x0038 - 0x0028)
class USolarisDebugData final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisDebugData">();
	}
	static class USolarisDebugData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisDebugData>();
	}
};
static_assert(alignof(USolarisDebugData) == 0x000008, "Wrong alignment on USolarisDebugData");
static_assert(sizeof(USolarisDebugData) == 0x000038, "Wrong size on USolarisDebugData");

// Class Solaris.SolarisDigest
// 0x0020 (0x0048 - 0x0028)
class USolarisDigest final : public UObject
{
public:
	TArray<uint8>                                 DigestCode;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ProjectName;                                       // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisDigest">();
	}
	static class USolarisDigest* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisDigest>();
	}
};
static_assert(alignof(USolarisDigest) == 0x000008, "Wrong alignment on USolarisDigest");
static_assert(sizeof(USolarisDigest) == 0x000048, "Wrong size on USolarisDigest");
static_assert(offsetof(USolarisDigest, DigestCode) == 0x000028, "Member 'USolarisDigest::DigestCode' has a wrong offset!");
static_assert(offsetof(USolarisDigest, ProjectName) == 0x000038, "Member 'USolarisDigest::ProjectName' has a wrong offset!");

// Class Solaris.SolarisGeneratedClass
// 0x00C0 (0x02F0 - 0x0230)
class USolarisGeneratedClass final : public USolarisGeneratedClassBase
{
public:
	uint32                                        SolClassFlags;                                     // 0x0230(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         TaskClasses;                                       // 0x0238(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class UClass*>                           InterfaceClasses;                                  // 0x0248(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, TFieldPath<class FProperty>> InterfaceMethodDelegateProperties;                 // 0x0298(0x0050)(NativeAccessSpecifierPublic)
	class UFunction*                              InitInstanceFunction;                              // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisGeneratedClass">();
	}
	static class USolarisGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisGeneratedClass>();
	}
};
static_assert(alignof(USolarisGeneratedClass) == 0x000008, "Wrong alignment on USolarisGeneratedClass");
static_assert(sizeof(USolarisGeneratedClass) == 0x0002F0, "Wrong size on USolarisGeneratedClass");
static_assert(offsetof(USolarisGeneratedClass, SolClassFlags) == 0x000230, "Member 'USolarisGeneratedClass::SolClassFlags' has a wrong offset!");
static_assert(offsetof(USolarisGeneratedClass, TaskClasses) == 0x000238, "Member 'USolarisGeneratedClass::TaskClasses' has a wrong offset!");
static_assert(offsetof(USolarisGeneratedClass, InterfaceClasses) == 0x000248, "Member 'USolarisGeneratedClass::InterfaceClasses' has a wrong offset!");
static_assert(offsetof(USolarisGeneratedClass, InterfaceMethodDelegateProperties) == 0x000298, "Member 'USolarisGeneratedClass::InterfaceMethodDelegateProperties' has a wrong offset!");
static_assert(offsetof(USolarisGeneratedClass, InitInstanceFunction) == 0x0002E8, "Member 'USolarisGeneratedClass::InitInstanceFunction' has a wrong offset!");

// Class Solaris.SolarisGeneratedEnum
// 0x0000 (0x0060 - 0x0060)
class USolarisGeneratedEnum final : public UEnum
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisGeneratedEnum">();
	}
	static class USolarisGeneratedEnum* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisGeneratedEnum>();
	}
};
static_assert(alignof(USolarisGeneratedEnum) == 0x000008, "Wrong alignment on USolarisGeneratedEnum");
static_assert(sizeof(USolarisGeneratedEnum) == 0x000060, "Wrong size on USolarisGeneratedEnum");

// Class Solaris.SolarisMathLibrary_Bool
// 0x0000 (0x0028 - 0x0028)
class USolarisMathLibrary_Bool final : public UObject
{
public:
	static void Query();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisMathLibrary_Bool">();
	}
	static class USolarisMathLibrary_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisMathLibrary_Bool>();
	}
};
static_assert(alignof(USolarisMathLibrary_Bool) == 0x000008, "Wrong alignment on USolarisMathLibrary_Bool");
static_assert(sizeof(USolarisMathLibrary_Bool) == 0x000028, "Wrong size on USolarisMathLibrary_Bool");

// Class Solaris.SolarisMathLibrary_Int
// 0x0000 (0x0028 - 0x0028)
class USolarisMathLibrary_Int final : public UObject
{
public:
	static void Abs(int64 Value);
	static void Add(int64 Lhs, int64 Rhs);
	static void AddEquals(int64* Lhs, int64 Rhs);
	static void ConvertI32I64(int64 Rhs);
	static void Divide(int64 Lhs, int64 Rhs);
	static void Greater(int64 Lhs, int64 Rhs);
	static void GreaterEqual(int64 Lhs, int64 Rhs);
	static void Less(int64 Lhs, int64 Rhs);
	static void LessEqual(int64 Lhs, int64 Rhs);
	static void Multiply(int64 Lhs, int64 Rhs);
	static void MultiplyEquals(int64* Lhs, int64 Rhs);
	static void Negate(int64 Value);
	static bool PredicateEqual(int64 Lhs, int64 Rhs);
	static bool PredicateGreater(int64 Lhs, int64 Rhs);
	static bool PredicateGreaterEqual(int64 Lhs, int64 Rhs);
	static bool PredicateLess(int64 Lhs, int64 Rhs);
	static bool PredicateLessEqual(int64 Lhs, int64 Rhs);
	static bool PredicateNotEqual(int64 Lhs, int64 Rhs);
	static void Subtract(int64 Lhs, int64 Rhs);
	static void SubtractEquals(int64* Lhs, int64 Rhs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisMathLibrary_Int">();
	}
	static class USolarisMathLibrary_Int* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisMathLibrary_Int>();
	}
};
static_assert(alignof(USolarisMathLibrary_Int) == 0x000008, "Wrong alignment on USolarisMathLibrary_Int");
static_assert(sizeof(USolarisMathLibrary_Int) == 0x000028, "Wrong size on USolarisMathLibrary_Int");

// Class Solaris.SolarisMathLibrary_Rational
// 0x0000 (0x0028 - 0x0028)
class USolarisMathLibrary_Rational final : public UObject
{
public:
	static void Ceil(const struct FVerseRational& Val);
	static void Floor(const struct FVerseRational& Val);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisMathLibrary_Rational">();
	}
	static class USolarisMathLibrary_Rational* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisMathLibrary_Rational>();
	}
};
static_assert(alignof(USolarisMathLibrary_Rational) == 0x000008, "Wrong alignment on USolarisMathLibrary_Rational");
static_assert(sizeof(USolarisMathLibrary_Rational) == 0x000028, "Wrong size on USolarisMathLibrary_Rational");

// Class Solaris.SolarisMathLibrary_Float
// 0x0000 (0x0028 - 0x0028)
class USolarisMathLibrary_Float final : public UObject
{
public:
	static double Abs(double Value);
	static double Add(double Lhs, double Rhs);
	static double AddEquals(double* Lhs, double Rhs);
	static double Divide(double Lhs, double Rhs);
	static double DivideEquals(double* Lhs, double Rhs);
	static void Greater(double Lhs, double Rhs);
	static void GreaterEqual(double Lhs, double Rhs);
	static void Less(double Lhs, double Rhs);
	static void LessEqual(double Lhs, double Rhs);
	static double Multiply(double Lhs, double Rhs);
	static double MultiplyEquals(double* Lhs, double Rhs);
	static double MultiplyFloatInt(double Lhs, int64 Rhs);
	static double MultiplyIntFloat(int64 Lhs, double Rhs);
	static double Negate(double Value);
	static double Subtract(double Lhs, double Rhs);
	static double SubtractEquals(double* Lhs, double Rhs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisMathLibrary_Float">();
	}
	static class USolarisMathLibrary_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisMathLibrary_Float>();
	}
};
static_assert(alignof(USolarisMathLibrary_Float) == 0x000008, "Wrong alignment on USolarisMathLibrary_Float");
static_assert(sizeof(USolarisMathLibrary_Float) == 0x000028, "Wrong size on USolarisMathLibrary_Float");

// Class Solaris.SolarisMathLibrary_String
// 0x0000 (0x0028 - 0x0028)
class USolarisMathLibrary_String final : public UObject
{
public:
	static void Call(const int32& String, int64 Index_0);
	static int32 Concat(const int32& Lhs, const int32& Rhs);
	static int32 ConcatEquals(int32* Lhs, const int32& Rhs);
	static int64 Length(const int32& Array);
	static void Make();
	static int32 MakeLiteral();
	static void RefCall(const int32& String, int64 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisMathLibrary_String">();
	}
	static class USolarisMathLibrary_String* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisMathLibrary_String>();
	}
};
static_assert(alignof(USolarisMathLibrary_String) == 0x000008, "Wrong alignment on USolarisMathLibrary_String");
static_assert(sizeof(USolarisMathLibrary_String) == 0x000028, "Wrong size on USolarisMathLibrary_String");

// Class Solaris.SolarisMathLibrary_Option
// 0x0000 (0x0028 - 0x0028)
class USolarisMathLibrary_Option final : public UObject
{
public:
	static void Make();
	static void Query();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisMathLibrary_Option">();
	}
	static class USolarisMathLibrary_Option* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisMathLibrary_Option>();
	}
};
static_assert(alignof(USolarisMathLibrary_Option) == 0x000008, "Wrong alignment on USolarisMathLibrary_Option");
static_assert(sizeof(USolarisMathLibrary_Option) == 0x000028, "Wrong size on USolarisMathLibrary_Option");

// Class Solaris.SolarisGameSettings
// 0x0018 (0x0040 - 0x0028)
class USolarisGameSettings final : public UObject
{
public:
	TArray<class FString>                         BlackList;                                         // 0x0028(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         MaxAllowedSize;                                    // 0x0038(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisGameSettings">();
	}
	static class USolarisGameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisGameSettings>();
	}
};
static_assert(alignof(USolarisGameSettings) == 0x000008, "Wrong alignment on USolarisGameSettings");
static_assert(sizeof(USolarisGameSettings) == 0x000040, "Wrong size on USolarisGameSettings");
static_assert(offsetof(USolarisGameSettings, BlackList) == 0x000028, "Member 'USolarisGameSettings::BlackList' has a wrong offset!");
static_assert(offsetof(USolarisGameSettings, MaxAllowedSize) == 0x000038, "Member 'USolarisGameSettings::MaxAllowedSize' has a wrong offset!");

// Class Solaris.SolarisUtilLibrary
// 0x0000 (0x0028 - 0x0028)
class USolarisUtilLibrary final : public UObject
{
public:
	static void CallDelegate();
	static int64 Dereference(int64 reference);
	static class UObject* GetCurrentlyInstantiatedObject();
	static void GetDelegateForInterfaceMethod(class UObject* Object, class FName MethodName);
	static int64 GetOptionValue(class UObject* Property, int64 Option);
	static bool HasInterface(class UObject* Object, class UClass* InterfaceClass);
	static class UObject* InstantiateObject(class UClass* Type);
	static bool IsNonNullObject(class UObject* Object);
	static bool IsOptionSet(class UObject* Property, int64 Option);
	static bool MakeOptionFromValue(class UObject* Property, int64 Value);
	static int64 MakeUnsetOption(class UObject* Property);
	static bool ReferenceIsValid(int64 reference);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarisUtilLibrary">();
	}
	static class USolarisUtilLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarisUtilLibrary>();
	}
};
static_assert(alignof(USolarisUtilLibrary) == 0x000008, "Wrong alignment on USolarisUtilLibrary");
static_assert(sizeof(USolarisUtilLibrary) == 0x000028, "Wrong size on USolarisUtilLibrary");

// Class Solaris.VerseDynamicallyTypedValueLibrary
// 0x0000 (0x0028 - 0x0028)
class UVerseDynamicallyTypedValueLibrary final : public UObject
{
public:
	static void ConvertFromDynamicallyTypedValue(int32 RuntimeType, int32 Value);
	static void ConvertToDynamicallyTypedValue(int32 RuntimeType, int32 Value);
	static void Equal(int32 Left, int32 Right);
	static void MakeRuntimeTypeArray(int32 ElementType);
	static void MakeRuntimeTypeClass();
	static void MakeRuntimeTypeDynamic();
	static void MakeRuntimeTypeEnum(class FName Name_0);
	static void MakeRuntimeTypeFloat();
	static void MakeRuntimeTypeFunction();
	static void MakeRuntimeTypeInt32();
	static void MakeRuntimeTypeInt64();
	static void MakeRuntimeTypeInt8();
	static void MakeRuntimeTypeLogic();
	static void MakeRuntimeTypeMap(int32 KeyType, int32 ValueType);
	static void MakeRuntimeTypeObject();
	static void MakeRuntimeTypeOption(int32 ValueType);
	static void MakeRuntimeTypeString();
	static void MakeRuntimeTypeTuple(const TArray<int32>& ValueType);
	static void NotEqual(int32 Left, int32 Right);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VerseDynamicallyTypedValueLibrary">();
	}
	static class UVerseDynamicallyTypedValueLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVerseDynamicallyTypedValueLibrary>();
	}
};
static_assert(alignof(UVerseDynamicallyTypedValueLibrary) == 0x000008, "Wrong alignment on UVerseDynamicallyTypedValueLibrary");
static_assert(sizeof(UVerseDynamicallyTypedValueLibrary) == 0x000028, "Wrong size on UVerseDynamicallyTypedValueLibrary");

// Class Solaris.VerseStmLibrary
// 0x0000 (0x0028 - 0x0028)
class UVerseStmLibrary final : public UObject
{
public:
	static void StmBegin();
	static void StmCommit();
	static void StmRollback();
	static void StmSave(const struct FakeType& Property);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VerseStmLibrary">();
	}
	static class UVerseStmLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVerseStmLibrary>();
	}
};
static_assert(alignof(UVerseStmLibrary) == 0x000008, "Wrong alignment on UVerseStmLibrary");
static_assert(sizeof(UVerseStmLibrary) == 0x000028, "Wrong size on UVerseStmLibrary");

}

