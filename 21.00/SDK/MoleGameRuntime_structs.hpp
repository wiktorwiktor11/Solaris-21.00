#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MoleGameRuntime

#include "Basic.hpp"

#include "NetCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_0_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayMessages_structs.hpp"
#include "FortniteGame_structs.hpp"
#include "GameplayAbilities_structs.hpp"


namespace SDK
{

// Enum MoleGameRuntime.EMoleTaskInterruptionType
// NumValues: 0x0003
enum class EMoleTaskInterruptionType : uint8
{
	RestartTask                              = 0,
	DisableTask                              = 1,
	EMoleTaskInterruptionType_MAX            = 2,
};

// Enum MoleGameRuntime.EMoleTaskObjectiveStatus
// NumValues: 0x0004
enum class EMoleTaskObjectiveStatus : uint8
{
	Unresolved                               = 0,
	SuccessfulCompletion                     = 1,
	FailedCompletion                         = 2,
	EMoleTaskObjectiveStatus_MAX             = 3,
};

// Enum MoleGameRuntime.EMolePlayerLeftReason
// NumValues: 0x0003
enum class EMolePlayerLeftReason : uint8
{
	PlayerLeft                               = 0,
	PlayerKickedNoPawn                       = 1,
	EMolePlayerLeftReason_MAX                = 2,
};

// Enum MoleGameRuntime.EMoleSabotageInterruptionType
// NumValues: 0x0003
enum class EMoleSabotageInterruptionType : uint8
{
	Interrupt                                = 0,
	Pause                                    = 1,
	EMoleSabotageInterruptionType_MAX        = 2,
};

// Enum MoleGameRuntime.EMoleLightsMode
// NumValues: 0x0004
enum class EMoleLightsMode : uint8
{
	Standard                                 = 0,
	Emergency                                = 1,
	Disabled                                 = 2,
	EMoleLightsMode_MAX                      = 3,
};

// Enum MoleGameRuntime.EMoleTaskLeashType
// NumValues: 0x0003
enum class EMoleTaskLeashType : uint8
{
	CollisionOverlap                         = 0,
	DistanceFromActorLocation                = 1,
	EMoleTaskLeashType_MAX                   = 2,
};

// Enum MoleGameRuntime.EMoleObjectiveCriteriaFloatType
// NumValues: 0x0004
enum class EMoleObjectiveCriteriaFloatType : uint8
{
	FloatValue                               = 0,
	UseObjectiveTaskActorCount               = 1,
	ExplicitActorCount                       = 2,
	EMoleObjectiveCriteriaFloatType_MAX      = 3,
};

// Enum MoleGameRuntime.EMoleTaskLogicSubobjectEventPolicy
// NumValues: 0x0006
enum class EMoleTaskLogicSubobjectEventPolicy : uint8
{
	None                                     = 0,
	OnPhaseEnd                               = 1,
	OnTaskInterruption                       = 2,
	OnTaskRemoval                            = 4,
	OnTaskCompletion                         = 8,
	EMoleTaskLogicSubobjectEventPolicy_MAX   = 9,
};

// Enum MoleGameRuntime.EMoleNewTaskNotificationType
// NumValues: 0x0004
enum class EMoleNewTaskNotificationType : uint8
{
	None                                     = 0,
	NewTaskOnly                              = 1,
	TaskCompletionAndNewTask                 = 2,
	EMoleNewTaskNotificationType_MAX         = 3,
};

// Enum MoleGameRuntime.EMoleRole
// NumValues: 0x0004
enum class EMoleRole : uint8
{
	Unknown                                  = 0,
	Ally                                     = 1,
	Enemy                                    = 2,
	EMoleRole_MAX                            = 3,
};

// Enum MoleGameRuntime.EEmergencyMeetingCause
// NumValues: 0x0004
enum class EEmergencyMeetingCause : uint8
{
	None                                     = 0,
	BodyReported                             = 1,
	MeetingCalled                            = 2,
	EEmergencyMeetingCause_MAX               = 3,
};

// Enum MoleGameRuntime.EVoteType
// NumValues: 0x0004
enum class EVoteType : uint8
{
	None                                     = 0,
	Skip                                     = 1,
	Vote                                     = 2,
	EVoteType_MAX                            = 3,
};

// Enum MoleGameRuntime.EMoleVoiceChannelState
// NumValues: 0x0006
enum class EMoleVoiceChannelState : uint8
{
	None                                     = 0,
	Lobby                                    = 1,
	Gameplay                                 = 2,
	Voting                                   = 3,
	Gameover                                 = 4,
	EMoleVoiceChannelState_MAX               = 5,
};

// ScriptStruct MoleGameRuntime.MoleQuickChatMessageSummary
// 0x0018 (0x0018 - 0x0000)
struct FMoleQuickChatMessageSummary final
{
public:
	class AFortPlayerController*                  SenderController;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleQuickChatMessageSummary) == 0x000008, "Wrong alignment on FMoleQuickChatMessageSummary");
static_assert(sizeof(FMoleQuickChatMessageSummary) == 0x000018, "Wrong size on FMoleQuickChatMessageSummary");
static_assert(offsetof(FMoleQuickChatMessageSummary, SenderController) == 0x000000, "Member 'FMoleQuickChatMessageSummary::SenderController' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MolePlayerContext
// 0x0008 (0x0008 - 0x0000)
struct FMolePlayerContext final
{
public:
	class APlayerState*                           PlayerContext;                                     // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMolePlayerContext) == 0x000008, "Wrong alignment on FMolePlayerContext");
static_assert(sizeof(FMolePlayerContext) == 0x000008, "Wrong size on FMolePlayerContext");
static_assert(offsetof(FMolePlayerContext, PlayerContext) == 0x000000, "Member 'FMolePlayerContext::PlayerContext' has a wrong offset!");

// ScriptStruct MoleGameRuntime.PlayerTaskStateData
// 0x0014 (0x0020 - 0x000C)
struct FPlayerTaskStateData final : public FFastArraySerializerItem
{
public:
	uint8                                         ChangeFlags;                                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            UserController;                                    // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInteractionInfoRowName;                        // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasPermission : 1;                                // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerTaskStateData) == 0x000008, "Wrong alignment on FPlayerTaskStateData");
static_assert(sizeof(FPlayerTaskStateData) == 0x000020, "Wrong size on FPlayerTaskStateData");
static_assert(offsetof(FPlayerTaskStateData, ChangeFlags) == 0x00000C, "Member 'FPlayerTaskStateData::ChangeFlags' has a wrong offset!");
static_assert(offsetof(FPlayerTaskStateData, UserController) == 0x000010, "Member 'FPlayerTaskStateData::UserController' has a wrong offset!");
static_assert(offsetof(FPlayerTaskStateData, TaskInteractionInfoRowName) == 0x000018, "Member 'FPlayerTaskStateData::TaskInteractionInfoRowName' has a wrong offset!");

// ScriptStruct MoleGameRuntime.PlayerTaskStateDataArray
// 0x0018 (0x0120 - 0x0108)
struct FPlayerTaskStateDataArray final : public FFastArraySerializer
{
public:
	class UMoleTaskLinkComponent*                 CachedTaskComponent;                               // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayerTaskStateData>           TaskStateArray;                                    // 0x0110(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPlayerTaskStateDataArray) == 0x000008, "Wrong alignment on FPlayerTaskStateDataArray");
static_assert(sizeof(FPlayerTaskStateDataArray) == 0x000120, "Wrong size on FPlayerTaskStateDataArray");
static_assert(offsetof(FPlayerTaskStateDataArray, CachedTaskComponent) == 0x000108, "Member 'FPlayerTaskStateDataArray::CachedTaskComponent' has a wrong offset!");
static_assert(offsetof(FPlayerTaskStateDataArray, TaskStateArray) == 0x000110, "Member 'FPlayerTaskStateDataArray::TaskStateArray' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleQuickChatMessageDetails
// 0x0050 (0x0050 - 0x0000)
struct FMoleQuickChatMessageDetails final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           PlayerA;                                           // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           PlayerB;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           PlayerC;                                           // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleQuickChatMessageDetails) == 0x000008, "Wrong alignment on FMoleQuickChatMessageDetails");
static_assert(sizeof(FMoleQuickChatMessageDetails) == 0x000050, "Wrong size on FMoleQuickChatMessageDetails");
static_assert(offsetof(FMoleQuickChatMessageDetails, PlayerA) == 0x000028, "Member 'FMoleQuickChatMessageDetails::PlayerA' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageDetails, PlayerB) == 0x000030, "Member 'FMoleQuickChatMessageDetails::PlayerB' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageDetails, PlayerC) == 0x000038, "Member 'FMoleQuickChatMessageDetails::PlayerC' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleAnalyticsFloatStat
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FMoleAnalyticsFloatStat final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleAnalyticsFloatStat) == 0x000008, "Wrong alignment on FMoleAnalyticsFloatStat");
static_assert(sizeof(FMoleAnalyticsFloatStat) == 0x000058, "Wrong size on FMoleAnalyticsFloatStat");

// ScriptStruct MoleGameRuntime.MoleRoleAssignedMessagePayload
// 0x0020 (0x0020 - 0x0000)
struct FMoleRoleAssignedMessagePayload final
{
public:
	bool                                          bIsImpostor;                                       // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerState*                       LocalPlayerState;                                  // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFortPlayerState*>               TeamPlayerStates;                                  // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleRoleAssignedMessagePayload) == 0x000008, "Wrong alignment on FMoleRoleAssignedMessagePayload");
static_assert(sizeof(FMoleRoleAssignedMessagePayload) == 0x000020, "Wrong size on FMoleRoleAssignedMessagePayload");
static_assert(offsetof(FMoleRoleAssignedMessagePayload, bIsImpostor) == 0x000000, "Member 'FMoleRoleAssignedMessagePayload::bIsImpostor' has a wrong offset!");
static_assert(offsetof(FMoleRoleAssignedMessagePayload, LocalPlayerState) == 0x000008, "Member 'FMoleRoleAssignedMessagePayload::LocalPlayerState' has a wrong offset!");
static_assert(offsetof(FMoleRoleAssignedMessagePayload, TeamPlayerStates) == 0x000010, "Member 'FMoleRoleAssignedMessagePayload::TeamPlayerStates' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleObjectiveValue
// 0x0008 (0x0008 - 0x0000)
struct FMoleObjectiveValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ForceRepCount;                                     // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleObjectiveValue) == 0x000004, "Wrong alignment on FMoleObjectiveValue");
static_assert(sizeof(FMoleObjectiveValue) == 0x000008, "Wrong size on FMoleObjectiveValue");
static_assert(offsetof(FMoleObjectiveValue, Value) == 0x000000, "Member 'FMoleObjectiveValue::Value' has a wrong offset!");
static_assert(offsetof(FMoleObjectiveValue, ForceRepCount) == 0x000004, "Member 'FMoleObjectiveValue::ForceRepCount' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleAFKData
// 0x0010 (0x0010 - 0x0000)
struct FMoleAFKData final
{
public:
	class APlayerState*                           Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUntilConfirmedAFK;                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleAFKData) == 0x000008, "Wrong alignment on FMoleAFKData");
static_assert(sizeof(FMoleAFKData) == 0x000010, "Wrong size on FMoleAFKData");
static_assert(offsetof(FMoleAFKData, Player) == 0x000000, "Member 'FMoleAFKData::Player' has a wrong offset!");
static_assert(offsetof(FMoleAFKData, TimeUntilConfirmedAFK) == 0x000008, "Member 'FMoleAFKData::TimeUntilConfirmedAFK' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleAnalyticsIntegerStat
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FMoleAnalyticsIntegerStat final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleAnalyticsIntegerStat) == 0x000008, "Wrong alignment on FMoleAnalyticsIntegerStat");
static_assert(sizeof(FMoleAnalyticsIntegerStat) == 0x000058, "Wrong size on FMoleAnalyticsIntegerStat");

// ScriptStruct MoleGameRuntime.MoleAssetLoadData
// 0x0004 (0x0004 - 0x0000)
struct FMoleAssetLoadData final
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleAssetLoadData) == 0x000004, "Wrong alignment on FMoleAssetLoadData");
static_assert(sizeof(FMoleAssetLoadData) == 0x000004, "Wrong size on FMoleAssetLoadData");
static_assert(offsetof(FMoleAssetLoadData, PrimaryAssetType) == 0x000000, "Member 'FMoleAssetLoadData::PrimaryAssetType' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleBindingData
// 0x0060 (0x0068 - 0x0008)
struct FMoleBindingData final : public FTableRowBase
{
public:
	class FName                                   KBMActionName;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GamepadActionName;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   BindingLabel;                                      // 0x0010(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   BindingDescription;                                // 0x0028(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsSaboteurBinding;                                // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKBMOnly;                                          // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamepadOnly;                                      // 0x0042(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryLabel;                                     // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsAxisMapping;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputScale;                                        // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleBindingData) == 0x000008, "Wrong alignment on FMoleBindingData");
static_assert(sizeof(FMoleBindingData) == 0x000068, "Wrong size on FMoleBindingData");
static_assert(offsetof(FMoleBindingData, KBMActionName) == 0x000008, "Member 'FMoleBindingData::KBMActionName' has a wrong offset!");
static_assert(offsetof(FMoleBindingData, GamepadActionName) == 0x00000C, "Member 'FMoleBindingData::GamepadActionName' has a wrong offset!");
static_assert(offsetof(FMoleBindingData, BindingLabel) == 0x000010, "Member 'FMoleBindingData::BindingLabel' has a wrong offset!");
static_assert(offsetof(FMoleBindingData, BindingDescription) == 0x000028, "Member 'FMoleBindingData::BindingDescription' has a wrong offset!");
static_assert(offsetof(FMoleBindingData, bIsSaboteurBinding) == 0x000040, "Member 'FMoleBindingData::bIsSaboteurBinding' has a wrong offset!");
static_assert(offsetof(FMoleBindingData, bKBMOnly) == 0x000041, "Member 'FMoleBindingData::bKBMOnly' has a wrong offset!");
static_assert(offsetof(FMoleBindingData, bGamepadOnly) == 0x000042, "Member 'FMoleBindingData::bGamepadOnly' has a wrong offset!");
static_assert(offsetof(FMoleBindingData, CategoryLabel) == 0x000048, "Member 'FMoleBindingData::CategoryLabel' has a wrong offset!");
static_assert(offsetof(FMoleBindingData, bIsAxisMapping) == 0x000060, "Member 'FMoleBindingData::bIsAxisMapping' has a wrong offset!");
static_assert(offsetof(FMoleBindingData, InputScale) == 0x000064, "Member 'FMoleBindingData::InputScale' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTaskDescription
// 0x0020 (0x0020 - 0x0000)
struct FMoleTaskDescription final
{
public:
	struct FGameplayTagContainer                  TaskDescription;                                   // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleTaskDescription) == 0x000008, "Wrong alignment on FMoleTaskDescription");
static_assert(sizeof(FMoleTaskDescription) == 0x000020, "Wrong size on FMoleTaskDescription");
static_assert(offsetof(FMoleTaskDescription, TaskDescription) == 0x000000, "Member 'FMoleTaskDescription::TaskDescription' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleRolePreference
// 0x0001 (0x0001 - 0x0000)
struct FMoleRolePreference final
{
public:
	EMoleRole                                     RolePreference;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleRolePreference) == 0x000001, "Wrong alignment on FMoleRolePreference");
static_assert(sizeof(FMoleRolePreference) == 0x000001, "Wrong size on FMoleRolePreference");
static_assert(offsetof(FMoleRolePreference, RolePreference) == 0x000000, "Member 'FMoleRolePreference::RolePreference' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleImpostorBias
// 0x0004 (0x0004 - 0x0000)
struct FMoleImpostorBias final
{
public:
	int32                                         ImpostorBias;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleImpostorBias) == 0x000004, "Wrong alignment on FMoleImpostorBias");
static_assert(sizeof(FMoleImpostorBias) == 0x000004, "Wrong size on FMoleImpostorBias");
static_assert(offsetof(FMoleImpostorBias, ImpostorBias) == 0x000000, "Member 'FMoleImpostorBias::ImpostorBias' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleLevelTaskRequest
// 0x0010 (0x0010 - 0x0000)
struct FMoleLevelTaskRequest final
{
public:
	TArray<struct FMoleTaskDescription>           SupportedTaskDescriptions;                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleLevelTaskRequest) == 0x000008, "Wrong alignment on FMoleLevelTaskRequest");
static_assert(sizeof(FMoleLevelTaskRequest) == 0x000010, "Wrong size on FMoleLevelTaskRequest");
static_assert(offsetof(FMoleLevelTaskRequest, SupportedTaskDescriptions) == 0x000000, "Member 'FMoleLevelTaskRequest::SupportedTaskDescriptions' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleMessageLobbyCountdown
// 0x0004 (0x0004 - 0x0000)
struct FMoleMessageLobbyCountdown final
{
public:
	int32                                         SecondsRemaining;                                  // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleMessageLobbyCountdown) == 0x000004, "Wrong alignment on FMoleMessageLobbyCountdown");
static_assert(sizeof(FMoleMessageLobbyCountdown) == 0x000004, "Wrong size on FMoleMessageLobbyCountdown");
static_assert(offsetof(FMoleMessageLobbyCountdown, SecondsRemaining) == 0x000000, "Member 'FMoleMessageLobbyCountdown::SecondsRemaining' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleGameplayInputEventData
// 0x0018 (0x0018 - 0x0000)
struct FMoleGameplayInputEventData final
{
public:
	struct FGameplayTag                           InputActionTag;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerControllerGameplay*          UserController;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPressEvent;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleGameplayInputEventData) == 0x000008, "Wrong alignment on FMoleGameplayInputEventData");
static_assert(sizeof(FMoleGameplayInputEventData) == 0x000018, "Wrong size on FMoleGameplayInputEventData");
static_assert(offsetof(FMoleGameplayInputEventData, InputActionTag) == 0x000000, "Member 'FMoleGameplayInputEventData::InputActionTag' has a wrong offset!");
static_assert(offsetof(FMoleGameplayInputEventData, UserController) == 0x000008, "Member 'FMoleGameplayInputEventData::UserController' has a wrong offset!");
static_assert(offsetof(FMoleGameplayInputEventData, bPressEvent) == 0x000010, "Member 'FMoleGameplayInputEventData::bPressEvent' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleGhostInfo
// 0x0010 (0x0010 - 0x0000)
struct FMoleGhostInfo final
{
public:
	class APlayerState*                           GhostPlayerState;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasVotedOut;                                      // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleGhostInfo) == 0x000008, "Wrong alignment on FMoleGhostInfo");
static_assert(sizeof(FMoleGhostInfo) == 0x000010, "Wrong size on FMoleGhostInfo");
static_assert(offsetof(FMoleGhostInfo, GhostPlayerState) == 0x000000, "Member 'FMoleGhostInfo::GhostPlayerState' has a wrong offset!");
static_assert(offsetof(FMoleGhostInfo, bWasVotedOut) == 0x000008, "Member 'FMoleGhostInfo::bWasVotedOut' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleDeathInformation
// 0x0002 (0x0002 - 0x0000)
struct FMoleDeathInformation final
{
public:
	bool                                          bIsGhost;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasVotedOut;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleDeathInformation) == 0x000001, "Wrong alignment on FMoleDeathInformation");
static_assert(sizeof(FMoleDeathInformation) == 0x000002, "Wrong size on FMoleDeathInformation");
static_assert(offsetof(FMoleDeathInformation, bIsGhost) == 0x000000, "Member 'FMoleDeathInformation::bIsGhost' has a wrong offset!");
static_assert(offsetof(FMoleDeathInformation, bWasVotedOut) == 0x000001, "Member 'FMoleDeathInformation::bWasVotedOut' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MolePlayerTeleportedInfo
// 0x0008 (0x0008 - 0x0000)
struct FMolePlayerTeleportedInfo final
{
public:
	class APlayerState*                           TeleportedPlayerState;                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMolePlayerTeleportedInfo) == 0x000008, "Wrong alignment on FMolePlayerTeleportedInfo");
static_assert(sizeof(FMolePlayerTeleportedInfo) == 0x000008, "Wrong size on FMolePlayerTeleportedInfo");
static_assert(offsetof(FMolePlayerTeleportedInfo, TeleportedPlayerState) == 0x000000, "Member 'FMolePlayerTeleportedInfo::TeleportedPlayerState' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MolePlayerTeleportedReplicatedData
// 0x0008 (0x0008 - 0x0000)
struct FMolePlayerTeleportedReplicatedData final
{
public:
	struct FEventMessageTag                       MessageTag;                                        // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReplicationCount;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMolePlayerTeleportedReplicatedData) == 0x000004, "Wrong alignment on FMolePlayerTeleportedReplicatedData");
static_assert(sizeof(FMolePlayerTeleportedReplicatedData) == 0x000008, "Wrong size on FMolePlayerTeleportedReplicatedData");
static_assert(offsetof(FMolePlayerTeleportedReplicatedData, MessageTag) == 0x000000, "Member 'FMolePlayerTeleportedReplicatedData::MessageTag' has a wrong offset!");
static_assert(offsetof(FMolePlayerTeleportedReplicatedData, ReplicationCount) == 0x000004, "Member 'FMolePlayerTeleportedReplicatedData::ReplicationCount' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MolePlayerCosmeticData
// 0x0020 (0x0020 - 0x0000)
struct FMolePlayerCosmeticData final
{
public:
	class UAthenaCharacterItemDefinition*         CharacterDefinition;                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMcpVariantChannelInfo>         CharacterVariantChannels;                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAthenaBackpackItemDefinition*          Backpack;                                          // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMolePlayerCosmeticData) == 0x000008, "Wrong alignment on FMolePlayerCosmeticData");
static_assert(sizeof(FMolePlayerCosmeticData) == 0x000020, "Wrong size on FMolePlayerCosmeticData");
static_assert(offsetof(FMolePlayerCosmeticData, CharacterDefinition) == 0x000000, "Member 'FMolePlayerCosmeticData::CharacterDefinition' has a wrong offset!");
static_assert(offsetof(FMolePlayerCosmeticData, CharacterVariantChannels) == 0x000008, "Member 'FMolePlayerCosmeticData::CharacterVariantChannels' has a wrong offset!");
static_assert(offsetof(FMolePlayerCosmeticData, Backpack) == 0x000018, "Member 'FMolePlayerCosmeticData::Backpack' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleActiveTaskStateHandle
// 0x0004 (0x0004 - 0x0000)
struct FMoleActiveTaskStateHandle final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMoleActiveTaskStateHandle) == 0x000004, "Wrong alignment on FMoleActiveTaskStateHandle");
static_assert(sizeof(FMoleActiveTaskStateHandle) == 0x000004, "Wrong size on FMoleActiveTaskStateHandle");
static_assert(offsetof(FMoleActiveTaskStateHandle, Handle) == 0x000000, "Member 'FMoleActiveTaskStateHandle::Handle' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleActiveTaskState
// 0x007C (0x0088 - 0x000C)
struct FMoleActiveTaskState final : public FFastArraySerializerItem
{
public:
	struct FMoleActiveTaskStateHandle             Handle;                                            // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoleTaskDataAsset*                     TaskAsset;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoleTaskLogic*                         TaskLogic;                                         // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TaskStateMachineId;                                // 0x0020(0x0004)(RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAbilitySetHandle                  AbilitySetHandle;                                  // 0x0028(0x0038)(RepSkip, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGuid                                  AbilitySetInputGuid;                               // 0x0060(0x0010)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          GrantedItemGuids;                                  // 0x0070(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	EMoleNewTaskNotificationType                  NotificationType;                                  // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleActiveTaskState) == 0x000008, "Wrong alignment on FMoleActiveTaskState");
static_assert(sizeof(FMoleActiveTaskState) == 0x000088, "Wrong size on FMoleActiveTaskState");
static_assert(offsetof(FMoleActiveTaskState, Handle) == 0x00000C, "Member 'FMoleActiveTaskState::Handle' has a wrong offset!");
static_assert(offsetof(FMoleActiveTaskState, TaskAsset) == 0x000010, "Member 'FMoleActiveTaskState::TaskAsset' has a wrong offset!");
static_assert(offsetof(FMoleActiveTaskState, TaskLogic) == 0x000018, "Member 'FMoleActiveTaskState::TaskLogic' has a wrong offset!");
static_assert(offsetof(FMoleActiveTaskState, TaskStateMachineId) == 0x000020, "Member 'FMoleActiveTaskState::TaskStateMachineId' has a wrong offset!");
static_assert(offsetof(FMoleActiveTaskState, AbilitySetHandle) == 0x000028, "Member 'FMoleActiveTaskState::AbilitySetHandle' has a wrong offset!");
static_assert(offsetof(FMoleActiveTaskState, AbilitySetInputGuid) == 0x000060, "Member 'FMoleActiveTaskState::AbilitySetInputGuid' has a wrong offset!");
static_assert(offsetof(FMoleActiveTaskState, GrantedItemGuids) == 0x000070, "Member 'FMoleActiveTaskState::GrantedItemGuids' has a wrong offset!");
static_assert(offsetof(FMoleActiveTaskState, NotificationType) == 0x000080, "Member 'FMoleActiveTaskState::NotificationType' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleActiveTaskStateArray
// 0x0040 (0x0148 - 0x0108)
struct FMoleActiveTaskStateArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x30];                                     // 0x0108(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMoleActiveTaskState>           TaskStateArray;                                    // 0x0138(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMoleActiveTaskStateArray) == 0x000008, "Wrong alignment on FMoleActiveTaskStateArray");
static_assert(sizeof(FMoleActiveTaskStateArray) == 0x000148, "Wrong size on FMoleActiveTaskStateArray");
static_assert(offsetof(FMoleActiveTaskStateArray, TaskStateArray) == 0x000138, "Member 'FMoleActiveTaskStateArray::TaskStateArray' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleCompletedTask
// 0x0014 (0x0020 - 0x000C)
struct FMoleCompletedTask final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMoleTaskDataAsset*                     TaskAsset;                                         // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMoleActiveTaskStateHandle             StateHandle;                                       // 0x0018(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleCompletedTask) == 0x000008, "Wrong alignment on FMoleCompletedTask");
static_assert(sizeof(FMoleCompletedTask) == 0x000020, "Wrong size on FMoleCompletedTask");
static_assert(offsetof(FMoleCompletedTask, TaskAsset) == 0x000010, "Member 'FMoleCompletedTask::TaskAsset' has a wrong offset!");
static_assert(offsetof(FMoleCompletedTask, StateHandle) == 0x000018, "Member 'FMoleCompletedTask::StateHandle' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleCompletedTaskArray
// 0x0028 (0x0130 - 0x0108)
struct FMoleCompletedTaskArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMoleCompletedTask>             CompletedTaskArray;                                // 0x0120(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMoleCompletedTaskArray) == 0x000008, "Wrong alignment on FMoleCompletedTaskArray");
static_assert(sizeof(FMoleCompletedTaskArray) == 0x000130, "Wrong size on FMoleCompletedTaskArray");
static_assert(offsetof(FMoleCompletedTaskArray, CompletedTaskArray) == 0x000120, "Member 'FMoleCompletedTaskArray::CompletedTaskArray' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleEnemyChangedEventData
// 0x0008 (0x0008 - 0x0000)
struct FMoleEnemyChangedEventData final
{
public:
	class AActor*                                 EnemyTargetActor;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleEnemyChangedEventData) == 0x000008, "Wrong alignment on FMoleEnemyChangedEventData");
static_assert(sizeof(FMoleEnemyChangedEventData) == 0x000008, "Wrong size on FMoleEnemyChangedEventData");
static_assert(offsetof(FMoleEnemyChangedEventData, EnemyTargetActor) == 0x000000, "Member 'FMoleEnemyChangedEventData::EnemyTargetActor' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTaskLeashData
// 0x0018 (0x0018 - 0x0000)
struct FMoleTaskLeashData final
{
public:
	class UMoleTaskDataAsset*                     TaskDataAsset;                                     // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LeashActor;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceSquared;                                   // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleTaskLeashData) == 0x000008, "Wrong alignment on FMoleTaskLeashData");
static_assert(sizeof(FMoleTaskLeashData) == 0x000018, "Wrong size on FMoleTaskLeashData");
static_assert(offsetof(FMoleTaskLeashData, TaskDataAsset) == 0x000000, "Member 'FMoleTaskLeashData::TaskDataAsset' has a wrong offset!");
static_assert(offsetof(FMoleTaskLeashData, LeashActor) == 0x000008, "Member 'FMoleTaskLeashData::LeashActor' has a wrong offset!");
static_assert(offsetof(FMoleTaskLeashData, DistanceSquared) == 0x000010, "Member 'FMoleTaskLeashData::DistanceSquared' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MolePlayerVisibilityInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FMolePlayerVisibilityInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMolePlayerVisibilityInfo) == 0x000008, "Wrong alignment on FMolePlayerVisibilityInfo");
static_assert(sizeof(FMolePlayerVisibilityInfo) == 0x000010, "Wrong size on FMolePlayerVisibilityInfo");

// ScriptStruct MoleGameRuntime.MoleQuickChatMessageInfo
// 0x0040 (0x0040 - 0x0000)
struct FMoleQuickChatMessageInfo final
{
public:
	class APlayerState*                           Sender;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CategoryIndex;                                     // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionIndex;                                       // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MessageIndex;                                      // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SectionALocationTag;                               // 0x0014(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SectionBLocationTag;                               // 0x0018(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SectionCLocationTag;                               // 0x001C(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           SectionASelectedPlayer;                            // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           SectionBSelectedPlayer;                            // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           SectionCSelectedPlayer;                            // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelfSelected;                                   // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DummyCount;                                        // 0x0039(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleQuickChatMessageInfo) == 0x000008, "Wrong alignment on FMoleQuickChatMessageInfo");
static_assert(sizeof(FMoleQuickChatMessageInfo) == 0x000040, "Wrong size on FMoleQuickChatMessageInfo");
static_assert(offsetof(FMoleQuickChatMessageInfo, Sender) == 0x000000, "Member 'FMoleQuickChatMessageInfo::Sender' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, CategoryIndex) == 0x000008, "Member 'FMoleQuickChatMessageInfo::CategoryIndex' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, ActionIndex) == 0x00000C, "Member 'FMoleQuickChatMessageInfo::ActionIndex' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, MessageIndex) == 0x000010, "Member 'FMoleQuickChatMessageInfo::MessageIndex' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, SectionALocationTag) == 0x000014, "Member 'FMoleQuickChatMessageInfo::SectionALocationTag' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, SectionBLocationTag) == 0x000018, "Member 'FMoleQuickChatMessageInfo::SectionBLocationTag' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, SectionCLocationTag) == 0x00001C, "Member 'FMoleQuickChatMessageInfo::SectionCLocationTag' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, SectionASelectedPlayer) == 0x000020, "Member 'FMoleQuickChatMessageInfo::SectionASelectedPlayer' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, SectionBSelectedPlayer) == 0x000028, "Member 'FMoleQuickChatMessageInfo::SectionBSelectedPlayer' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, SectionCSelectedPlayer) == 0x000030, "Member 'FMoleQuickChatMessageInfo::SectionCSelectedPlayer' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, bIsSelfSelected) == 0x000038, "Member 'FMoleQuickChatMessageInfo::bIsSelfSelected' has a wrong offset!");
static_assert(offsetof(FMoleQuickChatMessageInfo, DummyCount) == 0x000039, "Member 'FMoleQuickChatMessageInfo::DummyCount' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleSabotageStatus
// 0x0008 (0x0008 - 0x0000)
struct FMoleSabotageStatus final
{
public:
	struct FGameplayTag                           SabotageTag;                                       // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleSabotageStatus) == 0x000004, "Wrong alignment on FMoleSabotageStatus");
static_assert(sizeof(FMoleSabotageStatus) == 0x000008, "Wrong size on FMoleSabotageStatus");
static_assert(offsetof(FMoleSabotageStatus, SabotageTag) == 0x000000, "Member 'FMoleSabotageStatus::SabotageTag' has a wrong offset!");
static_assert(offsetof(FMoleSabotageStatus, bIsActive) == 0x000004, "Member 'FMoleSabotageStatus::bIsActive' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleLightingMode
// 0x0001 (0x0001 - 0x0000)
struct FMoleLightingMode final
{
public:
	EMoleLightsMode                               LightingMode;                                      // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleLightingMode) == 0x000001, "Wrong alignment on FMoleLightingMode");
static_assert(sizeof(FMoleLightingMode) == 0x000001, "Wrong size on FMoleLightingMode");
static_assert(offsetof(FMoleLightingMode, LightingMode) == 0x000000, "Member 'FMoleLightingMode::LightingMode' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleStateGameOverEventData
// 0x0018 (0x0018 - 0x0000)
struct FMoleStateGameOverEventData final
{
public:
	struct FGameplayTag                           GameOverReason;                                    // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoleRole                                     WinningRole;                                       // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerState*>                   WinningPlayerStates;                               // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleStateGameOverEventData) == 0x000008, "Wrong alignment on FMoleStateGameOverEventData");
static_assert(sizeof(FMoleStateGameOverEventData) == 0x000018, "Wrong size on FMoleStateGameOverEventData");
static_assert(offsetof(FMoleStateGameOverEventData, GameOverReason) == 0x000000, "Member 'FMoleStateGameOverEventData::GameOverReason' has a wrong offset!");
static_assert(offsetof(FMoleStateGameOverEventData, WinningRole) == 0x000004, "Member 'FMoleStateGameOverEventData::WinningRole' has a wrong offset!");
static_assert(offsetof(FMoleStateGameOverEventData, WinningPlayerStates) == 0x000008, "Member 'FMoleStateGameOverEventData::WinningPlayerStates' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleRevealedEnemies
// 0x0010 (0x0010 - 0x0000)
struct FMoleRevealedEnemies final
{
public:
	TArray<class APlayerState*>                   EnemyPlayerStates;                                 // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleRevealedEnemies) == 0x000008, "Wrong alignment on FMoleRevealedEnemies");
static_assert(sizeof(FMoleRevealedEnemies) == 0x000010, "Wrong size on FMoleRevealedEnemies");
static_assert(offsetof(FMoleRevealedEnemies, EnemyPlayerStates) == 0x000000, "Member 'FMoleRevealedEnemies::EnemyPlayerStates' has a wrong offset!");

// ScriptStruct MoleGameRuntime.TaskInteractionInfo
// 0x0040 (0x0048 - 0x0008)
struct FTaskInteractionInfo final : public FTableRowBase
{
public:
	class FText                                   PrimaryInteractionText;                            // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SecondaryInteractionText;                          // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bCanPrimaryInteract : 1;                           // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanSecondaryInteract : 1;                         // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrimaryInteractionSpeed;                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryInteractionSpeed;                         // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTaskInteractionInfo) == 0x000008, "Wrong alignment on FTaskInteractionInfo");
static_assert(sizeof(FTaskInteractionInfo) == 0x000048, "Wrong size on FTaskInteractionInfo");
static_assert(offsetof(FTaskInteractionInfo, PrimaryInteractionText) == 0x000008, "Member 'FTaskInteractionInfo::PrimaryInteractionText' has a wrong offset!");
static_assert(offsetof(FTaskInteractionInfo, SecondaryInteractionText) == 0x000020, "Member 'FTaskInteractionInfo::SecondaryInteractionText' has a wrong offset!");
static_assert(offsetof(FTaskInteractionInfo, PrimaryInteractionSpeed) == 0x00003C, "Member 'FTaskInteractionInfo::PrimaryInteractionSpeed' has a wrong offset!");
static_assert(offsetof(FTaskInteractionInfo, SecondaryInteractionSpeed) == 0x000040, "Member 'FTaskInteractionInfo::SecondaryInteractionSpeed' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleObjectiveCriteriaFloat
// 0x0038 (0x0038 - 0x0000)
struct FMoleObjectiveCriteriaFloat final
{
public:
	EMoleObjectiveCriteriaFloatType               ValueType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         FlatValue;                                         // 0x0008(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ActorRootTag;                                      // 0x0030(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCapValueByObjectiveTaskActorCount : 1;            // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowCapValueOption : 1;                           // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleObjectiveCriteriaFloat) == 0x000008, "Wrong alignment on FMoleObjectiveCriteriaFloat");
static_assert(sizeof(FMoleObjectiveCriteriaFloat) == 0x000038, "Wrong size on FMoleObjectiveCriteriaFloat");
static_assert(offsetof(FMoleObjectiveCriteriaFloat, ValueType) == 0x000000, "Member 'FMoleObjectiveCriteriaFloat::ValueType' has a wrong offset!");
static_assert(offsetof(FMoleObjectiveCriteriaFloat, FlatValue) == 0x000008, "Member 'FMoleObjectiveCriteriaFloat::FlatValue' has a wrong offset!");
static_assert(offsetof(FMoleObjectiveCriteriaFloat, ActorRootTag) == 0x000030, "Member 'FMoleObjectiveCriteriaFloat::ActorRootTag' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTaskLogicPhase
// 0x0028 (0x0028 - 0x0000)
struct FMoleTaskLogicPhase final
{
public:
	TArray<class UMoleTaskLogicAction*>           Actions;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMoleTaskLogicObjective*>        Objectives;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleTaskLogicPhase) == 0x000008, "Wrong alignment on FMoleTaskLogicPhase");
static_assert(sizeof(FMoleTaskLogicPhase) == 0x000028, "Wrong size on FMoleTaskLogicPhase");
static_assert(offsetof(FMoleTaskLogicPhase, Actions) == 0x000000, "Member 'FMoleTaskLogicPhase::Actions' has a wrong offset!");
static_assert(offsetof(FMoleTaskLogicPhase, Objectives) == 0x000010, "Member 'FMoleTaskLogicPhase::Objectives' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTaskMappingElement
// 0x0020 (0x0020 - 0x0000)
struct FMoleTaskMappingElement final
{
public:
	class FString                                 TaskDataContentPackageGuid;                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMoleTaskDescription>           SupportedTaskDescriptions;                         // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleTaskMappingElement) == 0x000008, "Wrong alignment on FMoleTaskMappingElement");
static_assert(sizeof(FMoleTaskMappingElement) == 0x000020, "Wrong size on FMoleTaskMappingElement");
static_assert(offsetof(FMoleTaskMappingElement, TaskDataContentPackageGuid) == 0x000000, "Member 'FMoleTaskMappingElement::TaskDataContentPackageGuid' has a wrong offset!");
static_assert(offsetof(FMoleTaskMappingElement, SupportedTaskDescriptions) == 0x000010, "Member 'FMoleTaskMappingElement::SupportedTaskDescriptions' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTaskScoreEventData
// 0x0008 (0x0008 - 0x0000)
struct FMoleTaskScoreEventData final
{
public:
	float                                         CurrentScore;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreGoal;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleTaskScoreEventData) == 0x000004, "Wrong alignment on FMoleTaskScoreEventData");
static_assert(sizeof(FMoleTaskScoreEventData) == 0x000008, "Wrong size on FMoleTaskScoreEventData");
static_assert(offsetof(FMoleTaskScoreEventData, CurrentScore) == 0x000000, "Member 'FMoleTaskScoreEventData::CurrentScore' has a wrong offset!");
static_assert(offsetof(FMoleTaskScoreEventData, ScoreGoal) == 0x000004, "Member 'FMoleTaskScoreEventData::ScoreGoal' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTaskTrackingData
// 0x0010 (0x0010 - 0x0000)
struct FMoleTaskTrackingData final
{
public:
	class UMoleTaskDataAsset*                     TaskAsset;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DistributionCountRemaining;                        // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInUse : 1;                                        // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasBeenGrantedBefore : 1;                         // 0x0009(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleTaskTrackingData) == 0x000008, "Wrong alignment on FMoleTaskTrackingData");
static_assert(sizeof(FMoleTaskTrackingData) == 0x000010, "Wrong size on FMoleTaskTrackingData");
static_assert(offsetof(FMoleTaskTrackingData, TaskAsset) == 0x000000, "Member 'FMoleTaskTrackingData::TaskAsset' has a wrong offset!");
static_assert(offsetof(FMoleTaskTrackingData, DistributionCountRemaining) == 0x000008, "Member 'FMoleTaskTrackingData::DistributionCountRemaining' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTaskPointData
// 0x0010 (0x0010 - 0x0000)
struct FMoleTaskPointData final
{
public:
	class AMoleTaskPoint*                         TaskPoint;                                         // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleTaskPointData) == 0x000008, "Wrong alignment on FMoleTaskPointData");
static_assert(sizeof(FMoleTaskPointData) == 0x000010, "Wrong size on FMoleTaskPointData");
static_assert(offsetof(FMoleTaskPointData, TaskPoint) == 0x000000, "Member 'FMoleTaskPointData::TaskPoint' has a wrong offset!");
static_assert(offsetof(FMoleTaskPointData, bIsVisible) == 0x000008, "Member 'FMoleTaskPointData::bIsVisible' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleNewTaskNotificationData
// 0x0020 (0x0020 - 0x0000)
struct FMoleNewTaskNotificationData final
{
public:
	class FText                                   TaskTitle;                                         // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EMoleNewTaskNotificationType                  NotificationType;                                  // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleNewTaskNotificationData) == 0x000008, "Wrong alignment on FMoleNewTaskNotificationData");
static_assert(sizeof(FMoleNewTaskNotificationData) == 0x000020, "Wrong size on FMoleNewTaskNotificationData");
static_assert(offsetof(FMoleNewTaskNotificationData, TaskTitle) == 0x000000, "Member 'FMoleNewTaskNotificationData::TaskTitle' has a wrong offset!");
static_assert(offsetof(FMoleNewTaskNotificationData, NotificationType) == 0x000018, "Member 'FMoleNewTaskNotificationData::NotificationType' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTaskMessagePayload
// 0x0020 (0x0020 - 0x0000)
struct FMoleTaskMessagePayload final
{
public:
	class UMoleTaskDataAsset*                     TaskAsset;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerState*                       AssociatedPlayerState;                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  AssociatedPlayerController;                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleTaskMessagePayload) == 0x000008, "Wrong alignment on FMoleTaskMessagePayload");
static_assert(sizeof(FMoleTaskMessagePayload) == 0x000020, "Wrong size on FMoleTaskMessagePayload");
static_assert(offsetof(FMoleTaskMessagePayload, TaskAsset) == 0x000000, "Member 'FMoleTaskMessagePayload::TaskAsset' has a wrong offset!");
static_assert(offsetof(FMoleTaskMessagePayload, AssociatedPlayerState) == 0x000008, "Member 'FMoleTaskMessagePayload::AssociatedPlayerState' has a wrong offset!");
static_assert(offsetof(FMoleTaskMessagePayload, AssociatedPlayerController) == 0x000010, "Member 'FMoleTaskMessagePayload::AssociatedPlayerController' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTimerInfo
// 0x0004 (0x0004 - 0x0000)
struct FMoleTimerInfo final
{
public:
	float                                         ServerTimeFinish;                                  // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleTimerInfo) == 0x000004, "Wrong alignment on FMoleTimerInfo");
static_assert(sizeof(FMoleTimerInfo) == 0x000004, "Wrong size on FMoleTimerInfo");
static_assert(offsetof(FMoleTimerInfo, ServerTimeFinish) == 0x000000, "Member 'FMoleTimerInfo::ServerTimeFinish' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleEmergencyMeetingData
// 0x0020 (0x0020 - 0x0000)
struct FMoleEmergencyMeetingData final
{
public:
	EEmergencyMeetingCause                        MeetingCause;                                      // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           MeetingCaller;                                     // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           BodyFound;                                         // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LocationTag;                                       // 0x0018(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleEmergencyMeetingData) == 0x000008, "Wrong alignment on FMoleEmergencyMeetingData");
static_assert(sizeof(FMoleEmergencyMeetingData) == 0x000020, "Wrong size on FMoleEmergencyMeetingData");
static_assert(offsetof(FMoleEmergencyMeetingData, MeetingCause) == 0x000000, "Member 'FMoleEmergencyMeetingData::MeetingCause' has a wrong offset!");
static_assert(offsetof(FMoleEmergencyMeetingData, MeetingCaller) == 0x000008, "Member 'FMoleEmergencyMeetingData::MeetingCaller' has a wrong offset!");
static_assert(offsetof(FMoleEmergencyMeetingData, BodyFound) == 0x000010, "Member 'FMoleEmergencyMeetingData::BodyFound' has a wrong offset!");
static_assert(offsetof(FMoleEmergencyMeetingData, LocationTag) == 0x000018, "Member 'FMoleEmergencyMeetingData::LocationTag' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleVote
// 0x0018 (0x0018 - 0x0000)
struct FMoleVote final
{
public:
	EVoteType                                     VoteType;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerState*                       VotingPlayer;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerState*                       AccusedPlayer;                                     // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleVote) == 0x000008, "Wrong alignment on FMoleVote");
static_assert(sizeof(FMoleVote) == 0x000018, "Wrong size on FMoleVote");
static_assert(offsetof(FMoleVote, VoteType) == 0x000000, "Member 'FMoleVote::VoteType' has a wrong offset!");
static_assert(offsetof(FMoleVote, VotingPlayer) == 0x000008, "Member 'FMoleVote::VotingPlayer' has a wrong offset!");
static_assert(offsetof(FMoleVote, AccusedPlayer) == 0x000010, "Member 'FMoleVote::AccusedPlayer' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleVoterList
// 0x0010 (0x0010 - 0x0000)
struct FMoleVoterList final
{
public:
	TArray<class APlayerState*>                   Voters;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleVoterList) == 0x000008, "Wrong alignment on FMoleVoterList");
static_assert(sizeof(FMoleVoterList) == 0x000010, "Wrong size on FMoleVoterList");
static_assert(offsetof(FMoleVoterList, Voters) == 0x000000, "Member 'FMoleVoterList::Voters' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleVotingSummary
// 0x0060 (0x0060 - 0x0000)
struct FMoleVotingSummary final
{
public:
	TMap<class APlayerState*, struct FMoleVoterList> VotingResults;                                     // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMoleVoterList                         SkippedVotes;                                      // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleVotingSummary) == 0x000008, "Wrong alignment on FMoleVotingSummary");
static_assert(sizeof(FMoleVotingSummary) == 0x000060, "Wrong size on FMoleVotingSummary");
static_assert(offsetof(FMoleVotingSummary, VotingResults) == 0x000000, "Member 'FMoleVotingSummary::VotingResults' has a wrong offset!");
static_assert(offsetof(FMoleVotingSummary, SkippedVotes) == 0x000050, "Member 'FMoleVotingSummary::SkippedVotes' has a wrong offset!");

// ScriptStruct MoleGameRuntime.TaskGenericPayload
// 0x0038 (0x0038 - 0x0000)
struct FTaskGenericPayload final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ContextTag;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextObject;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  UserTags;                                          // 0x0010(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UObject*                                UserObject;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTaskGenericPayload) == 0x000008, "Wrong alignment on FTaskGenericPayload");
static_assert(sizeof(FTaskGenericPayload) == 0x000038, "Wrong size on FTaskGenericPayload");
static_assert(offsetof(FTaskGenericPayload, EventTag) == 0x000000, "Member 'FTaskGenericPayload::EventTag' has a wrong offset!");
static_assert(offsetof(FTaskGenericPayload, ContextTag) == 0x000004, "Member 'FTaskGenericPayload::ContextTag' has a wrong offset!");
static_assert(offsetof(FTaskGenericPayload, ContextObject) == 0x000008, "Member 'FTaskGenericPayload::ContextObject' has a wrong offset!");
static_assert(offsetof(FTaskGenericPayload, UserTags) == 0x000010, "Member 'FTaskGenericPayload::UserTags' has a wrong offset!");
static_assert(offsetof(FTaskGenericPayload, UserObject) == 0x000030, "Member 'FTaskGenericPayload::UserObject' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleBlockedInput
// 0x0008 (0x0008 - 0x0000)
struct FMoleBlockedInput final
{
public:
	class FName                                   InputActionName;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAxis;                                           // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleBlockedInput) == 0x000004, "Wrong alignment on FMoleBlockedInput");
static_assert(sizeof(FMoleBlockedInput) == 0x000008, "Wrong size on FMoleBlockedInput");
static_assert(offsetof(FMoleBlockedInput, InputActionName) == 0x000000, "Member 'FMoleBlockedInput::InputActionName' has a wrong offset!");
static_assert(offsetof(FMoleBlockedInput, bIsAxis) == 0x000004, "Member 'FMoleBlockedInput::bIsAxis' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleHoldBinding
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMoleHoldBinding final
{
public:
	class FName                                   ActionBindingName;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   InvertedActionBindingName;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HoldTime;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0xC];                                        // 0x000C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleHoldBinding) == 0x000008, "Wrong alignment on FMoleHoldBinding");
static_assert(sizeof(FMoleHoldBinding) == 0x000018, "Wrong size on FMoleHoldBinding");
static_assert(offsetof(FMoleHoldBinding, ActionBindingName) == 0x000000, "Member 'FMoleHoldBinding::ActionBindingName' has a wrong offset!");
static_assert(offsetof(FMoleHoldBinding, InvertedActionBindingName) == 0x000004, "Member 'FMoleHoldBinding::InvertedActionBindingName' has a wrong offset!");
static_assert(offsetof(FMoleHoldBinding, HoldTime) == 0x000008, "Member 'FMoleHoldBinding::HoldTime' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleGenericMessagePayload
// 0x0030 (0x0030 - 0x0000)
struct FMoleGenericMessagePayload final
{
public:
	struct FGameplayTagContainer                  ContextTags;                                       // 0x0000(0x0020)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class AFortPlayerState*                       SourcePlayerState;                                 // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerState*                       TargetPlayerState;                                 // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleGenericMessagePayload) == 0x000008, "Wrong alignment on FMoleGenericMessagePayload");
static_assert(sizeof(FMoleGenericMessagePayload) == 0x000030, "Wrong size on FMoleGenericMessagePayload");
static_assert(offsetof(FMoleGenericMessagePayload, ContextTags) == 0x000000, "Member 'FMoleGenericMessagePayload::ContextTags' has a wrong offset!");
static_assert(offsetof(FMoleGenericMessagePayload, SourcePlayerState) == 0x000020, "Member 'FMoleGenericMessagePayload::SourcePlayerState' has a wrong offset!");
static_assert(offsetof(FMoleGenericMessagePayload, TargetPlayerState) == 0x000028, "Member 'FMoleGenericMessagePayload::TargetPlayerState' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleVoteResolutionData
// 0x0020 (0x0020 - 0x0000)
struct FMoleVoteResolutionData final
{
public:
	EVoteType                                     VoteType;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           EjectedPlayer;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortItemDefinition*                    EjectedPlayerItemDefinition;                       // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Votes;                                             // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnemy;                                          // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkippedDueToEqualVotesAndSkips;                   // 0x001D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleVoteResolutionData) == 0x000008, "Wrong alignment on FMoleVoteResolutionData");
static_assert(sizeof(FMoleVoteResolutionData) == 0x000020, "Wrong size on FMoleVoteResolutionData");
static_assert(offsetof(FMoleVoteResolutionData, VoteType) == 0x000000, "Member 'FMoleVoteResolutionData::VoteType' has a wrong offset!");
static_assert(offsetof(FMoleVoteResolutionData, EjectedPlayer) == 0x000008, "Member 'FMoleVoteResolutionData::EjectedPlayer' has a wrong offset!");
static_assert(offsetof(FMoleVoteResolutionData, EjectedPlayerItemDefinition) == 0x000010, "Member 'FMoleVoteResolutionData::EjectedPlayerItemDefinition' has a wrong offset!");
static_assert(offsetof(FMoleVoteResolutionData, Votes) == 0x000018, "Member 'FMoleVoteResolutionData::Votes' has a wrong offset!");
static_assert(offsetof(FMoleVoteResolutionData, bIsEnemy) == 0x00001C, "Member 'FMoleVoteResolutionData::bIsEnemy' has a wrong offset!");
static_assert(offsetof(FMoleVoteResolutionData, bSkippedDueToEqualVotesAndSkips) == 0x00001D, "Member 'FMoleVoteResolutionData::bSkippedDueToEqualVotesAndSkips' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleUIVisibilityData
// 0x0008 (0x0008 - 0x0000)
struct FMoleUIVisibilityData final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoleUIVisibilityData) == 0x000004, "Wrong alignment on FMoleUIVisibilityData");
static_assert(sizeof(FMoleUIVisibilityData) == 0x000008, "Wrong size on FMoleUIVisibilityData");
static_assert(offsetof(FMoleUIVisibilityData, bVisible) == 0x000000, "Member 'FMoleUIVisibilityData::bVisible' has a wrong offset!");
static_assert(offsetof(FMoleUIVisibilityData, PlayRate) == 0x000004, "Member 'FMoleUIVisibilityData::PlayRate' has a wrong offset!");

// ScriptStruct MoleGameRuntime.MoleTaskUIVisibilityData
// 0x0030 (0x0030 - 0x0000)
struct FMoleTaskUIVisibilityData final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  VisibleTaskExceptions;                             // 0x0008(0x0020)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoleTaskUIVisibilityData) == 0x000008, "Wrong alignment on FMoleTaskUIVisibilityData");
static_assert(sizeof(FMoleTaskUIVisibilityData) == 0x000030, "Wrong size on FMoleTaskUIVisibilityData");
static_assert(offsetof(FMoleTaskUIVisibilityData, bVisible) == 0x000000, "Member 'FMoleTaskUIVisibilityData::bVisible' has a wrong offset!");
static_assert(offsetof(FMoleTaskUIVisibilityData, VisibleTaskExceptions) == 0x000008, "Member 'FMoleTaskUIVisibilityData::VisibleTaskExceptions' has a wrong offset!");
static_assert(offsetof(FMoleTaskUIVisibilityData, PlayRate) == 0x000028, "Member 'FMoleTaskUIVisibilityData::PlayRate' has a wrong offset!");

// ScriptStruct MoleGameRuntime.FortCinematicBlackscreenData
// 0x000C (0x000C - 0x0000)
struct FFortCinematicBlackscreenData final
{
public:
	bool                                          bFadeToBlack;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldBlack;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFortCinematicBlackscreenData) == 0x000004, "Wrong alignment on FFortCinematicBlackscreenData");
static_assert(sizeof(FFortCinematicBlackscreenData) == 0x00000C, "Wrong size on FFortCinematicBlackscreenData");
static_assert(offsetof(FFortCinematicBlackscreenData, bFadeToBlack) == 0x000000, "Member 'FFortCinematicBlackscreenData::bFadeToBlack' has a wrong offset!");
static_assert(offsetof(FFortCinematicBlackscreenData, FadeTime) == 0x000004, "Member 'FFortCinematicBlackscreenData::FadeTime' has a wrong offset!");
static_assert(offsetof(FFortCinematicBlackscreenData, bHoldBlack) == 0x000008, "Member 'FFortCinematicBlackscreenData::bHoldBlack' has a wrong offset!");

// ScriptStruct MoleGameRuntime.FortCinematicElement
// 0x0008 (0x0008 - 0x0000)
struct FFortCinematicElement final
{
public:
	struct FGameplayTag                           ElementType;                                       // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ElementState;                                      // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFortCinematicElement) == 0x000004, "Wrong alignment on FFortCinematicElement");
static_assert(sizeof(FFortCinematicElement) == 0x000008, "Wrong size on FFortCinematicElement");
static_assert(offsetof(FFortCinematicElement, ElementType) == 0x000000, "Member 'FFortCinematicElement::ElementType' has a wrong offset!");
static_assert(offsetof(FFortCinematicElement, ElementState) == 0x000004, "Member 'FFortCinematicElement::ElementState' has a wrong offset!");

// ScriptStruct MoleGameRuntime.FortCinematicState
// 0x0048 (0x0048 - 0x0000)
struct FFortCinematicState final
{
public:
	struct FGameplayTag                           StateId;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortCinematicElement>          CinematicElements;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bSequenceStarted;                                  // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SequenceDuration;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntroFadeInBlackscreenTime;                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntroFadeOutBlackscreenTime;                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutroFadeOutBlackscreenTime;                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x1C];                                      // 0x002C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFortCinematicState) == 0x000008, "Wrong alignment on FFortCinematicState");
static_assert(sizeof(FFortCinematicState) == 0x000048, "Wrong size on FFortCinematicState");
static_assert(offsetof(FFortCinematicState, StateId) == 0x000000, "Member 'FFortCinematicState::StateId' has a wrong offset!");
static_assert(offsetof(FFortCinematicState, CinematicElements) == 0x000008, "Member 'FFortCinematicState::CinematicElements' has a wrong offset!");
static_assert(offsetof(FFortCinematicState, bSequenceStarted) == 0x000018, "Member 'FFortCinematicState::bSequenceStarted' has a wrong offset!");
static_assert(offsetof(FFortCinematicState, SequenceDuration) == 0x00001C, "Member 'FFortCinematicState::SequenceDuration' has a wrong offset!");
static_assert(offsetof(FFortCinematicState, IntroFadeInBlackscreenTime) == 0x000020, "Member 'FFortCinematicState::IntroFadeInBlackscreenTime' has a wrong offset!");
static_assert(offsetof(FFortCinematicState, IntroFadeOutBlackscreenTime) == 0x000024, "Member 'FFortCinematicState::IntroFadeOutBlackscreenTime' has a wrong offset!");
static_assert(offsetof(FFortCinematicState, OutroFadeOutBlackscreenTime) == 0x000028, "Member 'FFortCinematicState::OutroFadeOutBlackscreenTime' has a wrong offset!");

}

