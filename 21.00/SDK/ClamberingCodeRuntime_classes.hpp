#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ClamberingCodeRuntime

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_0_structs.hpp"
#include "ClamberingCodeRuntime_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "FortniteGame_classes.hpp"


namespace SDK
{

// Class ClamberingCodeRuntime.ClamberingAnalytics
// 0x0000 (0x0028 - 0x0028)
class UClamberingAnalytics final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClamberingAnalytics">();
	}
	static class UClamberingAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClamberingAnalytics>();
	}
};
static_assert(alignof(UClamberingAnalytics) == 0x000008, "Wrong alignment on UClamberingAnalytics");
static_assert(sizeof(UClamberingAnalytics) == 0x000028, "Wrong size on UClamberingAnalytics");

// Class ClamberingCodeRuntime.ClamberingComponent
// 0x0980 (0x0A20 - 0x00A0)
class UClamberingComponent final : public UFortPawnComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EClamberingState                              LocalClamberingState;                              // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EClamberingState                              ReplicatedClamberingState;                         // 0x00A9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClamberingTargetingData               LockedTargetingData;                               // 0x00B0(0x00D0)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FReplicatedClamberingTargetingData_SimClient ReplicatedTargetingData;                           // 0x0180(0x0038)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ClamberingEnabled;                                 // 0x01C0(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ClamberIndicatorEnabled;                           // 0x01E8(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ClamberStartMaxFallingDamageFraction;              // 0x0210(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bPerformTargetingWhileWalking;                     // 0x0238(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPerformTargetingWhileSwimming;                    // 0x0239(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A[0x6];                                      // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ServerFailDelay;                                   // 0x0240(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ServerValidatePlayerMaxDistance;                   // 0x0268(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FClamberingInputConfig                 InputConfig;                                       // 0x0290(0x0210)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FClamberingTargetingConfig_Ledge       TargetingConfig_Ledge;                             // 0x04A0(0x02A8)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FClamberingMovementConfig_Ledge        MoveConfig_Ledge;                                  // 0x0748(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ClamberSyncTargetLedgeOffset;                      // 0x0798(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ClamberingMaxAnalyticsEvents;                      // 0x07C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SynchedActionFailDelay;                            // 0x07E8(0x0028)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bTutorialModeEnabled;                              // 0x0810(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_811[0x7];                                      // 0x0811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClamberingTargetingData               LocalTargetingData;                                // 0x0818(0x00D0)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FClamberingTargetingData               ParallelTargetingData;                             // 0x08E8(0x00D0)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         QueuedInputTimer;                                  // 0x09B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InputEnabledTimer;                                 // 0x09BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bJumpInputPressed;                                 // 0x09C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C1[0x3];                                      // 0x09C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpHeldInAirTime;                                 // 0x09C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C8[0x50];                                     // 0x09C8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Tag_DisableClambering;                             // 0x0A18(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1C[0x4];                                      // 0x0A1C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_HandleClamberingStateChanged(const EClamberingState OldClamberingState, const EClamberingState NewClamberingState);
	void BP_HandleSynchedActionStarted();
	void DrawDebugHUD(class AHUD* HUD, class UCanvas* Canvas);
	void HandleClamberingTargetInActivationRange();
	void HandleClamberingTargetOutOfActivationRange();
	void HandleOwnerASCInitialized(class UFortAbilitySystemComponent* AbilitySystemComponent, class AFortPlayerPawn* AffectedPawn);
	void HandleOwnerASCInvalidated();
	void HandleOwnerDBNO();
	void HandleOwnerDied(class AFortPawn* DeadPawn);
	void HandleOwnerJumpInput(bool bPressed);
	void HandleOwnerMovementModeChanged(class ACharacter* Character, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode);
	void HandleTargetActorDestroyed(class AActor* Actor);
	void HandleTargetActorHealthChanged();
	void HandleTargetingDataInvalid();
	void HandleTargetingDataValid(const struct FClamberingTargetingData& TargetingData);
	void NetMulticast_ClamberingLedgeFailed(EClamberingFailedReason FailedReason, EClamberingState FailedState);
	void OnMutatorUpdated();
	void OnPlayerStatePawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn);
	void OnRep_ReplicatedClamberingState();
	void OnRep_ReplicatedTargetingData();
	void RegisterMutatorUpdatedDelegate(class APawn* AffectedPawn);
	void ServerStartClambering(const struct FReplicatedClamberingTargetingData& InReplicatedTargetingData);
	void SetTutorialModeEnabled(bool bEnabled);
	void UnregisterMutatorUpdatedDelegate();

	void BP_CanStartClambering(bool* bCanStartClambering) const;
	void BP_CanStartTargeting(bool* bCanStartTargeting) const;
	void BP_IsValidTargetActor(const class AActor* TargetActor, bool* bIsValidTargetActor) const;
	void BP_TutorialModeDisabled() const;
	void BP_TutorialModeEnabled() const;
	bool IsAutoClamberingEnabled() const;
	bool IsClamberingEnabled() const;
	bool IsTutorialModeEnabled() const;
	bool ShouldShowClamberIndicator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClamberingComponent">();
	}
	static class UClamberingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClamberingComponent>();
	}
};
static_assert(alignof(UClamberingComponent) == 0x000008, "Wrong alignment on UClamberingComponent");
static_assert(sizeof(UClamberingComponent) == 0x000A20, "Wrong size on UClamberingComponent");
static_assert(offsetof(UClamberingComponent, LocalClamberingState) == 0x0000A8, "Member 'UClamberingComponent::LocalClamberingState' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ReplicatedClamberingState) == 0x0000A9, "Member 'UClamberingComponent::ReplicatedClamberingState' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, LockedTargetingData) == 0x0000B0, "Member 'UClamberingComponent::LockedTargetingData' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ReplicatedTargetingData) == 0x000180, "Member 'UClamberingComponent::ReplicatedTargetingData' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberingEnabled) == 0x0001C0, "Member 'UClamberingComponent::ClamberingEnabled' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberIndicatorEnabled) == 0x0001E8, "Member 'UClamberingComponent::ClamberIndicatorEnabled' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberStartMaxFallingDamageFraction) == 0x000210, "Member 'UClamberingComponent::ClamberStartMaxFallingDamageFraction' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, bPerformTargetingWhileWalking) == 0x000238, "Member 'UClamberingComponent::bPerformTargetingWhileWalking' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, bPerformTargetingWhileSwimming) == 0x000239, "Member 'UClamberingComponent::bPerformTargetingWhileSwimming' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ServerFailDelay) == 0x000240, "Member 'UClamberingComponent::ServerFailDelay' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ServerValidatePlayerMaxDistance) == 0x000268, "Member 'UClamberingComponent::ServerValidatePlayerMaxDistance' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, InputConfig) == 0x000290, "Member 'UClamberingComponent::InputConfig' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, TargetingConfig_Ledge) == 0x0004A0, "Member 'UClamberingComponent::TargetingConfig_Ledge' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, MoveConfig_Ledge) == 0x000748, "Member 'UClamberingComponent::MoveConfig_Ledge' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberSyncTargetLedgeOffset) == 0x000798, "Member 'UClamberingComponent::ClamberSyncTargetLedgeOffset' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ClamberingMaxAnalyticsEvents) == 0x0007C0, "Member 'UClamberingComponent::ClamberingMaxAnalyticsEvents' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, SynchedActionFailDelay) == 0x0007E8, "Member 'UClamberingComponent::SynchedActionFailDelay' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, bTutorialModeEnabled) == 0x000810, "Member 'UClamberingComponent::bTutorialModeEnabled' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, LocalTargetingData) == 0x000818, "Member 'UClamberingComponent::LocalTargetingData' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, ParallelTargetingData) == 0x0008E8, "Member 'UClamberingComponent::ParallelTargetingData' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, QueuedInputTimer) == 0x0009B8, "Member 'UClamberingComponent::QueuedInputTimer' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, InputEnabledTimer) == 0x0009BC, "Member 'UClamberingComponent::InputEnabledTimer' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, bJumpInputPressed) == 0x0009C0, "Member 'UClamberingComponent::bJumpInputPressed' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, JumpHeldInAirTime) == 0x0009C4, "Member 'UClamberingComponent::JumpHeldInAirTime' has a wrong offset!");
static_assert(offsetof(UClamberingComponent, Tag_DisableClambering) == 0x000A18, "Member 'UClamberingComponent::Tag_DisableClambering' has a wrong offset!");

// Class ClamberingCodeRuntime.ClamberingLibrary
// 0x0000 (0x0028 - 0x0028)
class UClamberingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool PerformClamberingTargeting(const class ACharacter* Character, struct FClamberingTargetingData* OutTargetingData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClamberingLibrary">();
	}
	static class UClamberingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClamberingLibrary>();
	}
};
static_assert(alignof(UClamberingLibrary) == 0x000008, "Wrong alignment on UClamberingLibrary");
static_assert(sizeof(UClamberingLibrary) == 0x000028, "Wrong size on UClamberingLibrary");

}

