#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FortniteAI

#include "Basic.hpp"

#include "NavigationSystem_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "FortniteAI_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "ModularGameplay_classes.hpp"
#include "GameplayTags_0_structs.hpp"
#include "SmartObjectsModule_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Class FortniteAI.FortAthenaAISpawnerDataComponent
// 0x0008 (0x0030 - 0x0028)
class UFortAthenaAISpawnerDataComponent : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent">();
	}
	static class UFortAthenaAISpawnerDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent");

// Class FortniteAI.FortAITask_FuzzyQueue
// 0x0020 (0x0130 - 0x0110)
class UFortAITask_FuzzyQueue final : public UAITask_MoveTo
{
public:
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_FuzzyQueue">();
	}
	static class UFortAITask_FuzzyQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_FuzzyQueue>();
	}
};
static_assert(alignof(UFortAITask_FuzzyQueue) == 0x000008, "Wrong alignment on UFortAITask_FuzzyQueue");
static_assert(sizeof(UFortAITask_FuzzyQueue) == 0x000130, "Wrong size on UFortAITask_FuzzyQueue");

// Class FortniteAI.FortNavMesh
// 0x0008 (0x0558 - 0x0550)
class AFortNavMesh : public ARecastNavMesh
{
public:
	class UFortAIHotSpotManager*                  HotSpotManager;                                    // 0x0550(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavMesh">();
	}
	static class AFortNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavMesh>();
	}
};
static_assert(alignof(AFortNavMesh) == 0x000008, "Wrong alignment on AFortNavMesh");
static_assert(sizeof(AFortNavMesh) == 0x000558, "Wrong size on AFortNavMesh");
static_assert(offsetof(AFortNavMesh, HotSpotManager) == 0x000550, "Member 'AFortNavMesh::HotSpotManager' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_ScriptBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_ScriptBase : public UFortAthenaAISpawnerDataComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_ScriptBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_ScriptBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_ScriptBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_ScriptBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_ScriptBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_ScriptBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_ScriptBase");

// Class FortniteAI.FortAthenaAIBotSkillSet
// 0x0008 (0x0030 - 0x0028)
class UFortAthenaAIBotSkillSet : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotSkillSet">();
	}
	static class UFortAthenaAIBotSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotSkillSet");
static_assert(sizeof(UFortAthenaAIBotSkillSet) == 0x000030, "Wrong size on UFortAthenaAIBotSkillSet");

// Class FortniteAI.FortAthenaAIBotUnstuckSkillSet
// 0x0320 (0x0350 - 0x0030)
class UFortAthenaAIBotUnstuckSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         CanTeleportWhenStuck;                              // 0x0030(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CanTeleportWhenStuckWithPlayerAround;              // 0x0058(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxDistanceToPlayerToTeleport;                     // 0x0080(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         PlayerToPhoebeAngleVisibilityConeToTeleport;       // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxSafeZoneIndexToAllowTeleport;                   // 0x00D0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeToCloseBlockingDoor;                           // 0x00F8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeToBreakBlockingDoor;                           // 0x0120(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RiverbedObstacleCollisionNormalThreshold;          // 0x0148(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CanUseSteeringWhenStuckOnIsolatedIsland;           // 0x0170(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxSteeringDirectionAttempts;                      // 0x0198(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         SteeringAttemptDuration;                           // 0x01C0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EvaluateIsolatedIslandSteeringTime;                // 0x01E8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeBetweenPartialPathToConsiderPathStuck;         // 0x0210(0x0028)(Edit, AdvancedDisplay, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ConsecutivePartialPathCountToConsiderPathStuck;    // 0x0238(0x0028)(Edit, AdvancedDisplay, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         DistanceBetweenSampleToConsiderPathStuckInWater;   // 0x0260(0x0028)(Edit, AdvancedDisplay, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeBetweenSampleToConsiderPathStuckInWater;       // 0x0288(0x0028)(Edit, AdvancedDisplay, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         DistanceBetweenSampleToConsiderPathStuckOnGround;  // 0x02B0(0x0028)(Edit, AdvancedDisplay, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeBetweenSampleToConsiderPathStuckOnGround;      // 0x02D8(0x0028)(Edit, AdvancedDisplay, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         DistanceBetweenBlockedPathToConsiderPathStuck;     // 0x0300(0x0028)(Transient, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ConsecutiveBlockedPathCountToConsiderPathStuck;    // 0x0328(0x0028)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotUnstuckSkillSet">();
	}
	static class UFortAthenaAIBotUnstuckSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotUnstuckSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotUnstuckSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotUnstuckSkillSet");
static_assert(sizeof(UFortAthenaAIBotUnstuckSkillSet) == 0x000350, "Wrong size on UFortAthenaAIBotUnstuckSkillSet");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, CanTeleportWhenStuck) == 0x000030, "Member 'UFortAthenaAIBotUnstuckSkillSet::CanTeleportWhenStuck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, CanTeleportWhenStuckWithPlayerAround) == 0x000058, "Member 'UFortAthenaAIBotUnstuckSkillSet::CanTeleportWhenStuckWithPlayerAround' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, MaxDistanceToPlayerToTeleport) == 0x000080, "Member 'UFortAthenaAIBotUnstuckSkillSet::MaxDistanceToPlayerToTeleport' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, PlayerToPhoebeAngleVisibilityConeToTeleport) == 0x0000A8, "Member 'UFortAthenaAIBotUnstuckSkillSet::PlayerToPhoebeAngleVisibilityConeToTeleport' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, MaxSafeZoneIndexToAllowTeleport) == 0x0000D0, "Member 'UFortAthenaAIBotUnstuckSkillSet::MaxSafeZoneIndexToAllowTeleport' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, TimeToCloseBlockingDoor) == 0x0000F8, "Member 'UFortAthenaAIBotUnstuckSkillSet::TimeToCloseBlockingDoor' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, TimeToBreakBlockingDoor) == 0x000120, "Member 'UFortAthenaAIBotUnstuckSkillSet::TimeToBreakBlockingDoor' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, RiverbedObstacleCollisionNormalThreshold) == 0x000148, "Member 'UFortAthenaAIBotUnstuckSkillSet::RiverbedObstacleCollisionNormalThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, CanUseSteeringWhenStuckOnIsolatedIsland) == 0x000170, "Member 'UFortAthenaAIBotUnstuckSkillSet::CanUseSteeringWhenStuckOnIsolatedIsland' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, MaxSteeringDirectionAttempts) == 0x000198, "Member 'UFortAthenaAIBotUnstuckSkillSet::MaxSteeringDirectionAttempts' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, SteeringAttemptDuration) == 0x0001C0, "Member 'UFortAthenaAIBotUnstuckSkillSet::SteeringAttemptDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, EvaluateIsolatedIslandSteeringTime) == 0x0001E8, "Member 'UFortAthenaAIBotUnstuckSkillSet::EvaluateIsolatedIslandSteeringTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, TimeBetweenPartialPathToConsiderPathStuck) == 0x000210, "Member 'UFortAthenaAIBotUnstuckSkillSet::TimeBetweenPartialPathToConsiderPathStuck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, ConsecutivePartialPathCountToConsiderPathStuck) == 0x000238, "Member 'UFortAthenaAIBotUnstuckSkillSet::ConsecutivePartialPathCountToConsiderPathStuck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, DistanceBetweenSampleToConsiderPathStuckInWater) == 0x000260, "Member 'UFortAthenaAIBotUnstuckSkillSet::DistanceBetweenSampleToConsiderPathStuckInWater' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, TimeBetweenSampleToConsiderPathStuckInWater) == 0x000288, "Member 'UFortAthenaAIBotUnstuckSkillSet::TimeBetweenSampleToConsiderPathStuckInWater' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, DistanceBetweenSampleToConsiderPathStuckOnGround) == 0x0002B0, "Member 'UFortAthenaAIBotUnstuckSkillSet::DistanceBetweenSampleToConsiderPathStuckOnGround' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, TimeBetweenSampleToConsiderPathStuckOnGround) == 0x0002D8, "Member 'UFortAthenaAIBotUnstuckSkillSet::TimeBetweenSampleToConsiderPathStuckOnGround' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, DistanceBetweenBlockedPathToConsiderPathStuck) == 0x000300, "Member 'UFortAthenaAIBotUnstuckSkillSet::DistanceBetweenBlockedPathToConsiderPathStuck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckSkillSet, ConsecutiveBlockedPathCountToConsiderPathStuck) == 0x000328, "Member 'UFortAthenaAIBotUnstuckSkillSet::ConsecutiveBlockedPathCountToConsiderPathStuck' has a wrong offset!");

// Class FortniteAI.AITask_ExecuteAbility
// 0x0028 (0x0090 - 0x0068)
class UAITask_ExecuteAbility : public UAITask
{
public:
	uint8                                         Pad_68[0x28];                                      // 0x0068(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITask_ExecuteAbility">();
	}
	static class UAITask_ExecuteAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITask_ExecuteAbility>();
	}
};
static_assert(alignof(UAITask_ExecuteAbility) == 0x000008, "Wrong alignment on UAITask_ExecuteAbility");
static_assert(sizeof(UAITask_ExecuteAbility) == 0x000090, "Wrong size on UAITask_ExecuteAbility");

// Class FortniteAI.FortAthenaAIRuntimeParameters
// 0x0008 (0x0030 - 0x0028)
class UFortAthenaAIRuntimeParameters : public UObject
{
public:
	int32                                         ExtractedLevel;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters">();
	}
	static class UFortAthenaAIRuntimeParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters");
static_assert(sizeof(UFortAthenaAIRuntimeParameters) == 0x000030, "Wrong size on UFortAthenaAIRuntimeParameters");
static_assert(offsetof(UFortAthenaAIRuntimeParameters, ExtractedLevel) == 0x000028, "Member 'UFortAthenaAIRuntimeParameters::ExtractedLevel' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_Analytic
// 0x0020 (0x0050 - 0x0030)
class UFortAthenaAIRuntimeParameters_Analytic : public UFortAthenaAIRuntimeParameters
{
public:
	struct FGameplayTagContainer                  OnDeathGameplayTags;                               // 0x0030(0x0020)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_Analytic">();
	}
	static class UFortAthenaAIRuntimeParameters_Analytic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_Analytic>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_Analytic) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_Analytic");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_Analytic) == 0x000050, "Wrong size on UFortAthenaAIRuntimeParameters_Analytic");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Analytic, OnDeathGameplayTags) == 0x000030, "Member 'UFortAthenaAIRuntimeParameters_Analytic::OnDeathGameplayTags' has a wrong offset!");

// Class FortniteAI.FortAIComponent_Telemetry
// 0x0058 (0x00F8 - 0x00A0)
class UFortAIComponent_Telemetry : public UActorComponent
{
public:
	class AFortAIPawn*                            PossessedPawn;                                     // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AAthenaAIController*                    CachedAIController;                                // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            DeathInstigator;                                   // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UFortItemDefinition*>            GrabbedPickups;                                    // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UFortItemDefinition*>            DroppedPickups;                                    // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFortAthenaAIRuntimeParameters_AIAnalytic* AnalyticRuntimeParameters;                         // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDidDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnPawnDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnTetheredFollowerChanged(class AFortPawn* NewFollower, class AFortPawn* OldFollower);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIComponent_Telemetry">();
	}
	static class UFortAIComponent_Telemetry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIComponent_Telemetry>();
	}
};
static_assert(alignof(UFortAIComponent_Telemetry) == 0x000008, "Wrong alignment on UFortAIComponent_Telemetry");
static_assert(sizeof(UFortAIComponent_Telemetry) == 0x0000F8, "Wrong size on UFortAIComponent_Telemetry");
static_assert(offsetof(UFortAIComponent_Telemetry, PossessedPawn) == 0x0000A0, "Member 'UFortAIComponent_Telemetry::PossessedPawn' has a wrong offset!");
static_assert(offsetof(UFortAIComponent_Telemetry, CachedAIController) == 0x0000A8, "Member 'UFortAIComponent_Telemetry::CachedAIController' has a wrong offset!");
static_assert(offsetof(UFortAIComponent_Telemetry, DeathInstigator) == 0x0000B0, "Member 'UFortAIComponent_Telemetry::DeathInstigator' has a wrong offset!");
static_assert(offsetof(UFortAIComponent_Telemetry, GrabbedPickups) == 0x0000B8, "Member 'UFortAIComponent_Telemetry::GrabbedPickups' has a wrong offset!");
static_assert(offsetof(UFortAIComponent_Telemetry, DroppedPickups) == 0x0000C8, "Member 'UFortAIComponent_Telemetry::DroppedPickups' has a wrong offset!");
static_assert(offsetof(UFortAIComponent_Telemetry, AnalyticRuntimeParameters) == 0x0000D8, "Member 'UFortAIComponent_Telemetry::AnalyticRuntimeParameters' has a wrong offset!");

// Class FortniteAI.AISenseScalableConfig
// 0x0000 (0x0028 - 0x0028)
class UAISenseScalableConfig : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseScalableConfig">();
	}
	static class UAISenseScalableConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseScalableConfig>();
	}
};
static_assert(alignof(UAISenseScalableConfig) == 0x000008, "Wrong alignment on UAISenseScalableConfig");
static_assert(sizeof(UAISenseScalableConfig) == 0x000028, "Wrong size on UAISenseScalableConfig");

// Class FortniteAI.AthenaAIPopulationTracker
// 0x0128 (0x0160 - 0x0038)
class alignas(0x10) UAthenaAIPopulationTracker final : public UAISubsystem
{
public:
	TMulticastInlineDelegate<void(class AController* KilledController, bool bIsABot, class AFortPawn* KilledAIPawn, class AFortPlayerPawn* KilledPlayerPawn, class AController* KillerController)> OnAIPawnDied;                                      // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AController* SpawnedController, bool bIsABot, class AFortPawn* FortAIPawn, class AFortPlayerPawn* PlayerPawn)> OnAIPawnSpawned;                                   // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x60];                                      // 0x0058(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AController*>                    AIList;                                            // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AFortGameModeAthena*                    CachedGameMode;                                    // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x90];                                      // 0x00D0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAgentGameOver(class AFortAthenaAIBotController* AIBotController, class AFortPawn* Pawn, class AController* Instigator);
	void OnAISpawned(class APawn* Pawn, const int32 RequestId);
	void OnFortPawnDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

	TArray<class AController*> GetAIMatchingQuery(const struct FGameplayTagQuery& TagQuery) const;
	struct FAIPopulationCountSnapshot GetAIPopulationTrackerCount() const;
	int32 GetNumAIPawn() const;
	int32 GetNumNonAthenaParticipantBots() const;
	int32 GetNumPlayerBots() const;
	int32 GetNumTotalBots() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIPopulationTracker">();
	}
	static class UAthenaAIPopulationTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIPopulationTracker>();
	}
};
static_assert(alignof(UAthenaAIPopulationTracker) == 0x000010, "Wrong alignment on UAthenaAIPopulationTracker");
static_assert(sizeof(UAthenaAIPopulationTracker) == 0x000160, "Wrong size on UAthenaAIPopulationTracker");
static_assert(offsetof(UAthenaAIPopulationTracker, OnAIPawnDied) == 0x000038, "Member 'UAthenaAIPopulationTracker::OnAIPawnDied' has a wrong offset!");
static_assert(offsetof(UAthenaAIPopulationTracker, OnAIPawnSpawned) == 0x000048, "Member 'UAthenaAIPopulationTracker::OnAIPawnSpawned' has a wrong offset!");
static_assert(offsetof(UAthenaAIPopulationTracker, AIList) == 0x0000B8, "Member 'UAthenaAIPopulationTracker::AIList' has a wrong offset!");
static_assert(offsetof(UAthenaAIPopulationTracker, CachedGameMode) == 0x0000C8, "Member 'UAthenaAIPopulationTracker::CachedGameMode' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotController
// 0x0E18 (0x11B0 - 0x0398)
class AFortAthenaAIBotController final : public AAIController
{
public:
	uint8                                         Pad_398[0x40];                                     // 0x0398(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PreviousVehicle;                                   // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FFortAbilitySetHandle> AppliedInGameModifierAbilitySetHandles;            // 0x03F0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<struct FGuid>                            GadgetTrackedAttributeItemInstanceIds;             // 0x0440(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortBotTargetHandler                  TargetHandler;                                     // 0x04E0(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x1];                                      // 0x0508(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_509_0 : 1;                                  // 0x0509(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsAnAthenaGameParticipant : 1;                    // 0x0509(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EReachLocationValidationMode                  ReachLocationValidationMode;                       // 0x050A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50B[0x5];                                      // 0x050B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortBotInventoryInfo                  SlotItems[0x6];                                    // 0x0518(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A8[0x18];                                     // 0x05A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotInventoryDigestedSkillSet* CacheInventoryDigestedSkillSet;                    // 0x05C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerPawnAthena*                  PlayerBotPawn;                                     // 0x05D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAthenaAIServicePlayerBots*             CachedAIServicePlayerBots;                         // 0x05D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortGameModeAthena*                    CachedGameMode;                                    // 0x05E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIRuntimeParametersComponent* CachedAIRuntimeParametersComponent;                // 0x05E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIRuntimeParameters_Leash*   CachedLeashRuntimeParameters;                      // 0x05F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIRuntimeParameters_AffiliationBase* CachedAffiliationRuntimeParameters;                // 0x05F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaNpcPatrollingComponent*      CachedPatrollingComponent;                         // 0x0600(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAIControllerPerksComponent*        CachedAIPerksComponent;                            // 0x0608(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_610[0x8];                                      // 0x0610(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBotDelayedStimulus>            DelayedStimulus;                                   // 0x0618(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_628[0x18];                                     // 0x0628(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortBotThreatActorInfo>        ObjectsThreatList;                                 // 0x0640(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortBotThreatActorInfo>        TrapsThreatList;                                   // 0x0650(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	EAlertLevel                                   CurrentAlertLevel;                                 // 0x0660(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_661[0x7];                                      // 0x0661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlertLevelInfo                        DefaultAlertLevelInfo;                             // 0x0668(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AFortAthenaAIBotController* BotController, EAlertLevel OldAlertLevel, EAlertLevel NewAlertLevel)> OnAlertLevelChangedEventDelegate;                  // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AFortAthenaAIBotController* BotController, float StealthMeterTarget, float StealthMeterTargetTime)> OnStealthMeterChangedEventDelegate;                // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AFortAthenaAIBotController* BotController, bool bIsDBNO)> OnAgentDBNOStatusChangedEventDelegate;             // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AFortAthenaAIBotController* BotController, class AFortPawn* AgentPawn)> OnAgentDiedEventDelegate;                          // 0x06B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AFortAthenaAIBotController* BotController, class AFortPawn* AgentPawn, class AController* InstigatedBy)> OnAgentGameOver;                                   // 0x06C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D0[0x48];                                     // 0x06D0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AFortPlayerPawn* KilledPlayerPawn)> OnPlayerPawnKilledByBot;                           // 0x0718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AFortAIPawn* KilledAIPawn)> OnAIPawnKilledByBot;                               // 0x0728(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class AFortInventory*                         Inventory;                                         // 0x0738(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Skill;                                             // 0x0740(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllowUnsupportedItemsInDefaultInventory : 1;      // 0x0744(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_745[0x3];                                      // 0x0745(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UFortAthenaAIBotSkillSet>> BotSkillSetClasses;                                // 0x0748(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_758[0x20];                                     // 0x0758(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotInventoryItems*         StartupInventory;                                  // 0x0778(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TStructCycleFixup<struct FFortAthenaLoadout, 0x0168, 0x08> CosmeticLoadoutBC;                                 // 0x0780(0x0168)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UCustomCharacterPart*>           CustomCharacterPartOverridesBC;                    // 0x08E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UFortBotNameSettings*                   NameSettingsBC;                                    // 0x08F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SpectateOnDeathMinTime;                            // 0x0900(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SpectateOnDeathMaxTime;                            // 0x0928(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         EmotesMaxCount;                                    // 0x0950(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotPerceptionDigestedSkillSet* CachePerceptionDigestedSkillSet;                   // 0x0978(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotHarvestDigestedSkillSet* CacheHarvestDigestedSkillSet;                      // 0x0980(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotMovementDigestedSkillSet* CacheMovementSkillSet;                             // 0x0988(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotLootingDigestedSkillSet* CacheLootingSkillSet;                              // 0x0990(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotAttackingDigestedSkillSet* CacheAttackingSkillSet;                            // 0x0998(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotPlayStyleDigestedSkillSet* CachePlayStyleSkillSet;                            // 0x09A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotUnstuckDigestedSkillSet* CacheUnstuckSkillSet;                              // 0x09A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotRangeAttackDigestedSkillSet* CacheRangeAttackSkillSet;                          // 0x09B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B8[0x60];                                     // 0x09B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortInteractContextInfo*               InteractContextInfo;                               // 0x0A18(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A20[0x50];                                     // 0x0A20(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotAimingDigestedSkillSet* CacheAimingDigestedSkillSet;                       // 0x0A70(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A78[0x4];                                      // 0x0A78(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCanBeDestroyedOnDeath : 1;                        // 0x0A7C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A7D[0xB];                                      // 0x0A7D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastDeathLocation;                                 // 0x0A88(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LastDeathRotation;                                 // 0x0AA0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UFortWorldItem*                         CachedWorldItem;                                   // 0x0AB8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC0[0x8];                                      // 0x0AC0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortWeapon*                            CacheWeaponUsedToCalculateType;                    // 0x0AC8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCachedIsUsingArcedProjectileWeapon;               // 0x0AD0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD1[0x3];                                      // 0x0AD1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedProjectileGravityScale;                      // 0x0AD4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortWeapon*                            CachedWeaponUsedToCalculateProjectileData;         // 0x0AD8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatManager*                           StatManager;                                       // 0x0AE0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBuildingWeakSpotData>          ActiveWeakSpots;                                   // 0x0AE8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF8[0x28];                                     // 0x0AF8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortPawn>                  CacheBotPawnClass;                                 // 0x0B20(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B28[0x8];                                      // 0x0B28(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentLootActor;                                  // 0x0B30(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAthenaMarkerComponent*                 MarkerComponent;                                   // 0x0B38(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BotPlayerName;                                     // 0x0B40(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BotIDSuffix;                                       // 0x0B50(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BotPlayerNameWithSkillRating;                      // 0x0B60(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B70[0x10];                                     // 0x0B70(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaMutator_SpawningPolicyData*  PolicyDataSpawner;                                 // 0x0B80(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B88[0xD8];                                     // 0x0B88(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortControllerComponent_Telemetry*     FortControllerComponent_Telemetry;                 // 0x0C60(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceUsingBuildingTool;                           // 0x0C68(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceHolsterWeapon;                               // 0x0C69(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C6A[0x6];                                      // 0x0C6A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortWorldItem*                         PendingEquipWeapon;                                // 0x0C70(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C78[0x48];                                     // 0x0C78(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  PlayerToSpectateOnDeath;                           // 0x0CC0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AFortAthenaAIBotController* BotController, class AFortPlayerPawnAthena* BotPawn)> OnPlayerPawnAISpawnedDelegate;                     // 0x0CC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD8[0xF0];                                     // 0x0CD8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISenseConfig_Sight*                   AISenseConfig_SightOverride;                       // 0x0DC8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD0[0x10];                                     // 0x0DD0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BotOwner;                                          // 0x0DE0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BotControllerUID;                                  // 0x0DE8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DEC[0x4];                                      // 0x0DEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerPawnAthena*                  ReviveTarget;                                      // 0x0DF0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DF8[0x90];                                     // 0x0DF8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotCustomizationData*      BotData;                                           // 0x0E88(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDebugMinimapData                      DebugMinimapData;                                  // 0x0E90(0x01B0)(Transient, Protected, NativeAccessSpecifierProtected)
	class AFortPlayerPawnAthena*                  RevivePlayerPawnToken;                             // 0x1040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1048[0x18];                                    // 0x1048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LeashActorToFollow;                                // 0x1060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeashActorToFollowLocalOffset;                     // 0x1068(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAthenaAILeashVolume*               LeashVolume;                                       // 0x1080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortGameStateComponent_AffiliationManager* CachedAffiliationManager;                          // 0x1088(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortActorComponent_Affiliation*        CachedAffiliationComponent;                        // 0x1090(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAffectedByMutatorHealthAndShieldModifiers;      // 0x1098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1099[0x7];                                     // 0x1099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasChangedPawnCullDistanceToAggroMode;            // 0x10A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A1[0x7];                                     // 0x10A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIRuntimeParameters_AIBotRespawn* RespawnRuntimeParameters;                          // 0x10A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingWall*                          CurrentBlockingDoor;                               // 0x10B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B8[0x10];                                    // 0x10B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  FinisherPawn;                                      // 0x10C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D0[0x54];                                    // 0x10D0(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	EFortPawnStasisMode                           PreviousStasisMode;                                // 0x1124(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPostponeGiveWeaponCheat;                          // 0x1125(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPostponeGiveMaterialsCheat;                       // 0x1126(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1127[0x1];                                     // 0x1127(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartSpectatingTime;                               // 0x1128(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112C[0x3C];                                    // 0x112C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAthenaDanceItemDefinition*             RequestedEmoteAsset;                               // 0x1168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1170[0x8];                                     // 0x1170(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BTAssetToRunOnPawnAISpawned;                       // 0x1178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1180[0x30];                                    // 0x1180(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTargetInfo(class AActor* Target, const bool bForceTarget, const EPerceptionState PerceptionState, const float ForgetTime, const float ForgetDistance);
	void AddTargetInfos(const TArray<class AActor*>& Targets, const EPerceptionState PerceptionState, const float ForgetTime, const float ForgetDistance);
	void BlueprintOnBehaviorTreeStarted();
	void ChangeActiveVariantForCosmeticItem(class FName ItemTemplateToChange, const struct FGameplayTag& VariantChannelToChange, const struct FGameplayTag& DesiredActiveVariant);
	class AFortWeapon* EquipBestWeapon();
	class AFortWeapon* EquipMeleeWeapon();
	class AFortWeapon* EquipWeapon(const class UFortWorldItem* Weapon);
	class AFortWeapon* EquipWeaponByTag(const struct FGameplayTag& WeaponTag);
	void NotifyPickupsSpawnedOnDeath(const TArray<class AFortPickup*>& SpawnedPickups);
	void OnAgentDBNO(class AFortPawn* InPlayer, bool bInIsDBNO);
	void OnAlertLevelChanged(const EAlertLevel OldAlertLevel, const EAlertLevel NewAlertLevel);
	void OnBeginSpectating(class AFortPlayerStateZone* Spectator);
	void OnCurrentHarvestableDestroyed(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnEndSpectating(class AFortPlayerStateZone* Spectator);
	void OnGamePhaseChanged(EAthenaGamePhase GamePhase);
	void OnGamePhaseStepChanged(const TScriptInterface<class IFortSafeZoneInterface>& SafeZoneInterface, const EAthenaGamePhaseStep GamePhaseStep);
	void OnKnockbacked(const struct FGameplayTag& KnockbackTypeTag);
	void OnLaunched(const struct FVector& LaunchVelocity, const bool bXYOverride, const bool bZOverride);
	void OnMovementModeChange(class ACharacter* InCharacter, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnPawnDidDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnPawnWeaponChanged(class AFortWeapon* NewWeapon, class AFortWeapon* OldWeapon);
	void OnPerceptionSensed(class AActor* SourceActor, const struct FAIStimulus& Stim);
	void OnPossesedPawnDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnPossessedPawnReceiveDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnSafezoneStateChanged(const EFortSafeZoneState NewState);
	void OnSafeZoneUpdated();
	void OnServerMarkerAdded(const struct FFortWorldMarkerData& MarkerData);
	void OnTargetActorDestroyed(class AActor* DestroyedActor);
	void OnTargetBuildingDestroyed(class ABuildingActor* Building, class AAthenaAIController* AIController);
	void OnTargetPawnDead(class AFortPawn* FortPawn);
	void OnTargetPawnDestroyed();
	void OverrideAggressivenessPlayStyle(bool bInIsAggressive);
	void OverrideSkill(const float NewSkill);
	void PlayEmote(const struct FPrimaryAssetId& EmotePrimaryAssetId);
	void QueueStim(class AActor* SourceActor, const struct FVector& SourceLocation, const struct FVector& SourceDirection, const EStimType NewStimType, const float StimStrength, const class FName StimTag);
	void ReleaseBuildTool();
	void RemoveEmoteRequest();
	void RemoveSkillSet(TSubclassOf<class UFortAthenaAIBotSkillSet> SkillSetClass);
	void RequestEmote(const struct FPrimaryAssetId& EmotePrimaryAssetId, float InfiniteEmoteMaxDuration);
	void SetBotOwner(class AActor* InBotOwner);
	void SetLeashActorToFollow(const class AActor* ActorToFollow, const float LeashLocationUpdateRate, const struct FVector& LocalOffset);
	void SetLeashReturnLocationMode(ELeashReturnLocationMode ReturnMode);
	void SetLeashVolume(class AFortAthenaAILeashVolume* InLeashVolume);
	void SetPatrollingEnable(const bool bEnable);
	void SetRadialLeashInnerRadius(const float InnerRadius);
	void SetRadialLeashOuterRadius(const float OuterRadius);
	void SetSkillSet(TSubclassOf<class UFortAthenaAIBotSkillSet> SkillSetClass);
	void StartFire();
	void StartSecondaryFire();
	void StopEmote();
	void StopFire();
	void StopSecondaryFire(const bool bFireWhenStopping);
	void SwitchTeam(uint8 TeamIndex);
	void ThankBusDriver();
	void UpdateLeashActorToFollowLocation();

	class AActor* GetBotOwner() const;
	class AActor* GetCurrentThreat() const;
	class UAthenaMarkerComponent* GetMarkerComponent() const;
	bool IsAnAthenaGameParticipant() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotController">();
	}
	static class AFortAthenaAIBotController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaAIBotController>();
	}
};
static_assert(alignof(AFortAthenaAIBotController) == 0x000010, "Wrong alignment on AFortAthenaAIBotController");
static_assert(sizeof(AFortAthenaAIBotController) == 0x0011B0, "Wrong size on AFortAthenaAIBotController");
static_assert(offsetof(AFortAthenaAIBotController, PreviousVehicle) == 0x0003D8, "Member 'AFortAthenaAIBotController::PreviousVehicle' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, AppliedInGameModifierAbilitySetHandles) == 0x0003F0, "Member 'AFortAthenaAIBotController::AppliedInGameModifierAbilitySetHandles' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, GadgetTrackedAttributeItemInstanceIds) == 0x000440, "Member 'AFortAthenaAIBotController::GadgetTrackedAttributeItemInstanceIds' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, TargetHandler) == 0x0004E0, "Member 'AFortAthenaAIBotController::TargetHandler' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, ReachLocationValidationMode) == 0x00050A, "Member 'AFortAthenaAIBotController::ReachLocationValidationMode' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, BehaviorTree) == 0x000510, "Member 'AFortAthenaAIBotController::BehaviorTree' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, SlotItems) == 0x000518, "Member 'AFortAthenaAIBotController::SlotItems' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheInventoryDigestedSkillSet) == 0x0005C0, "Member 'AFortAthenaAIBotController::CacheInventoryDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, PlayerBotPawn) == 0x0005D0, "Member 'AFortAthenaAIBotController::PlayerBotPawn' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedAIServicePlayerBots) == 0x0005D8, "Member 'AFortAthenaAIBotController::CachedAIServicePlayerBots' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedGameMode) == 0x0005E0, "Member 'AFortAthenaAIBotController::CachedGameMode' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedAIRuntimeParametersComponent) == 0x0005E8, "Member 'AFortAthenaAIBotController::CachedAIRuntimeParametersComponent' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedLeashRuntimeParameters) == 0x0005F0, "Member 'AFortAthenaAIBotController::CachedLeashRuntimeParameters' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedAffiliationRuntimeParameters) == 0x0005F8, "Member 'AFortAthenaAIBotController::CachedAffiliationRuntimeParameters' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedPatrollingComponent) == 0x000600, "Member 'AFortAthenaAIBotController::CachedPatrollingComponent' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedAIPerksComponent) == 0x000608, "Member 'AFortAthenaAIBotController::CachedAIPerksComponent' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, DelayedStimulus) == 0x000618, "Member 'AFortAthenaAIBotController::DelayedStimulus' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, ObjectsThreatList) == 0x000640, "Member 'AFortAthenaAIBotController::ObjectsThreatList' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, TrapsThreatList) == 0x000650, "Member 'AFortAthenaAIBotController::TrapsThreatList' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CurrentAlertLevel) == 0x000660, "Member 'AFortAthenaAIBotController::CurrentAlertLevel' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, DefaultAlertLevelInfo) == 0x000668, "Member 'AFortAthenaAIBotController::DefaultAlertLevelInfo' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, OnAlertLevelChangedEventDelegate) == 0x000678, "Member 'AFortAthenaAIBotController::OnAlertLevelChangedEventDelegate' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, OnStealthMeterChangedEventDelegate) == 0x000688, "Member 'AFortAthenaAIBotController::OnStealthMeterChangedEventDelegate' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, OnAgentDBNOStatusChangedEventDelegate) == 0x0006A0, "Member 'AFortAthenaAIBotController::OnAgentDBNOStatusChangedEventDelegate' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, OnAgentDiedEventDelegate) == 0x0006B0, "Member 'AFortAthenaAIBotController::OnAgentDiedEventDelegate' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, OnAgentGameOver) == 0x0006C0, "Member 'AFortAthenaAIBotController::OnAgentGameOver' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, OnPlayerPawnKilledByBot) == 0x000718, "Member 'AFortAthenaAIBotController::OnPlayerPawnKilledByBot' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, OnAIPawnKilledByBot) == 0x000728, "Member 'AFortAthenaAIBotController::OnAIPawnKilledByBot' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, Inventory) == 0x000738, "Member 'AFortAthenaAIBotController::Inventory' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, Skill) == 0x000740, "Member 'AFortAthenaAIBotController::Skill' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, BotSkillSetClasses) == 0x000748, "Member 'AFortAthenaAIBotController::BotSkillSetClasses' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, StartupInventory) == 0x000778, "Member 'AFortAthenaAIBotController::StartupInventory' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CosmeticLoadoutBC) == 0x000780, "Member 'AFortAthenaAIBotController::CosmeticLoadoutBC' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CustomCharacterPartOverridesBC) == 0x0008E8, "Member 'AFortAthenaAIBotController::CustomCharacterPartOverridesBC' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, NameSettingsBC) == 0x0008F8, "Member 'AFortAthenaAIBotController::NameSettingsBC' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, SpectateOnDeathMinTime) == 0x000900, "Member 'AFortAthenaAIBotController::SpectateOnDeathMinTime' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, SpectateOnDeathMaxTime) == 0x000928, "Member 'AFortAthenaAIBotController::SpectateOnDeathMaxTime' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, EmotesMaxCount) == 0x000950, "Member 'AFortAthenaAIBotController::EmotesMaxCount' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachePerceptionDigestedSkillSet) == 0x000978, "Member 'AFortAthenaAIBotController::CachePerceptionDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheHarvestDigestedSkillSet) == 0x000980, "Member 'AFortAthenaAIBotController::CacheHarvestDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheMovementSkillSet) == 0x000988, "Member 'AFortAthenaAIBotController::CacheMovementSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheLootingSkillSet) == 0x000990, "Member 'AFortAthenaAIBotController::CacheLootingSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheAttackingSkillSet) == 0x000998, "Member 'AFortAthenaAIBotController::CacheAttackingSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachePlayStyleSkillSet) == 0x0009A0, "Member 'AFortAthenaAIBotController::CachePlayStyleSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheUnstuckSkillSet) == 0x0009A8, "Member 'AFortAthenaAIBotController::CacheUnstuckSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheRangeAttackSkillSet) == 0x0009B0, "Member 'AFortAthenaAIBotController::CacheRangeAttackSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, InteractContextInfo) == 0x000A18, "Member 'AFortAthenaAIBotController::InteractContextInfo' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheAimingDigestedSkillSet) == 0x000A70, "Member 'AFortAthenaAIBotController::CacheAimingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, LastDeathLocation) == 0x000A88, "Member 'AFortAthenaAIBotController::LastDeathLocation' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, LastDeathRotation) == 0x000AA0, "Member 'AFortAthenaAIBotController::LastDeathRotation' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedWorldItem) == 0x000AB8, "Member 'AFortAthenaAIBotController::CachedWorldItem' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheWeaponUsedToCalculateType) == 0x000AC8, "Member 'AFortAthenaAIBotController::CacheWeaponUsedToCalculateType' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, bCachedIsUsingArcedProjectileWeapon) == 0x000AD0, "Member 'AFortAthenaAIBotController::bCachedIsUsingArcedProjectileWeapon' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedProjectileGravityScale) == 0x000AD4, "Member 'AFortAthenaAIBotController::CachedProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedWeaponUsedToCalculateProjectileData) == 0x000AD8, "Member 'AFortAthenaAIBotController::CachedWeaponUsedToCalculateProjectileData' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, StatManager) == 0x000AE0, "Member 'AFortAthenaAIBotController::StatManager' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, ActiveWeakSpots) == 0x000AE8, "Member 'AFortAthenaAIBotController::ActiveWeakSpots' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CacheBotPawnClass) == 0x000B20, "Member 'AFortAthenaAIBotController::CacheBotPawnClass' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CurrentLootActor) == 0x000B30, "Member 'AFortAthenaAIBotController::CurrentLootActor' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, MarkerComponent) == 0x000B38, "Member 'AFortAthenaAIBotController::MarkerComponent' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, BotPlayerName) == 0x000B40, "Member 'AFortAthenaAIBotController::BotPlayerName' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, BotIDSuffix) == 0x000B50, "Member 'AFortAthenaAIBotController::BotIDSuffix' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, BotPlayerNameWithSkillRating) == 0x000B60, "Member 'AFortAthenaAIBotController::BotPlayerNameWithSkillRating' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, PolicyDataSpawner) == 0x000B80, "Member 'AFortAthenaAIBotController::PolicyDataSpawner' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, FortControllerComponent_Telemetry) == 0x000C60, "Member 'AFortAthenaAIBotController::FortControllerComponent_Telemetry' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, bForceUsingBuildingTool) == 0x000C68, "Member 'AFortAthenaAIBotController::bForceUsingBuildingTool' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, bForceHolsterWeapon) == 0x000C69, "Member 'AFortAthenaAIBotController::bForceHolsterWeapon' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, PendingEquipWeapon) == 0x000C70, "Member 'AFortAthenaAIBotController::PendingEquipWeapon' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, PlayerToSpectateOnDeath) == 0x000CC0, "Member 'AFortAthenaAIBotController::PlayerToSpectateOnDeath' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, OnPlayerPawnAISpawnedDelegate) == 0x000CC8, "Member 'AFortAthenaAIBotController::OnPlayerPawnAISpawnedDelegate' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, AISenseConfig_SightOverride) == 0x000DC8, "Member 'AFortAthenaAIBotController::AISenseConfig_SightOverride' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, BotOwner) == 0x000DE0, "Member 'AFortAthenaAIBotController::BotOwner' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, BotControllerUID) == 0x000DE8, "Member 'AFortAthenaAIBotController::BotControllerUID' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, ReviveTarget) == 0x000DF0, "Member 'AFortAthenaAIBotController::ReviveTarget' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, BotData) == 0x000E88, "Member 'AFortAthenaAIBotController::BotData' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, DebugMinimapData) == 0x000E90, "Member 'AFortAthenaAIBotController::DebugMinimapData' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, RevivePlayerPawnToken) == 0x001040, "Member 'AFortAthenaAIBotController::RevivePlayerPawnToken' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, LeashActorToFollow) == 0x001060, "Member 'AFortAthenaAIBotController::LeashActorToFollow' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, LeashActorToFollowLocalOffset) == 0x001068, "Member 'AFortAthenaAIBotController::LeashActorToFollowLocalOffset' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, LeashVolume) == 0x001080, "Member 'AFortAthenaAIBotController::LeashVolume' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedAffiliationManager) == 0x001088, "Member 'AFortAthenaAIBotController::CachedAffiliationManager' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CachedAffiliationComponent) == 0x001090, "Member 'AFortAthenaAIBotController::CachedAffiliationComponent' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, bIsAffectedByMutatorHealthAndShieldModifiers) == 0x001098, "Member 'AFortAthenaAIBotController::bIsAffectedByMutatorHealthAndShieldModifiers' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, bHasChangedPawnCullDistanceToAggroMode) == 0x0010A0, "Member 'AFortAthenaAIBotController::bHasChangedPawnCullDistanceToAggroMode' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, RespawnRuntimeParameters) == 0x0010A8, "Member 'AFortAthenaAIBotController::RespawnRuntimeParameters' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, CurrentBlockingDoor) == 0x0010B0, "Member 'AFortAthenaAIBotController::CurrentBlockingDoor' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, FinisherPawn) == 0x0010C8, "Member 'AFortAthenaAIBotController::FinisherPawn' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, PreviousStasisMode) == 0x001124, "Member 'AFortAthenaAIBotController::PreviousStasisMode' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, bPostponeGiveWeaponCheat) == 0x001125, "Member 'AFortAthenaAIBotController::bPostponeGiveWeaponCheat' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, bPostponeGiveMaterialsCheat) == 0x001126, "Member 'AFortAthenaAIBotController::bPostponeGiveMaterialsCheat' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, StartSpectatingTime) == 0x001128, "Member 'AFortAthenaAIBotController::StartSpectatingTime' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, RequestedEmoteAsset) == 0x001168, "Member 'AFortAthenaAIBotController::RequestedEmoteAsset' has a wrong offset!");
static_assert(offsetof(AFortAthenaAIBotController, BTAssetToRunOnPawnAISpawned) == 0x001178, "Member 'AFortAthenaAIBotController::BTAssetToRunOnPawnAISpawned' has a wrong offset!");

// Class FortniteAI.FortAIEncounterInfoOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAIEncounterInfoOwnerInterface final : public IInterface
{
public:
	class UFortAIEncounterInfo* GetEncounterInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterInfoOwnerInterface">();
	}
	static class IFortAIEncounterInfoOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIEncounterInfoOwnerInterface>();
	}
};
static_assert(alignof(IFortAIEncounterInfoOwnerInterface) == 0x000008, "Wrong alignment on IFortAIEncounterInfoOwnerInterface");
static_assert(sizeof(IFortAIEncounterInfoOwnerInterface) == 0x000028, "Wrong size on IFortAIEncounterInfoOwnerInterface");

// Class FortniteAI.FortQueryGenerator_SpecificAssignmentGoals
// 0x0040 (0x0090 - 0x0050)
class UFortQueryGenerator_SpecificAssignmentGoals final : public UEnvQueryGenerator
{
public:
	struct FFortAIAssignmentIdentifier            AssignmentIdentifier;                              // 0x0050(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	class UFortAIAssignmentSettings*              AssignmentSettings;                                // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortAIGoalProvider>        GoalProvider;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_SpecificAssignmentGoals">();
	}
	static class UFortQueryGenerator_SpecificAssignmentGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_SpecificAssignmentGoals>();
	}
};
static_assert(alignof(UFortQueryGenerator_SpecificAssignmentGoals) == 0x000008, "Wrong alignment on UFortQueryGenerator_SpecificAssignmentGoals");
static_assert(sizeof(UFortQueryGenerator_SpecificAssignmentGoals) == 0x000090, "Wrong size on UFortQueryGenerator_SpecificAssignmentGoals");
static_assert(offsetof(UFortQueryGenerator_SpecificAssignmentGoals, AssignmentIdentifier) == 0x000050, "Member 'UFortQueryGenerator_SpecificAssignmentGoals::AssignmentIdentifier' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_SpecificAssignmentGoals, AssignmentSettings) == 0x000080, "Member 'UFortQueryGenerator_SpecificAssignmentGoals::AssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_SpecificAssignmentGoals, GoalProvider) == 0x000088, "Member 'UFortQueryGenerator_SpecificAssignmentGoals::GoalProvider' has a wrong offset!");

// Class FortniteAI.FortAIDirector
// 0x0D68 (0x0FD8 - 0x0270)
class AFortAIDirector : public AActor
{
public:
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   MaxAliveCurve;                                     // 0x0280(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MinAliveCurve;                                     // 0x0290(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntensityData                         IntensityInfo;                                     // 0x02A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortAIEncounterPIDController          AIDirectorPIDController;                           // 0x02D0(0x0068)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FFortAIEncounterPIDControllerSettings  PIDControllerSettings;                             // 0x0338(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FUtilityData                           UtilityContributionData[0x10];                     // 0x0368(0x0040)(Edit, NativeAccessSpecifierPublic)
	float                                         UnreachableLocationPathCost;                       // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76C[0x4];                                      // 0x076C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortPlayerPerformanceEstimateSettings PlayerPerformanceEstimateSettings;                 // 0x0770(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bUsePrototypeEnemies : 1;                          // 0x07B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7B1[0x3];                                      // 0x07B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceByPassNavMeshForAISpawning;                  // 0x07B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B5[0x3];                                      // 0x07B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortEncounterDirection>               DebugEncounterDirections;                          // 0x07B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	EDespawnAIType                                DespawnAIType;                                     // 0x07C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C9[0x3];                                      // 0x07C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DespawnDistance;                                   // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DespawnInterval;                                   // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D4[0x4];                                      // 0x07D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DebugSpawnAIGroupTags;                             // 0x07D8(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DebugEncounterTags;                                // 0x07F8(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         BurstSpawnThreatVisualsEndDelay;                   // 0x0818(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81C[0x4];                                      // 0x081C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAIEncounterSpawnGroupCapsProfile> EncounterSpawnGroupCapSettings;                    // 0x0820(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIEncounterSpawnPointsProfile> EncounterSpawnPointsSettings;                      // 0x0830(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIEncounterPawnDifficultyLevelModifier> EncounterPawnDifficultyLevelModifiers;             // 0x0840(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAISpawnGroupUpgradeData>   SpawnGroupUpgrades;                                // 0x0850(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         GuaranteedUpgradeGroupUtilityBonus;                // 0x0860(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiscreteEncounterUtilityDesireMappings[0x4];       // 0x0864(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortAIUtility                                InitialDynamicUtilities[0x4];                      // 0x0874(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TStructCycleFixup<struct FEncounterEnvironmentQueryInfo, 0x0028, 0x08> SpawnLocationPlacementQueries[0x4];                // 0x0878(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TStructCycleFixup<struct FEncounterEnvironmentQueryInfo, 0x0028, 0x08> SpawnLocationActorSearchQueries[0x4];              // 0x0918(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UFortAIDirectorDataTrackingSettings*    DataTrackingSettings;                              // 0x09B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDataTableRowHandle>            BaseLootDropData;                                  // 0x09C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAILootDropModifiers>       LootDropModifiers;                                 // 0x09D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      LootDropDenialQuery;                               // 0x09E0(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bDebugEncounterQueries : 1;                        // 0x0A28(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A29[0x17];                                     // 0x0A29(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPlayerControllerZone*>      PlayerControllersForBVTree;                        // 0x0A40(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortPlayerPawn*>                PlayerPawnsForBVTree;                              // 0x0A50(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A60[0x40];                                     // 0x0A60(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortAIController*>              AIControllersForBVTree;                            // 0x0AA0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortAIPawn*>                    AIPawnsForBVTree;                                  // 0x0AB0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC0[0x40];                                     // 0x0AC0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortAthenaAIBotController*>     AIPlayerBotControllersForBVTree;                   // 0x0B00(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortPlayerPawn*>                AIPlayerBotPawnsForBVTree;                         // 0x0B10(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B20[0x40];                                     // 0x0B20(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortAthenaAIBotController*>     AINonPlayerBotControllersForBVTree;                // 0x0B60(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortPlayerPawn*>                AINonPlayerBotPawnsForBVTree;                      // 0x0B70(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B80[0x40];                                     // 0x0B80(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPlayerPawn*>                NonPlayerBotPawns;                                 // 0x0BC0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortPlayerPawn*>                PlayerBotPawns;                                    // 0x0BD0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortPlayerPawn*>                PlayerPawns;                                       // 0x0BE0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortAIPawn*>                    FortAIPawns;                                       // 0x0BF0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C00[0xB0];                                     // 0x0C00(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseLODSettings;                                   // 0x0CB0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CB1[0x6F];                                     // 0x0CB1(0x006F)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IFortAthenaAILODSettings> CachedLODSettingsManager;                          // 0x0D20(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAsyncProcessUpdateAliveAIs;                       // 0x0D30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowProcessPlayerTargeting;                      // 0x0D31(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D32[0x2];                                      // 0x0D32(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumLODAIProcessPerFrame;                        // 0x0D34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortEncounterPawnNumberCaps           DefaultEncounterPawnCaps;                          // 0x0D38(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D50[0x8];                                      // 0x0D50(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UReporterGraph*                         IntensityGraph;                                    // 0x0D58(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         UtilitiesGraph;                                    // 0x0D60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDValuesGraph;                                    // 0x0D68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDContributionsGraph;                             // 0x0D70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNightActive : 1;                                  // 0x0D78(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAIDisabled : 1;                                   // 0x0D78(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRegisteredForDayPhaseChange : 1;                  // 0x0D78(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSpawnCap : 1;                                  // 0x0D78(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D79[0x3];                                      // 0x0D79(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NightCount;                                        // 0x0D7C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NightEncounterFailureBreatherTime;                 // 0x0D80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterPawnSpawnInterval;                        // 0x0D84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortAIEncounterInfo>       DefaultNightEncounter;                             // 0x0D88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortAIEncounterInfo>       DummyDebugEncounter;                               // 0x0D90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortAIEncounterInfo>       BaseEncounterClass;                                // 0x0D98(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxActiveAlive;                                    // 0x0DA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumActiveAlive;                                    // 0x0DA4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPendingCapRelevantAI;                           // 0x0DA8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DAC[0x54];                                     // 0x0DAC(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPendingSpawnInfo>              PendingSpawns;                                     // 0x0E00(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxAISpawnedPerFrame;                              // 0x0E10(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxAIDespawnedPerFrame;                            // 0x0E14(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DespawnAllAIMaxAIDespawnedPerFrame;                // 0x0E18(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1C[0x4];                                      // 0x0E1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AFortAIPawn>>     PendingDespawns;                                   // 0x0E20(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E30[0x8];                                      // 0x0E30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumWorldSubdivides;                                // 0x0E38(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAISpawnDistanceFromPlayers;                     // 0x0E3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AmbientThreatPreferredPlacementActorTags;          // 0x0E40(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AmbientThreatRequiredPlacementActorTags;           // 0x0E60(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAIEncounterInfo*>           ActiveEncounters;                                  // 0x0E80(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAIEncounterInfo*>           InactiveEncounters;                                // 0x0E90(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortPendingStoppedEncounterData> PendingStoppedEncounters;                          // 0x0EA0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UFortAIEncounterInfo*                   ActiveDefaultEncounter;                            // 0x0EB0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAIEncounterInfo*                   ActiveDummyDebugEncounter;                         // 0x0EB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFortAIEncounterSequence*>       EncounterSequences;                                // 0x0EC0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UEQSRenderingComponent*                 EQSRenderingComp;                                  // 0x0ED0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DebugGraphUpdateFrequency;                         // 0x0ED8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNormalLODDistanceToPlayer;                      // 0x0EDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIRelevantDistanceToPlayer;                        // 0x0EE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterRelevantDistanceToPlayer;                 // 0x0EE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterRelevantDistanceToDefender;               // 0x0EE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EEC[0x4];                                      // 0x0EEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IFortPatrolWardInterface>> PatrolWards;                                       // 0x0EF0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F00[0x4];                                      // 0x0F00(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTotalActiveAliveAI;                             // 0x0F04(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEncounterActiveAliveAI;                         // 0x0F08(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSPUsed;                                         // 0x0F0C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F10[0x8];                                      // 0x0F10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          DebugEncounterTopUtilityPercentages;               // 0x0F18(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UCurveFloat*>                    DebugEncounterSpawnPointsCurves;                   // 0x0F28(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bDebugAllowEncounterModifierTags : 1;              // 0x0F38(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F39[0x3];                                      // 0x0F39(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SimulatedNumberOfPlayersForAIEncounters;           // 0x0F3C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F40[0x78];                                     // 0x0F40(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumberOfEncounterGroups;                        // 0x0FB8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FBC[0x4];                                      // 0x0FBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABuildingProp_AISpawner*>        RegisteredAISpawners;                              // 0x0FC0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD0[0x8];                                      // 0x0FD0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<EFortEncounterDirection> ConvertInvalidDirectionsToValidDirections(const TArray<EFortEncounterDirection>& InvalidDirections);
	static EFortEncounterDirection GetEncounterDirectionFromVector(const struct FVector& DirectionVector);
	static struct FVector GetVectorFromEncounterDirection(EFortEncounterDirection Direction);

	void Activate();
	void Deactivate();
	int32 GetNumActiveEncounters();
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void OnDirectorDeactivated();
	void OnFadeStarted();
	void OnPawnDied(class AFortAIPawn* KilledPawn);
	void OnPeakStarted();
	void OnPlayerDied(class AFortPlayerPawn* PlayerPawn);
	void OnPlayerSpawn(class AFortPlayerPawn* PlayerPawn);
	void OnRampStarted();
	void OnRestStarted();
	void PostDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void ReceivePawnSpawned(class AFortPawn* SpawnedPawn);
	void RegisterPatrolWard(TScriptInterface<class IFortPatrolWardInterface> PatrolWard);
	class UFortAIEncounterInfo* StartEncounter(class FString& EncounterInstigator, class UFortDifficultyEncounterSettings* DifficultyEncounterSettings, const struct FFortAIEncounterQueryData& OptionalQueryData);
	void UnregisterPatrolWard(TScriptInterface<class IFortPatrolWardInterface> PatrolWard);

	void GetAmbientThreatEncounterSpawnLocations(TArray<struct FVector>* AmbientThreatEncounterSpawnLocations) const;
	int32 GetNumPlayers() const;
	TArray<class ABuildingRift*> GetRiftsFromClosestActiveEncounterTo(class AActor* Target) const;
	bool IsAnyActiveEncounterRelevantToDefender(class AFortAIPawn* Defender) const;
	bool IsAnyActiveEncounterRelevantToPlayer(class AFortPlayerPawn* Player) const;
	bool IsAnyAIRelevantToPlayer(class AFortPlayerPawn* Player) const;
	bool IsAnyEncounterGoalWithinDistanceOfPoint(const struct FVector& Point, float Distance, bool bOnlyActiveEncounters) const;
	bool IsLineTooCloseToPatrolWards(const struct FVector& LineStart, const struct FVector& LineEnd) const;
	bool IsPointTooCloseToPatrolWards(const struct FVector& Point, const EWardAffectType WardEffectTypeFilter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirector">();
	}
	static class AFortAIDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIDirector>();
	}
};
static_assert(alignof(AFortAIDirector) == 0x000008, "Wrong alignment on AFortAIDirector");
static_assert(sizeof(AFortAIDirector) == 0x000FD8, "Wrong size on AFortAIDirector");
static_assert(offsetof(AFortAIDirector, MaxAliveCurve) == 0x000280, "Member 'AFortAIDirector::MaxAliveCurve' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MinAliveCurve) == 0x000290, "Member 'AFortAIDirector::MinAliveCurve' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, IntensityInfo) == 0x0002A0, "Member 'AFortAIDirector::IntensityInfo' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIDirectorPIDController) == 0x0002D0, "Member 'AFortAIDirector::AIDirectorPIDController' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PIDControllerSettings) == 0x000338, "Member 'AFortAIDirector::PIDControllerSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, UtilityContributionData) == 0x000368, "Member 'AFortAIDirector::UtilityContributionData' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, UnreachableLocationPathCost) == 0x000768, "Member 'AFortAIDirector::UnreachableLocationPathCost' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PlayerPerformanceEstimateSettings) == 0x000770, "Member 'AFortAIDirector::PlayerPerformanceEstimateSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, bForceByPassNavMeshForAISpawning) == 0x0007B4, "Member 'AFortAIDirector::bForceByPassNavMeshForAISpawning' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterDirections) == 0x0007B8, "Member 'AFortAIDirector::DebugEncounterDirections' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DespawnAIType) == 0x0007C8, "Member 'AFortAIDirector::DespawnAIType' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DespawnDistance) == 0x0007CC, "Member 'AFortAIDirector::DespawnDistance' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DespawnInterval) == 0x0007D0, "Member 'AFortAIDirector::DespawnInterval' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugSpawnAIGroupTags) == 0x0007D8, "Member 'AFortAIDirector::DebugSpawnAIGroupTags' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterTags) == 0x0007F8, "Member 'AFortAIDirector::DebugEncounterTags' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, BurstSpawnThreatVisualsEndDelay) == 0x000818, "Member 'AFortAIDirector::BurstSpawnThreatVisualsEndDelay' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterSpawnGroupCapSettings) == 0x000820, "Member 'AFortAIDirector::EncounterSpawnGroupCapSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterSpawnPointsSettings) == 0x000830, "Member 'AFortAIDirector::EncounterSpawnPointsSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterPawnDifficultyLevelModifiers) == 0x000840, "Member 'AFortAIDirector::EncounterPawnDifficultyLevelModifiers' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, SpawnGroupUpgrades) == 0x000850, "Member 'AFortAIDirector::SpawnGroupUpgrades' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, GuaranteedUpgradeGroupUtilityBonus) == 0x000860, "Member 'AFortAIDirector::GuaranteedUpgradeGroupUtilityBonus' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DiscreteEncounterUtilityDesireMappings) == 0x000864, "Member 'AFortAIDirector::DiscreteEncounterUtilityDesireMappings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, InitialDynamicUtilities) == 0x000874, "Member 'AFortAIDirector::InitialDynamicUtilities' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, SpawnLocationPlacementQueries) == 0x000878, "Member 'AFortAIDirector::SpawnLocationPlacementQueries' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, SpawnLocationActorSearchQueries) == 0x000918, "Member 'AFortAIDirector::SpawnLocationActorSearchQueries' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DataTrackingSettings) == 0x0009B8, "Member 'AFortAIDirector::DataTrackingSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, BaseLootDropData) == 0x0009C0, "Member 'AFortAIDirector::BaseLootDropData' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, LootDropModifiers) == 0x0009D0, "Member 'AFortAIDirector::LootDropModifiers' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, LootDropDenialQuery) == 0x0009E0, "Member 'AFortAIDirector::LootDropDenialQuery' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PlayerControllersForBVTree) == 0x000A40, "Member 'AFortAIDirector::PlayerControllersForBVTree' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PlayerPawnsForBVTree) == 0x000A50, "Member 'AFortAIDirector::PlayerPawnsForBVTree' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIControllersForBVTree) == 0x000AA0, "Member 'AFortAIDirector::AIControllersForBVTree' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIPawnsForBVTree) == 0x000AB0, "Member 'AFortAIDirector::AIPawnsForBVTree' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIPlayerBotControllersForBVTree) == 0x000B00, "Member 'AFortAIDirector::AIPlayerBotControllersForBVTree' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIPlayerBotPawnsForBVTree) == 0x000B10, "Member 'AFortAIDirector::AIPlayerBotPawnsForBVTree' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AINonPlayerBotControllersForBVTree) == 0x000B60, "Member 'AFortAIDirector::AINonPlayerBotControllersForBVTree' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AINonPlayerBotPawnsForBVTree) == 0x000B70, "Member 'AFortAIDirector::AINonPlayerBotPawnsForBVTree' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NonPlayerBotPawns) == 0x000BC0, "Member 'AFortAIDirector::NonPlayerBotPawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PlayerBotPawns) == 0x000BD0, "Member 'AFortAIDirector::PlayerBotPawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PlayerPawns) == 0x000BE0, "Member 'AFortAIDirector::PlayerPawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, FortAIPawns) == 0x000BF0, "Member 'AFortAIDirector::FortAIPawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, bUseLODSettings) == 0x000CB0, "Member 'AFortAIDirector::bUseLODSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, CachedLODSettingsManager) == 0x000D20, "Member 'AFortAIDirector::CachedLODSettingsManager' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, bAsyncProcessUpdateAliveAIs) == 0x000D30, "Member 'AFortAIDirector::bAsyncProcessUpdateAliveAIs' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, bAllowProcessPlayerTargeting) == 0x000D31, "Member 'AFortAIDirector::bAllowProcessPlayerTargeting' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxNumLODAIProcessPerFrame) == 0x000D34, "Member 'AFortAIDirector::MaxNumLODAIProcessPerFrame' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DefaultEncounterPawnCaps) == 0x000D38, "Member 'AFortAIDirector::DefaultEncounterPawnCaps' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, IntensityGraph) == 0x000D58, "Member 'AFortAIDirector::IntensityGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, UtilitiesGraph) == 0x000D60, "Member 'AFortAIDirector::UtilitiesGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PIDValuesGraph) == 0x000D68, "Member 'AFortAIDirector::PIDValuesGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PIDContributionsGraph) == 0x000D70, "Member 'AFortAIDirector::PIDContributionsGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NightCount) == 0x000D7C, "Member 'AFortAIDirector::NightCount' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NightEncounterFailureBreatherTime) == 0x000D80, "Member 'AFortAIDirector::NightEncounterFailureBreatherTime' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterPawnSpawnInterval) == 0x000D84, "Member 'AFortAIDirector::EncounterPawnSpawnInterval' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DefaultNightEncounter) == 0x000D88, "Member 'AFortAIDirector::DefaultNightEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DummyDebugEncounter) == 0x000D90, "Member 'AFortAIDirector::DummyDebugEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, BaseEncounterClass) == 0x000D98, "Member 'AFortAIDirector::BaseEncounterClass' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxActiveAlive) == 0x000DA0, "Member 'AFortAIDirector::MaxActiveAlive' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NumActiveAlive) == 0x000DA4, "Member 'AFortAIDirector::NumActiveAlive' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NumPendingCapRelevantAI) == 0x000DA8, "Member 'AFortAIDirector::NumPendingCapRelevantAI' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PendingSpawns) == 0x000E00, "Member 'AFortAIDirector::PendingSpawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxAISpawnedPerFrame) == 0x000E10, "Member 'AFortAIDirector::MaxAISpawnedPerFrame' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxAIDespawnedPerFrame) == 0x000E14, "Member 'AFortAIDirector::MaxAIDespawnedPerFrame' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DespawnAllAIMaxAIDespawnedPerFrame) == 0x000E18, "Member 'AFortAIDirector::DespawnAllAIMaxAIDespawnedPerFrame' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PendingDespawns) == 0x000E20, "Member 'AFortAIDirector::PendingDespawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NumWorldSubdivides) == 0x000E38, "Member 'AFortAIDirector::NumWorldSubdivides' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MinAISpawnDistanceFromPlayers) == 0x000E3C, "Member 'AFortAIDirector::MinAISpawnDistanceFromPlayers' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AmbientThreatPreferredPlacementActorTags) == 0x000E40, "Member 'AFortAIDirector::AmbientThreatPreferredPlacementActorTags' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AmbientThreatRequiredPlacementActorTags) == 0x000E60, "Member 'AFortAIDirector::AmbientThreatRequiredPlacementActorTags' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, ActiveEncounters) == 0x000E80, "Member 'AFortAIDirector::ActiveEncounters' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, InactiveEncounters) == 0x000E90, "Member 'AFortAIDirector::InactiveEncounters' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PendingStoppedEncounters) == 0x000EA0, "Member 'AFortAIDirector::PendingStoppedEncounters' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, ActiveDefaultEncounter) == 0x000EB0, "Member 'AFortAIDirector::ActiveDefaultEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, ActiveDummyDebugEncounter) == 0x000EB8, "Member 'AFortAIDirector::ActiveDummyDebugEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterSequences) == 0x000EC0, "Member 'AFortAIDirector::EncounterSequences' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EQSRenderingComp) == 0x000ED0, "Member 'AFortAIDirector::EQSRenderingComp' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugGraphUpdateFrequency) == 0x000ED8, "Member 'AFortAIDirector::DebugGraphUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxNormalLODDistanceToPlayer) == 0x000EDC, "Member 'AFortAIDirector::MaxNormalLODDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIRelevantDistanceToPlayer) == 0x000EE0, "Member 'AFortAIDirector::AIRelevantDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterRelevantDistanceToPlayer) == 0x000EE4, "Member 'AFortAIDirector::EncounterRelevantDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterRelevantDistanceToDefender) == 0x000EE8, "Member 'AFortAIDirector::EncounterRelevantDistanceToDefender' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PatrolWards) == 0x000EF0, "Member 'AFortAIDirector::PatrolWards' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxTotalActiveAliveAI) == 0x000F04, "Member 'AFortAIDirector::MaxTotalActiveAliveAI' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxEncounterActiveAliveAI) == 0x000F08, "Member 'AFortAIDirector::MaxEncounterActiveAliveAI' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxSPUsed) == 0x000F0C, "Member 'AFortAIDirector::MaxSPUsed' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterTopUtilityPercentages) == 0x000F18, "Member 'AFortAIDirector::DebugEncounterTopUtilityPercentages' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterSpawnPointsCurves) == 0x000F28, "Member 'AFortAIDirector::DebugEncounterSpawnPointsCurves' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, SimulatedNumberOfPlayersForAIEncounters) == 0x000F3C, "Member 'AFortAIDirector::SimulatedNumberOfPlayersForAIEncounters' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxNumberOfEncounterGroups) == 0x000FB8, "Member 'AFortAIDirector::MaxNumberOfEncounterGroups' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, RegisteredAISpawners) == 0x000FC0, "Member 'AFortAIDirector::RegisteredAISpawners' has a wrong offset!");

// Class FortniteAI.FortNavModifierComponent
// 0x00A0 (0x0230 - 0x0190)
class UFortNavModifierComponent : public UNavModifierComponent
{
public:
	float                                         LowSpeedSquareThreshold;                           // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowSpeedSquareDistanceThreshold;                   // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowSpeedRotationThreshold;                         // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowSpeedScaleThreshold;                            // 0x019C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutomaticNavBoundComputation : 1;                 // 0x01A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceFailSafeExtent : 1;                          // 0x01A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtrapolationMultiplierForFailsafeExtent;          // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ANavigationData>>    DisableForNavmeshClasses;                          // 0x01A8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    PrimCompAffectingNavMesh;                          // 0x01B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x70];                                     // 0x01C0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetComponentAffectingNavMesh(class UPrimitiveComponent* InComponentAffectingNavMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavModifierComponent">();
	}
	static class UFortNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavModifierComponent>();
	}
};
static_assert(alignof(UFortNavModifierComponent) == 0x000010, "Wrong alignment on UFortNavModifierComponent");
static_assert(sizeof(UFortNavModifierComponent) == 0x000230, "Wrong size on UFortNavModifierComponent");
static_assert(offsetof(UFortNavModifierComponent, LowSpeedSquareThreshold) == 0x000190, "Member 'UFortNavModifierComponent::LowSpeedSquareThreshold' has a wrong offset!");
static_assert(offsetof(UFortNavModifierComponent, LowSpeedSquareDistanceThreshold) == 0x000194, "Member 'UFortNavModifierComponent::LowSpeedSquareDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UFortNavModifierComponent, LowSpeedRotationThreshold) == 0x000198, "Member 'UFortNavModifierComponent::LowSpeedRotationThreshold' has a wrong offset!");
static_assert(offsetof(UFortNavModifierComponent, LowSpeedScaleThreshold) == 0x00019C, "Member 'UFortNavModifierComponent::LowSpeedScaleThreshold' has a wrong offset!");
static_assert(offsetof(UFortNavModifierComponent, ExtrapolationMultiplierForFailsafeExtent) == 0x0001A4, "Member 'UFortNavModifierComponent::ExtrapolationMultiplierForFailsafeExtent' has a wrong offset!");
static_assert(offsetof(UFortNavModifierComponent, DisableForNavmeshClasses) == 0x0001A8, "Member 'UFortNavModifierComponent::DisableForNavmeshClasses' has a wrong offset!");
static_assert(offsetof(UFortNavModifierComponent, PrimCompAffectingNavMesh) == 0x0001B8, "Member 'UFortNavModifierComponent::PrimCompAffectingNavMesh' has a wrong offset!");

// Class FortniteAI.FortPhysicsObjectNavigationComponent
// 0x0010 (0x0240 - 0x0230)
class UFortPhysicsObjectNavigationComponent : public UFortNavModifierComponent
{
public:
	class UFortPhysicsObjectComponent*            PhysicsObjectComponent;                            // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSleepStateChanged(class UPrimitiveComponent* SimulatingComponent, bool bIsAwake);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPhysicsObjectNavigationComponent">();
	}
	static class UFortPhysicsObjectNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPhysicsObjectNavigationComponent>();
	}
};
static_assert(alignof(UFortPhysicsObjectNavigationComponent) == 0x000010, "Wrong alignment on UFortPhysicsObjectNavigationComponent");
static_assert(sizeof(UFortPhysicsObjectNavigationComponent) == 0x000240, "Wrong size on UFortPhysicsObjectNavigationComponent");
static_assert(offsetof(UFortPhysicsObjectNavigationComponent, PhysicsObjectComponent) == 0x000230, "Member 'UFortPhysicsObjectNavigationComponent::PhysicsObjectComponent' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_UseSmartObject
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_UseSmartObject final : public UBTTaskNode
{
public:
	class FName                                   SmartObjectsStatusKeyName;                         // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_UseSmartObject">();
	}
	static class UFortAthenaBTTask_UseSmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_UseSmartObject>();
	}
};
static_assert(alignof(UFortAthenaBTTask_UseSmartObject) == 0x000008, "Wrong alignment on UFortAthenaBTTask_UseSmartObject");
static_assert(sizeof(UFortAthenaBTTask_UseSmartObject) == 0x000078, "Wrong size on UFortAthenaBTTask_UseSmartObject");
static_assert(offsetof(UFortAthenaBTTask_UseSmartObject, SmartObjectsStatusKeyName) == 0x000070, "Member 'UFortAthenaBTTask_UseSmartObject::SmartObjectsStatusKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotDigestedSkillSet
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAIBotDigestedSkillSet : public UFortAthenaAIRuntimeParameters
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotDigestedSkillSet">();
	}
	static class UFortAthenaAIBotDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotDigestedSkillSet) == 0x000030, "Wrong size on UFortAthenaAIBotDigestedSkillSet");

// Class FortniteAI.FortAthenaAIBotHarvestDigestedSkillSet
// 0x0010 (0x0040 - 0x0030)
class UFortAthenaAIBotHarvestDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         DelayBetweenHarvest;                               // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeviationTimeBetweenHarvest;                       // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HarvestingMaxDistanceSquared;                      // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeakSpotHitProbability;                            // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotHarvestDigestedSkillSet">();
	}
	static class UFortAthenaAIBotHarvestDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotHarvestDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotHarvestDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotHarvestDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotHarvestDigestedSkillSet) == 0x000040, "Wrong size on UFortAthenaAIBotHarvestDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotHarvestDigestedSkillSet, DelayBetweenHarvest) == 0x000030, "Member 'UFortAthenaAIBotHarvestDigestedSkillSet::DelayBetweenHarvest' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHarvestDigestedSkillSet, DeviationTimeBetweenHarvest) == 0x000034, "Member 'UFortAthenaAIBotHarvestDigestedSkillSet::DeviationTimeBetweenHarvest' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHarvestDigestedSkillSet, HarvestingMaxDistanceSquared) == 0x000038, "Member 'UFortAthenaAIBotHarvestDigestedSkillSet::HarvestingMaxDistanceSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHarvestDigestedSkillSet, WeakSpotHitProbability) == 0x00003C, "Member 'UFortAthenaAIBotHarvestDigestedSkillSet::WeakSpotHitProbability' has a wrong offset!");

// Class FortniteAI.AthenaAIService
// 0x0050 (0x0078 - 0x0028)
class UAthenaAIService : public UObject
{
public:
	class AFortGameModeAthena*                    CachedGameMode;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortGameStateAthena*                   CachedGameState;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UAthenaAIServiceManager*                AIServiceManager;                                  // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIService">();
	}
	static class UAthenaAIService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIService>();
	}
};
static_assert(alignof(UAthenaAIService) == 0x000008, "Wrong alignment on UAthenaAIService");
static_assert(sizeof(UAthenaAIService) == 0x000078, "Wrong size on UAthenaAIService");
static_assert(offsetof(UAthenaAIService, CachedGameMode) == 0x000028, "Member 'UAthenaAIService::CachedGameMode' has a wrong offset!");
static_assert(offsetof(UAthenaAIService, CachedGameState) == 0x000030, "Member 'UAthenaAIService::CachedGameState' has a wrong offset!");
static_assert(offsetof(UAthenaAIService, AIServiceManager) == 0x000068, "Member 'UAthenaAIService::AIServiceManager' has a wrong offset!");

// Class FortniteAI.AthenaAIServiceVehicle
// 0x0050 (0x00C8 - 0x0078)
class UAthenaAIServiceVehicle final : public UAthenaAIService
{
public:
	uint8                                         Pad_78[0x38];                                      // 0x0078(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortAthenaVehicle*>             TrackedVehicles;                                   // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         TimeToRefreshTree;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIServiceVehicle">();
	}
	static class UAthenaAIServiceVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIServiceVehicle>();
	}
};
static_assert(alignof(UAthenaAIServiceVehicle) == 0x000008, "Wrong alignment on UAthenaAIServiceVehicle");
static_assert(sizeof(UAthenaAIServiceVehicle) == 0x0000C8, "Wrong size on UAthenaAIServiceVehicle");
static_assert(offsetof(UAthenaAIServiceVehicle, TrackedVehicles) == 0x0000B0, "Member 'UAthenaAIServiceVehicle::TrackedVehicles' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceVehicle, TimeToRefreshTree) == 0x0000C0, "Member 'UAthenaAIServiceVehicle::TimeToRefreshTree' has a wrong offset!");

// Class FortniteAI.FortAITask_Move
// 0x0048 (0x0158 - 0x0110)
class UFortAITask_Move : public UAITask_MoveTo
{
public:
	struct FFortMoveConfig                        MoveConfig;                                        // 0x0110(0x0038)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_Move">();
	}
	static class UFortAITask_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_Move>();
	}
};
static_assert(alignof(UFortAITask_Move) == 0x000008, "Wrong alignment on UFortAITask_Move");
static_assert(sizeof(UFortAITask_Move) == 0x000158, "Wrong size on UFortAITask_Move");
static_assert(offsetof(UFortAITask_Move, MoveConfig) == 0x000110, "Member 'UFortAITask_Move::MoveConfig' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalBase
// 0x0028 (0x0220 - 0x01F8)
class UFortQueryTest_GoalBase : public UEnvQueryTest
{
public:
	uint8                                         bScoreEnemies : 1;                                 // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScoreEncounterGoals : 1;                          // 0x01F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScoreWorldGoals : 1;                              // 0x01F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScoreSpecificAssignments : 1;                     // 0x01F8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAIAssignmentIdentifier>    AssignmentIDs;                                     // 0x0200(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIAssignmentIdentifier>    ProhibitedAssignmentIDs;                           // 0x0210(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalBase">();
	}
	static class UFortQueryTest_GoalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalBase>();
	}
};
static_assert(alignof(UFortQueryTest_GoalBase) == 0x000008, "Wrong alignment on UFortQueryTest_GoalBase");
static_assert(sizeof(UFortQueryTest_GoalBase) == 0x000220, "Wrong size on UFortQueryTest_GoalBase");
static_assert(offsetof(UFortQueryTest_GoalBase, AssignmentIDs) == 0x000200, "Member 'UFortQueryTest_GoalBase::AssignmentIDs' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalBase, ProhibitedAssignmentIDs) == 0x000210, "Member 'UFortQueryTest_GoalBase::ProhibitedAssignmentIDs' has a wrong offset!");

// Class FortniteAI.FortAITask_MoveTo
// 0x0000 (0x0110 - 0x0110)
class UFortAITask_MoveTo final : public UAITask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_MoveTo">();
	}
	static class UFortAITask_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_MoveTo>();
	}
};
static_assert(alignof(UFortAITask_MoveTo) == 0x000008, "Wrong alignment on UFortAITask_MoveTo");
static_assert(sizeof(UFortAITask_MoveTo) == 0x000110, "Wrong size on UFortAITask_MoveTo");

// Class FortniteAI.FortNavSystem
// 0x0260 (0x18A8 - 0x1648)
class UFortNavSystem : public UNavigationSystemV1
{
public:
	uint8                                         Pad_1648[0x10];                                    // 0x1648(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DefaultSmashableArea;                              // 0x1658(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownArea;                                      // 0x1680(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownSmashableArea;                             // 0x16A8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownSmashableArea2;                            // 0x16D0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownSmashableArea3;                            // 0x16F8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortCustomNavLinkGlobalProxy*>  LinkGlobalProxies;                                 // 0x1720(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class ARecastNavMesh*>                 NamedNavmeshes;                                    // 0x1730(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UFortNavLinkBlockerComponent*>   NavLinkBlockers;                                   // 0x1740(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1750[0x10];                                    // 0x1750(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortPathCostEstimator*>         PathEstimators;                                    // 0x1760(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UFortInescapableZoneTracker*>    InescapableZones;                                  // 0x1770(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         bAllowAutoRebuild : 1;                             // 0x1780(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRebuildOnInitialUnlock : 1;                       // 0x1780(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsesStreamedInNavLevel : 1;                       // 0x1780(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseStaticMeshLinks : 1;                           // 0x1780(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseStaticWorldLinksDown : 1;                      // 0x1780(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseStaticWorldLinksUp : 1;                        // 0x1780(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseJumpLinkActors : 1;                            // 0x1780(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateWallClimbLinks : 1;                       // 0x1780(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateClamberLinks : 1;                         // 0x1781(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1782[0x2];                                     // 0x1782(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirtyAreasUpdateFreqInactive;                      // 0x1784(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1788[0xD8];                                    // 0x1788(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortNavigationGraph*                   NavGraphData;                                      // 0x1860(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         CompositePathGoals;                                // 0x1868(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBox>                           AtlasCells;                                        // 0x1878(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1888[0x10];                                    // 0x1888(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMetaNavCachedEntry>            MetaNavCachedAreas;                                // 0x1898(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static bool IsNavmeshInRadiusInitialized(class UObject* WorldContext, const struct FVector& TestLocation, float TestRadius);

	void OnNavDataRegistered(class ANavigationData* NavData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavSystem">();
	}
	static class UFortNavSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavSystem>();
	}
};
static_assert(alignof(UFortNavSystem) == 0x000008, "Wrong alignment on UFortNavSystem");
static_assert(sizeof(UFortNavSystem) == 0x0018A8, "Wrong size on UFortNavSystem");
static_assert(offsetof(UFortNavSystem, DefaultSmashableArea) == 0x001658, "Member 'UFortNavSystem::DefaultSmashableArea' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownArea) == 0x001680, "Member 'UFortNavSystem::JumpDownArea' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownSmashableArea) == 0x0016A8, "Member 'UFortNavSystem::JumpDownSmashableArea' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownSmashableArea2) == 0x0016D0, "Member 'UFortNavSystem::JumpDownSmashableArea2' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownSmashableArea3) == 0x0016F8, "Member 'UFortNavSystem::JumpDownSmashableArea3' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, LinkGlobalProxies) == 0x001720, "Member 'UFortNavSystem::LinkGlobalProxies' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, NamedNavmeshes) == 0x001730, "Member 'UFortNavSystem::NamedNavmeshes' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, NavLinkBlockers) == 0x001740, "Member 'UFortNavSystem::NavLinkBlockers' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, PathEstimators) == 0x001760, "Member 'UFortNavSystem::PathEstimators' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, InescapableZones) == 0x001770, "Member 'UFortNavSystem::InescapableZones' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, DirtyAreasUpdateFreqInactive) == 0x001784, "Member 'UFortNavSystem::DirtyAreasUpdateFreqInactive' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, NavGraphData) == 0x001860, "Member 'UFortNavSystem::NavGraphData' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, CompositePathGoals) == 0x001868, "Member 'UFortNavSystem::CompositePathGoals' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, AtlasCells) == 0x001878, "Member 'UFortNavSystem::AtlasCells' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, MetaNavCachedAreas) == 0x001898, "Member 'UFortNavSystem::MetaNavCachedAreas' has a wrong offset!");

// Class FortniteAI.AthenaNavSystem
// 0x01A0 (0x1A48 - 0x18A8)
class UAthenaNavSystem final : public UFortNavSystem
{
public:
	uint8                                         Pad_18A8[0x8];                                     // 0x18A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNavDataSetVariantSettings>     NavDataSetVariants;                                // 0x18B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         bUseNavDataSetVariants : 1;                        // 0x18C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bMarkBuildingFoundationDirty : 1;                  // 0x18C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bSupportRuntimeNavmeshDisabling : 1;               // 0x18C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_18C1[0x3];                                     // 0x18C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavGenerationObserverCheckInterval;                // 0x18C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C8[0x20];                                    // 0x18C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoxNavInvoker>                 BoxInvokers;                                       // 0x18E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18F8[0x138];                                   // 0x18F8(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBox>                           NavOctTreeInclusionBounds;                         // 0x1A30(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A40[0x8];                                     // 0x1A40(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsInitialNavigationLockActive(class UObject* WorldContextObject);
	static void RegisterNavGenerationObserver(class USceneComponent* Component, TDelegate<void(class USceneComponent* Component)> event);
	static void UnregisterNavGenerationObserver(class USceneComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaNavSystem">();
	}
	static class UAthenaNavSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaNavSystem>();
	}
};
static_assert(alignof(UAthenaNavSystem) == 0x000008, "Wrong alignment on UAthenaNavSystem");
static_assert(sizeof(UAthenaNavSystem) == 0x001A48, "Wrong size on UAthenaNavSystem");
static_assert(offsetof(UAthenaNavSystem, NavDataSetVariants) == 0x0018B0, "Member 'UAthenaNavSystem::NavDataSetVariants' has a wrong offset!");
static_assert(offsetof(UAthenaNavSystem, NavGenerationObserverCheckInterval) == 0x0018C4, "Member 'UAthenaNavSystem::NavGenerationObserverCheckInterval' has a wrong offset!");
static_assert(offsetof(UAthenaNavSystem, BoxInvokers) == 0x0018E8, "Member 'UAthenaNavSystem::BoxInvokers' has a wrong offset!");
static_assert(offsetof(UAthenaNavSystem, NavOctTreeInclusionBounds) == 0x001A30, "Member 'UAthenaNavSystem::NavOctTreeInclusionBounds' has a wrong offset!");

// Class FortniteAI.FortAthenaTrackableAIObjectComponent
// 0x0040 (0x00E0 - 0x00A0)
class UFortAthenaTrackableAIObjectComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x00B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CustomRegistrationClass;                           // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaTrackableAIObjectComponent">();
	}
	static class UFortAthenaTrackableAIObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaTrackableAIObjectComponent>();
	}
};
static_assert(alignof(UFortAthenaTrackableAIObjectComponent) == 0x000008, "Wrong alignment on UFortAthenaTrackableAIObjectComponent");
static_assert(sizeof(UFortAthenaTrackableAIObjectComponent) == 0x0000E0, "Wrong size on UFortAthenaTrackableAIObjectComponent");
static_assert(offsetof(UFortAthenaTrackableAIObjectComponent, GameplayTags) == 0x0000B0, "Member 'UFortAthenaTrackableAIObjectComponent::GameplayTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaTrackableAIObjectComponent, CustomRegistrationClass) == 0x0000D8, "Member 'UFortAthenaTrackableAIObjectComponent::CustomRegistrationClass' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_BehaviorBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_BehaviorBase : public UFortAthenaAISpawnerDataComponent
{
public:
	class UBehaviorTree* GetBehaviorTree();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_BehaviorBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_BehaviorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_BehaviorBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_BehaviorBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_BehaviorBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_BehaviorBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_BehaviorBase");

// Class FortniteAI.FortBehaviorTreeComponent
// 0x0000 (0x0288 - 0x0288)
class UFortBehaviorTreeComponent : public UBehaviorTreeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBehaviorTreeComponent">();
	}
	static class UFortBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBehaviorTreeComponent>();
	}
};
static_assert(alignof(UFortBehaviorTreeComponent) == 0x000008, "Wrong alignment on UFortBehaviorTreeComponent");
static_assert(sizeof(UFortBehaviorTreeComponent) == 0x000288, "Wrong size on UFortBehaviorTreeComponent");

// Class FortniteAI.FortEnvQueryGenerator_ProjectedPoints
// 0x0008 (0x0090 - 0x0088)
class UFortEnvQueryGenerator_ProjectedPoints : public UEnvQueryGenerator_ProjectedPoints
{
public:
	class FName                                   OverridenAgentNameForNavmesh;                      // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnvQueryGenerator_ProjectedPoints">();
	}
	static class UFortEnvQueryGenerator_ProjectedPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEnvQueryGenerator_ProjectedPoints>();
	}
};
static_assert(alignof(UFortEnvQueryGenerator_ProjectedPoints) == 0x000008, "Wrong alignment on UFortEnvQueryGenerator_ProjectedPoints");
static_assert(sizeof(UFortEnvQueryGenerator_ProjectedPoints) == 0x000090, "Wrong size on UFortEnvQueryGenerator_ProjectedPoints");
static_assert(offsetof(UFortEnvQueryGenerator_ProjectedPoints, OverridenAgentNameForNavmesh) == 0x000088, "Member 'UFortEnvQueryGenerator_ProjectedPoints::OverridenAgentNameForNavmesh' has a wrong offset!");

// Class FortniteAI.FortEnvQueryGenerator_SimpleGrid
// 0x0078 (0x0108 - 0x0090)
class UFortEnvQueryGenerator_SimpleGrid final : public UFortEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              GridSize;                                          // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnvQueryGenerator_SimpleGrid">();
	}
	static class UFortEnvQueryGenerator_SimpleGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEnvQueryGenerator_SimpleGrid>();
	}
};
static_assert(alignof(UFortEnvQueryGenerator_SimpleGrid) == 0x000008, "Wrong alignment on UFortEnvQueryGenerator_SimpleGrid");
static_assert(sizeof(UFortEnvQueryGenerator_SimpleGrid) == 0x000108, "Wrong size on UFortEnvQueryGenerator_SimpleGrid");
static_assert(offsetof(UFortEnvQueryGenerator_SimpleGrid, GridSize) == 0x000090, "Member 'UFortEnvQueryGenerator_SimpleGrid::GridSize' has a wrong offset!");
static_assert(offsetof(UFortEnvQueryGenerator_SimpleGrid, SpaceBetween) == 0x0000C8, "Member 'UFortEnvQueryGenerator_SimpleGrid::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UFortEnvQueryGenerator_SimpleGrid, GenerateAround) == 0x000100, "Member 'UFortEnvQueryGenerator_SimpleGrid::GenerateAround' has a wrong offset!");

// Class FortniteAI.AIGoalComponent
// 0x0068 (0x0108 - 0x00A0)
class UAIGoalComponent : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x68];                                      // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIGoalComponent">();
	}
	static class UAIGoalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIGoalComponent>();
	}
};
static_assert(alignof(UAIGoalComponent) == 0x000008, "Wrong alignment on UAIGoalComponent");
static_assert(sizeof(UAIGoalComponent) == 0x000108, "Wrong size on UAIGoalComponent");

// Class FortniteAI.FortAITask_AdjustToSlot
// 0x0058 (0x00C0 - 0x0068)
class UFortAITask_AdjustToSlot final : public UAITask
{
public:
	struct FVector                                SlotLocation;                                      // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SlotDirection;                                     // 0x0080(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x28];                                      // 0x0098(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_AdjustToSlot">();
	}
	static class UFortAITask_AdjustToSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_AdjustToSlot>();
	}
};
static_assert(alignof(UFortAITask_AdjustToSlot) == 0x000008, "Wrong alignment on UFortAITask_AdjustToSlot");
static_assert(sizeof(UFortAITask_AdjustToSlot) == 0x0000C0, "Wrong size on UFortAITask_AdjustToSlot");
static_assert(offsetof(UFortAITask_AdjustToSlot, SlotLocation) == 0x000068, "Member 'UFortAITask_AdjustToSlot::SlotLocation' has a wrong offset!");
static_assert(offsetof(UFortAITask_AdjustToSlot, SlotDirection) == 0x000080, "Member 'UFortAITask_AdjustToSlot::SlotDirection' has a wrong offset!");

// Class FortniteAI.AIHotSpot
// 0x01B0 (0x0420 - 0x0270)
class AAIHotSpot : public AActor
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIHotSpotSlot*>                 UserSlots;                                         // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAIHotSpotSlotGenerator*                SlotGenerator;                                     // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAIHotSpotSlot*>                 Slots;                                             // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 FocusActor;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CustomNavmeshSearchExtent;                         // 0x02B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bStartEnabled : 1;                                 // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowSlotlessAssignment : 1;                      // 0x02C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowClaimingMultipleSlots : 1;                   // 0x02C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTrackOverlappingSlots : 1;                        // 0x02C8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProjectSlotsOnNavmesh : 1;                        // 0x02C8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCustomNavmeshSearchExtent : 1;                    // 0x02C8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsEnabled : 1;                                    // 0x02C8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAIController*>                  NoSlotAssignees;                                   // 0x02D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x128];                                    // 0x02E0(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    RenderingComponent;                                // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignFromWaitingList();
	int32 AssignGroupToHotspot(const TArray<class AAIController*>& GroupOfAI);
	bool AssignToHotspot(class AAIController* AI);
	bool AssignToSlotByIndex(class AAIController* AI, int32 Index_0);
	bool OccupySlotByIndex(int32 Index_0);
	bool OnAssignedClaimedBehavior(class AAIController* AI, int32 Index_0, int32 UserId, bool bWasOnWaitingList);
	bool OnAssignedOccupiedBehavior(class AAIController* AI, int32 Index_0, int32 UserId);
	bool OnAssignedSlotlessBehavior(class AAIController* AI);
	void OnHotSpotDisabled();
	void OnHotSpotEnabled();
	void OnMoveToSlotFinished(class AAIController* AI, int32 Index_0, int32 UserId, bool bResult);
	void OnRemovedBehavior(class AAIController* AI, int32 Index_0, int32 UserId, EAIHotSpotSlot PrevState, bool bWasOnWaitingList);
	void OnRemovedSlotlessBehavior(class AAIController* AI, bool bIsClamingSlot);
	void OnSlotBlocked(class AAIController* AI, int32 Index_0, int32 UserId);
	void OnSlotClaimed(class AAIController* AI, int32 Index_0, int32 UserId);
	void OnSlotDisabled(int32 Index_0, int32 UserId);
	void OnSlotEnabled(int32 Index_0, int32 UserId);
	void OnSlotFreed(class AAIController* AI, int32 Index_0, int32 UserId);
	void OnSlotOccupied(class AAIController* AI, int32 Index_0, int32 UserId);
	bool RemoveFromHotspot(class AAIController* AI, bool bAssignFromWaitingList);
	int32 RemoveGroupFromHotspot(const TArray<class AAIController*>& GroupOfAI);
	void SetEnabled(bool bEnabled);

	bool CanUseSlotByIndex(const class AAIController* AI, int32 Index_0) const;
	int32 FindBestSlotIndex(class AAIController* AI) const;
	TArray<int32> FindBestSlotIndices(const TArray<class AAIController*>& AI) const;
	TArray<class AAIController*> GetAssignedAI(EAIHotSpotAssignmentFilter Filter) const;
	int32 GetAssignedAICount(EAIHotSpotAssignmentFilter Filter) const;
	class UAIHotSpotSlot* GetSlotByIndex(int32 Index_0) const;
	class UAIHotSpotSlot* GetSlotByOwner(const class AAIController* AIOwner) const;
	int32 GetSlotCount(EAIHotSpotSlotFilter Filter) const;
	int32 GetSlotIndexByOwner(const class AAIController* AIOwner) const;
	struct FVector GetSlotLocationByIndex(int32 Index_0) const;
	class AAIController* GetSlotOwnerByIndex(int32 Index_0) const;
	struct FRotator GetSlotRotationByIndex(int32 Index_0) const;
	EAIHotSpotSlot GetSlotStateByIndex(int32 Index_0) const;
	EAIHotSpotSlot GetSlotStateByOwner(const class AAIController* AIOwner) const;
	int32 GetSlotUserIdByIndex(int32 Index_0) const;
	bool HasAssignedAI(const class AAIController* AI, EAIHotSpotAssignmentFilter Filter) const;
	bool HasEnabledSlots() const;
	bool IsAIAllowed(const class AAIController* AI) const;
	bool IsEnabled() const;
	bool IsSlotlessAssignmentAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpot">();
	}
	static class AAIHotSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIHotSpot>();
	}
};
static_assert(alignof(AAIHotSpot) == 0x000008, "Wrong alignment on AAIHotSpot");
static_assert(sizeof(AAIHotSpot) == 0x000420, "Wrong size on AAIHotSpot");
static_assert(offsetof(AAIHotSpot, UserSlots) == 0x000278, "Member 'AAIHotSpot::UserSlots' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, SlotGenerator) == 0x000288, "Member 'AAIHotSpot::SlotGenerator' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, Slots) == 0x000290, "Member 'AAIHotSpot::Slots' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, FocusActor) == 0x0002A0, "Member 'AAIHotSpot::FocusActor' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, FilterClass) == 0x0002A8, "Member 'AAIHotSpot::FilterClass' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, CustomNavmeshSearchExtent) == 0x0002B0, "Member 'AAIHotSpot::CustomNavmeshSearchExtent' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, NoSlotAssignees) == 0x0002D0, "Member 'AAIHotSpot::NoSlotAssignees' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, RenderingComponent) == 0x000408, "Member 'AAIHotSpot::RenderingComponent' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, SpriteComponent) == 0x000410, "Member 'AAIHotSpot::SpriteComponent' has a wrong offset!");

// Class FortniteAI.AthenaAIBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAthenaAIBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AIPawnFromGAHasLuringPickupAsGoal(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayTag& GameplayTag, const float MaxLifetime, const EFortPickupSpawnSource RequiredPickupSpawnSource);
	static class APawn* AthenaSpawnAIFromClass(class UObject* WorldContextObject, TSubclassOf<class APawn> PawnClass, class UBehaviorTree* BehaviorTree, const struct FVector& Location, const struct FRotator& Rotation, bool bNoCollisionFail, class AActor* Owner);
	static class UAthenaAIPopulationTracker* GetAIPopulationTracker(class UObject* WorldContextObject);
	static class UAthenaAIServiceCreativePlayerBots* GetAIServiceCreativePlayerBots(class UObject* WorldContextObject);
	static class UAthenaAIServiceLoot* GetAIServiceLoot(class UObject* WorldContextObject);
	static class UAthenaAIServicePlayerBots* GetAIServicePlayerBots(class UObject* WorldContextObject);
	static bool IsItemDefinitionSupported(class UObject* WorldContextObject, const class UFortItemDefinition* FortItemDef);
	static bool IsWeaponSupported(class UObject* WorldContextObject, class AFortWeapon* FortWeapon);
	static void JoinTeam(class UObject* WorldContextObject, const class AController* SourceTeamController, class AController* DestinationTeamController);
	static void KillBots(class UObject* WorldContextObject, const bool bKillPlayers, const bool bKillNoneParticipants, const uint8 TeamIndex, class AActor* BotOwner);
	static void MakeBotGroupsTakeEachOtherAsTargets(const TArray<class AActor*>& GroupA, const TArray<class AActor*>& GroupB, EPerceptionState PerceptionState, float ForgetTime, float ForgetDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIBlueprintLibrary">();
	}
	static class UAthenaAIBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIBlueprintLibrary>();
	}
};
static_assert(alignof(UAthenaAIBlueprintLibrary) == 0x000008, "Wrong alignment on UAthenaAIBlueprintLibrary");
static_assert(sizeof(UAthenaAIBlueprintLibrary) == 0x000028, "Wrong size on UAthenaAIBlueprintLibrary");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_VehicleBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_VehicleBase : public UFortAthenaAISpawnerDataComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_VehicleBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_VehicleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_VehicleBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_VehicleBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_VehicleBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_VehicleBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_VehicleBase");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_Vehicle
// 0x0020 (0x0050 - 0x0030)
class UFortAthenaAISpawnerDataComponent_Vehicle final : public UFortAthenaAISpawnerDataComponent_VehicleBase
{
public:
	TSubclassOf<class AFortAthenaVehicle>         VehicleToSpawnAndEnter;                            // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bSetInfiniteFuel : 1;                              // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UFortAthenaAIBotSkillSet>> VehicleSkillSets;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_Vehicle">();
	}
	static class UFortAthenaAISpawnerDataComponent_Vehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_Vehicle>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_Vehicle) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_Vehicle");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_Vehicle) == 0x000050, "Wrong size on UFortAthenaAISpawnerDataComponent_Vehicle");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_Vehicle, VehicleToSpawnAndEnter) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_Vehicle::VehicleToSpawnAndEnter' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_Vehicle, VehicleSkillSets) == 0x000040, "Member 'UFortAthenaAISpawnerDataComponent_Vehicle::VehicleSkillSets' has a wrong offset!");

// Class FortniteAI.AIHotSpotConfig
// 0x0020 (0x0050 - 0x0030)
class UAIHotSpotConfig final : public UDataAsset
{
public:
	TArray<struct FAIHotSpotSlotConfig>           Slots;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bDetectUnreachableSlots : 1;                       // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIHotSpotSlotGenerator*                SlotGenerator;                                     // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotConfig">();
	}
	static class UAIHotSpotConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotConfig>();
	}
};
static_assert(alignof(UAIHotSpotConfig) == 0x000008, "Wrong alignment on UAIHotSpotConfig");
static_assert(sizeof(UAIHotSpotConfig) == 0x000050, "Wrong size on UAIHotSpotConfig");
static_assert(offsetof(UAIHotSpotConfig, Slots) == 0x000030, "Member 'UAIHotSpotConfig::Slots' has a wrong offset!");
static_assert(offsetof(UAIHotSpotConfig, SlotGenerator) == 0x000048, "Member 'UAIHotSpotConfig::SlotGenerator' has a wrong offset!");

// Class FortniteAI.AIHotSpotManagerProxy
// 0x0058 (0x0080 - 0x0028)
class UAIHotSpotManagerProxy : public UAIHotSpotManager
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotManagerProxy">();
	}
	static class UAIHotSpotManagerProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotManagerProxy>();
	}
};
static_assert(alignof(UAIHotSpotManagerProxy) == 0x000008, "Wrong alignment on UAIHotSpotManagerProxy");
static_assert(sizeof(UAIHotSpotManagerProxy) == 0x000080, "Wrong size on UAIHotSpotManagerProxy");

// Class FortniteAI.FortForcedLODZone
// 0x0008 (0x0278 - 0x0270)
class AFortForcedLODZone final : public AActor
{
public:
	EFortAILODLevel                               ForcedLODLevel;                                    // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortForcedLODZone">();
	}
	static class AFortForcedLODZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortForcedLODZone>();
	}
};
static_assert(alignof(AFortForcedLODZone) == 0x000008, "Wrong alignment on AFortForcedLODZone");
static_assert(sizeof(AFortForcedLODZone) == 0x000278, "Wrong size on AFortForcedLODZone");
static_assert(offsetof(AFortForcedLODZone, ForcedLODLevel) == 0x000270, "Member 'AFortForcedLODZone::ForcedLODLevel' has a wrong offset!");

// Class FortniteAI.FortQueryTest_CanAttackTarget
// 0x0000 (0x0220 - 0x0220)
class UFortQueryTest_CanAttackTarget final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CanAttackTarget">();
	}
	static class UFortQueryTest_CanAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CanAttackTarget>();
	}
};
static_assert(alignof(UFortQueryTest_CanAttackTarget) == 0x000008, "Wrong alignment on UFortQueryTest_CanAttackTarget");
static_assert(sizeof(UFortQueryTest_CanAttackTarget) == 0x000220, "Wrong size on UFortQueryTest_CanAttackTarget");

// Class FortniteAI.AIHotSpotRenderingComponent
// 0x0000 (0x0530 - 0x0530)
class UAIHotSpotRenderingComponent final : public UDebugDrawComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotRenderingComponent">();
	}
	static class UAIHotSpotRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotRenderingComponent>();
	}
};
static_assert(alignof(UAIHotSpotRenderingComponent) == 0x000010, "Wrong alignment on UAIHotSpotRenderingComponent");
static_assert(sizeof(UAIHotSpotRenderingComponent) == 0x000530, "Wrong size on UAIHotSpotRenderingComponent");

// Class FortniteAI.FortCustomNavLinkGlobalProxy
// 0x0018 (0x0040 - 0x0028)
class UFortCustomNavLinkGlobalProxy : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        LinkID;                                            // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Owner;                                             // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCustomNavLinkGlobalProxy">();
	}
	static class UFortCustomNavLinkGlobalProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCustomNavLinkGlobalProxy>();
	}
};
static_assert(alignof(UFortCustomNavLinkGlobalProxy) == 0x000008, "Wrong alignment on UFortCustomNavLinkGlobalProxy");
static_assert(sizeof(UFortCustomNavLinkGlobalProxy) == 0x000040, "Wrong size on UFortCustomNavLinkGlobalProxy");
static_assert(offsetof(UFortCustomNavLinkGlobalProxy, LinkID) == 0x000030, "Member 'UFortCustomNavLinkGlobalProxy::LinkID' has a wrong offset!");
static_assert(offsetof(UFortCustomNavLinkGlobalProxy, Owner) == 0x000038, "Member 'UFortCustomNavLinkGlobalProxy::Owner' has a wrong offset!");

// Class FortniteAI.FortClamberLinkGlobalProxy
// 0x0000 (0x0040 - 0x0040)
class UFortClamberLinkGlobalProxy final : public UFortCustomNavLinkGlobalProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClamberLinkGlobalProxy">();
	}
	static class UFortClamberLinkGlobalProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClamberLinkGlobalProxy>();
	}
};
static_assert(alignof(UFortClamberLinkGlobalProxy) == 0x000008, "Wrong alignment on UFortClamberLinkGlobalProxy");
static_assert(sizeof(UFortClamberLinkGlobalProxy) == 0x000040, "Wrong size on UFortClamberLinkGlobalProxy");

// Class FortniteAI.AIHotSpotSlot
// 0x00F8 (0x0120 - 0x0028)
class UAIHotSpotSlot : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToFocusActor;                              // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UserId;                                            // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bStartEnabled : 1;                                 // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasCachedAgentData : 1;                           // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasOverlappingSlots : 1;                          // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasDistanceToFocusActor : 1;                      // 0x00A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsBlockingOthers : 1;                             // 0x00A0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsEnabled : 1;                                    // 0x00A0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          Owner;                                             // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotIndex;                                         // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIHotSpotSlot                                SlotState;                                         // 0x00B4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B5[0x6B];                                      // 0x00B5(0x006B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSlot();
	void OnStateChanged(class AAIController* SlotOwner, EAIHotSpotSlot NewState);
	void SetSlotEnabled(bool bNewEnabled);
	void SetSlotOwnerAndState(class AAIController* NewOwner, EAIHotSpotSlot NewState);
	void SetSlotState(EAIHotSpotSlot NewState);

	class AAIHotSpot* GetHotSpot() const;
	struct FBox GetSlotBounds() const;
	float GetSlotHeight() const;
	int32 GetSlotIndex() const;
	struct FVector GetSlotLocation() const;
	class AAIController* GetSlotOwner() const;
	float GetSlotRadius() const;
	struct FRotator GetSlotRotation() const;
	EAIHotSpotSlot GetSlotState() const;
	int32 GetSlotUserId() const;
	bool HasUserId() const;
	bool IsAIAllowed(const class AAIController* AI) const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotSlot">();
	}
	static class UAIHotSpotSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotSlot>();
	}
};
static_assert(alignof(UAIHotSpotSlot) == 0x000010, "Wrong alignment on UAIHotSpotSlot");
static_assert(sizeof(UAIHotSpotSlot) == 0x000120, "Wrong size on UAIHotSpotSlot");
static_assert(offsetof(UAIHotSpotSlot, LocalTransform) == 0x000030, "Member 'UAIHotSpotSlot::LocalTransform' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, Height) == 0x000090, "Member 'UAIHotSpotSlot::Height' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, Radius) == 0x000094, "Member 'UAIHotSpotSlot::Radius' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, DistanceToFocusActor) == 0x000098, "Member 'UAIHotSpotSlot::DistanceToFocusActor' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, UserId) == 0x00009C, "Member 'UAIHotSpotSlot::UserId' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, Owner) == 0x0000A8, "Member 'UAIHotSpotSlot::Owner' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, SlotIndex) == 0x0000B0, "Member 'UAIHotSpotSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, SlotState) == 0x0000B4, "Member 'UAIHotSpotSlot::SlotState' has a wrong offset!");

// Class FortniteAI.FortNavArea
// 0x0008 (0x0050 - 0x0048)
class UFortNavArea : public UNavArea
{
public:
	uint8                                         bObstacle : 1;                                     // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSmashable : 1;                                    // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea">();
	}
	static class UFortNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea>();
	}
};
static_assert(alignof(UFortNavArea) == 0x000008, "Wrong alignment on UFortNavArea");
static_assert(sizeof(UFortNavArea) == 0x000050, "Wrong size on UFortNavArea");

// Class FortniteAI.FortNavArea_ClosedDoors
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_ClosedDoors final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_ClosedDoors">();
	}
	static class UFortNavArea_ClosedDoors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_ClosedDoors>();
	}
};
static_assert(alignof(UFortNavArea_ClosedDoors) == 0x000008, "Wrong alignment on UFortNavArea_ClosedDoors");
static_assert(sizeof(UFortNavArea_ClosedDoors) == 0x000050, "Wrong size on UFortNavArea_ClosedDoors");

// Class FortniteAI.FortQueryTest_EnvironmentalDanger
// 0x0008 (0x0200 - 0x01F8)
class UFortQueryTest_EnvironmentalDanger final : public UEnvQueryTest
{
public:
	bool                                          bUse3DBoundsCheck;                                 // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DangerSourceActorRegistryTag;                      // 0x01FC(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_EnvironmentalDanger">();
	}
	static class UFortQueryTest_EnvironmentalDanger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_EnvironmentalDanger>();
	}
};
static_assert(alignof(UFortQueryTest_EnvironmentalDanger) == 0x000008, "Wrong alignment on UFortQueryTest_EnvironmentalDanger");
static_assert(sizeof(UFortQueryTest_EnvironmentalDanger) == 0x000200, "Wrong size on UFortQueryTest_EnvironmentalDanger");
static_assert(offsetof(UFortQueryTest_EnvironmentalDanger, bUse3DBoundsCheck) == 0x0001F8, "Member 'UFortQueryTest_EnvironmentalDanger::bUse3DBoundsCheck' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_EnvironmentalDanger, DangerSourceActorRegistryTag) == 0x0001FC, "Member 'UFortQueryTest_EnvironmentalDanger::DangerSourceActorRegistryTag' has a wrong offset!");

// Class FortniteAI.FortAITask_NavmeshWait
// 0x0010 (0x0078 - 0x0068)
class UFortAITask_NavmeshWait final : public UAITask
{
public:
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_NavmeshWait">();
	}
	static class UFortAITask_NavmeshWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_NavmeshWait>();
	}
};
static_assert(alignof(UFortAITask_NavmeshWait) == 0x000008, "Wrong alignment on UFortAITask_NavmeshWait");
static_assert(sizeof(UFortAITask_NavmeshWait) == 0x000078, "Wrong size on UFortAITask_NavmeshWait");

// Class FortniteAI.FortAthenaBTTask_Zipline
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTTask_Zipline final : public UBTTaskNode
{
public:
	class FName                                   UsageExecutionStatusName;                          // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ZiplineTargetName;                                 // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x1];                                       // 0x007C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExitZiplineOnTaskFinished;                        // 0x007D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_Zipline">();
	}
	static class UFortAthenaBTTask_Zipline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_Zipline>();
	}
};
static_assert(alignof(UFortAthenaBTTask_Zipline) == 0x000008, "Wrong alignment on UFortAthenaBTTask_Zipline");
static_assert(sizeof(UFortAthenaBTTask_Zipline) == 0x000080, "Wrong size on UFortAthenaBTTask_Zipline");
static_assert(offsetof(UFortAthenaBTTask_Zipline, UsageExecutionStatusName) == 0x000070, "Member 'UFortAthenaBTTask_Zipline::UsageExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Zipline, ZiplineTargetName) == 0x000078, "Member 'UFortAthenaBTTask_Zipline::ZiplineTargetName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Zipline, bExitZiplineOnTaskFinished) == 0x00007D, "Member 'UFortAthenaBTTask_Zipline::bExitZiplineOnTaskFinished' has a wrong offset!");

// Class FortniteAI.FortAIPerceptionComponent
// 0x0008 (0x0180 - 0x0178)
class UFortAIPerceptionComponent : public UAIPerceptionComponent
{
public:
	float                                         LosingSightRadiusBump;                             // 0x0178(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPerceptionComponent">();
	}
	static class UFortAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPerceptionComponent>();
	}
};
static_assert(alignof(UFortAIPerceptionComponent) == 0x000008, "Wrong alignment on UFortAIPerceptionComponent");
static_assert(sizeof(UFortAIPerceptionComponent) == 0x000180, "Wrong size on UFortAIPerceptionComponent");
static_assert(offsetof(UFortAIPerceptionComponent, LosingSightRadiusBump) == 0x000178, "Member 'UFortAIPerceptionComponent::LosingSightRadiusBump' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalFrustrationDiscouragement
// 0x0000 (0x0220 - 0x0220)
class UFortQueryTest_GoalFrustrationDiscouragement final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalFrustrationDiscouragement">();
	}
	static class UFortQueryTest_GoalFrustrationDiscouragement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalFrustrationDiscouragement>();
	}
};
static_assert(alignof(UFortQueryTest_GoalFrustrationDiscouragement) == 0x000008, "Wrong alignment on UFortQueryTest_GoalFrustrationDiscouragement");
static_assert(sizeof(UFortQueryTest_GoalFrustrationDiscouragement) == 0x000220, "Wrong size on UFortQueryTest_GoalFrustrationDiscouragement");

// Class FortniteAI.AIHotSpotSlotGenerator
// 0x0000 (0x0028 - 0x0028)
class UAIHotSpotSlotGenerator : public UObject
{
public:
	void GenerateSlots();

	class UAIHotSpotSlot* AddSlot(const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, TSubclassOf<class UAIHotSpotSlot> CustomSlotClass, bool bEnabled) const;
	class AAIHotSpot* GetHotSpot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotSlotGenerator">();
	}
	static class UAIHotSpotSlotGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotSlotGenerator>();
	}
};
static_assert(alignof(UAIHotSpotSlotGenerator) == 0x000008, "Wrong alignment on UAIHotSpotSlotGenerator");
static_assert(sizeof(UAIHotSpotSlotGenerator) == 0x000028, "Wrong size on UAIHotSpotSlotGenerator");

// Class FortniteAI.AIHotSpotSlotGenerator_OnBoundingBox
// 0x0070 (0x0098 - 0x0028)
class UAIHotSpotSlotGenerator_OnBoundingBox : public UAIHotSpotSlotGenerator
{
public:
	TSubclassOf<class UAIHotSpotSlot>             SlotClass;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxExtent;                                         // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpandBy;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetFromEdge;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spacing;                                           // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLimitMaxExtent : 1;                               // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMustHitFocusActor : 1;                            // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EBoundingBoxSlotDirectionCalculation          SlotDirectionCalculation;                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3F];                                      // 0x0059(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotSlotGenerator_OnBoundingBox">();
	}
	static class UAIHotSpotSlotGenerator_OnBoundingBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotSlotGenerator_OnBoundingBox>();
	}
};
static_assert(alignof(UAIHotSpotSlotGenerator_OnBoundingBox) == 0x000008, "Wrong alignment on UAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(sizeof(UAIHotSpotSlotGenerator_OnBoundingBox) == 0x000098, "Wrong size on UAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, SlotClass) == 0x000028, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::SlotClass' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, MaxExtent) == 0x000030, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::MaxExtent' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, ExpandBy) == 0x000048, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::ExpandBy' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, OffsetFromEdge) == 0x00004C, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::OffsetFromEdge' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, Spacing) == 0x000050, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::Spacing' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, SlotDirectionCalculation) == 0x000058, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::SlotDirectionCalculation' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_Jump
// 0x0018 (0x0088 - 0x0070)
class UFortAthenaBTService_Jump : public UBTService
{
public:
	class FName                                   JumpExecutionStatusName;                           // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CrouchExecutionStatusName;                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpInputReleaseDelay;                             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Jump">();
	}
	static class UFortAthenaBTService_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Jump>();
	}
};
static_assert(alignof(UFortAthenaBTService_Jump) == 0x000008, "Wrong alignment on UFortAthenaBTService_Jump");
static_assert(sizeof(UFortAthenaBTService_Jump) == 0x000088, "Wrong size on UFortAthenaBTService_Jump");
static_assert(offsetof(UFortAthenaBTService_Jump, JumpExecutionStatusName) == 0x000070, "Member 'UFortAthenaBTService_Jump::JumpExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Jump, CrouchExecutionStatusName) == 0x000078, "Member 'UFortAthenaBTService_Jump::CrouchExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Jump, JumpInputReleaseDelay) == 0x000080, "Member 'UFortAthenaBTService_Jump::JumpInputReleaseDelay' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_JetpackStrafe
// 0x0010 (0x0098 - 0x0088)
class UFortAthenaBTService_JetpackStrafe final : public UFortAthenaBTService_Jump
{
public:
	class FName                                   JetpackStrafeExecutionStatusName;                  // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotEvasiveManeuversDigestedSkillSet* CacheEMDigestedSkillSet;                           // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_JetpackStrafe">();
	}
	static class UFortAthenaBTService_JetpackStrafe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_JetpackStrafe>();
	}
};
static_assert(alignof(UFortAthenaBTService_JetpackStrafe) == 0x000008, "Wrong alignment on UFortAthenaBTService_JetpackStrafe");
static_assert(sizeof(UFortAthenaBTService_JetpackStrafe) == 0x000098, "Wrong size on UFortAthenaBTService_JetpackStrafe");
static_assert(offsetof(UFortAthenaBTService_JetpackStrafe, JetpackStrafeExecutionStatusName) == 0x000088, "Member 'UFortAthenaBTService_JetpackStrafe::JetpackStrafeExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_JetpackStrafe, CacheEMDigestedSkillSet) == 0x000090, "Member 'UFortAthenaBTService_JetpackStrafe::CacheEMDigestedSkillSet' has a wrong offset!");

// Class FortniteAI.FortAISpawnGroupUpgrade
// 0x00F8 (0x0120 - 0x0028)
class UFortAISpawnGroupUpgrade final : public UObject
{
public:
	struct FGameplayTagContainer                  UpgradeTags;                                       // 0x0028(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      GroupRequiredTagQuery;                             // 0x0048(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIPawnUpgrade>             BasePawnUpgrades;                                  // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   AdditionalModifiersLootTierGroup;                  // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvalidForEnemySpawners;                          // 0x00A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnGroupDiscountPercentage;                      // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TStructCycleFixup<struct FFortAISpawnGroupUpgradeUIData, 0x0070, 0x08> UIData;                                            // 0x00B0(0x0070)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnGroupUpgrade">();
	}
	static class UFortAISpawnGroupUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnGroupUpgrade>();
	}
};
static_assert(alignof(UFortAISpawnGroupUpgrade) == 0x000008, "Wrong alignment on UFortAISpawnGroupUpgrade");
static_assert(sizeof(UFortAISpawnGroupUpgrade) == 0x000120, "Wrong size on UFortAISpawnGroupUpgrade");
static_assert(offsetof(UFortAISpawnGroupUpgrade, UpgradeTags) == 0x000028, "Member 'UFortAISpawnGroupUpgrade::UpgradeTags' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroupUpgrade, GroupRequiredTagQuery) == 0x000048, "Member 'UFortAISpawnGroupUpgrade::GroupRequiredTagQuery' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroupUpgrade, BasePawnUpgrades) == 0x000090, "Member 'UFortAISpawnGroupUpgrade::BasePawnUpgrades' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroupUpgrade, AdditionalModifiersLootTierGroup) == 0x0000A0, "Member 'UFortAISpawnGroupUpgrade::AdditionalModifiersLootTierGroup' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroupUpgrade, bInvalidForEnemySpawners) == 0x0000A4, "Member 'UFortAISpawnGroupUpgrade::bInvalidForEnemySpawners' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroupUpgrade, SpawnGroupDiscountPercentage) == 0x0000A8, "Member 'UFortAISpawnGroupUpgrade::SpawnGroupDiscountPercentage' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroupUpgrade, UIData) == 0x0000B0, "Member 'UFortAISpawnGroupUpgrade::UIData' has a wrong offset!");

// Class FortniteAI.FortBTTask_TriggerVOEvent
// 0x0030 (0x00A0 - 0x0070)
class UFortBTTask_TriggerVOEvent final : public UBTTaskNode
{
public:
	uint8                                         bUseFeedbackBank : 1;                              // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomEventName;                                   // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelectedEvent;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortFeedbackBank*                      FeedbackBank;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_TriggerVOEvent">();
	}
	static class UFortBTTask_TriggerVOEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_TriggerVOEvent>();
	}
};
static_assert(alignof(UFortBTTask_TriggerVOEvent) == 0x000008, "Wrong alignment on UFortBTTask_TriggerVOEvent");
static_assert(sizeof(UFortBTTask_TriggerVOEvent) == 0x0000A0, "Wrong size on UFortBTTask_TriggerVOEvent");
static_assert(offsetof(UFortBTTask_TriggerVOEvent, CustomEventName) == 0x000078, "Member 'UFortBTTask_TriggerVOEvent::CustomEventName' has a wrong offset!");
static_assert(offsetof(UFortBTTask_TriggerVOEvent, SelectedEvent) == 0x000088, "Member 'UFortBTTask_TriggerVOEvent::SelectedEvent' has a wrong offset!");
static_assert(offsetof(UFortBTTask_TriggerVOEvent, FeedbackBank) == 0x000098, "Member 'UFortBTTask_TriggerVOEvent::FeedbackBank' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_TerrainDonut
// 0x00F0 (0x0140 - 0x0050)
class UFortQueryGenerator_TerrainDonut final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              Radius;                                            // 0x0058(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              RadiusWidth;                                       // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SpacingArc;                                        // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumRings;                                          // 0x0100(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bFilterAllowTerrain : 1;                           // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowBuildings : 1;                         // 0x0138(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_TerrainDonut">();
	}
	static class UFortQueryGenerator_TerrainDonut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_TerrainDonut>();
	}
};
static_assert(alignof(UFortQueryGenerator_TerrainDonut) == 0x000008, "Wrong alignment on UFortQueryGenerator_TerrainDonut");
static_assert(sizeof(UFortQueryGenerator_TerrainDonut) == 0x000140, "Wrong size on UFortQueryGenerator_TerrainDonut");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, Center) == 0x000050, "Member 'UFortQueryGenerator_TerrainDonut::Center' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, Radius) == 0x000058, "Member 'UFortQueryGenerator_TerrainDonut::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, RadiusWidth) == 0x000090, "Member 'UFortQueryGenerator_TerrainDonut::RadiusWidth' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, SpacingArc) == 0x0000C8, "Member 'UFortQueryGenerator_TerrainDonut::SpacingArc' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, NumRings) == 0x000100, "Member 'UFortQueryGenerator_TerrainDonut::NumRings' has a wrong offset!");

// Class FortniteAI.AthenaAIBudgetManager
// 0x0248 (0x0278 - 0x0030)
class UAthenaAIBudgetManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x248];                                     // 0x0030(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIBudgetManager">();
	}
	static class UAthenaAIBudgetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIBudgetManager>();
	}
};
static_assert(alignof(UAthenaAIBudgetManager) == 0x000008, "Wrong alignment on UAthenaAIBudgetManager");
static_assert(sizeof(UAthenaAIBudgetManager) == 0x000278, "Wrong size on UAthenaAIBudgetManager");

// Class FortniteAI.FortAIController
// 0x0150 (0x04E8 - 0x0398)
class AFortAIController : public AAIController
{
public:
	uint8                                         Pad_398[0x20];                                     // 0x0398(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUsingNavMesh : 1;                                 // 0x03B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysNotifyBumpWall : 1;                         // 0x03B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInstantRotation : 1;                              // 0x03B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTurnTransitionsEnabled : 1;                       // 0x03B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_3B8_4 : 4;                                  // 0x03B8(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         BitPad_3B9_0 : 7;                                  // 0x03B9(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIgnoreAllActorsThatAreNotPawnsOrBuildings : 1;    // 0x03B9(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowHotspotAbilityLooping : 1;                   // 0x03BA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3BB[0x5];                                      // 0x03BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortPathFollowingComponent*            FortPathFollowingComp;                             // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIHotSpotUseInfo                      CurrentHotSpot;                                    // 0x03C8(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UFortAthenaAIRuntimeParametersComponent* CachedAIRuntimeParametersComponent;                // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIRuntimeParameters_AffiliationBase* CachedAffiliationRuntimeParameters;                // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GoalInfoUpdateRate;                                // 0x03F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GoalActor;                                         // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GoalVisibilityPersistanceTime;                     // 0x0400(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0xA4];                                     // 0x0404(0x00A4)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIPawn*                            MyFortPawn;                                        // 0x04A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTeamSetDelegate;                                 // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AFortAIController* OwnerController, class UFortControllerComponent* AttachedComponent)> OnControllerComponentAttachedEvent;                // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UAIGoalComponent*                       AIGoalComponent;                                   // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BTAssetToRunOnPawnAISpawned;                       // 0x04D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortGameStateComponent_AffiliationManager* CachedAffiliationManager;                          // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool IsIgnoringProximity(class AFortAIController* FortAIController);

	void ClearAllFocalPoints();
	bool CreateBuildingActor(TSubclassOf<class ABuildingSMActor> BuildingClass, const struct FVector& BuildLoc, const struct FRotator& BuildRot, bool bMirrored);
	void IgnoreProximityForDuration(float DurationToIgnore);
	bool IsAllowedToSleep();
	void LockBehaviorResource();
	void LockMovementResource();
	void OnActorGoalDestroyed(class AActor* DestroyedActor);
	void OnBuildingActorGoalDestroyed();
	void SetAlwaysGameplayRelevant(bool bInAlwaysGameplayRelevant);
	void SetFullPeripheralVision(bool bNewFullPeripheralVision);
	void SetGoalActor(class AActor* InActor, bool bLocationAlwaysKnown);
	void SetIsSleeping(bool bNewSleepStatus);
	void SetPawnAIType(EFortressAIType NewAIType, class AActor* SpawnSpot);
	void SetTeam(EFortTeam InTeam);
	void SetTeamInt(uint8 InTeam);
	void SetupCustomVIM(class UClass* VIM);
	void UnlockBehaviorResource();
	void UnlockMovementResource();
	void WakeUp();

	class UFortAIEncounterInfo* GetEncounterInfo() const;
	class AActor* GetGoalActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIController">();
	}
	static class AFortAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIController>();
	}
};
static_assert(alignof(AFortAIController) == 0x000008, "Wrong alignment on AFortAIController");
static_assert(sizeof(AFortAIController) == 0x0004E8, "Wrong size on AFortAIController");
static_assert(offsetof(AFortAIController, FortPathFollowingComp) == 0x0003C0, "Member 'AFortAIController::FortPathFollowingComp' has a wrong offset!");
static_assert(offsetof(AFortAIController, CurrentHotSpot) == 0x0003C8, "Member 'AFortAIController::CurrentHotSpot' has a wrong offset!");
static_assert(offsetof(AFortAIController, CachedAIRuntimeParametersComponent) == 0x0003E0, "Member 'AFortAIController::CachedAIRuntimeParametersComponent' has a wrong offset!");
static_assert(offsetof(AFortAIController, CachedAffiliationRuntimeParameters) == 0x0003E8, "Member 'AFortAIController::CachedAffiliationRuntimeParameters' has a wrong offset!");
static_assert(offsetof(AFortAIController, GoalInfoUpdateRate) == 0x0003F0, "Member 'AFortAIController::GoalInfoUpdateRate' has a wrong offset!");
static_assert(offsetof(AFortAIController, GoalActor) == 0x0003F8, "Member 'AFortAIController::GoalActor' has a wrong offset!");
static_assert(offsetof(AFortAIController, GoalVisibilityPersistanceTime) == 0x000400, "Member 'AFortAIController::GoalVisibilityPersistanceTime' has a wrong offset!");
static_assert(offsetof(AFortAIController, MyFortPawn) == 0x0004A8, "Member 'AFortAIController::MyFortPawn' has a wrong offset!");
static_assert(offsetof(AFortAIController, OnTeamSetDelegate) == 0x0004B0, "Member 'AFortAIController::OnTeamSetDelegate' has a wrong offset!");
static_assert(offsetof(AFortAIController, OnControllerComponentAttachedEvent) == 0x0004C0, "Member 'AFortAIController::OnControllerComponentAttachedEvent' has a wrong offset!");
static_assert(offsetof(AFortAIController, AIGoalComponent) == 0x0004D0, "Member 'AFortAIController::AIGoalComponent' has a wrong offset!");
static_assert(offsetof(AFortAIController, BTAssetToRunOnPawnAISpawned) == 0x0004D8, "Member 'AFortAIController::BTAssetToRunOnPawnAISpawned' has a wrong offset!");
static_assert(offsetof(AFortAIController, CachedAffiliationManager) == 0x0004E0, "Member 'AFortAIController::CachedAffiliationManager' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_Inventory
// 0x0018 (0x0048 - 0x0030)
class UFortAthenaAIRuntimeParameters_Inventory final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bShouldDropCurrencyOnDeath : 1;                    // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDefaultInventoryIgnoresRestrictions : 1;          // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bSkipInventoryInitialization : 1;                  // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrencyPayoutRowName;                             // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    LootInfo;                                          // 0x0038(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_Inventory">();
	}
	static class UFortAthenaAIRuntimeParameters_Inventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_Inventory>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_Inventory) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_Inventory");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_Inventory) == 0x000048, "Wrong size on UFortAthenaAIRuntimeParameters_Inventory");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Inventory, CurrencyPayoutRowName) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_Inventory::CurrencyPayoutRowName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Inventory, LootInfo) == 0x000038, "Member 'UFortAthenaAIRuntimeParameters_Inventory::LootInfo' has a wrong offset!");

// Class FortniteAI.AthenaAIController
// 0x0090 (0x0578 - 0x04E8)
class AAthenaAIController : public AFortAIController
{
public:
	uint8                                         Pad_4E8[0x20];                                     // 0x04E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortGameplayAbility*                   PrimaryMeleeAttackAbilityInstance;                 // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortGameplayAbility*                   PrimaryRangedAttackAbilityInstance;                // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NavWalkingSearchExtentScale;                       // 0x0518(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheapFlyingNavPointHorizontalGridRatio;            // 0x0530(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheapFlyingNavNavPointVerticalGridRatio;           // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CheapFlyingNavSmashableAbilityTag;                 // 0x0538(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bEnableCheapFlyingNavigation : 1;                  // 0x0558(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowBacktrackPathfinding : 1;                    // 0x0558(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsGoalRequiredForBehavior : 1;                    // 0x0558(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoGenerateHotspotOnPlayerBuildings : 1;         // 0x0558(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_558_4 : 4;                                  // 0x0558(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bRegisterToAthenaAIDropper : 1;                    // 0x0559(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_55A[0x6];                                      // 0x055A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SecondaryGoalActor;                                // 0x0560(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAthenaPathFollowingComponent*          AthenaPFC;                                         // 0x0570(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIController">();
	}
	static class AAthenaAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAthenaAIController>();
	}
};
static_assert(alignof(AAthenaAIController) == 0x000008, "Wrong alignment on AAthenaAIController");
static_assert(sizeof(AAthenaAIController) == 0x000578, "Wrong size on AAthenaAIController");
static_assert(offsetof(AAthenaAIController, PrimaryMeleeAttackAbilityInstance) == 0x000508, "Member 'AAthenaAIController::PrimaryMeleeAttackAbilityInstance' has a wrong offset!");
static_assert(offsetof(AAthenaAIController, PrimaryRangedAttackAbilityInstance) == 0x000510, "Member 'AAthenaAIController::PrimaryRangedAttackAbilityInstance' has a wrong offset!");
static_assert(offsetof(AAthenaAIController, NavWalkingSearchExtentScale) == 0x000518, "Member 'AAthenaAIController::NavWalkingSearchExtentScale' has a wrong offset!");
static_assert(offsetof(AAthenaAIController, CheapFlyingNavPointHorizontalGridRatio) == 0x000530, "Member 'AAthenaAIController::CheapFlyingNavPointHorizontalGridRatio' has a wrong offset!");
static_assert(offsetof(AAthenaAIController, CheapFlyingNavNavPointVerticalGridRatio) == 0x000534, "Member 'AAthenaAIController::CheapFlyingNavNavPointVerticalGridRatio' has a wrong offset!");
static_assert(offsetof(AAthenaAIController, CheapFlyingNavSmashableAbilityTag) == 0x000538, "Member 'AAthenaAIController::CheapFlyingNavSmashableAbilityTag' has a wrong offset!");
static_assert(offsetof(AAthenaAIController, SecondaryGoalActor) == 0x000560, "Member 'AAthenaAIController::SecondaryGoalActor' has a wrong offset!");
static_assert(offsetof(AAthenaAIController, AthenaPFC) == 0x000570, "Member 'AAthenaAIController::AthenaPFC' has a wrong offset!");

// Class FortniteAI.AthenaAIPerceptionComponent
// 0x0000 (0x0180 - 0x0180)
class UAthenaAIPerceptionComponent final : public UFortAIPerceptionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIPerceptionComponent">();
	}
	static class UAthenaAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIPerceptionComponent>();
	}
};
static_assert(alignof(UAthenaAIPerceptionComponent) == 0x000008, "Wrong alignment on UAthenaAIPerceptionComponent");
static_assert(sizeof(UAthenaAIPerceptionComponent) == 0x000180, "Wrong size on UAthenaAIPerceptionComponent");

// Class FortniteAI.FortAthenaAIEvaluator
// 0x0030 (0x0058 - 0x0028)
class UFortAthenaAIEvaluator : public UObject
{
public:
	class UBehaviorTreeComponent*                 CachedOwnerComp;                                   // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ExecutionStatusName;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IFortAthenaAILODSettings> CachedLODSettingsInterface;                        // 0x0040(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardKeyAccessValidator*          KeyAccessValidator;                                // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIEvaluator">();
	}
	static class UFortAthenaAIEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIEvaluator>();
	}
};
static_assert(alignof(UFortAthenaAIEvaluator) == 0x000008, "Wrong alignment on UFortAthenaAIEvaluator");
static_assert(sizeof(UFortAthenaAIEvaluator) == 0x000058, "Wrong size on UFortAthenaAIEvaluator");
static_assert(offsetof(UFortAthenaAIEvaluator, CachedOwnerComp) == 0x000028, "Member 'UFortAthenaAIEvaluator::CachedOwnerComp' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator, ExecutionStatusName) == 0x000030, "Member 'UFortAthenaAIEvaluator::ExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator, CachedLODSettingsInterface) == 0x000040, "Member 'UFortAthenaAIEvaluator::CachedLODSettingsInterface' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator, KeyAccessValidator) == 0x000050, "Member 'UFortAthenaAIEvaluator::KeyAccessValidator' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator
// 0x0030 (0x0088 - 0x0058)
class UFortAthenaAIBotEvaluator : public UFortAthenaAIEvaluator
{
public:
	TSubclassOf<class UNavigationQueryFilter>     OverrideNavigationFilterClass;                     // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAthenaAIBotController*             CachedBotController;                               // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator">();
	}
	static class UFortAthenaAIBotEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator");
static_assert(sizeof(UFortAthenaAIBotEvaluator) == 0x000088, "Wrong size on UFortAthenaAIBotEvaluator");
static_assert(offsetof(UFortAthenaAIBotEvaluator, OverrideNavigationFilterClass) == 0x000058, "Member 'UFortAthenaAIBotEvaluator::OverrideNavigationFilterClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator, CachedBotController) == 0x000060, "Member 'UFortAthenaAIBotEvaluator::CachedBotController' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Movement
// 0x0190 (0x0218 - 0x0088)
class UFortAthenaAIBotEvaluator_Movement : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   MovementStateKeyName;                              // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MovementDestinationKeyName;                        // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastPartialPathTimeKeyName;                        // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastPartialPathCountKeyName;                       // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastBlockedPathCountKeyName;                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UnstuckInWaterExecutionStatusName;                 // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UnstuckLastBlockedByActorKeyName;                  // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UnstuckExecutionStatusKeyName;                     // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TeleportExecutionStatusKeyName;                    // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UndermineExecutionStatusKeyName;                   // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UndermineTargetKeyName;                            // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UndermineLocationImpactName;                       // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UnstuckSteerExecutionStatusKeyName;                // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UnstuckSteerDirectionKeyName;                      // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZiplineTargetKeyName;                              // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastZiplineUsedName;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZiplineMoveExecutionStatusKeyName;                 // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZiplineMovementStateName;                          // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZiplineEntryLocationKeyName;                       // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZiplineExitLocationKeyName;                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZiplineLastUsageTimeName;                          // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZiplineUsageExecutionStatusName;                   // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WaitTimeBetweenZiplineRandomChoices;               // 0x00E0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ProbabilityToUseZipline;                           // 0x0108(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAthenaAIServicePlayerBots*             CachedAIServicePlayerBots;                         // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotMovementDigestedSkillSet* CachedMovementDigestedSkillSet;                    // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotUnstuckDigestedSkillSet* UnstuckSkillSet;                                   // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0xC0];                                     // 0x0158(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EvaluateIsolatedIslandSteering();
	void OnCurrentUnstuckSteeringAttemptFinished(const EBotUnstuckSteeringReason UnstuckSteeringReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Movement">();
	}
	static class UFortAthenaAIBotEvaluator_Movement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Movement>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Movement) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Movement");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Movement) == 0x000218, "Wrong size on UFortAthenaAIBotEvaluator_Movement");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, MovementStateKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_Movement::MovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, MovementDestinationKeyName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_Movement::MovementDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, LastPartialPathTimeKeyName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_Movement::LastPartialPathTimeKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, LastPartialPathCountKeyName) == 0x000094, "Member 'UFortAthenaAIBotEvaluator_Movement::LastPartialPathCountKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, LastBlockedPathCountKeyName) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_Movement::LastBlockedPathCountKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, UnstuckInWaterExecutionStatusName) == 0x00009C, "Member 'UFortAthenaAIBotEvaluator_Movement::UnstuckInWaterExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, UnstuckLastBlockedByActorKeyName) == 0x0000A0, "Member 'UFortAthenaAIBotEvaluator_Movement::UnstuckLastBlockedByActorKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, UnstuckExecutionStatusKeyName) == 0x0000A4, "Member 'UFortAthenaAIBotEvaluator_Movement::UnstuckExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, TeleportExecutionStatusKeyName) == 0x0000A8, "Member 'UFortAthenaAIBotEvaluator_Movement::TeleportExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, UndermineExecutionStatusKeyName) == 0x0000AC, "Member 'UFortAthenaAIBotEvaluator_Movement::UndermineExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, UndermineTargetKeyName) == 0x0000B0, "Member 'UFortAthenaAIBotEvaluator_Movement::UndermineTargetKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, UndermineLocationImpactName) == 0x0000B4, "Member 'UFortAthenaAIBotEvaluator_Movement::UndermineLocationImpactName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, UnstuckSteerExecutionStatusKeyName) == 0x0000B8, "Member 'UFortAthenaAIBotEvaluator_Movement::UnstuckSteerExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, UnstuckSteerDirectionKeyName) == 0x0000BC, "Member 'UFortAthenaAIBotEvaluator_Movement::UnstuckSteerDirectionKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, ZiplineTargetKeyName) == 0x0000C0, "Member 'UFortAthenaAIBotEvaluator_Movement::ZiplineTargetKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, LastZiplineUsedName) == 0x0000C4, "Member 'UFortAthenaAIBotEvaluator_Movement::LastZiplineUsedName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, ZiplineMoveExecutionStatusKeyName) == 0x0000C8, "Member 'UFortAthenaAIBotEvaluator_Movement::ZiplineMoveExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, ZiplineMovementStateName) == 0x0000CC, "Member 'UFortAthenaAIBotEvaluator_Movement::ZiplineMovementStateName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, ZiplineEntryLocationKeyName) == 0x0000D0, "Member 'UFortAthenaAIBotEvaluator_Movement::ZiplineEntryLocationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, ZiplineExitLocationKeyName) == 0x0000D4, "Member 'UFortAthenaAIBotEvaluator_Movement::ZiplineExitLocationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, ZiplineLastUsageTimeName) == 0x0000D8, "Member 'UFortAthenaAIBotEvaluator_Movement::ZiplineLastUsageTimeName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, ZiplineUsageExecutionStatusName) == 0x0000DC, "Member 'UFortAthenaAIBotEvaluator_Movement::ZiplineUsageExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, WaitTimeBetweenZiplineRandomChoices) == 0x0000E0, "Member 'UFortAthenaAIBotEvaluator_Movement::WaitTimeBetweenZiplineRandomChoices' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, ProbabilityToUseZipline) == 0x000108, "Member 'UFortAthenaAIBotEvaluator_Movement::ProbabilityToUseZipline' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, CachedAIServicePlayerBots) == 0x000130, "Member 'UFortAthenaAIBotEvaluator_Movement::CachedAIServicePlayerBots' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, CachedMovementDigestedSkillSet) == 0x000148, "Member 'UFortAthenaAIBotEvaluator_Movement::CachedMovementDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Movement, UnstuckSkillSet) == 0x000150, "Member 'UFortAthenaAIBotEvaluator_Movement::UnstuckSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaNpcEvaluator_FollowSquadLeader
// 0x0150 (0x0368 - 0x0218)
class UFortAthenaNpcEvaluator_FollowSquadLeader final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	struct FScalableFloat                         FormationOffsetRadiusMin;                          // 0x0218(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         FormationOffsetRadiusMax;                          // 0x0240(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TooFarFromSquadLeaderDistance;                     // 0x0268(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxNoiseRadius;                                    // 0x0290(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MinDurationNoiseEvaluate;                          // 0x02B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxDurationNoiseEvaluate;                          // 0x02E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   FollowSquadLeaderStatusKeyName;                    // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FollowSquadLeaderMovementStateKeyName;             // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FollowSquadLeaderDestinationKeyName;               // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TooFarFromLeaderKeyName;                           // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CachedSquadFormationOffset;                        // 0x0328(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CachedNoiseOffset;                                 // 0x0340(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CachedTooFarFromSquadLeaderDistanceSqr;            // 0x0358(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastNoiseOffsetUpdateTime;                         // 0x035C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DurationNoiseEvaluate;                             // 0x0360(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNpcEvaluator_FollowSquadLeader">();
	}
	static class UFortAthenaNpcEvaluator_FollowSquadLeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNpcEvaluator_FollowSquadLeader>();
	}
};
static_assert(alignof(UFortAthenaNpcEvaluator_FollowSquadLeader) == 0x000008, "Wrong alignment on UFortAthenaNpcEvaluator_FollowSquadLeader");
static_assert(sizeof(UFortAthenaNpcEvaluator_FollowSquadLeader) == 0x000368, "Wrong size on UFortAthenaNpcEvaluator_FollowSquadLeader");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, FormationOffsetRadiusMin) == 0x000218, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::FormationOffsetRadiusMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, FormationOffsetRadiusMax) == 0x000240, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::FormationOffsetRadiusMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, TooFarFromSquadLeaderDistance) == 0x000268, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::TooFarFromSquadLeaderDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, MaxNoiseRadius) == 0x000290, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::MaxNoiseRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, MinDurationNoiseEvaluate) == 0x0002B8, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::MinDurationNoiseEvaluate' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, MaxDurationNoiseEvaluate) == 0x0002E0, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::MaxDurationNoiseEvaluate' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, FollowSquadLeaderStatusKeyName) == 0x000308, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::FollowSquadLeaderStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, FollowSquadLeaderMovementStateKeyName) == 0x000310, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::FollowSquadLeaderMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, FollowSquadLeaderDestinationKeyName) == 0x000318, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::FollowSquadLeaderDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, TooFarFromLeaderKeyName) == 0x000320, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::TooFarFromLeaderKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, CachedSquadFormationOffset) == 0x000328, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::CachedSquadFormationOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, CachedNoiseOffset) == 0x000340, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::CachedNoiseOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, CachedTooFarFromSquadLeaderDistanceSqr) == 0x000358, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::CachedTooFarFromSquadLeaderDistanceSqr' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, LastNoiseOffsetUpdateTime) == 0x00035C, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::LastNoiseOffsetUpdateTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowSquadLeader, DurationNoiseEvaluate) == 0x000360, "Member 'UFortAthenaNpcEvaluator_FollowSquadLeader::DurationNoiseEvaluate' has a wrong offset!");

// Class FortniteAI.FortCreativeCreatureManagerInfoComponent
// 0x00B8 (0x0220 - 0x0168)
class UFortCreativeCreatureManagerInfoComponent final : public TObjectBasedCycleFixup<class UFortMinigameLogicComponent, 0x0140, 0x08>
{
public:
	uint8                                         Pad_168[0x18];                                     // 0x0168(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CreatureBlueprintClass;                            // 0x0180(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxHealth;                                         // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HearingAggroRange;                                 // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ScorePoints;                                       // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageCaused;                                      // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnvironmentalDamageOverride;                       // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeedMultiplier;                           // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bImmuneToWeaponKnockback;                          // 0x01C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortCreativeCreatureManagerComponent*  CreatureManagerComponent;                          // 0x01C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            DamageOverrideEffect;                              // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            EnvironmentalDamageOverrideEffect;                 // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            MovementSpeedOverrideEffect;                       // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            WeaponKnockbackImmunityEffect;                     // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            MaxHealthOverrideEffect;                           // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EScoreDistributionType                        ScoreDistribution;                                 // 0x01F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECreatureManagerAffectedTargets               AffectedTargetsType;                               // 0x01F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FA[0x26];                                     // 0x01FA(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFortCreativeCreatureManagerComponent* GetCreatureManagerComponent();
	void ResetEnvironmentalDamageOverride();
	void ResetHearingAggroRange();
	void ResetMaxHealth();
	void ResetMovementSpeedMultiplier();
	void ResetOverrideDamage();
	void ResetScoreDistribution();
	void ResetScorePoints();
	void ResetWeaponKnockbackImmunity();
	void SetAffectedTargetsType(ECreatureManagerAffectedTargets InAffectedTargetsType);
	void SetCreatureBlueprintClass(TSoftClassPtr<class UClass> InCreatureBlueprintClass);
	void SetCreatureManagerComponent(class UFortCreativeCreatureManagerComponent* InCreatureManagerComponent);
	void SetDamageOverrideEffect(TSubclassOf<class UGameplayEffect> Effect);
	void SetDamageOverrideTag(const struct FGameplayTag& Tag);
	void SetEnvironmentalDamageOverride(float InOverrideDamage);
	void SetEnvironmentalDamageOverrideEffect(TSubclassOf<class UGameplayEffect> Effect);
	void SetHearingAggroRange(float InHearingAggroRange);
	void SetMaxHealth(int32 InMaxHealth);
	void SetMaxHealthOverrideEffect(TSubclassOf<class UGameplayEffect> Effect);
	void SetMaxHealthOverrideTag(const struct FGameplayTag& Tag);
	void SetMovementOverrideTag(const struct FGameplayTag& Tag);
	void SetMovementSpeedMultiplier(float InOverrideMovementSpeedMultiplier);
	void SetMovementSpeedOverrideEffect(TSubclassOf<class UGameplayEffect> Effect);
	void SetOverrideDamage(float InOverrideDamage);
	void SetScoreDistribution(const EScoreDistributionType InScoreDistribution);
	void SetScorePoints(int32 InScorePoints);
	void SetWeaponKnockbackImmunity(bool InImmuneToWeaponKnockback);
	void SetWeaponKnockbackImmunityEffect(TSubclassOf<class UGameplayEffect> Effect);

	ECreatureManagerAffectedTargets GetAffectedTargetsType() const;
	TSoftClassPtr<class UClass> GetCreatureBlueprintClass() const;
	float GetEnvironmentalDamageOverride() const;
	float GetHearingAggroRange() const;
	int32 GetMaxHealth() const;
	float GetMovementSpeedMultiplier() const;
	float GetOverrideDamage() const;
	EScoreDistributionType GetScoreDistribution() const;
	int32 GetScorePoints() const;
	bool GetWeaponKnockbackImmunity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCreativeCreatureManagerInfoComponent">();
	}
	static class UFortCreativeCreatureManagerInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCreativeCreatureManagerInfoComponent>();
	}
};
static_assert(alignof(UFortCreativeCreatureManagerInfoComponent) == 0x000008, "Wrong alignment on UFortCreativeCreatureManagerInfoComponent");
static_assert(sizeof(UFortCreativeCreatureManagerInfoComponent) == 0x000220, "Wrong size on UFortCreativeCreatureManagerInfoComponent");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, CreatureBlueprintClass) == 0x000180, "Member 'UFortCreativeCreatureManagerInfoComponent::CreatureBlueprintClass' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, MaxHealth) == 0x0001A8, "Member 'UFortCreativeCreatureManagerInfoComponent::MaxHealth' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, HearingAggroRange) == 0x0001AC, "Member 'UFortCreativeCreatureManagerInfoComponent::HearingAggroRange' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, ScorePoints) == 0x0001B0, "Member 'UFortCreativeCreatureManagerInfoComponent::ScorePoints' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, DamageCaused) == 0x0001B4, "Member 'UFortCreativeCreatureManagerInfoComponent::DamageCaused' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, EnvironmentalDamageOverride) == 0x0001B8, "Member 'UFortCreativeCreatureManagerInfoComponent::EnvironmentalDamageOverride' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, MovementSpeedMultiplier) == 0x0001BC, "Member 'UFortCreativeCreatureManagerInfoComponent::MovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, bImmuneToWeaponKnockback) == 0x0001C0, "Member 'UFortCreativeCreatureManagerInfoComponent::bImmuneToWeaponKnockback' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, CreatureManagerComponent) == 0x0001C8, "Member 'UFortCreativeCreatureManagerInfoComponent::CreatureManagerComponent' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, DamageOverrideEffect) == 0x0001D0, "Member 'UFortCreativeCreatureManagerInfoComponent::DamageOverrideEffect' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, EnvironmentalDamageOverrideEffect) == 0x0001D8, "Member 'UFortCreativeCreatureManagerInfoComponent::EnvironmentalDamageOverrideEffect' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, MovementSpeedOverrideEffect) == 0x0001E0, "Member 'UFortCreativeCreatureManagerInfoComponent::MovementSpeedOverrideEffect' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, WeaponKnockbackImmunityEffect) == 0x0001E8, "Member 'UFortCreativeCreatureManagerInfoComponent::WeaponKnockbackImmunityEffect' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, MaxHealthOverrideEffect) == 0x0001F0, "Member 'UFortCreativeCreatureManagerInfoComponent::MaxHealthOverrideEffect' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, ScoreDistribution) == 0x0001F8, "Member 'UFortCreativeCreatureManagerInfoComponent::ScoreDistribution' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerInfoComponent, AffectedTargetsType) == 0x0001F9, "Member 'UFortCreativeCreatureManagerInfoComponent::AffectedTargetsType' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_PointsInVolume
// 0x0048 (0x0098 - 0x0050)
class UFortQueryGenerator_PointsInVolume final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderIntValue                NumberOfPoints;                                    // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EFortNamedNavmesh                             NavMeshToUse;                                      // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateIn;                                        // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsInVolume">();
	}
	static class UFortQueryGenerator_PointsInVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsInVolume>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsInVolume) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsInVolume");
static_assert(sizeof(UFortQueryGenerator_PointsInVolume) == 0x000098, "Wrong size on UFortQueryGenerator_PointsInVolume");
static_assert(offsetof(UFortQueryGenerator_PointsInVolume, NumberOfPoints) == 0x000050, "Member 'UFortQueryGenerator_PointsInVolume::NumberOfPoints' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsInVolume, NavMeshToUse) == 0x000088, "Member 'UFortQueryGenerator_PointsInVolume::NavMeshToUse' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsInVolume, GenerateIn) == 0x000090, "Member 'UFortQueryGenerator_PointsInVolume::GenerateIn' has a wrong offset!");

// Class FortniteAI.AthenaBehaviorTreeComponent
// 0x0000 (0x0288 - 0x0288)
class UAthenaBehaviorTreeComponent final : public UFortBehaviorTreeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaBehaviorTreeComponent">();
	}
	static class UAthenaBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaBehaviorTreeComponent>();
	}
};
static_assert(alignof(UAthenaBehaviorTreeComponent) == 0x000008, "Wrong alignment on UAthenaBehaviorTreeComponent");
static_assert(sizeof(UAthenaBehaviorTreeComponent) == 0x000288, "Wrong size on UAthenaBehaviorTreeComponent");

// Class FortniteAI.AthenaAIDirector
// 0x0008 (0x0FE0 - 0x0FD8)
class AAthenaAIDirector final : public AFortAIDirector
{
public:
	uint8                                         Pad_FD8[0x8];                                      // 0x0FD8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AggroOnActor(const class AAthenaAIController* AIController, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIDirector">();
	}
	static class AAthenaAIDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAthenaAIDirector>();
	}
};
static_assert(alignof(AAthenaAIDirector) == 0x000008, "Wrong alignment on AAthenaAIDirector");
static_assert(sizeof(AAthenaAIDirector) == 0x000FE0, "Wrong size on AAthenaAIDirector");

// Class FortniteAI.AthenaAIDropper
// 0x0010 (0x0038 - 0x0028)
class UAthenaAIDropper final : public UObject
{
public:
	TArray<struct FDroppingAgentData>             InactiveAgents;                                    // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIDropper">();
	}
	static class UAthenaAIDropper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIDropper>();
	}
};
static_assert(alignof(UAthenaAIDropper) == 0x000008, "Wrong alignment on UAthenaAIDropper");
static_assert(sizeof(UAthenaAIDropper) == 0x000038, "Wrong size on UAthenaAIDropper");
static_assert(offsetof(UAthenaAIDropper, InactiveAgents) == 0x000028, "Member 'UAthenaAIDropper::InactiveAgents' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_GroupBase
// 0x00B0 (0x00E0 - 0x0030)
class UFortAthenaAISpawnerDataComponent_GroupBase final : public UFortAthenaAISpawnerDataComponent
{
public:
	struct FScalableFloat                         EnableGroupComponent;                              // 0x0030(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CanBeGroupLeader;                                  // 0x0058(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EnableFormationComponent;                          // 0x0080(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        FormationSlots;                                    // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxDistanceFromSlotToSprint;                       // 0x00B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_GroupBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_GroupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_GroupBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_GroupBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_GroupBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_GroupBase) == 0x0000E0, "Wrong size on UFortAthenaAISpawnerDataComponent_GroupBase");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GroupBase, EnableGroupComponent) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_GroupBase::EnableGroupComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GroupBase, CanBeGroupLeader) == 0x000058, "Member 'UFortAthenaAISpawnerDataComponent_GroupBase::CanBeGroupLeader' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GroupBase, EnableFormationComponent) == 0x000080, "Member 'UFortAthenaAISpawnerDataComponent_GroupBase::EnableFormationComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GroupBase, FormationSlots) == 0x0000A8, "Member 'UFortAthenaAISpawnerDataComponent_GroupBase::FormationSlots' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GroupBase, MaxDistanceFromSlotToSprint) == 0x0000B8, "Member 'UFortAthenaAISpawnerDataComponent_GroupBase::MaxDistanceFromSlotToSprint' has a wrong offset!");

// Class FortniteAI.AthenaAIPerceptionManager
// 0x0010 (0x0048 - 0x0038)
class UAthenaAIPerceptionManager final : public UAISubsystem
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIPerceptionManager">();
	}
	static class UAthenaAIPerceptionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIPerceptionManager>();
	}
};
static_assert(alignof(UAthenaAIPerceptionManager) == 0x000008, "Wrong alignment on UAthenaAIPerceptionManager");
static_assert(sizeof(UAthenaAIPerceptionManager) == 0x000048, "Wrong size on UAthenaAIPerceptionManager");

// Class FortniteAI.AthenaAIPerceptionStimuliSourceComponent
// 0x0000 (0x00B8 - 0x00B8)
class UAthenaAIPerceptionStimuliSourceComponent : public UAIPerceptionStimuliSourceComponent
{
public:
	void OnOwnerTeamIndexChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIPerceptionStimuliSourceComponent">();
	}
	static class UAthenaAIPerceptionStimuliSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIPerceptionStimuliSourceComponent>();
	}
};
static_assert(alignof(UAthenaAIPerceptionStimuliSourceComponent) == 0x000008, "Wrong alignment on UAthenaAIPerceptionStimuliSourceComponent");
static_assert(sizeof(UAthenaAIPerceptionStimuliSourceComponent) == 0x0000B8, "Wrong size on UAthenaAIPerceptionStimuliSourceComponent");

// Class FortniteAI.AthenaAISense_Hearing
// 0x0000 (0x00E8 - 0x00E8)
class UAthenaAISense_Hearing final : public UAISense_Hearing
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAISense_Hearing">();
	}
	static class UAthenaAISense_Hearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAISense_Hearing>();
	}
};
static_assert(alignof(UAthenaAISense_Hearing) == 0x000008, "Wrong alignment on UAthenaAISense_Hearing");
static_assert(sizeof(UAthenaAISense_Hearing) == 0x0000E8, "Wrong size on UAthenaAISense_Hearing");

// Class FortniteAI.FortCreativeCreatureManagerComponent
// 0x00C0 (0x0160 - 0x00A0)
class UFortCreativeCreatureManagerComponent final : public UActorComponent
{
public:
	TArray<class UFortCreativeCreatureManagerInfoComponent*> CreatureManagerInfos;                              // 0x00A0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, class UFortCreativeCreatureManagerInfoComponent*> EnabledCreatureManagerInfos;                       // 0x00B0(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x60];                                     // 0x0100(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAIPawnDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnInfoComponentAdded(class UFortCreativeCreatureManagerInfoComponent* CreatureManagerInfoComponent);
	void OnInfoComponentRemoved(class UFortCreativeCreatureManagerInfoComponent* CreatureManagerInfoComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCreativeCreatureManagerComponent">();
	}
	static class UFortCreativeCreatureManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCreativeCreatureManagerComponent>();
	}
};
static_assert(alignof(UFortCreativeCreatureManagerComponent) == 0x000008, "Wrong alignment on UFortCreativeCreatureManagerComponent");
static_assert(sizeof(UFortCreativeCreatureManagerComponent) == 0x000160, "Wrong size on UFortCreativeCreatureManagerComponent");
static_assert(offsetof(UFortCreativeCreatureManagerComponent, CreatureManagerInfos) == 0x0000A0, "Member 'UFortCreativeCreatureManagerComponent::CreatureManagerInfos' has a wrong offset!");
static_assert(offsetof(UFortCreativeCreatureManagerComponent, EnabledCreatureManagerInfos) == 0x0000B0, "Member 'UFortCreativeCreatureManagerComponent::EnabledCreatureManagerInfos' has a wrong offset!");

// Class FortniteAI.FortBTTask_GameMoveTo
// 0x0040 (0x00F0 - 0x00B0)
class UFortBTTask_GameMoveTo : public UBTTask_MoveTo
{
public:
	struct FBlackboardKeySelector                 FocalPointWhileMoving;                             // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPublic)
	EPathObstacleAction                           PathObstacleAction;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortPawn>                  PushBumpedPawnClass;                               // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NavFilterTag;                                      // 0x00E8(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDetectUnexpectedPathBlockingObstacles : 1;        // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableSlowdownAtGoal : 1;                         // 0x00EC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopAtGoal : 1;                                   // 0x00EC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFinishMoveOnOverlap : 1;                          // 0x00EC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDeimosFlavor : 1;                                 // 0x00EC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_GameMoveTo">();
	}
	static class UFortBTTask_GameMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_GameMoveTo>();
	}
};
static_assert(alignof(UFortBTTask_GameMoveTo) == 0x000008, "Wrong alignment on UFortBTTask_GameMoveTo");
static_assert(sizeof(UFortBTTask_GameMoveTo) == 0x0000F0, "Wrong size on UFortBTTask_GameMoveTo");
static_assert(offsetof(UFortBTTask_GameMoveTo, FocalPointWhileMoving) == 0x0000B0, "Member 'UFortBTTask_GameMoveTo::FocalPointWhileMoving' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveTo, PathObstacleAction) == 0x0000D8, "Member 'UFortBTTask_GameMoveTo::PathObstacleAction' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveTo, PushBumpedPawnClass) == 0x0000E0, "Member 'UFortBTTask_GameMoveTo::PushBumpedPawnClass' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveTo, NavFilterTag) == 0x0000E8, "Member 'UFortBTTask_GameMoveTo::NavFilterTag' has a wrong offset!");

// Class FortniteAI.AthenaAIServiceCover
// 0x0030 (0x00A8 - 0x0078)
class UAthenaAIServiceCover final : public UAthenaAIService
{
public:
	TSubclassOf<class UNavigationQueryFilter>     CoverPositionFilterClass;                          // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAthenaAIServiceCover* GetAthenaAIServiceCover(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIServiceCover">();
	}
	static class UAthenaAIServiceCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIServiceCover>();
	}
};
static_assert(alignof(UAthenaAIServiceCover) == 0x000008, "Wrong alignment on UAthenaAIServiceCover");
static_assert(sizeof(UAthenaAIServiceCover) == 0x0000A8, "Wrong size on UAthenaAIServiceCover");
static_assert(offsetof(UAthenaAIServiceCover, CoverPositionFilterClass) == 0x000078, "Member 'UAthenaAIServiceCover::CoverPositionFilterClass' has a wrong offset!");

// Class FortniteAI.AthenaAIServicePlayerBots
// 0x0C88 (0x0D00 - 0x0078)
class UAthenaAIServicePlayerBots : public UAthenaAIService
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAISpawnerDataComponentList*  DefaultAISpawnerDataComponentList;                 // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAISpawnerDataComponent_SpawnParamsBase* DefaultAISpawnComponent;                           // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFortServerBotInfo>             DeadBots;                                          // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFortServerBotInfo>             PlayerBotsRestartLeft;                             // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FVector                                ZiplineOctreeCenter;                               // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ZiplineOctreeRadius;                               // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         UseZiplines;                                       // 0x00F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x138];                                    // 0x0118(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDebugMinimapData                      DebugMinimapData;                                  // 0x0250(0x01B0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   MarkPlayerBotsAggressiveStencilName;               // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MarkPlayerBotsDefensiveStencilName;                // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBotHostileToHumanPlayersOnly;                     // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         UseAllBattleBusPOIsSquadRatio;                     // 0x0410(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            TagQueryWeightChance;                              // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UEnvQuery>               FindLocationsAroundPOIQuery;                       // 0x0440(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBattleBusPOI>                  BattleBusTagQueryPOIList;                          // 0x0468(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FBattleBusPOI>                  SecondaryBattleBusTagQueryPOIList;                 // 0x0478(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNavigationPOI>                 OnGroundTagQueryPOIList;                           // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FConstructionBuildingInfo              ConstructionBuildingInfo[0x6];                     // 0x04A0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         UseCustomSupportedItemList;                        // 0x0530(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UDataTable*                             BotItemDataTable;                                  // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         UseRegionalNameList;                               // 0x0560(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxAnonymousBotCount;                              // 0x0588(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UFortAthenaAIBotNameDataAsset> BotNameDataAsset;                                  // 0x05B0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ThankBusDriverProbability;                         // 0x05D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ThankBusDriverMinTime;                             // 0x0600(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ThankBusDriverMaxTime;                             // 0x0628(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShowSeasonLevelProbability;                        // 0x0650(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxNumberOfBotsToSpawnAroundPlayer;                // 0x0678(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MaxAroundBotDistanceToSearchPOIToLand;             // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A4[0x4];                                      // 0x06A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         BackfillEnabled;                                   // 0x06A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         UsePlayerCosmeticForBackfill;                      // 0x06D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         UsePlayerInventoryForBackfill;                     // 0x06F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         OnlyUseBackfillDuringSafezones;                    // 0x0720(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   BackfillSpawnerData;                               // 0x0748(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  SupportedItemTags;                                 // 0x0770(0x0020)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FCachedPOIVolumeLocations>      CachedValidPOIVolumeLocations;                     // 0x0790(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABuildingFoundation*>            CachedBuildingFoundations;                         // 0x07A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B0[0x158];                                    // 0x07B0(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerStartWarmup*                 LastTeamPlayerStart;                               // 0x0908(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_910[0x8];                                      // 0x0910(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UCacheSafeZoneLocation*>    CacheSafeZoneLocationsMap;                         // 0x0918(0x0050)(Transient, NativeAccessSpecifierPrivate)
	float                                         DeadBotCleanupMinDelay;                            // 0x0968(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_96C[0xC];                                      // 0x096C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FString>                           ReservedPlayerNames;                               // 0x0978(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C8[0x8];                                      // 0x09C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 LocationsInSafeZoneFreeIndices;                    // 0x09D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E0[0x50];                                     // 0x09E0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortTeamInfoAthena*                    CurrentFillingTeam;                                // 0x0A30(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A38[0x58];                                     // 0x0A38(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         BotsUniqueIDUseValidAccountID;                     // 0x0A90(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         CurrentBotControllerUID;                           // 0x0AB8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ABC[0x4];                                      // 0x0ABC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAthenaBeaconComponent*>     BeaconList;                                        // 0x0AC0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         BitPad_AD0_0 : 6;                                  // 0x0AD0(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bWaitForNavmeshToBeLoaded : 1;                     // 0x0AD0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDoSpawnBotFlow : 1;                               // 0x0AD0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDoMapSampling : 1;                                // 0x0AD1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	EAthenaGamePhase                              GamePhaseToStartSpawning;                          // 0x0AD2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD3[0x5];                                      // 0x0AD3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortAthenaAISpawnerData>   DefaultBotAISpawnerData;                           // 0x0AD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AE0[0x10];                                     // 0x0AE0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UEnvQuery>               EQSMapSampling;                                    // 0x0AF0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B18[0x30];                                     // 0x0B18(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UAthenaAIPopulationTracker*             CachedAIPopulationTracker;                         // 0x0B48(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFortServerBotInfo>             PlayerBots;                                        // 0x0B50(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFortServerBotInfo>             NonAthenaParticipantBots;                          // 0x0B60(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B70[0x88];                                     // 0x0B70(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              MMRSpawnTable;                                     // 0x0BF8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMMRSpawningPlayerBotsRuntimeInfo      CachedMMRSpawningInfo;                             // 0x0C20(0x0038)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C58[0x20];                                     // 0x0C58(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         OverridePOISpreadingSquadCount;                    // 0x0C78(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CA0[0x60];                                     // 0x0CA0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsWeaponSupported(class AFortWeapon* FortWeapon);
	void JoinTeam(const class AController* SourceTeamController, class AController* DestinationTeamController);
	void KillBots(bool bKillPlayers, bool bKillNoneParticipants, uint8 TeamIndex, class AActor* BotOwner);
	void OnAgentGameOver(class AFortAthenaAIBotController* AIBotController, class AFortPawn* Pawn, class AController* Instigator);
	void OnGamePhaseChanged(EAthenaGamePhase NewPhase);
	void OnPawnSpawned(class APawn* Pawn, const int32 RequestId, const bool bIsRespawn);
	void OnSafeZoneUpdated();
	void OnServerGameMemberRemoved(uint8 InSquadId, uint8 InTeamIndex, class AFortPlayerStateAthena* ChangedPS);
	class APawn* SpawnAI(const struct FVector& InSpawnLocation, const struct FRotator& InSpawnRotation, const class UFortAthenaAISpawnerDataComponentList* AISpawnerComponentList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIServicePlayerBots">();
	}
	static class UAthenaAIServicePlayerBots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIServicePlayerBots>();
	}
};
static_assert(alignof(UAthenaAIServicePlayerBots) == 0x000010, "Wrong alignment on UAthenaAIServicePlayerBots");
static_assert(sizeof(UAthenaAIServicePlayerBots) == 0x000D00, "Wrong size on UAthenaAIServicePlayerBots");
static_assert(offsetof(UAthenaAIServicePlayerBots, DefaultAISpawnerDataComponentList) == 0x000080, "Member 'UAthenaAIServicePlayerBots::DefaultAISpawnerDataComponentList' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, DefaultAISpawnComponent) == 0x000088, "Member 'UAthenaAIServicePlayerBots::DefaultAISpawnComponent' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, DeadBots) == 0x000090, "Member 'UAthenaAIServicePlayerBots::DeadBots' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, PlayerBotsRestartLeft) == 0x0000A0, "Member 'UAthenaAIServicePlayerBots::PlayerBotsRestartLeft' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, ZiplineOctreeCenter) == 0x0000B0, "Member 'UAthenaAIServicePlayerBots::ZiplineOctreeCenter' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, ZiplineOctreeRadius) == 0x0000C8, "Member 'UAthenaAIServicePlayerBots::ZiplineOctreeRadius' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, UseZiplines) == 0x0000F0, "Member 'UAthenaAIServicePlayerBots::UseZiplines' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, DebugMinimapData) == 0x000250, "Member 'UAthenaAIServicePlayerBots::DebugMinimapData' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, MarkPlayerBotsAggressiveStencilName) == 0x000400, "Member 'UAthenaAIServicePlayerBots::MarkPlayerBotsAggressiveStencilName' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, MarkPlayerBotsDefensiveStencilName) == 0x000404, "Member 'UAthenaAIServicePlayerBots::MarkPlayerBotsDefensiveStencilName' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, bBotHostileToHumanPlayersOnly) == 0x000408, "Member 'UAthenaAIServicePlayerBots::bBotHostileToHumanPlayersOnly' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, UseAllBattleBusPOIsSquadRatio) == 0x000410, "Member 'UAthenaAIServicePlayerBots::UseAllBattleBusPOIsSquadRatio' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, TagQueryWeightChance) == 0x000438, "Member 'UAthenaAIServicePlayerBots::TagQueryWeightChance' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, FindLocationsAroundPOIQuery) == 0x000440, "Member 'UAthenaAIServicePlayerBots::FindLocationsAroundPOIQuery' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, BattleBusTagQueryPOIList) == 0x000468, "Member 'UAthenaAIServicePlayerBots::BattleBusTagQueryPOIList' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, SecondaryBattleBusTagQueryPOIList) == 0x000478, "Member 'UAthenaAIServicePlayerBots::SecondaryBattleBusTagQueryPOIList' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, OnGroundTagQueryPOIList) == 0x000490, "Member 'UAthenaAIServicePlayerBots::OnGroundTagQueryPOIList' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, ConstructionBuildingInfo) == 0x0004A0, "Member 'UAthenaAIServicePlayerBots::ConstructionBuildingInfo' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, UseCustomSupportedItemList) == 0x000530, "Member 'UAthenaAIServicePlayerBots::UseCustomSupportedItemList' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, BotItemDataTable) == 0x000558, "Member 'UAthenaAIServicePlayerBots::BotItemDataTable' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, UseRegionalNameList) == 0x000560, "Member 'UAthenaAIServicePlayerBots::UseRegionalNameList' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, MaxAnonymousBotCount) == 0x000588, "Member 'UAthenaAIServicePlayerBots::MaxAnonymousBotCount' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, BotNameDataAsset) == 0x0005B0, "Member 'UAthenaAIServicePlayerBots::BotNameDataAsset' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, ThankBusDriverProbability) == 0x0005D8, "Member 'UAthenaAIServicePlayerBots::ThankBusDriverProbability' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, ThankBusDriverMinTime) == 0x000600, "Member 'UAthenaAIServicePlayerBots::ThankBusDriverMinTime' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, ThankBusDriverMaxTime) == 0x000628, "Member 'UAthenaAIServicePlayerBots::ThankBusDriverMaxTime' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, ShowSeasonLevelProbability) == 0x000650, "Member 'UAthenaAIServicePlayerBots::ShowSeasonLevelProbability' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, MaxNumberOfBotsToSpawnAroundPlayer) == 0x000678, "Member 'UAthenaAIServicePlayerBots::MaxNumberOfBotsToSpawnAroundPlayer' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, MaxAroundBotDistanceToSearchPOIToLand) == 0x0006A0, "Member 'UAthenaAIServicePlayerBots::MaxAroundBotDistanceToSearchPOIToLand' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, BackfillEnabled) == 0x0006A8, "Member 'UAthenaAIServicePlayerBots::BackfillEnabled' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, UsePlayerCosmeticForBackfill) == 0x0006D0, "Member 'UAthenaAIServicePlayerBots::UsePlayerCosmeticForBackfill' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, UsePlayerInventoryForBackfill) == 0x0006F8, "Member 'UAthenaAIServicePlayerBots::UsePlayerInventoryForBackfill' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, OnlyUseBackfillDuringSafezones) == 0x000720, "Member 'UAthenaAIServicePlayerBots::OnlyUseBackfillDuringSafezones' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, BackfillSpawnerData) == 0x000748, "Member 'UAthenaAIServicePlayerBots::BackfillSpawnerData' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, SupportedItemTags) == 0x000770, "Member 'UAthenaAIServicePlayerBots::SupportedItemTags' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, CachedValidPOIVolumeLocations) == 0x000790, "Member 'UAthenaAIServicePlayerBots::CachedValidPOIVolumeLocations' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, CachedBuildingFoundations) == 0x0007A0, "Member 'UAthenaAIServicePlayerBots::CachedBuildingFoundations' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, LastTeamPlayerStart) == 0x000908, "Member 'UAthenaAIServicePlayerBots::LastTeamPlayerStart' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, CacheSafeZoneLocationsMap) == 0x000918, "Member 'UAthenaAIServicePlayerBots::CacheSafeZoneLocationsMap' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, DeadBotCleanupMinDelay) == 0x000968, "Member 'UAthenaAIServicePlayerBots::DeadBotCleanupMinDelay' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, ReservedPlayerNames) == 0x000978, "Member 'UAthenaAIServicePlayerBots::ReservedPlayerNames' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, LocationsInSafeZoneFreeIndices) == 0x0009D0, "Member 'UAthenaAIServicePlayerBots::LocationsInSafeZoneFreeIndices' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, CurrentFillingTeam) == 0x000A30, "Member 'UAthenaAIServicePlayerBots::CurrentFillingTeam' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, BotsUniqueIDUseValidAccountID) == 0x000A90, "Member 'UAthenaAIServicePlayerBots::BotsUniqueIDUseValidAccountID' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, CurrentBotControllerUID) == 0x000AB8, "Member 'UAthenaAIServicePlayerBots::CurrentBotControllerUID' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, BeaconList) == 0x000AC0, "Member 'UAthenaAIServicePlayerBots::BeaconList' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, GamePhaseToStartSpawning) == 0x000AD2, "Member 'UAthenaAIServicePlayerBots::GamePhaseToStartSpawning' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, DefaultBotAISpawnerData) == 0x000AD8, "Member 'UAthenaAIServicePlayerBots::DefaultBotAISpawnerData' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, EQSMapSampling) == 0x000AF0, "Member 'UAthenaAIServicePlayerBots::EQSMapSampling' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, CachedAIPopulationTracker) == 0x000B48, "Member 'UAthenaAIServicePlayerBots::CachedAIPopulationTracker' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, PlayerBots) == 0x000B50, "Member 'UAthenaAIServicePlayerBots::PlayerBots' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, NonAthenaParticipantBots) == 0x000B60, "Member 'UAthenaAIServicePlayerBots::NonAthenaParticipantBots' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, MMRSpawnTable) == 0x000BF8, "Member 'UAthenaAIServicePlayerBots::MMRSpawnTable' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, CachedMMRSpawningInfo) == 0x000C20, "Member 'UAthenaAIServicePlayerBots::CachedMMRSpawningInfo' has a wrong offset!");
static_assert(offsetof(UAthenaAIServicePlayerBots, OverridePOISpreadingSquadCount) == 0x000C78, "Member 'UAthenaAIServicePlayerBots::OverridePOISpreadingSquadCount' has a wrong offset!");

// Class FortniteAI.FortBTDecorator_QueryGameplayAbility
// 0x0070 (0x00D8 - 0x0068)
class UFortBTDecorator_QueryGameplayAbility : public UBTDecorator
{
public:
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0068(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 Target;                                            // 0x0088(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActiveAbilityTagsToSkipTesting;                    // 0x00B0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseTarget;                                        // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_QueryGameplayAbility">();
	}
	static class UFortBTDecorator_QueryGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_QueryGameplayAbility>();
	}
};
static_assert(alignof(UFortBTDecorator_QueryGameplayAbility) == 0x000008, "Wrong alignment on UFortBTDecorator_QueryGameplayAbility");
static_assert(sizeof(UFortBTDecorator_QueryGameplayAbility) == 0x0000D8, "Wrong size on UFortBTDecorator_QueryGameplayAbility");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, GameplayAbilityTag) == 0x000068, "Member 'UFortBTDecorator_QueryGameplayAbility::GameplayAbilityTag' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, Target) == 0x000088, "Member 'UFortBTDecorator_QueryGameplayAbility::Target' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, ActiveAbilityTagsToSkipTesting) == 0x0000B0, "Member 'UFortBTDecorator_QueryGameplayAbility::ActiveAbilityTagsToSkipTesting' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, bUseTarget) == 0x0000D0, "Member 'UFortBTDecorator_QueryGameplayAbility::bUseTarget' has a wrong offset!");

// Class FortniteAI.FortBTDecorator_IsMoving
// 0x0048 (0x0120 - 0x00D8)
class UFortBTDecorator_IsMoving final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	float                                         UpdateInterval;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTime;                                           // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMinDist;                                       // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistMinTime;                                    // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDistanceToTargetComparison            MinDistanceComparison;                             // 0x00E8(0x0038)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_IsMoving">();
	}
	static class UFortBTDecorator_IsMoving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_IsMoving>();
	}
};
static_assert(alignof(UFortBTDecorator_IsMoving) == 0x000008, "Wrong alignment on UFortBTDecorator_IsMoving");
static_assert(sizeof(UFortBTDecorator_IsMoving) == 0x000120, "Wrong size on UFortBTDecorator_IsMoving");
static_assert(offsetof(UFortBTDecorator_IsMoving, UpdateInterval) == 0x0000D8, "Member 'UFortBTDecorator_IsMoving::UpdateInterval' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_IsMoving, MinTime) == 0x0000DC, "Member 'UFortBTDecorator_IsMoving::MinTime' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_IsMoving, bUseMinDist) == 0x0000E0, "Member 'UFortBTDecorator_IsMoving::bUseMinDist' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_IsMoving, MinDistMinTime) == 0x0000E4, "Member 'UFortBTDecorator_IsMoving::MinDistMinTime' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_IsMoving, MinDistanceComparison) == 0x0000E8, "Member 'UFortBTDecorator_IsMoving::MinDistanceComparison' has a wrong offset!");

// Class FortniteAI.AthenaAIServiceCreativePlayerBots
// 0x0050 (0x0D50 - 0x0D00)
class UAthenaAIServiceCreativePlayerBots final : public UAthenaAIServicePlayerBots
{
public:
	TMap<class AActor*, class APlayerController*> HiringHistory;                                     // 0x0D00(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void AddHiringHistory(class AActor* HiredOwner, class APlayerController* HiringPlayer);
	void ClearHiringHistory(class AActor* HiredOwner);

	const class APlayerController* GetLastHiringPlayer(const class AActor* HiredOwner) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIServiceCreativePlayerBots">();
	}
	static class UAthenaAIServiceCreativePlayerBots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIServiceCreativePlayerBots>();
	}
};
static_assert(alignof(UAthenaAIServiceCreativePlayerBots) == 0x000010, "Wrong alignment on UAthenaAIServiceCreativePlayerBots");
static_assert(sizeof(UAthenaAIServiceCreativePlayerBots) == 0x000D50, "Wrong size on UAthenaAIServiceCreativePlayerBots");
static_assert(offsetof(UAthenaAIServiceCreativePlayerBots, HiringHistory) == 0x000D00, "Member 'UAthenaAIServiceCreativePlayerBots::HiringHistory' has a wrong offset!");

// Class FortniteAI.AthenaAIServiceGroup
// 0x0018 (0x0090 - 0x0078)
class UAthenaAIServiceGroup final : public UAthenaAIService
{
public:
	int32                                         GroupIndexCount;                                   // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAthenaAIServiceGroupInfo>      GroupList;                                         // 0x0080(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIServiceGroup">();
	}
	static class UAthenaAIServiceGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIServiceGroup>();
	}
};
static_assert(alignof(UAthenaAIServiceGroup) == 0x000008, "Wrong alignment on UAthenaAIServiceGroup");
static_assert(sizeof(UAthenaAIServiceGroup) == 0x000090, "Wrong size on UAthenaAIServiceGroup");
static_assert(offsetof(UAthenaAIServiceGroup, GroupIndexCount) == 0x000078, "Member 'UAthenaAIServiceGroup::GroupIndexCount' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceGroup, GroupList) == 0x000080, "Member 'UAthenaAIServiceGroup::GroupList' has a wrong offset!");

// Class FortniteAI.FortBTTask_BotMissionBuild
// 0x0000 (0x0098 - 0x0098)
class UFortBTTask_BotMissionBuild final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_BotMissionBuild">();
	}
	static class UFortBTTask_BotMissionBuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_BotMissionBuild>();
	}
};
static_assert(alignof(UFortBTTask_BotMissionBuild) == 0x000008, "Wrong alignment on UFortBTTask_BotMissionBuild");
static_assert(sizeof(UFortBTTask_BotMissionBuild) == 0x000098, "Wrong size on UFortBTTask_BotMissionBuild");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_SkillsetBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_SkillsetBase : public UFortAthenaAISpawnerDataComponent
{
public:
	float GetSkill();
	TArray<TSubclassOf<class UFortAthenaAIBotSkillSet>> GetSkillSets();
	bool ShouldUseMatchMMRToOverrideSkillLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_SkillsetBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_SkillsetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_SkillsetBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_SkillsetBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_SkillsetBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_SkillsetBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_SkillsetBase");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotSkillset
// 0x00C8 (0x00F8 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIBotSkillset : public UFortAthenaAISpawnerDataComponent_SkillsetBase
{
public:
	TSubclassOf<class UFortAthenaAIBotAimingSkillSet> AimingSkillSet;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotAttackingSkillSet> AttackingSkillSet;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotBuildingSkillSet> BuildingSkillSet;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotDBNOSkillSet> DBNOSkillSet;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotEmoteSkillSet> EmoteSkillSet;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotEvasiveManeuversSkillSet> EvasiveManeuversSkillSet;                          // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotHarvestSkillSet> HarvestSkillSet;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotHealingSkillSet> HealingSkillSet;                                   // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotInventorySkillSet> InventorySkillSet;                                 // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotLootingSkillSet> LootingSkillSet;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotMovementSkillSet> MovementSkillSet;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotPerceptionSkillSet> PerceptionSkillSet;                                // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotPlayStyleSkillSet> PlayStyleSkillSet;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotPropagateAwarenessSkillSet> PropagateAwarenessSkillSet;                        // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotRangeAttackSkillSet> RangeAttackSkillSet;                               // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotReviveSkillSet> ReviveSkillSet;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotUnstuckSkillSet> UnstuckSkillSet;                                   // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAIBotVehicleSkillSet> VehicleSkillSet;                                   // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bUseMatchMMRToOverrideSkillLevel : 1;              // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              OverrideSkillLevelMMRTable;                        // 0x00C8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Skill;                                             // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSkill(const float InSKill);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotSkillset">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotSkillset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotSkillset>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotSkillset) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotSkillset");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotSkillset) == 0x0000F8, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotSkillset");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, AimingSkillSet) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::AimingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, AttackingSkillSet) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::AttackingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, BuildingSkillSet) == 0x000040, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::BuildingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, DBNOSkillSet) == 0x000048, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::DBNOSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, EmoteSkillSet) == 0x000050, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::EmoteSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, EvasiveManeuversSkillSet) == 0x000058, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::EvasiveManeuversSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, HarvestSkillSet) == 0x000060, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::HarvestSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, HealingSkillSet) == 0x000068, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::HealingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, InventorySkillSet) == 0x000070, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::InventorySkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, LootingSkillSet) == 0x000078, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::LootingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, MovementSkillSet) == 0x000080, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::MovementSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, PerceptionSkillSet) == 0x000088, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::PerceptionSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, PlayStyleSkillSet) == 0x000090, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::PlayStyleSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, PropagateAwarenessSkillSet) == 0x000098, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::PropagateAwarenessSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, RangeAttackSkillSet) == 0x0000A0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::RangeAttackSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, ReviveSkillSet) == 0x0000A8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::ReviveSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, UnstuckSkillSet) == 0x0000B0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::UnstuckSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, VehicleSkillSet) == 0x0000B8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::VehicleSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, OverrideSkillLevelMMRTable) == 0x0000C8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::OverrideSkillLevelMMRTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotSkillset, Skill) == 0x0000F0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotSkillset::Skill' has a wrong offset!");

// Class FortniteAI.AthenaAIServiceLOFOccluder
// 0x0020 (0x0098 - 0x0078)
class UAthenaAIServiceLOFOccluder final : public UAthenaAIService
{
public:
	TArray<TWeakObjectPtr<class AActor>>          TrackedActors;                                     // 0x0078(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAthenaAIServiceLOFOccluder* GetAthenaAIServiceLOFOccluder(const class UObject* WorldContextObject);

	void RegisterOccluder(class AActor* OccluderActor, const float SphereRadius);
	void UnregisterOccluder(class AActor* OccluderActor);

	bool IsLOFOccluded(const struct FVector& StartLocation, const struct FVector& EndLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIServiceLOFOccluder">();
	}
	static class UAthenaAIServiceLOFOccluder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIServiceLOFOccluder>();
	}
};
static_assert(alignof(UAthenaAIServiceLOFOccluder) == 0x000008, "Wrong alignment on UAthenaAIServiceLOFOccluder");
static_assert(sizeof(UAthenaAIServiceLOFOccluder) == 0x000098, "Wrong size on UAthenaAIServiceLOFOccluder");
static_assert(offsetof(UAthenaAIServiceLOFOccluder, TrackedActors) == 0x000078, "Member 'UAthenaAIServiceLOFOccluder::TrackedActors' has a wrong offset!");

// Class FortniteAI.AthenaAIServiceLoot
// 0x03F8 (0x0470 - 0x0078)
class alignas(0x10) UAthenaAIServiceLoot final : public UAthenaAIService
{
public:
	struct FVector                                LootOctreeCenter;                                  // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         LootOctreeRadius;                                  // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         SupplyDropStatusUpdateRate;                        // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RemoveInvalidChestFromOctreeProbability;           // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MovingLootTrackingEnabled;                         // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MovingLootUpdateRate;                              // 0x0130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MovingLootOctreeUpdateDistanceThreshold;           // 0x0158(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class ABuildingProp>>      HarvestableActorClassList;                         // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x210];                                    // 0x0190(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AFortPickup>, struct FMovingLootInfo> MovingLoots;                                       // 0x03A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedSupplyDrop>              CachedSupplyDrops;                                 // 0x03F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFortWorldItem*                         CachedWorldItem;                                   // 0x0408(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             BotBuildingContainerBlacklistDataTable;            // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x58];                                     // 0x0418(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_AddGameplayTagToLoot(const class AActor* LootActor, const struct FGameplayTag& GameplayTag);
	void K2_RemoveGameplayTagFromLoot(const class AActor* LootActor, const struct FGameplayTag& GameplayTag);
	void OnGamePhaseStepChanged(const TScriptInterface<class IFortSafeZoneInterface>& SafeZoneInterface, const EAthenaGamePhaseStep GamePhaseStep);
	void UpdateMovingLoots();
	void UpdateSupplyDropStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIServiceLoot">();
	}
	static class UAthenaAIServiceLoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIServiceLoot>();
	}
};
static_assert(alignof(UAthenaAIServiceLoot) == 0x000010, "Wrong alignment on UAthenaAIServiceLoot");
static_assert(sizeof(UAthenaAIServiceLoot) == 0x000470, "Wrong size on UAthenaAIServiceLoot");
static_assert(offsetof(UAthenaAIServiceLoot, LootOctreeCenter) == 0x000078, "Member 'UAthenaAIServiceLoot::LootOctreeCenter' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, LootOctreeRadius) == 0x000090, "Member 'UAthenaAIServiceLoot::LootOctreeRadius' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, SupplyDropStatusUpdateRate) == 0x0000B8, "Member 'UAthenaAIServiceLoot::SupplyDropStatusUpdateRate' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, RemoveInvalidChestFromOctreeProbability) == 0x0000E0, "Member 'UAthenaAIServiceLoot::RemoveInvalidChestFromOctreeProbability' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, MovingLootTrackingEnabled) == 0x000108, "Member 'UAthenaAIServiceLoot::MovingLootTrackingEnabled' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, MovingLootUpdateRate) == 0x000130, "Member 'UAthenaAIServiceLoot::MovingLootUpdateRate' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, MovingLootOctreeUpdateDistanceThreshold) == 0x000158, "Member 'UAthenaAIServiceLoot::MovingLootOctreeUpdateDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, HarvestableActorClassList) == 0x000180, "Member 'UAthenaAIServiceLoot::HarvestableActorClassList' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, MovingLoots) == 0x0003A0, "Member 'UAthenaAIServiceLoot::MovingLoots' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, CachedSupplyDrops) == 0x0003F8, "Member 'UAthenaAIServiceLoot::CachedSupplyDrops' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, CachedWorldItem) == 0x000408, "Member 'UAthenaAIServiceLoot::CachedWorldItem' has a wrong offset!");
static_assert(offsetof(UAthenaAIServiceLoot, BotBuildingContainerBlacklistDataTable) == 0x000410, "Member 'UAthenaAIServiceLoot::BotBuildingContainerBlacklistDataTable' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_CosmeticBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_CosmeticBase : public UFortAthenaAISpawnerDataComponent
{
public:
	void GetFallbackTag(struct FGameplayTag* OutFallbackTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_CosmeticBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_CosmeticBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_CosmeticBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_CosmeticBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_CosmeticBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_CosmeticBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_CosmeticBase");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotCosmeticBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase : public UFortAthenaAISpawnerDataComponent_CosmeticBase
{
public:
	void GetAllLoadouts(TArray<struct FFortAthenaLoadout>* OutLoadouts);
	void GetCustomCharacterParts(TArray<class UCustomCharacterPart*>* OutCustomCharacterParts);
	void GetDances(TArray<class UAthenaDanceItemDefinition*>* Dances, const class AFortAthenaAIBotController* BotController);
	void GetLoadout(struct FFortAthenaLoadout* OutLoadout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotCosmeticBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_CosmeticLoadout
// 0x0190 (0x01C0 - 0x0030)
class UFortAthenaAISpawnerDataComponent_CosmeticLoadout final : public UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase
{
public:
	TStructCycleFixup<struct FFortAthenaLoadout, 0x0168, 0x08> CosmeticLoadout;                                   // 0x0030(0x0168)(Deprecated, NativeAccessSpecifierPrivate)
	TArray<struct FFortAthenaAIWeightedCosmeticLoadout> WeightedLoadouts;                                  // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UCustomCharacterPart*>           CustomCharacterParts;                              // 0x01A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bCanShowDefaultSkin;                               // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           FallbackTag;                                       // 0x01BC(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_CosmeticLoadout">();
	}
	static class UFortAthenaAISpawnerDataComponent_CosmeticLoadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_CosmeticLoadout>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_CosmeticLoadout) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_CosmeticLoadout");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_CosmeticLoadout) == 0x0001C0, "Wrong size on UFortAthenaAISpawnerDataComponent_CosmeticLoadout");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLoadout, CosmeticLoadout) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLoadout::CosmeticLoadout' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLoadout, WeightedLoadouts) == 0x000198, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLoadout::WeightedLoadouts' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLoadout, CustomCharacterParts) == 0x0001A8, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLoadout::CustomCharacterParts' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLoadout, bCanShowDefaultSkin) == 0x0001B8, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLoadout::bCanShowDefaultSkin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLoadout, FallbackTag) == 0x0001BC, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLoadout::FallbackTag' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_ValidSpawnRiftActors
// 0x0038 (0x0088 - 0x0050)
class UFortQueryGenerator_ValidSpawnRiftActors final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderIntValue                NumAIForGroup;                                     // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_ValidSpawnRiftActors">();
	}
	static class UFortQueryGenerator_ValidSpawnRiftActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_ValidSpawnRiftActors>();
	}
};
static_assert(alignof(UFortQueryGenerator_ValidSpawnRiftActors) == 0x000008, "Wrong alignment on UFortQueryGenerator_ValidSpawnRiftActors");
static_assert(sizeof(UFortQueryGenerator_ValidSpawnRiftActors) == 0x000088, "Wrong size on UFortQueryGenerator_ValidSpawnRiftActors");
static_assert(offsetof(UFortQueryGenerator_ValidSpawnRiftActors, NumAIForGroup) == 0x000050, "Member 'UFortQueryGenerator_ValidSpawnRiftActors::NumAIForGroup' has a wrong offset!");

// Class FortniteAI.AthenaAIServiceManager
// 0x0048 (0x0080 - 0x0038)
class UAthenaAIServiceManager final : public UAISubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAthenaAIService*>               AIServices;                                        // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIServiceManager">();
	}
	static class UAthenaAIServiceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIServiceManager>();
	}
};
static_assert(alignof(UAthenaAIServiceManager) == 0x000008, "Wrong alignment on UAthenaAIServiceManager");
static_assert(sizeof(UAthenaAIServiceManager) == 0x000080, "Wrong size on UAthenaAIServiceManager");
static_assert(offsetof(UAthenaAIServiceManager, AIServices) == 0x000050, "Member 'UAthenaAIServiceManager::AIServices' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_PerceptionBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_PerceptionBase : public UFortAthenaAISpawnerDataComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_PerceptionBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_PerceptionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_PerceptionBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_PerceptionBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_PerceptionBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_PerceptionBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_PerceptionBase");

// Class FortniteAI.CacheSafeZoneLocation
// 0x0018 (0x0040 - 0x0028)
class UCacheSafeZoneLocation final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CacheSafeZoneLocation">();
	}
	static class UCacheSafeZoneLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCacheSafeZoneLocation>();
	}
};
static_assert(alignof(UCacheSafeZoneLocation) == 0x000008, "Wrong alignment on UCacheSafeZoneLocation");
static_assert(sizeof(UCacheSafeZoneLocation) == 0x000040, "Wrong size on UCacheSafeZoneLocation");

// Class FortniteAI.AthenaAISettingsAIDIrectorLOD
// 0x00E8 (0x0118 - 0x0030)
class UAthenaAISettingsAIDIrectorLOD final : public UDataAsset
{
public:
	TArray<struct FPlayerLODViewConeConfig>       PlayerLODViewConeConfigs;                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FPlayerLODViewConeHysteresisConfig     PlayerLODViewConeHysteresisConfig;                 // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         CouldBeVisibleViewConeAngleDegrees;                // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         CouldBeVisibleMaxDistance;                         // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         LODSortHysteresisDistance;                         // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFortAIDirectorPerLODConfig>    FortAIDirectorLODConfigs;                          // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAISettingsAIDIrectorLOD">();
	}
	static class UAthenaAISettingsAIDIrectorLOD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAISettingsAIDIrectorLOD>();
	}
};
static_assert(alignof(UAthenaAISettingsAIDIrectorLOD) == 0x000008, "Wrong alignment on UAthenaAISettingsAIDIrectorLOD");
static_assert(sizeof(UAthenaAISettingsAIDIrectorLOD) == 0x000118, "Wrong size on UAthenaAISettingsAIDIrectorLOD");
static_assert(offsetof(UAthenaAISettingsAIDIrectorLOD, PlayerLODViewConeConfigs) == 0x000030, "Member 'UAthenaAISettingsAIDIrectorLOD::PlayerLODViewConeConfigs' has a wrong offset!");
static_assert(offsetof(UAthenaAISettingsAIDIrectorLOD, PlayerLODViewConeHysteresisConfig) == 0x000040, "Member 'UAthenaAISettingsAIDIrectorLOD::PlayerLODViewConeHysteresisConfig' has a wrong offset!");
static_assert(offsetof(UAthenaAISettingsAIDIrectorLOD, CouldBeVisibleViewConeAngleDegrees) == 0x000090, "Member 'UAthenaAISettingsAIDIrectorLOD::CouldBeVisibleViewConeAngleDegrees' has a wrong offset!");
static_assert(offsetof(UAthenaAISettingsAIDIrectorLOD, CouldBeVisibleMaxDistance) == 0x0000B8, "Member 'UAthenaAISettingsAIDIrectorLOD::CouldBeVisibleMaxDistance' has a wrong offset!");
static_assert(offsetof(UAthenaAISettingsAIDIrectorLOD, LODSortHysteresisDistance) == 0x0000E0, "Member 'UAthenaAISettingsAIDIrectorLOD::LODSortHysteresisDistance' has a wrong offset!");
static_assert(offsetof(UAthenaAISettingsAIDIrectorLOD, FortAIDirectorLODConfigs) == 0x000108, "Member 'UAthenaAISettingsAIDIrectorLOD::FortAIDirectorLODConfigs' has a wrong offset!");

// Class FortniteAI.AthenaAISettings
// 0x0070 (0x00A0 - 0x0030)
class UAthenaAISettings final : public UDataAsset
{
public:
	uint8                                         bAllowAIDirector : 1;                              // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bAllowAIGoalManager : 1;                           // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bForceRVOUse : 1;                                  // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPlayerSpeedScaleFootstepSounds;                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinFootstepHearingRange;                           // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFootstepHearingRange;                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DamagedHearingRange;                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CrouchHearingModifier;                             // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxNPCHearingRange;                                // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxPerceptualStimuliAge;                           // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeAggroRange;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ReducedDeAggroRange;                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DurationReduceAggroLimits;                         // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AAthenaNavSystemConfigOverride> NavigationSystemConfig;                            // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAthenaAISettingsAIDIrectorLOD> AIDIrectorLOD;                                     // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UAthenaAIService>>   AIServices;                                        // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAISettings">();
	}
	static class UAthenaAISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAISettings>();
	}
};
static_assert(alignof(UAthenaAISettings) == 0x000008, "Wrong alignment on UAthenaAISettings");
static_assert(sizeof(UAthenaAISettings) == 0x0000A0, "Wrong size on UAthenaAISettings");
static_assert(offsetof(UAthenaAISettings, MaxPlayerSpeedScaleFootstepSounds) == 0x000034, "Member 'UAthenaAISettings::MaxPlayerSpeedScaleFootstepSounds' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, MinFootstepHearingRange) == 0x000038, "Member 'UAthenaAISettings::MinFootstepHearingRange' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, MaxFootstepHearingRange) == 0x00003C, "Member 'UAthenaAISettings::MaxFootstepHearingRange' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, DamagedHearingRange) == 0x000040, "Member 'UAthenaAISettings::DamagedHearingRange' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, CrouchHearingModifier) == 0x000044, "Member 'UAthenaAISettings::CrouchHearingModifier' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, MaxNPCHearingRange) == 0x000048, "Member 'UAthenaAISettings::MaxNPCHearingRange' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, MaxPerceptualStimuliAge) == 0x00004C, "Member 'UAthenaAISettings::MaxPerceptualStimuliAge' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, DeAggroRange) == 0x000050, "Member 'UAthenaAISettings::DeAggroRange' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, ReducedDeAggroRange) == 0x000054, "Member 'UAthenaAISettings::ReducedDeAggroRange' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, DurationReduceAggroLimits) == 0x000058, "Member 'UAthenaAISettings::DurationReduceAggroLimits' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, NavigationSystemConfig) == 0x000060, "Member 'UAthenaAISettings::NavigationSystemConfig' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, AIDIrectorLOD) == 0x000068, "Member 'UAthenaAISettings::AIDIrectorLOD' has a wrong offset!");
static_assert(offsetof(UAthenaAISettings, AIServices) == 0x000090, "Member 'UAthenaAISettings::AIServices' has a wrong offset!");

// Class FortniteAI.FortBTDecorator_GameplayAbility_CanHitTarget
// 0x0008 (0x00E0 - 0x00D8)
class UFortBTDecorator_GameplayAbility_CanHitTarget final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	uint8                                         UseIdealYawRotationToTarget : 1;                   // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_CanHitTarget">();
	}
	static class UFortBTDecorator_GameplayAbility_CanHitTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_CanHitTarget>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_CanHitTarget) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_CanHitTarget");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_CanHitTarget) == 0x0000E0, "Wrong size on UFortBTDecorator_GameplayAbility_CanHitTarget");

// Class FortniteAI.AthenaAISpawner
// 0x00D0 (0x0108 - 0x0038)
class UAthenaAISpawner final : public UAISubsystem
{
public:
	TMulticastInlineDelegate<void(class APawn* Pawn, int32 RequestId)> OnPawnPreFinishSpawningEvent;                      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class APawn* Pawn, int32 RequestId)> OnPawnSpawnedEvent;                                // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0xB0];                                      // 0x0058(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CancelRequest(const int32 RequestId);
	void QueueForDespawn(class AActor* ActorToDespawn);
	int32 RequestSpawn(class UFortAthenaAISpawnerDataComponentList* AISpawnerComponentList, const struct FTransform& SpawnTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAISpawner">();
	}
	static class UAthenaAISpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAISpawner>();
	}
};
static_assert(alignof(UAthenaAISpawner) == 0x000008, "Wrong alignment on UAthenaAISpawner");
static_assert(sizeof(UAthenaAISpawner) == 0x000108, "Wrong size on UAthenaAISpawner");
static_assert(offsetof(UAthenaAISpawner, OnPawnPreFinishSpawningEvent) == 0x000038, "Member 'UAthenaAISpawner::OnPawnPreFinishSpawningEvent' has a wrong offset!");
static_assert(offsetof(UAthenaAISpawner, OnPawnSpawnedEvent) == 0x000048, "Member 'UAthenaAISpawner::OnPawnSpawnedEvent' has a wrong offset!");

// Class FortniteAI.FortAISystem
// 0x00A0 (0x01E8 - 0x0148)
class UFortAISystem : public UAISystem
{
public:
	TArray<class UFortQueryTwoPointSolver*>       TwoPointSolvers;                                   // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UFortInfluenceMap*                      InfluenceMap;                                      // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortBotMissionManager*                 BotManager;                                        // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortRiftBlockerComponent*>      ActiveRiftBlockers;                                // 0x0178(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x50];                                     // 0x0188(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UAthenaAISpawner*                       AISpawner;                                         // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAthenaAIServiceManager*                AIServiceManager;                                  // 0x01E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool IsInCone2D(const struct FVector& ConeOrigin, const struct FVector& ConeDirection, float HalfAngle, const struct FVector& LocationToCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISystem">();
	}
	static class UFortAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISystem>();
	}
};
static_assert(alignof(UFortAISystem) == 0x000008, "Wrong alignment on UFortAISystem");
static_assert(sizeof(UFortAISystem) == 0x0001E8, "Wrong size on UFortAISystem");
static_assert(offsetof(UFortAISystem, TwoPointSolvers) == 0x000148, "Member 'UFortAISystem::TwoPointSolvers' has a wrong offset!");
static_assert(offsetof(UFortAISystem, InfluenceMap) == 0x000158, "Member 'UFortAISystem::InfluenceMap' has a wrong offset!");
static_assert(offsetof(UFortAISystem, BotManager) == 0x000160, "Member 'UFortAISystem::BotManager' has a wrong offset!");
static_assert(offsetof(UFortAISystem, ActiveRiftBlockers) == 0x000178, "Member 'UFortAISystem::ActiveRiftBlockers' has a wrong offset!");
static_assert(offsetof(UFortAISystem, AISpawner) == 0x0001D8, "Member 'UFortAISystem::AISpawner' has a wrong offset!");
static_assert(offsetof(UFortAISystem, AIServiceManager) == 0x0001E0, "Member 'UFortAISystem::AIServiceManager' has a wrong offset!");

// Class FortniteAI.FortBTService_UpdateBotMissionBuilding
// 0x0050 (0x00C0 - 0x0070)
class UFortBTService_UpdateBotMissionBuilding final : public UBTService
{
public:
	struct FBlackboardKeySelector                 InterestLocationKey;                               // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BuildOrderKey;                                     // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTService_UpdateBotMissionBuilding">();
	}
	static class UFortBTService_UpdateBotMissionBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTService_UpdateBotMissionBuilding>();
	}
};
static_assert(alignof(UFortBTService_UpdateBotMissionBuilding) == 0x000008, "Wrong alignment on UFortBTService_UpdateBotMissionBuilding");
static_assert(sizeof(UFortBTService_UpdateBotMissionBuilding) == 0x0000C0, "Wrong size on UFortBTService_UpdateBotMissionBuilding");
static_assert(offsetof(UFortBTService_UpdateBotMissionBuilding, InterestLocationKey) == 0x000070, "Member 'UFortBTService_UpdateBotMissionBuilding::InterestLocationKey' has a wrong offset!");
static_assert(offsetof(UFortBTService_UpdateBotMissionBuilding, BuildOrderKey) == 0x000098, "Member 'UFortBTService_UpdateBotMissionBuilding::BuildOrderKey' has a wrong offset!");

// Class FortniteAI.FortQueryContext_WorldLocationParam
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_WorldLocationParam final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_WorldLocationParam">();
	}
	static class UFortQueryContext_WorldLocationParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_WorldLocationParam>();
	}
};
static_assert(alignof(UFortQueryContext_WorldLocationParam) == 0x000008, "Wrong alignment on UFortQueryContext_WorldLocationParam");
static_assert(sizeof(UFortQueryContext_WorldLocationParam) == 0x000028, "Wrong size on UFortQueryContext_WorldLocationParam");

// Class FortniteAI.AthenaAISystem
// 0x0058 (0x0240 - 0x01E8)
class UAthenaAISystem final : public UFortAISystem
{
public:
	class UAthenaAIPerceptionManager*             PerceptionManager;                                 // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAthenaAIDropper*                       AIDropper;                                         // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAthenaAIPopulationTracker*             AIPopulationTracker;                               // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAthenaAIVehicleAvoidanceManager*       AIVehicleAvoidanceManager;                         // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AAthenaAIController*>            AIControllers;                                     // 0x0208(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UAthenaPathFollowingComponent*>  PathFollowingComponents;                           // 0x0218(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         RegisteredAISpawners;                              // 0x0228(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUnlimitedAIHealth : 1;                            // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNavigationReady : 1;                              // 0x0238(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AIProfiling_OnGamePhaseChanged(EAthenaGamePhase GamePhase);
	void AIProfiling_OnSafeZoneUpdated();
	void HandleGamePhaseStepChanged(const TScriptInterface<class IFortSafeZoneInterface>& SafeZoneInterface, const EAthenaGamePhaseStep GamePhaseStep);
	void OnAIPawnDied(class AController* KilledController, bool bIsABot, class AFortPawn* KilledAIPawn, class AFortPlayerPawn* KilledPlayerPawn, class AController* KillerController);
	void OnAIPawnSpawned(class AController* SpawnedController, bool bIsABot, class AFortPawn* FortAIPawn, class AFortPlayerPawn* PlayerPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAISystem">();
	}
	static class UAthenaAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAISystem>();
	}
};
static_assert(alignof(UAthenaAISystem) == 0x000008, "Wrong alignment on UAthenaAISystem");
static_assert(sizeof(UAthenaAISystem) == 0x000240, "Wrong size on UAthenaAISystem");
static_assert(offsetof(UAthenaAISystem, PerceptionManager) == 0x0001E8, "Member 'UAthenaAISystem::PerceptionManager' has a wrong offset!");
static_assert(offsetof(UAthenaAISystem, AIDropper) == 0x0001F0, "Member 'UAthenaAISystem::AIDropper' has a wrong offset!");
static_assert(offsetof(UAthenaAISystem, AIPopulationTracker) == 0x0001F8, "Member 'UAthenaAISystem::AIPopulationTracker' has a wrong offset!");
static_assert(offsetof(UAthenaAISystem, AIVehicleAvoidanceManager) == 0x000200, "Member 'UAthenaAISystem::AIVehicleAvoidanceManager' has a wrong offset!");
static_assert(offsetof(UAthenaAISystem, AIControllers) == 0x000208, "Member 'UAthenaAISystem::AIControllers' has a wrong offset!");
static_assert(offsetof(UAthenaAISystem, PathFollowingComponents) == 0x000218, "Member 'UAthenaAISystem::PathFollowingComponents' has a wrong offset!");
static_assert(offsetof(UAthenaAISystem, RegisteredAISpawners) == 0x000228, "Member 'UAthenaAISystem::RegisteredAISpawners' has a wrong offset!");

// Class FortniteAI.AthenaAIVehicleAvoidanceManager
// 0x0050 (0x0088 - 0x0038)
class UAthenaAIVehicleAvoidanceManager final : public UAISubsystem
{
public:
	uint8                                         Pad_38[0x4C];                                      // 0x0038(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToRefreshTree;                                 // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAIVehicleAvoidanceManager">();
	}
	static class UAthenaAIVehicleAvoidanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAIVehicleAvoidanceManager>();
	}
};
static_assert(alignof(UAthenaAIVehicleAvoidanceManager) == 0x000008, "Wrong alignment on UAthenaAIVehicleAvoidanceManager");
static_assert(sizeof(UAthenaAIVehicleAvoidanceManager) == 0x000088, "Wrong size on UAthenaAIVehicleAvoidanceManager");
static_assert(offsetof(UAthenaAIVehicleAvoidanceManager, TimeToRefreshTree) == 0x000084, "Member 'UAthenaAIVehicleAvoidanceManager::TimeToRefreshTree' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotPerception
// 0x0010 (0x0040 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIBotPerception final : public UFortAthenaAISpawnerDataComponent_PerceptionBase
{
public:
	bool                                          bOverrideVisibilityRange;                          // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightRadius;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoseSightRadius;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetVisibilityRange(const float InSightRadius, const float LoseSightRadius_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotPerception">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotPerception* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotPerception>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotPerception) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotPerception");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotPerception) == 0x000040, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotPerception");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotPerception, bOverrideVisibilityRange) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_AIBotPerception::bOverrideVisibilityRange' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotPerception, SightRadius) == 0x000034, "Member 'UFortAthenaAISpawnerDataComponent_AIBotPerception::SightRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotPerception, LoseSightRadius) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_AIBotPerception::LoseSightRadius' has a wrong offset!");

// Class FortniteAI.FortNavArea_StoneWall
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_StoneWall final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_StoneWall">();
	}
	static class UFortNavArea_StoneWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_StoneWall>();
	}
};
static_assert(alignof(UFortNavArea_StoneWall) == 0x000008, "Wrong alignment on UFortNavArea_StoneWall");
static_assert(sizeof(UFortNavArea_StoneWall) == 0x000050, "Wrong size on UFortNavArea_StoneWall");

// Class FortniteAI.FortQueryContext_TwoPointSolverPointA
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_TwoPointSolverPointA final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_TwoPointSolverPointA">();
	}
	static class UFortQueryContext_TwoPointSolverPointA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_TwoPointSolverPointA>();
	}
};
static_assert(alignof(UFortQueryContext_TwoPointSolverPointA) == 0x000008, "Wrong alignment on UFortQueryContext_TwoPointSolverPointA");
static_assert(sizeof(UFortQueryContext_TwoPointSolverPointA) == 0x000028, "Wrong size on UFortQueryContext_TwoPointSolverPointA");

// Class FortniteAI.AthenaAvoidanceManager
// 0x0000 (0x00E0 - 0x00E0)
class UAthenaAvoidanceManager final : public UAvoidanceManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaAvoidanceManager">();
	}
	static class UAthenaAvoidanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaAvoidanceManager>();
	}
};
static_assert(alignof(UAthenaAvoidanceManager) == 0x000008, "Wrong alignment on UAthenaAvoidanceManager");
static_assert(sizeof(UAthenaAvoidanceManager) == 0x0000E0, "Wrong size on UAthenaAvoidanceManager");

// Class FortniteAI.FortQueryTest_IsCloseToPatrolWard
// 0x0008 (0x0200 - 0x01F8)
class UFortQueryTest_IsCloseToPatrolWard final : public UEnvQueryTest
{
public:
	EWardAffectType                               WardEffectTypeFilter;                              // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_IsCloseToPatrolWard">();
	}
	static class UFortQueryTest_IsCloseToPatrolWard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_IsCloseToPatrolWard>();
	}
};
static_assert(alignof(UFortQueryTest_IsCloseToPatrolWard) == 0x000008, "Wrong alignment on UFortQueryTest_IsCloseToPatrolWard");
static_assert(sizeof(UFortQueryTest_IsCloseToPatrolWard) == 0x000200, "Wrong size on UFortQueryTest_IsCloseToPatrolWard");
static_assert(offsetof(UFortQueryTest_IsCloseToPatrolWard, WardEffectTypeFilter) == 0x0001F8, "Member 'UFortQueryTest_IsCloseToPatrolWard::WardEffectTypeFilter' has a wrong offset!");

// Class FortniteAI.AthenaCreativeRift
// 0x00F0 (0x0C10 - 0x0B20)
class AAthenaCreativeRift final : public TObjectBasedCycleFixup<class ABuildingRift, 0x0AF0, 0x10>
{
public:
	class USphereComponent*                       DespawnSphereComponent;                            // 0x0B18(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingProp_AISpawner*                ParentTrap;                                        // 0x0B20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TStructCycleFixup<struct FFortEncounterSettings, 0x00B8, 0x08> OverrideEncounterSettings;                         // 0x0B28(0x00B8)(NativeAccessSpecifierPrivate)
	bool                                          bHasLoadedSettings;                                // 0x0BE0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BE1[0x7];                                      // 0x0BE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPlayerPawn*>                DespawnPlayerOverlaps;                             // 0x0BE8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BF8[0x8];                                      // 0x0BF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIManagerMinigameComponent*        CachedAIMinigamecomponent;                         // 0x0C00(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C08[0x8];                                      // 0x0C08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintShowRift();
	void NotifyActorDespawnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaCreativeRift">();
	}
	static class AAthenaCreativeRift* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAthenaCreativeRift>();
	}
};
static_assert(alignof(AAthenaCreativeRift) == 0x000010, "Wrong alignment on AAthenaCreativeRift");
static_assert(sizeof(AAthenaCreativeRift) == 0x000C10, "Wrong size on AAthenaCreativeRift");
static_assert(offsetof(AAthenaCreativeRift, DespawnSphereComponent) == 0x000B18, "Member 'AAthenaCreativeRift::DespawnSphereComponent' has a wrong offset!");
static_assert(offsetof(AAthenaCreativeRift, ParentTrap) == 0x000B20, "Member 'AAthenaCreativeRift::ParentTrap' has a wrong offset!");
static_assert(offsetof(AAthenaCreativeRift, OverrideEncounterSettings) == 0x000B28, "Member 'AAthenaCreativeRift::OverrideEncounterSettings' has a wrong offset!");
static_assert(offsetof(AAthenaCreativeRift, bHasLoadedSettings) == 0x000BE0, "Member 'AAthenaCreativeRift::bHasLoadedSettings' has a wrong offset!");
static_assert(offsetof(AAthenaCreativeRift, DespawnPlayerOverlaps) == 0x000BE8, "Member 'AAthenaCreativeRift::DespawnPlayerOverlaps' has a wrong offset!");
static_assert(offsetof(AAthenaCreativeRift, CachedAIMinigamecomponent) == 0x000C00, "Member 'AAthenaCreativeRift::CachedAIMinigamecomponent' has a wrong offset!");

// Class FortniteAI.AthenaNavInvokerBox
// 0x0010 (0x0280 - 0x0270)
class AAthenaNavInvokerBox final : public AActor
{
public:
	float                                         GenerationRange;                                   // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavigationInvokerComponent*            InvokerComp;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetInvokerEnabled(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaNavInvokerBox">();
	}
	static class AAthenaNavInvokerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAthenaNavInvokerBox>();
	}
};
static_assert(alignof(AAthenaNavInvokerBox) == 0x000008, "Wrong alignment on AAthenaNavInvokerBox");
static_assert(sizeof(AAthenaNavInvokerBox) == 0x000280, "Wrong size on AAthenaNavInvokerBox");
static_assert(offsetof(AAthenaNavInvokerBox, GenerationRange) == 0x000270, "Member 'AAthenaNavInvokerBox::GenerationRange' has a wrong offset!");
static_assert(offsetof(AAthenaNavInvokerBox, InvokerComp) == 0x000278, "Member 'AAthenaNavInvokerBox::InvokerComp' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_SmartObject
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTService_SmartObject final : public UBTService
{
public:
	class FName                                   SmartObjectStatusKeyName;                          // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SmartObjectDestinationKeyName;                     // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_SmartObject">();
	}
	static class UFortAthenaBTService_SmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_SmartObject>();
	}
};
static_assert(alignof(UFortAthenaBTService_SmartObject) == 0x000008, "Wrong alignment on UFortAthenaBTService_SmartObject");
static_assert(sizeof(UFortAthenaBTService_SmartObject) == 0x000080, "Wrong size on UFortAthenaBTService_SmartObject");
static_assert(offsetof(UFortAthenaBTService_SmartObject, SmartObjectStatusKeyName) == 0x000070, "Member 'UFortAthenaBTService_SmartObject::SmartObjectStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_SmartObject, SmartObjectDestinationKeyName) == 0x000074, "Member 'UFortAthenaBTService_SmartObject::SmartObjectDestinationKeyName' has a wrong offset!");

// Class FortniteAI.AthenaNavMesh
// 0x00D8 (0x0630 - 0x0558)
class AAthenaNavMesh : public AFortNavMesh
{
public:
	int32                                         HotSpotPathfindingMaxSearchNodes;                  // 0x0558(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShallowWaterTraceStartOffsetZ;                     // 0x055C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShallowWaterTraceEndOffsetZ;                       // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaximumTilesToProcessForWaterPerFrame;             // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSuspendNavmeshWhenNoAIUsersAlive;                 // 0x0568(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x7];                                      // 0x0569(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBox>                           SerializedDirtyAreas;                              // 0x0570(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_580[0xB0];                                     // 0x0580(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ComputeOffsetForMoveTiles(const struct FVector& StartPosition, const struct FVector& DesiredPosition, struct FVector* OutEndPosition, struct FIntPoint* OutTileOffset);
	void MoveTiles(const struct FBox& SourceBox, const struct FIntPoint& TileOffset, const float RotationDeg, const struct FVector2D& FillerTilePosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaNavMesh">();
	}
	static class AAthenaNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAthenaNavMesh>();
	}
};
static_assert(alignof(AAthenaNavMesh) == 0x000008, "Wrong alignment on AAthenaNavMesh");
static_assert(sizeof(AAthenaNavMesh) == 0x000630, "Wrong size on AAthenaNavMesh");
static_assert(offsetof(AAthenaNavMesh, HotSpotPathfindingMaxSearchNodes) == 0x000558, "Member 'AAthenaNavMesh::HotSpotPathfindingMaxSearchNodes' has a wrong offset!");
static_assert(offsetof(AAthenaNavMesh, ShallowWaterTraceStartOffsetZ) == 0x00055C, "Member 'AAthenaNavMesh::ShallowWaterTraceStartOffsetZ' has a wrong offset!");
static_assert(offsetof(AAthenaNavMesh, ShallowWaterTraceEndOffsetZ) == 0x000560, "Member 'AAthenaNavMesh::ShallowWaterTraceEndOffsetZ' has a wrong offset!");
static_assert(offsetof(AAthenaNavMesh, MaximumTilesToProcessForWaterPerFrame) == 0x000564, "Member 'AAthenaNavMesh::MaximumTilesToProcessForWaterPerFrame' has a wrong offset!");
static_assert(offsetof(AAthenaNavMesh, bSuspendNavmeshWhenNoAIUsersAlive) == 0x000568, "Member 'AAthenaNavMesh::bSuspendNavmeshWhenNoAIUsersAlive' has a wrong offset!");
static_assert(offsetof(AAthenaNavMesh, SerializedDirtyAreas) == 0x000570, "Member 'AAthenaNavMesh::SerializedDirtyAreas' has a wrong offset!");

// Class FortniteAI.AthenaNavMeshRenderingComponent
// 0x0000 (0x0540 - 0x0540)
class UAthenaNavMeshRenderingComponent final : public UNavMeshRenderingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaNavMeshRenderingComponent">();
	}
	static class UAthenaNavMeshRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaNavMeshRenderingComponent>();
	}
};
static_assert(alignof(UAthenaNavMeshRenderingComponent) == 0x000010, "Wrong alignment on UAthenaNavMeshRenderingComponent");
static_assert(sizeof(UAthenaNavMeshRenderingComponent) == 0x000540, "Wrong size on UAthenaNavMeshRenderingComponent");

// Class FortniteAI.AthenaNavMesh_Big
// 0x0008 (0x0638 - 0x0630)
class AAthenaNavMesh_Big final : public AAthenaNavMesh
{
public:
	float                                         MaximumDistanceToWaterForShallow;                  // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaNavMesh_Big">();
	}
	static class AAthenaNavMesh_Big* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAthenaNavMesh_Big>();
	}
};
static_assert(alignof(AAthenaNavMesh_Big) == 0x000008, "Wrong alignment on AAthenaNavMesh_Big");
static_assert(sizeof(AAthenaNavMesh_Big) == 0x000638, "Wrong size on AAthenaNavMesh_Big");
static_assert(offsetof(AAthenaNavMesh_Big, MaximumDistanceToWaterForShallow) == 0x000630, "Member 'AAthenaNavMesh_Big::MaximumDistanceToWaterForShallow' has a wrong offset!");

// Class FortniteAI.AthenaNavOctTreeInclusionBounds
// 0x0000 (0x02A8 - 0x02A8)
class AAthenaNavOctTreeInclusionBounds final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaNavOctTreeInclusionBounds">();
	}
	static class AAthenaNavOctTreeInclusionBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAthenaNavOctTreeInclusionBounds>();
	}
};
static_assert(alignof(AAthenaNavOctTreeInclusionBounds) == 0x000008, "Wrong alignment on AAthenaNavOctTreeInclusionBounds");
static_assert(sizeof(AAthenaNavOctTreeInclusionBounds) == 0x0002A8, "Wrong size on AAthenaNavOctTreeInclusionBounds");

// Class FortniteAI.FortNavArea_TakerOnly
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_TakerOnly final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_TakerOnly">();
	}
	static class UFortNavArea_TakerOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_TakerOnly>();
	}
};
static_assert(alignof(UFortNavArea_TakerOnly) == 0x000008, "Wrong alignment on UFortNavArea_TakerOnly");
static_assert(sizeof(UFortNavArea_TakerOnly) == 0x000050, "Wrong size on UFortNavArea_TakerOnly");

// Class FortniteAI.AthenaNavRelevantActorInterface
// 0x0000 (0x0028 - 0x0028)
class IAthenaNavRelevantActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaNavRelevantActorInterface">();
	}
	static class IAthenaNavRelevantActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAthenaNavRelevantActorInterface>();
	}
};
static_assert(alignof(IAthenaNavRelevantActorInterface) == 0x000008, "Wrong alignment on IAthenaNavRelevantActorInterface");
static_assert(sizeof(IAthenaNavRelevantActorInterface) == 0x000028, "Wrong size on IAthenaNavRelevantActorInterface");

// Class FortniteAI.FortBTService_ContextOverride
// 0x0000 (0x0070 - 0x0070)
class UFortBTService_ContextOverride : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTService_ContextOverride">();
	}
	static class UFortBTService_ContextOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTService_ContextOverride>();
	}
};
static_assert(alignof(UFortBTService_ContextOverride) == 0x000008, "Wrong alignment on UFortBTService_ContextOverride");
static_assert(sizeof(UFortBTService_ContextOverride) == 0x000070, "Wrong size on UFortBTService_ContextOverride");

// Class FortniteAI.FortBTContext_SuppressGoalUpdate
// 0x0008 (0x0078 - 0x0070)
class UFortBTContext_SuppressGoalUpdate final : public UFortBTService_ContextOverride
{
public:
	bool                                          bUnregisterFromGoalManager;                        // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTContext_SuppressGoalUpdate">();
	}
	static class UFortBTContext_SuppressGoalUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTContext_SuppressGoalUpdate>();
	}
};
static_assert(alignof(UFortBTContext_SuppressGoalUpdate) == 0x000008, "Wrong alignment on UFortBTContext_SuppressGoalUpdate");
static_assert(sizeof(UFortBTContext_SuppressGoalUpdate) == 0x000078, "Wrong size on UFortBTContext_SuppressGoalUpdate");
static_assert(offsetof(UFortBTContext_SuppressGoalUpdate, bUnregisterFromGoalManager) == 0x000070, "Member 'UFortBTContext_SuppressGoalUpdate::bUnregisterFromGoalManager' has a wrong offset!");

// Class FortniteAI.FortNavSystemConfig
// 0x0008 (0x0060 - 0x0058)
class UFortNavSystemConfig : public UNavigationSystemModuleConfig
{
public:
	uint8                                         bAllowAutoRebuild : 1;                             // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRebuildOnInitialUnlock : 1;                       // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUsesStreamedInNavLevel : 1;                       // 0x0058(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavSystemConfig">();
	}
	static class UFortNavSystemConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavSystemConfig>();
	}
};
static_assert(alignof(UFortNavSystemConfig) == 0x000008, "Wrong alignment on UFortNavSystemConfig");
static_assert(sizeof(UFortNavSystemConfig) == 0x000060, "Wrong size on UFortNavSystemConfig");

// Class FortniteAI.AthenaNavSystemConfig
// 0x0030 (0x0090 - 0x0060)
class UAthenaNavSystemConfig final : public UFortNavSystemConfig
{
public:
	TArray<struct FNavDataSetVariantSettings>     NavDataSetVariants;                                // 0x0060(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUseNavDataSetVariants : 1;                        // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDiscardNavDataFromSublevels : 1;                  // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseNavigationInvokers : 1;                        // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLazyOctree : 1;                                   // 0x0070(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseNavOctTreeInclusionBounds : 1;                 // 0x0070(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPrioritizeNavigationAroundSpawners : 1;           // 0x0070(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bResetDirtyAreasOnInitialBuildingRelease : 1;      // 0x0070(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSupportRuntimeNavmeshDisabling : 1;               // 0x0070(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNavOctreeUnlockedByDefaultWhenNotPreloadingNavData : 1; // 0x0071(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bConfigureDirtyAreaWarningSizeThreshold : 1;       // 0x0071(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirtyAreaWarningSizeThreshold;                     // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOverriddenSupportedAgentsByReleaseVersion> OverriddenSupportedAgentsByReleaseVersion;         // 0x0078(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSuspendNavmeshWhenNoPossibleUsers;                // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaNavSystemConfig">();
	}
	static class UAthenaNavSystemConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaNavSystemConfig>();
	}
};
static_assert(alignof(UAthenaNavSystemConfig) == 0x000008, "Wrong alignment on UAthenaNavSystemConfig");
static_assert(sizeof(UAthenaNavSystemConfig) == 0x000090, "Wrong size on UAthenaNavSystemConfig");
static_assert(offsetof(UAthenaNavSystemConfig, NavDataSetVariants) == 0x000060, "Member 'UAthenaNavSystemConfig::NavDataSetVariants' has a wrong offset!");
static_assert(offsetof(UAthenaNavSystemConfig, DirtyAreaWarningSizeThreshold) == 0x000074, "Member 'UAthenaNavSystemConfig::DirtyAreaWarningSizeThreshold' has a wrong offset!");
static_assert(offsetof(UAthenaNavSystemConfig, OverriddenSupportedAgentsByReleaseVersion) == 0x000078, "Member 'UAthenaNavSystemConfig::OverriddenSupportedAgentsByReleaseVersion' has a wrong offset!");
static_assert(offsetof(UAthenaNavSystemConfig, bSuspendNavmeshWhenNoPossibleUsers) == 0x000088, "Member 'UAthenaNavSystemConfig::bSuspendNavmeshWhenNoPossibleUsers' has a wrong offset!");

// Class FortniteAI.FortBotStructureBuilder
// 0x0038 (0x02A8 - 0x0270)
class AFortBotStructureBuilder final : public AActor
{
public:
	class UFortBuildingInstructions*              BuildingInstructions;                              // 0x0270(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingActor*>                 BuiltActors;                                       // 0x0278(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 CachedGoal;                                        // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildAll();
	void OnBuildingDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void RunDeconstructor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotStructureBuilder">();
	}
	static class AFortBotStructureBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortBotStructureBuilder>();
	}
};
static_assert(alignof(AFortBotStructureBuilder) == 0x000008, "Wrong alignment on AFortBotStructureBuilder");
static_assert(sizeof(AFortBotStructureBuilder) == 0x0002A8, "Wrong size on AFortBotStructureBuilder");
static_assert(offsetof(AFortBotStructureBuilder, BuildingInstructions) == 0x000270, "Member 'AFortBotStructureBuilder::BuildingInstructions' has a wrong offset!");
static_assert(offsetof(AFortBotStructureBuilder, BuiltActors) == 0x000278, "Member 'AFortBotStructureBuilder::BuiltActors' has a wrong offset!");
static_assert(offsetof(AFortBotStructureBuilder, CachedGoal) == 0x000288, "Member 'AFortBotStructureBuilder::CachedGoal' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_ConstructionBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_ConstructionBase : public UFortAthenaAISpawnerDataComponent
{
public:
	bool GetConstructionBuildingInfo(struct FConstructionBuildingList* OutConstructionInfoList) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_ConstructionBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_ConstructionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_ConstructionBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_ConstructionBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_ConstructionBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_ConstructionBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_ConstructionBase");

// Class FortniteAI.AthenaNavSystemConfigOverride
// 0x0000 (0x0280 - 0x0280)
class AAthenaNavSystemConfigOverride final : public ANavSystemConfigOverride
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaNavSystemConfigOverride">();
	}
	static class AAthenaNavSystemConfigOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAthenaNavSystemConfigOverride>();
	}
};
static_assert(alignof(AAthenaNavSystemConfigOverride) == 0x000008, "Wrong alignment on AAthenaNavSystemConfigOverride");
static_assert(sizeof(AAthenaNavSystemConfigOverride) == 0x000280, "Wrong size on AAthenaNavSystemConfigOverride");

// Class FortniteAI.FortQueryTest_IsObstructed
// 0x00A8 (0x0388 - 0x02E0)
class UFortQueryTest_IsObstructed final : public UEnvQueryTest_Trace
{
public:
	struct FAIDataProviderBoolValue               OverrideContextLocationXWithItemLocationX;         // 0x02E0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               OverrideContextLocationYWithItemLocationY;         // 0x0318(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               OverrideContextLocationZWithItemLocationZ;         // 0x0350(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_IsObstructed">();
	}
	static class UFortQueryTest_IsObstructed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_IsObstructed>();
	}
};
static_assert(alignof(UFortQueryTest_IsObstructed) == 0x000008, "Wrong alignment on UFortQueryTest_IsObstructed");
static_assert(sizeof(UFortQueryTest_IsObstructed) == 0x000388, "Wrong size on UFortQueryTest_IsObstructed");
static_assert(offsetof(UFortQueryTest_IsObstructed, OverrideContextLocationXWithItemLocationX) == 0x0002E0, "Member 'UFortQueryTest_IsObstructed::OverrideContextLocationXWithItemLocationX' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_IsObstructed, OverrideContextLocationYWithItemLocationY) == 0x000318, "Member 'UFortQueryTest_IsObstructed::OverrideContextLocationYWithItemLocationY' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_IsObstructed, OverrideContextLocationZWithItemLocationZ) == 0x000350, "Member 'UFortQueryTest_IsObstructed::OverrideContextLocationZWithItemLocationZ' has a wrong offset!");

// Class FortniteAI.FortNavArea_MetaReplacement
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_MetaReplacement final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_MetaReplacement">();
	}
	static class UFortNavArea_MetaReplacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_MetaReplacement>();
	}
};
static_assert(alignof(UFortNavArea_MetaReplacement) == 0x000008, "Wrong alignment on UFortNavArea_MetaReplacement");
static_assert(sizeof(UFortNavArea_MetaReplacement) == 0x000050, "Wrong size on UFortNavArea_MetaReplacement");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_Behavior
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAISpawnerDataComponent_Behavior : public UFortAthenaAISpawnerDataComponent_BehaviorBase
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_Behavior">();
	}
	static class UFortAthenaAISpawnerDataComponent_Behavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_Behavior>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_Behavior) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_Behavior");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_Behavior) == 0x000038, "Wrong size on UFortAthenaAISpawnerDataComponent_Behavior");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_Behavior, BehaviorTree) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_Behavior::BehaviorTree' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotBehavior
// 0x0178 (0x01B0 - 0x0038)
class UFortAthenaAISpawnerDataComponent_AIBotBehavior final : public UFortAthenaAISpawnerDataComponent_Behavior
{
public:
	uint32                                        BehaviorTreeControls;                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bCanUseFallbackPatrolAround : 1;                   // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bAllowReviveSquadmates : 1;                        // 0x003C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bAllowReviveSameFactionNPCs : 1;                   // 0x003C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bUseReviveToken : 1;                               // 0x003C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToRevive;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         DieWhenAllAlliesAreDBNO;                           // 0x0048(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         AliveAlliesMaxRange;                               // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         SupportsHolsteredWeapon;                           // 0x0098(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         SurfaceTypeCheckEnabled;                           // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         bShouldResetAggressivePlayStyleOnUnaware;          // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeToKeepTrackOfDamagingActorsForAggressivePlayStyle; // 0x0110(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TimeToIgnoreDamagingActorsWhenBeingControlled;     // 0x0138(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         PauseBehaviorOnSpawnDuration;                      // 0x0160(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         bShouldBeInvulnerableDuringPause;                  // 0x0188(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	void DisableBehaviorTreeBranch(const EBehaviorTreeBranches Behavior);
	void EnableBehaviorTreeBranch(const EBehaviorTreeBranches Behavior);

	bool IsBehaviorTreeBranchActive(const EBehaviorTreeBranches Behavior) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotBehavior">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotBehavior>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotBehavior) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotBehavior");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotBehavior) == 0x0001B0, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotBehavior");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, BehaviorTreeControls) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::BehaviorTreeControls' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, MaxDistanceToRevive) == 0x000040, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::MaxDistanceToRevive' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, DieWhenAllAlliesAreDBNO) == 0x000048, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::DieWhenAllAlliesAreDBNO' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, AliveAlliesMaxRange) == 0x000070, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::AliveAlliesMaxRange' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, SupportsHolsteredWeapon) == 0x000098, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::SupportsHolsteredWeapon' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, SurfaceTypeCheckEnabled) == 0x0000C0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::SurfaceTypeCheckEnabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, bShouldResetAggressivePlayStyleOnUnaware) == 0x0000E8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::bShouldResetAggressivePlayStyleOnUnaware' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, TimeToKeepTrackOfDamagingActorsForAggressivePlayStyle) == 0x000110, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::TimeToKeepTrackOfDamagingActorsForAggressivePlayStyle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, TimeToIgnoreDamagingActorsWhenBeingControlled) == 0x000138, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::TimeToIgnoreDamagingActorsWhenBeingControlled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, PauseBehaviorOnSpawnDuration) == 0x000160, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::PauseBehaviorOnSpawnDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotBehavior, bShouldBeInvulnerableDuringPause) == 0x000188, "Member 'UFortAthenaAISpawnerDataComponent_AIBotBehavior::bShouldBeInvulnerableDuringPause' has a wrong offset!");

// Class FortniteAI.FortNavArea_WallCornerReplacement
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_WallCornerReplacement final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_WallCornerReplacement">();
	}
	static class UFortNavArea_WallCornerReplacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_WallCornerReplacement>();
	}
};
static_assert(alignof(UFortNavArea_WallCornerReplacement) == 0x000008, "Wrong alignment on UFortNavArea_WallCornerReplacement");
static_assert(sizeof(UFortNavArea_WallCornerReplacement) == 0x000050, "Wrong size on UFortNavArea_WallCornerReplacement");

// Class FortniteAI.FortNavArea_ObstacleReplacement
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_ObstacleReplacement final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_ObstacleReplacement">();
	}
	static class UFortNavArea_ObstacleReplacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_ObstacleReplacement>();
	}
};
static_assert(alignof(UFortNavArea_ObstacleReplacement) == 0x000008, "Wrong alignment on UFortNavArea_ObstacleReplacement");
static_assert(sizeof(UFortNavArea_ObstacleReplacement) == 0x000050, "Wrong size on UFortNavArea_ObstacleReplacement");

// Class FortniteAI.FortNavAreaAutomatic
// 0x0018 (0x0068 - 0x0050)
class UFortNavAreaAutomatic : public UFortNavArea
{
public:
	struct FCurveTableRowHandle                   NavCostCurveHandle;                                // 0x0050(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NavAreaStrength;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutomaticNavCost;                                  // 0x0064(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavAreaAutomatic">();
	}
	static class UFortNavAreaAutomatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavAreaAutomatic>();
	}
};
static_assert(alignof(UFortNavAreaAutomatic) == 0x000008, "Wrong alignment on UFortNavAreaAutomatic");
static_assert(sizeof(UFortNavAreaAutomatic) == 0x000068, "Wrong size on UFortNavAreaAutomatic");
static_assert(offsetof(UFortNavAreaAutomatic, NavCostCurveHandle) == 0x000050, "Member 'UFortNavAreaAutomatic::NavCostCurveHandle' has a wrong offset!");
static_assert(offsetof(UFortNavAreaAutomatic, NavAreaStrength) == 0x000060, "Member 'UFortNavAreaAutomatic::NavAreaStrength' has a wrong offset!");
static_assert(offsetof(UFortNavAreaAutomatic, AutomaticNavCost) == 0x000064, "Member 'UFortNavAreaAutomatic::AutomaticNavCost' has a wrong offset!");

// Class FortniteAI.FortNavArea_TempWallReplacement
// 0x0000 (0x0068 - 0x0068)
class UFortNavArea_TempWallReplacement final : public UFortNavAreaAutomatic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_TempWallReplacement">();
	}
	static class UFortNavArea_TempWallReplacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_TempWallReplacement>();
	}
};
static_assert(alignof(UFortNavArea_TempWallReplacement) == 0x000008, "Wrong alignment on UFortNavArea_TempWallReplacement");
static_assert(sizeof(UFortNavArea_TempWallReplacement) == 0x000068, "Wrong size on UFortNavArea_TempWallReplacement");

// Class FortniteAI.FortAthenaNpcGalileoComponent
// 0x0060 (0x0100 - 0x00A0)
class UFortAthenaNpcGalileoComponent final : public UActorComponent
{
public:
	class AFortAthenaAIBotController*             CachedBotController;                               // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPawn*                              PossessedPawn;                                     // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        PatrolPath;                                        // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AFortAthenaAIBotController*>     CommunicationGroup;                                // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnPatrollingStart;                                 // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnPatrollingStop;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class AFortAthenaAIBotController*> GetCommunicationGroup();
	void OnPawnDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void SetCommunicationGroup(const TArray<class AFortAthenaAIBotController*>& AIBotControllerList);
	void SetPatrolPath(const TArray<struct FVector>& NewPatrolPath);

	const TArray<struct FVector> GetPatrolPath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNpcGalileoComponent">();
	}
	static class UFortAthenaNpcGalileoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNpcGalileoComponent>();
	}
};
static_assert(alignof(UFortAthenaNpcGalileoComponent) == 0x000008, "Wrong alignment on UFortAthenaNpcGalileoComponent");
static_assert(sizeof(UFortAthenaNpcGalileoComponent) == 0x000100, "Wrong size on UFortAthenaNpcGalileoComponent");
static_assert(offsetof(UFortAthenaNpcGalileoComponent, CachedBotController) == 0x0000A0, "Member 'UFortAthenaNpcGalileoComponent::CachedBotController' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcGalileoComponent, PossessedPawn) == 0x0000A8, "Member 'UFortAthenaNpcGalileoComponent::PossessedPawn' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcGalileoComponent, PatrolPath) == 0x0000B0, "Member 'UFortAthenaNpcGalileoComponent::PatrolPath' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcGalileoComponent, CommunicationGroup) == 0x0000C0, "Member 'UFortAthenaNpcGalileoComponent::CommunicationGroup' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcGalileoComponent, OnPatrollingStart) == 0x0000D0, "Member 'UFortAthenaNpcGalileoComponent::OnPatrollingStart' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcGalileoComponent, OnPatrollingStop) == 0x0000E0, "Member 'UFortAthenaNpcGalileoComponent::OnPatrollingStop' has a wrong offset!");

// Class FortniteAI.FortPathFollowingComponentBase
// 0x0020 (0x0328 - 0x0308)
class UFortPathFollowingComponentBase : public UCrowdFollowingComponent
{
public:
	class AAIController*                          AIController;                                      // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPathFollowingComponentBase">();
	}
	static class UFortPathFollowingComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPathFollowingComponentBase>();
	}
};
static_assert(alignof(UFortPathFollowingComponentBase) == 0x000008, "Wrong alignment on UFortPathFollowingComponentBase");
static_assert(sizeof(UFortPathFollowingComponentBase) == 0x000328, "Wrong size on UFortPathFollowingComponentBase");
static_assert(offsetof(UFortPathFollowingComponentBase, AIController) == 0x000308, "Member 'UFortPathFollowingComponentBase::AIController' has a wrong offset!");

// Class FortniteAI.FortPathFollowingComponent
// 0x00F0 (0x0418 - 0x0328)
class UFortPathFollowingComponent : public UFortPathFollowingComponentBase
{
public:
	class AFortAIController*                      MyAI;                                              // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementBlockFrustrationCooldownSpeed;             // 0x0350(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0xC4];                                     // 0x0354(0x00C4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPathFollowingComponent">();
	}
	static class UFortPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPathFollowingComponent>();
	}
};
static_assert(alignof(UFortPathFollowingComponent) == 0x000008, "Wrong alignment on UFortPathFollowingComponent");
static_assert(sizeof(UFortPathFollowingComponent) == 0x000418, "Wrong size on UFortPathFollowingComponent");
static_assert(offsetof(UFortPathFollowingComponent, MyAI) == 0x000328, "Member 'UFortPathFollowingComponent::MyAI' has a wrong offset!");
static_assert(offsetof(UFortPathFollowingComponent, MovementBlockFrustrationCooldownSpeed) == 0x000350, "Member 'UFortPathFollowingComponent::MovementBlockFrustrationCooldownSpeed' has a wrong offset!");

// Class FortniteAI.FortBotMissionLogic
// 0x0050 (0x0078 - 0x0028)
class UFortBotMissionLogic final : public UObject
{
public:
	class AFortMission*                           Mission;                                           // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Goals;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class AFortBotStructureBuilder*>       Builders;                                          // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          CurrentBehaviorAsset;                              // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFortBotController*>             AssignedAI;                                        // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<uint8>                                 GoalHasLocator;                                    // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	void ClearAllLocated();
	void MarkAllLocated();
	void MarkSingleLocator(const class AActor* LocatorActor);
	void OnAssignedBehavior(class AFortAIController* BotAI);
	bool OnCanStartOtherMission(class AFortAIController* BotAI, class AFortMission* OtherMission);
	bool OnInteractWithMissionGoal(class AFortAIController* BotAI, class AActor* MissionGoal);
	void OnMissionActivated();
	void OnMissionFinished();
	void OnMissionStarted();
	void ResetBehavior();
	void SetCurrentBehavior(class UBehaviorTree* Behavior);
	void SetGoalsInvulnerable(bool bGodMode);
	class AFortBotStructureBuilder* SpawnStructureBuilder(class AActor* MissionGoal, class UFortBuildingInstructions* BuildingInstructions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotMissionLogic">();
	}
	static class UFortBotMissionLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBotMissionLogic>();
	}
};
static_assert(alignof(UFortBotMissionLogic) == 0x000008, "Wrong alignment on UFortBotMissionLogic");
static_assert(sizeof(UFortBotMissionLogic) == 0x000078, "Wrong size on UFortBotMissionLogic");
static_assert(offsetof(UFortBotMissionLogic, Mission) == 0x000028, "Member 'UFortBotMissionLogic::Mission' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, Goals) == 0x000030, "Member 'UFortBotMissionLogic::Goals' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, Builders) == 0x000040, "Member 'UFortBotMissionLogic::Builders' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, CurrentBehaviorAsset) == 0x000050, "Member 'UFortBotMissionLogic::CurrentBehaviorAsset' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, AssignedAI) == 0x000058, "Member 'UFortBotMissionLogic::AssignedAI' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, GoalHasLocator) == 0x000068, "Member 'UFortBotMissionLogic::GoalHasLocator' has a wrong offset!");

// Class FortniteAI.FortQueryContext_BotPOIVolume
// 0x0020 (0x0048 - 0x0028)
class UFortQueryContext_BotPOIVolume final : public UEnvQueryContext
{
public:
	bool                                          bSetProjectedToNavmeshLocationAsContext;           // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProjectionExtent;                                  // 0x0030(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_BotPOIVolume">();
	}
	static class UFortQueryContext_BotPOIVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_BotPOIVolume>();
	}
};
static_assert(alignof(UFortQueryContext_BotPOIVolume) == 0x000008, "Wrong alignment on UFortQueryContext_BotPOIVolume");
static_assert(sizeof(UFortQueryContext_BotPOIVolume) == 0x000048, "Wrong size on UFortQueryContext_BotPOIVolume");
static_assert(offsetof(UFortQueryContext_BotPOIVolume, bSetProjectedToNavmeshLocationAsContext) == 0x000028, "Member 'UFortQueryContext_BotPOIVolume::bSetProjectedToNavmeshLocationAsContext' has a wrong offset!");
static_assert(offsetof(UFortQueryContext_BotPOIVolume, ProjectionExtent) == 0x000030, "Member 'UFortQueryContext_BotPOIVolume::ProjectionExtent' has a wrong offset!");

// Class FortniteAI.AthenaPathFollowingComponent
// 0x0038 (0x0450 - 0x0418)
class UAthenaPathFollowingComponent final : public UFortPathFollowingComponent
{
public:
	uint8                                         Pad_418[0x18];                                     // 0x0418(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AAthenaAIController*                    AthenaAIController;                                // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x18];                                     // 0x0438(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaPathFollowingComponent">();
	}
	static class UAthenaPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaPathFollowingComponent>();
	}
};
static_assert(alignof(UAthenaPathFollowingComponent) == 0x000008, "Wrong alignment on UAthenaPathFollowingComponent");
static_assert(sizeof(UAthenaPathFollowingComponent) == 0x000450, "Wrong size on UAthenaPathFollowingComponent");
static_assert(offsetof(UAthenaPathFollowingComponent, AthenaAIController) == 0x000430, "Member 'UAthenaPathFollowingComponent::AthenaAIController' has a wrong offset!");

// Class FortniteAI.AthenaPhysicsAIPerceptionStimuliSourceComponent
// 0x0000 (0x00B8 - 0x00B8)
class UAthenaPhysicsAIPerceptionStimuliSourceComponent final : public UAthenaAIPerceptionStimuliSourceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaPhysicsAIPerceptionStimuliSourceComponent">();
	}
	static class UAthenaPhysicsAIPerceptionStimuliSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaPhysicsAIPerceptionStimuliSourceComponent>();
	}
};
static_assert(alignof(UAthenaPhysicsAIPerceptionStimuliSourceComponent) == 0x000008, "Wrong alignment on UAthenaPhysicsAIPerceptionStimuliSourceComponent");
static_assert(sizeof(UAthenaPhysicsAIPerceptionStimuliSourceComponent) == 0x0000B8, "Wrong size on UAthenaPhysicsAIPerceptionStimuliSourceComponent");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_ChanceEncounterBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_ChanceEncounterBase : public UFortAthenaAISpawnerDataComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_ChanceEncounterBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_ChanceEncounterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_ChanceEncounterBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_ChanceEncounterBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_ChanceEncounterBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_ChanceEncounterBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_ChanceEncounterBase");

// Class FortniteAI.AthenaTrapAIPerceptionStimuliSourceComponent
// 0x0058 (0x0110 - 0x00B8)
class UAthenaTrapAIPerceptionStimuliSourceComponent final : public UAIPerceptionStimuliSourceComponent
{
public:
	TMap<class AActor*, struct FTrapDetectionState> TrapDiscoverabilityMap;                            // 0x00B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         bEnablePerceptionSystemOnTrap : 1;                 // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AthenaTrapAIPerceptionStimuliSourceComponent">();
	}
	static class UAthenaTrapAIPerceptionStimuliSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAthenaTrapAIPerceptionStimuliSourceComponent>();
	}
};
static_assert(alignof(UAthenaTrapAIPerceptionStimuliSourceComponent) == 0x000008, "Wrong alignment on UAthenaTrapAIPerceptionStimuliSourceComponent");
static_assert(sizeof(UAthenaTrapAIPerceptionStimuliSourceComponent) == 0x000110, "Wrong size on UAthenaTrapAIPerceptionStimuliSourceComponent");
static_assert(offsetof(UAthenaTrapAIPerceptionStimuliSourceComponent, TrapDiscoverabilityMap) == 0x0000B8, "Member 'UAthenaTrapAIPerceptionStimuliSourceComponent::TrapDiscoverabilityMap' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerData
// 0x00A0 (0x00E8 - 0x0048)
class UFortAthenaAISpawnerData : public TObjectBasedCycleFixup<class UFortAthenaSpawnerDataBase, 0x0020, 0x08>
{
public:
	TArray<class UFortAthenaAISpawnerDataComponent*> ClassComponentList;                                // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_InventoryBase> InventoryComponent;                                // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_SpawnParamsBase> SpawnParamsComponent;                              // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_BehaviorBase> BehaviorComponent;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_AffiliationBase> AffiliationComponent;                              // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_LODBase> LODComponent;                                      // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_DebugBase> DebugComponent;                                    // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_AnalyticBase> AnalyticComponent;                                 // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_GameplayBase> GameplayComponent;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_ConversationBase> ConversationComponent;                             // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_VoiceBase> VoiceComponent;                                    // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_CosmeticBase> CosmeticComponent;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_ChanceEncounterBase> ChanceEncounterComponent;                          // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_OptimBase> OptimizationComponent;                             // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_GameplayAbilityBase> GameplayAbilityComponent;                          // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_PerceptionBase> PerceptionComponent;                               // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_SmartObjectBase> SmartObjectComponent;                              // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_GroupBase> GroupComponent;                                    // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_ScriptBase> ScriptComponent;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UFortAthenaAISpawnerDataComponentList* CreateComponentListFromClass(const TSubclassOf<class UFortAthenaAISpawnerData> AISpawnerDataClass, class UObject* OuterObject);

	class UFortAthenaAISpawnerDataComponentList* CreateComponentList(class UObject* OuterObject) const;
	class UFortAthenaAISpawnerDataComponent_AffiliationBase* GetAffiliationComponent() const;
	class UFortAthenaAISpawnerDataComponent_LODBase* GetAILODComponent() const;
	class UFortAthenaAISpawnerDataComponent_AnalyticBase* GetAnalyticComponent() const;
	class UFortAthenaAISpawnerDataComponent_BehaviorBase* GetBehaviorComponent() const;
	class UFortAthenaAISpawnerDataComponent_ChanceEncounterBase* GetChanceEncounterComponent() const;
	class UFortAthenaAISpawnerDataComponent_ConversationBase* GetConversationComponent() const;
	class UFortAthenaAISpawnerDataComponent_CosmeticBase* GetCosmeticComponent() const;
	class UFortAthenaAISpawnerDataComponent_DebugBase* GetDebugComponent() const;
	class UFortAthenaAISpawnerDataComponent_GameplayAbilityBase* GetGameplayAbilityComponent() const;
	class UFortAthenaAISpawnerDataComponent_GameplayBase* GetGameplayComponent() const;
	class UFortAthenaAISpawnerDataComponent_GroupBase* GetGroupComponent() const;
	class UFortAthenaAISpawnerDataComponent_InventoryBase* GetInventoryComponent() const;
	class UFortAthenaAISpawnerDataComponent_OptimBase* GetOptimizationComponent() const;
	class UFortAthenaAISpawnerDataComponent_PerceptionBase* GetPerceptionComponent() const;
	class UFortAthenaAISpawnerDataComponent_ScriptBase* GetScriptComponent() const;
	class UFortAthenaAISpawnerDataComponent_SmartObjectBase* GetSmartObjectComponent() const;
	class UFortAthenaAISpawnerDataComponent_SpawnParamsBase* GetSpawnParamsComponent() const;
	class UFortAthenaAISpawnerDataComponent_VoiceBase* GetVoiceComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerData">();
	}
	static class UFortAthenaAISpawnerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerData>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerData) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerData");
static_assert(sizeof(UFortAthenaAISpawnerData) == 0x0000E8, "Wrong size on UFortAthenaAISpawnerData");
static_assert(offsetof(UFortAthenaAISpawnerData, ClassComponentList) == 0x000048, "Member 'UFortAthenaAISpawnerData::ClassComponentList' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, InventoryComponent) == 0x000058, "Member 'UFortAthenaAISpawnerData::InventoryComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, SpawnParamsComponent) == 0x000060, "Member 'UFortAthenaAISpawnerData::SpawnParamsComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, BehaviorComponent) == 0x000068, "Member 'UFortAthenaAISpawnerData::BehaviorComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, AffiliationComponent) == 0x000070, "Member 'UFortAthenaAISpawnerData::AffiliationComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, LODComponent) == 0x000078, "Member 'UFortAthenaAISpawnerData::LODComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, DebugComponent) == 0x000080, "Member 'UFortAthenaAISpawnerData::DebugComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, AnalyticComponent) == 0x000088, "Member 'UFortAthenaAISpawnerData::AnalyticComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, GameplayComponent) == 0x000090, "Member 'UFortAthenaAISpawnerData::GameplayComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, ConversationComponent) == 0x000098, "Member 'UFortAthenaAISpawnerData::ConversationComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, VoiceComponent) == 0x0000A0, "Member 'UFortAthenaAISpawnerData::VoiceComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, CosmeticComponent) == 0x0000A8, "Member 'UFortAthenaAISpawnerData::CosmeticComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, ChanceEncounterComponent) == 0x0000B0, "Member 'UFortAthenaAISpawnerData::ChanceEncounterComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, OptimizationComponent) == 0x0000B8, "Member 'UFortAthenaAISpawnerData::OptimizationComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, GameplayAbilityComponent) == 0x0000C0, "Member 'UFortAthenaAISpawnerData::GameplayAbilityComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, PerceptionComponent) == 0x0000C8, "Member 'UFortAthenaAISpawnerData::PerceptionComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, SmartObjectComponent) == 0x0000D0, "Member 'UFortAthenaAISpawnerData::SmartObjectComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, GroupComponent) == 0x0000D8, "Member 'UFortAthenaAISpawnerData::GroupComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerData, ScriptComponent) == 0x0000E0, "Member 'UFortAthenaAISpawnerData::ScriptComponent' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotSpawnerData
// 0x0028 (0x0110 - 0x00E8)
class UFortAthenaAIBotSpawnerData : public UFortAthenaAISpawnerData
{
public:
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_SkillsetBase> SkillSetComponent;                                 // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_ConstructionBase> ConstructionComponent;                             // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_VehicleBase> VehicleComponent;                                  // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_CoverBase> CoverComponent;                                    // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAISpawnerDataComponent_PerksBase> PerksComponent;                                    // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UFortAthenaAISpawnerDataComponent_ConstructionBase* GetConstructionComponent() const;
	class UFortAthenaAISpawnerDataComponent_CoverBase* GetCoverComponent() const;
	class UFortAthenaAISpawnerDataComponent_PerksBase* GetPerksComponent() const;
	class UFortAthenaAISpawnerDataComponent_SkillsetBase* GetSkillSetComponent() const;
	class UFortAthenaAISpawnerDataComponent_VehicleBase* GetVehicleComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotSpawnerData">();
	}
	static class UFortAthenaAIBotSpawnerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotSpawnerData>();
	}
};
static_assert(alignof(UFortAthenaAIBotSpawnerData) == 0x000008, "Wrong alignment on UFortAthenaAIBotSpawnerData");
static_assert(sizeof(UFortAthenaAIBotSpawnerData) == 0x000110, "Wrong size on UFortAthenaAIBotSpawnerData");
static_assert(offsetof(UFortAthenaAIBotSpawnerData, SkillSetComponent) == 0x0000E8, "Member 'UFortAthenaAIBotSpawnerData::SkillSetComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotSpawnerData, ConstructionComponent) == 0x0000F0, "Member 'UFortAthenaAIBotSpawnerData::ConstructionComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotSpawnerData, VehicleComponent) == 0x0000F8, "Member 'UFortAthenaAIBotSpawnerData::VehicleComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotSpawnerData, CoverComponent) == 0x000100, "Member 'UFortAthenaAIBotSpawnerData::CoverComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotSpawnerData, PerksComponent) == 0x000108, "Member 'UFortAthenaAIBotSpawnerData::PerksComponent' has a wrong offset!");

// Class FortniteAI.FortAthenaNPCSpawnerData
// 0x0000 (0x0110 - 0x0110)
class UFortAthenaNPCSpawnerData final : public UFortAthenaAIBotSpawnerData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNPCSpawnerData">();
	}
	static class UFortAthenaNPCSpawnerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNPCSpawnerData>();
	}
};
static_assert(alignof(UFortAthenaNPCSpawnerData) == 0x000008, "Wrong alignment on UFortAthenaNPCSpawnerData");
static_assert(sizeof(UFortAthenaNPCSpawnerData) == 0x000110, "Wrong size on UFortAthenaNPCSpawnerData");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AffiliationBase
// 0x0088 (0x00B8 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AffiliationBase : public UFortAthenaAISpawnerDataComponent
{
public:
	struct FGameplayTagContainer                  FactionTags;                                       // 0x0030(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TurnHostileOnDamageIfNeutral;                      // 0x0050(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TurnHostileWhenBlockedTime;                        // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnerDataComponentAffiliationSharedBBConfiguration> FactionSharedBBConfigurations;                     // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         bFullTeamAwarenessPropagation : 1;                 // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bAwarenessPropagationIsBasedOnAlertLevel : 1;      // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FullTeamAwarenessMaxDistance;                      // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FGameplayTagContainer GetFactionTag();
	void SetAwarenessPropagationIsBasedOnAlertLevel(const bool bInAwarenessPropagationIsBasedOnAlertLevel);
	void SetFactionTags(const struct FGameplayTagContainer& NewTags);
	void SetFullTeamAwarenessPropagation(const bool bInFullTeamAwarenessPropagation);
	void SetFullTeamAwarenessPropagationDistance(const float InFullTeamAwarenessMaxDistance);

	bool GetAwarenessPropagationIsBasedOnAlertLevel() const;
	float GetFullTeamAwarenessMaxDistance() const;
	bool GetFullTeamAwarenessPropagation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AffiliationBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_AffiliationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AffiliationBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AffiliationBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AffiliationBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AffiliationBase) == 0x0000B8, "Wrong size on UFortAthenaAISpawnerDataComponent_AffiliationBase");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AffiliationBase, FactionTags) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_AffiliationBase::FactionTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AffiliationBase, TurnHostileOnDamageIfNeutral) == 0x000050, "Member 'UFortAthenaAISpawnerDataComponent_AffiliationBase::TurnHostileOnDamageIfNeutral' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AffiliationBase, TurnHostileWhenBlockedTime) == 0x000078, "Member 'UFortAthenaAISpawnerDataComponent_AffiliationBase::TurnHostileWhenBlockedTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AffiliationBase, FactionSharedBBConfigurations) == 0x0000A0, "Member 'UFortAthenaAISpawnerDataComponent_AffiliationBase::FactionSharedBBConfigurations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AffiliationBase, FullTeamAwarenessMaxDistance) == 0x0000B4, "Member 'UFortAthenaAISpawnerDataComponent_AffiliationBase::FullTeamAwarenessMaxDistance' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotAffiliation
// 0x0208 (0x02C0 - 0x00B8)
class UFortAthenaAISpawnerDataComponent_AIBotAffiliation final : public UFortAthenaAISpawnerDataComponent_AffiliationBase
{
public:
	bool                                          bForceAddToCollectionOnDamage;                     // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bOverrideIsAnAthenaGameParticipant : 1;            // 0x00B9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsAnAthenaGameParticipant : 1;                    // 0x00B9(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         SupportsMarkerWithFaction;                         // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MarkerPropagationMaxDistance;                      // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         DisguiseProbability;                               // 0x0110(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RevealDisguiseOnDamage;                            // 0x0138(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RevealOnDamageExcludeAIPawnDamage;                 // 0x0160(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RevealDisguiseOnPlayerProximity;                   // 0x0188(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RevealPlayerProximityDistance;                     // 0x01B0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RevealPlayerProximityMinDuration;                  // 0x01D8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RevealPlayerProximityMaxDuration;                  // 0x0200(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class UFortBotNameSettings*                   NameSettingsAfterReveal;                           // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  DisguisedFactionsBeforeReveal;                     // 0x0230(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  DisguisedFactionsAfterReveal;                      // 0x0250(0x0020)(Edit, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UGameplayEffect>>    DisguiseGameplayEffectBeforeReveal;                // 0x0270(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UGameplayEffect>>    DisguiseGameplayEffectAfterReveal;                 // 0x0280(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FItemAndCount>                  DisguiseInventory;                                 // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    DisguiseLootInfo;                                  // 0x02A0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortNPCConversationParticipantComponent> DisguiseConversationComponent;                     // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OverrideTeamIndex;                                 // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOverrideTeamIndex(const int32 InOverrideTeamIdx);

	bool GetSquadID(int32* OutSquadId) const;
	bool GetTeamID(int32* OutTeamId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotAffiliation">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotAffiliation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotAffiliation>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotAffiliation");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation) == 0x0002C0, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotAffiliation");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, bForceAddToCollectionOnDamage) == 0x0000B8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::bForceAddToCollectionOnDamage' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, SupportsMarkerWithFaction) == 0x0000C0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::SupportsMarkerWithFaction' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, MarkerPropagationMaxDistance) == 0x0000E8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::MarkerPropagationMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, DisguiseProbability) == 0x000110, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::DisguiseProbability' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, RevealDisguiseOnDamage) == 0x000138, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::RevealDisguiseOnDamage' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, RevealOnDamageExcludeAIPawnDamage) == 0x000160, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::RevealOnDamageExcludeAIPawnDamage' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, RevealDisguiseOnPlayerProximity) == 0x000188, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::RevealDisguiseOnPlayerProximity' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, RevealPlayerProximityDistance) == 0x0001B0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::RevealPlayerProximityDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, RevealPlayerProximityMinDuration) == 0x0001D8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::RevealPlayerProximityMinDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, RevealPlayerProximityMaxDuration) == 0x000200, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::RevealPlayerProximityMaxDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, NameSettingsAfterReveal) == 0x000228, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::NameSettingsAfterReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, DisguisedFactionsBeforeReveal) == 0x000230, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::DisguisedFactionsBeforeReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, DisguisedFactionsAfterReveal) == 0x000250, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::DisguisedFactionsAfterReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, DisguiseGameplayEffectBeforeReveal) == 0x000270, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::DisguiseGameplayEffectBeforeReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, DisguiseGameplayEffectAfterReveal) == 0x000280, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::DisguiseGameplayEffectAfterReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, DisguiseInventory) == 0x000290, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::DisguiseInventory' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, DisguiseLootInfo) == 0x0002A0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::DisguiseLootInfo' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, DisguiseConversationComponent) == 0x0002B0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::DisguiseConversationComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAffiliation, OverrideTeamIndex) == 0x0002B8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAffiliation::OverrideTeamIndex' has a wrong offset!");

// Class FortniteAI.BuildingActorHotSpotConfig
// 0x0128 (0x0158 - 0x0030)
class UBuildingActorHotSpotConfig final : public UDataAsset
{
public:
	struct FBuildingActorHotSpotDirection         DirectionSetup[0x6];                               // 0x0030(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBuildingActorHotSpotDirection         DefaultSetup;                                      // 0x0120(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAIHotSpotConfig*                       ExtraTypeConfig;                                   // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasDirectionalSetup : 1;                          // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActorHotSpotConfig">();
	}
	static class UBuildingActorHotSpotConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingActorHotSpotConfig>();
	}
};
static_assert(alignof(UBuildingActorHotSpotConfig) == 0x000008, "Wrong alignment on UBuildingActorHotSpotConfig");
static_assert(sizeof(UBuildingActorHotSpotConfig) == 0x000158, "Wrong size on UBuildingActorHotSpotConfig");
static_assert(offsetof(UBuildingActorHotSpotConfig, DirectionSetup) == 0x000030, "Member 'UBuildingActorHotSpotConfig::DirectionSetup' has a wrong offset!");
static_assert(offsetof(UBuildingActorHotSpotConfig, DefaultSetup) == 0x000120, "Member 'UBuildingActorHotSpotConfig::DefaultSetup' has a wrong offset!");
static_assert(offsetof(UBuildingActorHotSpotConfig, ExtraTypeConfig) == 0x000148, "Member 'UBuildingActorHotSpotConfig::ExtraTypeConfig' has a wrong offset!");

// Class FortniteAI.BuildingActorHotSpotRenderingComponent
// 0x0000 (0x0530 - 0x0530)
class UBuildingActorHotSpotRenderingComponent final : public UDebugDrawComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActorHotSpotRenderingComponent">();
	}
	static class UBuildingActorHotSpotRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingActorHotSpotRenderingComponent>();
	}
};
static_assert(alignof(UBuildingActorHotSpotRenderingComponent) == 0x000010, "Wrong alignment on UBuildingActorHotSpotRenderingComponent");
static_assert(sizeof(UBuildingActorHotSpotRenderingComponent) == 0x000530, "Wrong size on UBuildingActorHotSpotRenderingComponent");

// Class FortniteAI.FortAthenaAIRuntimeParameters_AffiliationBase
// 0x0010 (0x0040 - 0x0030)
class UFortAthenaAIRuntimeParameters_AffiliationBase final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFullTeamAwarenessPropagation : 1;                 // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bAwarenessPropagationIsBasedOnAlertLevel : 1;      // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bTurnHostileOnDamageIfNeutral : 1;                 // 0x0034(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnHostileWhenBlockedTime;                        // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_AffiliationBase">();
	}
	static class UFortAthenaAIRuntimeParameters_AffiliationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_AffiliationBase>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_AffiliationBase) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_AffiliationBase");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_AffiliationBase) == 0x000040, "Wrong size on UFortAthenaAIRuntimeParameters_AffiliationBase");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AffiliationBase, TurnHostileWhenBlockedTime) == 0x000038, "Member 'UFortAthenaAIRuntimeParameters_AffiliationBase::TurnHostileWhenBlockedTime' has a wrong offset!");

// Class FortniteAI.FortQueryContext_BuildingRifts
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_BuildingRifts final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_BuildingRifts">();
	}
	static class UFortQueryContext_BuildingRifts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_BuildingRifts>();
	}
};
static_assert(alignof(UFortQueryContext_BuildingRifts) == 0x000008, "Wrong alignment on UFortQueryContext_BuildingRifts");
static_assert(sizeof(UFortQueryContext_BuildingRifts) == 0x000028, "Wrong size on UFortQueryContext_BuildingRifts");

// Class FortniteAI.DespawnExpiredPawnComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDespawnExpiredPawnComponent final : public TObjectBasedCycleFixup<class UFortPawnComponent, 0x0078, 0x08>
{
public:
	void AddDespawnRift(class ABuildingRift* NewRift);
	void DespawnExpired();
	TArray<class ABuildingRift*> GetDespawnRifts();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DespawnExpiredPawnComponent">();
	}
	static class UDespawnExpiredPawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDespawnExpiredPawnComponent>();
	}
};
static_assert(alignof(UDespawnExpiredPawnComponent) == 0x000008, "Wrong alignment on UDespawnExpiredPawnComponent");
static_assert(sizeof(UDespawnExpiredPawnComponent) == 0x0000A0, "Wrong size on UDespawnExpiredPawnComponent");

// Class FortniteAI.FortAthenaNpcEvaluator_Patrolling
// 0x0040 (0x0258 - 0x0218)
class UFortAthenaNpcEvaluator_Patrolling final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   PatrollingKeyName;                                 // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PatrollingMovementStateKeyName;                    // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PatrollingDestinationKeyName;                      // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DynamicBlueprintStatusKeyName;                     // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DynamicBlueprintActorKeyName;                      // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PatrollingShouldMoveKeyName;                       // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PatrollingAppendDestinationKeyName;                // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x8];                                      // 0x0234(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToTestPoint;                               // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanDisablePatrolling;                             // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanReenablePatrolling;                            // 0x0241(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_242[0x2];                                      // 0x0242(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReenableTimer;                                     // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanSelectNearestPatrolPointAtStart;               // 0x0248(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaNpcPatrollingComponent*      CachedNpcPatrollingComponent;                      // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNpcEvaluator_Patrolling">();
	}
	static class UFortAthenaNpcEvaluator_Patrolling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNpcEvaluator_Patrolling>();
	}
};
static_assert(alignof(UFortAthenaNpcEvaluator_Patrolling) == 0x000008, "Wrong alignment on UFortAthenaNpcEvaluator_Patrolling");
static_assert(sizeof(UFortAthenaNpcEvaluator_Patrolling) == 0x000258, "Wrong size on UFortAthenaNpcEvaluator_Patrolling");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, PatrollingKeyName) == 0x000218, "Member 'UFortAthenaNpcEvaluator_Patrolling::PatrollingKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, PatrollingMovementStateKeyName) == 0x00021C, "Member 'UFortAthenaNpcEvaluator_Patrolling::PatrollingMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, PatrollingDestinationKeyName) == 0x000220, "Member 'UFortAthenaNpcEvaluator_Patrolling::PatrollingDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, DynamicBlueprintStatusKeyName) == 0x000224, "Member 'UFortAthenaNpcEvaluator_Patrolling::DynamicBlueprintStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, DynamicBlueprintActorKeyName) == 0x000228, "Member 'UFortAthenaNpcEvaluator_Patrolling::DynamicBlueprintActorKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, PatrollingShouldMoveKeyName) == 0x00022C, "Member 'UFortAthenaNpcEvaluator_Patrolling::PatrollingShouldMoveKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, PatrollingAppendDestinationKeyName) == 0x000230, "Member 'UFortAthenaNpcEvaluator_Patrolling::PatrollingAppendDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, DistanceToTestPoint) == 0x00023C, "Member 'UFortAthenaNpcEvaluator_Patrolling::DistanceToTestPoint' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, bCanDisablePatrolling) == 0x000240, "Member 'UFortAthenaNpcEvaluator_Patrolling::bCanDisablePatrolling' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, bCanReenablePatrolling) == 0x000241, "Member 'UFortAthenaNpcEvaluator_Patrolling::bCanReenablePatrolling' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, ReenableTimer) == 0x000244, "Member 'UFortAthenaNpcEvaluator_Patrolling::ReenableTimer' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, bCanSelectNearestPatrolPointAtStart) == 0x000248, "Member 'UFortAthenaNpcEvaluator_Patrolling::bCanSelectNearestPatrolPointAtStart' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Patrolling, CachedNpcPatrollingComponent) == 0x000250, "Member 'UFortAthenaNpcEvaluator_Patrolling::CachedNpcPatrollingComponent' has a wrong offset!");

// Class FortniteAI.FortQueryContext_AllGoals
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_AllGoals final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllGoals">();
	}
	static class UFortQueryContext_AllGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllGoals>();
	}
};
static_assert(alignof(UFortQueryContext_AllGoals) == 0x000008, "Wrong alignment on UFortQueryContext_AllGoals");
static_assert(sizeof(UFortQueryContext_AllGoals) == 0x000028, "Wrong size on UFortQueryContext_AllGoals");

// Class FortniteAI.EdgeNavLinks
// 0x0050 (0x0310 - 0x02C0)
class AEdgeNavLinks final : public ANavLinkProxy
{
public:
	float                                         DistanceBetweenLinks;                              // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x02C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                End;                                               // 0x02E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SnapRadius;                                        // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SnapHeight;                                        // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LinkProjectionHeight;                              // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightLinkForwardOffset;                            // 0x0304(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionChannel;                                  // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bManualAdjustment : 1;                             // 0x030C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdgeNavLinks">();
	}
	static class AEdgeNavLinks* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEdgeNavLinks>();
	}
};
static_assert(alignof(AEdgeNavLinks) == 0x000008, "Wrong alignment on AEdgeNavLinks");
static_assert(sizeof(AEdgeNavLinks) == 0x000310, "Wrong size on AEdgeNavLinks");
static_assert(offsetof(AEdgeNavLinks, DistanceBetweenLinks) == 0x0002C0, "Member 'AEdgeNavLinks::DistanceBetweenLinks' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, Start) == 0x0002C8, "Member 'AEdgeNavLinks::Start' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, End) == 0x0002E0, "Member 'AEdgeNavLinks::End' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, SnapRadius) == 0x0002F8, "Member 'AEdgeNavLinks::SnapRadius' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, SnapHeight) == 0x0002FC, "Member 'AEdgeNavLinks::SnapHeight' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, LinkProjectionHeight) == 0x000300, "Member 'AEdgeNavLinks::LinkProjectionHeight' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, RightLinkForwardOffset) == 0x000304, "Member 'AEdgeNavLinks::RightLinkForwardOffset' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, CollisionChannel) == 0x000308, "Member 'AEdgeNavLinks::CollisionChannel' has a wrong offset!");

// Class FortniteAI.FortQueryContext_NearbyAIPawnsMoveDestinations
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_NearbyAIPawnsMoveDestinations final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_NearbyAIPawnsMoveDestinations">();
	}
	static class UFortQueryContext_NearbyAIPawnsMoveDestinations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_NearbyAIPawnsMoveDestinations>();
	}
};
static_assert(alignof(UFortQueryContext_NearbyAIPawnsMoveDestinations) == 0x000008, "Wrong alignment on UFortQueryContext_NearbyAIPawnsMoveDestinations");
static_assert(sizeof(UFortQueryContext_NearbyAIPawnsMoveDestinations) == 0x000028, "Wrong size on UFortQueryContext_NearbyAIPawnsMoveDestinations");

// Class FortniteAI.EdgeNavLinksRenderingComponent
// 0x0000 (0x0530 - 0x0530)
class UEdgeNavLinksRenderingComponent final : public UNavLinkRenderingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdgeNavLinksRenderingComponent">();
	}
	static class UEdgeNavLinksRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdgeNavLinksRenderingComponent>();
	}
};
static_assert(alignof(UEdgeNavLinksRenderingComponent) == 0x000010, "Wrong alignment on UEdgeNavLinksRenderingComponent");
static_assert(sizeof(UEdgeNavLinksRenderingComponent) == 0x000530, "Wrong size on UEdgeNavLinksRenderingComponent");

// Class FortniteAI.FortAIAssetLoader
// 0x0028 (0x0050 - 0x0028)
class UFortAIAssetLoader final : public UObject
{
public:
	TArray<struct FPendingRequestManager>         PendingRequests;                                   // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        AssetsLoaded;                                      // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAssetLoader">();
	}
	static class UFortAIAssetLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAssetLoader>();
	}
};
static_assert(alignof(UFortAIAssetLoader) == 0x000008, "Wrong alignment on UFortAIAssetLoader");
static_assert(sizeof(UFortAIAssetLoader) == 0x000050, "Wrong size on UFortAIAssetLoader");
static_assert(offsetof(UFortAIAssetLoader, PendingRequests) == 0x000028, "Member 'UFortAIAssetLoader::PendingRequests' has a wrong offset!");
static_assert(offsetof(UFortAIAssetLoader, AssetsLoaded) == 0x000038, "Member 'UFortAIAssetLoader::AssetsLoaded' has a wrong offset!");

// Class FortniteAI.FortAIAssignment
// 0x00B0 (0x00D8 - 0x0028)
class UFortAIAssignment final : public UObject
{
public:
	struct FFortAIAssignmentIdentifier            AssignmentIdentifier;                              // 0x0028(0x0030)(Protected, NativeAccessSpecifierProtected)
	class UFortAIAssignmentSettings*              AssignmentSettings;                                // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAIGoalProvider*                    GoalProvider;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAIGoalComponent*>               GoalComponentsOnAssignment;                        // 0x0068(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAIGoal>                    Goals;                                             // 0x00C8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAssignment">();
	}
	static class UFortAIAssignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAssignment>();
	}
};
static_assert(alignof(UFortAIAssignment) == 0x000008, "Wrong alignment on UFortAIAssignment");
static_assert(sizeof(UFortAIAssignment) == 0x0000D8, "Wrong size on UFortAIAssignment");
static_assert(offsetof(UFortAIAssignment, AssignmentIdentifier) == 0x000028, "Member 'UFortAIAssignment::AssignmentIdentifier' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, AssignmentSettings) == 0x000058, "Member 'UFortAIAssignment::AssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, GoalProvider) == 0x000060, "Member 'UFortAIAssignment::GoalProvider' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, GoalComponentsOnAssignment) == 0x000068, "Member 'UFortAIAssignment::GoalComponentsOnAssignment' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, Goals) == 0x0000C8, "Member 'UFortAIAssignment::Goals' has a wrong offset!");

// Class FortniteAI.FortAIAssignmentSettings
// 0x0060 (0x0090 - 0x0030)
class UFortAIAssignmentSettings final : public UDataAsset
{
public:
	TArray<struct FGoalSelectionQueryInfo>        GoalSelectionQueryInfos;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bGoalLocationsAlwaysKnown;                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEnemyAssignment;                                // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0048(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ProhibitedTags;                                    // 0x0068(0x0020)(Edit, NativeAccessSpecifierPrivate)
	float                                         MaxAIAllowedForAssignment;                         // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAIAllowedPerGoal;                               // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAssignmentSettings">();
	}
	static class UFortAIAssignmentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAssignmentSettings>();
	}
};
static_assert(alignof(UFortAIAssignmentSettings) == 0x000008, "Wrong alignment on UFortAIAssignmentSettings");
static_assert(sizeof(UFortAIAssignmentSettings) == 0x000090, "Wrong size on UFortAIAssignmentSettings");
static_assert(offsetof(UFortAIAssignmentSettings, GoalSelectionQueryInfos) == 0x000030, "Member 'UFortAIAssignmentSettings::GoalSelectionQueryInfos' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, bGoalLocationsAlwaysKnown) == 0x000040, "Member 'UFortAIAssignmentSettings::bGoalLocationsAlwaysKnown' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, bIsEnemyAssignment) == 0x000041, "Member 'UFortAIAssignmentSettings::bIsEnemyAssignment' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, RequiredTags) == 0x000048, "Member 'UFortAIAssignmentSettings::RequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, ProhibitedTags) == 0x000068, "Member 'UFortAIAssignmentSettings::ProhibitedTags' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, MaxAIAllowedForAssignment) == 0x000088, "Member 'UFortAIAssignmentSettings::MaxAIAllowedForAssignment' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, MaxAIAllowedPerGoal) == 0x00008C, "Member 'UFortAIAssignmentSettings::MaxAIAllowedPerGoal' has a wrong offset!");

// Class FortniteAI.FortAIComponent_Voice
// 0x0008 (0x00A8 - 0x00A0)
class UFortAIComponent_Voice : public UActorComponent
{
public:
	class UFortTaggedSoundBank*                   VoiceSoundBank;                                    // 0x00A0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetVoiceSoundBank(class UFortTaggedSoundBank* InSoundBank);

	class UFortTaggedSoundBank* GetVoiceSoundBank() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIComponent_Voice">();
	}
	static class UFortAIComponent_Voice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIComponent_Voice>();
	}
};
static_assert(alignof(UFortAIComponent_Voice) == 0x000008, "Wrong alignment on UFortAIComponent_Voice");
static_assert(sizeof(UFortAIComponent_Voice) == 0x0000A8, "Wrong size on UFortAIComponent_Voice");
static_assert(offsetof(UFortAIComponent_Voice, VoiceSoundBank) == 0x0000A0, "Member 'UFortAIComponent_Voice::VoiceSoundBank' has a wrong offset!");

// Class FortniteAI.FortStaticMeshLinkComponent
// 0x0030 (0x0120 - 0x00F0)
class UFortStaticMeshLinkComponent final : public UNavRelevantComponent
{
public:
	uint8                                         Pad_F0[0x30];                                      // 0x00F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStaticMeshLinkComponent">();
	}
	static class UFortStaticMeshLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStaticMeshLinkComponent>();
	}
};
static_assert(alignof(UFortStaticMeshLinkComponent) == 0x000008, "Wrong alignment on UFortStaticMeshLinkComponent");
static_assert(sizeof(UFortStaticMeshLinkComponent) == 0x000120, "Wrong size on UFortStaticMeshLinkComponent");

// Class FortniteAI.FortAIControllerPerksComponent
// 0x0018 (0x00B8 - 0x00A0)
class UFortAIControllerPerksComponent final : public TObjectBasedCycleFixup<class UFortControllerComponent, 0x0078, 0x08>
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIControllerPerksComponent">();
	}
	static class UFortAIControllerPerksComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIControllerPerksComponent>();
	}
};
static_assert(alignof(UFortAIControllerPerksComponent) == 0x000008, "Wrong alignment on UFortAIControllerPerksComponent");
static_assert(sizeof(UFortAIControllerPerksComponent) == 0x0000B8, "Wrong size on UFortAIControllerPerksComponent");

// Class FortniteAI.FortAICustomTargetingComponent
// 0x0060 (0x0100 - 0x00A0)
class UFortAICustomTargetingComponent final : public UActorComponent
{
public:
	TArray<struct FAICustomTargetConfiguration>   Configurations;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAICustomTargetingComponent">();
	}
	static class UFortAICustomTargetingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAICustomTargetingComponent>();
	}
};
static_assert(alignof(UFortAICustomTargetingComponent) == 0x000008, "Wrong alignment on UFortAICustomTargetingComponent");
static_assert(sizeof(UFortAICustomTargetingComponent) == 0x000100, "Wrong size on UFortAICustomTargetingComponent");
static_assert(offsetof(UFortAICustomTargetingComponent, Configurations) == 0x0000A0, "Member 'UFortAICustomTargetingComponent::Configurations' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_Undermine
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTTask_Undermine final : public UBTTaskNode
{
public:
	class FName                                   UndermineTargetKeyName;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   UndermineLocationImpactName;                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   UndermineExecutionStatusKeyName;                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_Undermine">();
	}
	static class UFortAthenaBTTask_Undermine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_Undermine>();
	}
};
static_assert(alignof(UFortAthenaBTTask_Undermine) == 0x000008, "Wrong alignment on UFortAthenaBTTask_Undermine");
static_assert(sizeof(UFortAthenaBTTask_Undermine) == 0x000080, "Wrong size on UFortAthenaBTTask_Undermine");
static_assert(offsetof(UFortAthenaBTTask_Undermine, UndermineTargetKeyName) == 0x000070, "Member 'UFortAthenaBTTask_Undermine::UndermineTargetKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Undermine, UndermineLocationImpactName) == 0x000074, "Member 'UFortAthenaBTTask_Undermine::UndermineLocationImpactName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Undermine, UndermineExecutionStatusKeyName) == 0x000078, "Member 'UFortAthenaBTTask_Undermine::UndermineExecutionStatusKeyName' has a wrong offset!");

// Class FortniteAI.FortAIDataProvider_Ability
// 0x0048 (0x0070 - 0x0028)
class UFortAIDataProvider_Ability : public UAIDataProvider
{
public:
	struct FGameplayTagContainer                  AbilityTag;                                        // 0x0028(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityBehaviorDistanceTag;                        // 0x0048(0x0020)(Edit, NativeAccessSpecifierPublic)
	float                                         BehaviorDistance;                                  // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetSelectionRange;                           // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_Ability">();
	}
	static class UFortAIDataProvider_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_Ability>();
	}
};
static_assert(alignof(UFortAIDataProvider_Ability) == 0x000008, "Wrong alignment on UFortAIDataProvider_Ability");
static_assert(sizeof(UFortAIDataProvider_Ability) == 0x000070, "Wrong size on UFortAIDataProvider_Ability");
static_assert(offsetof(UFortAIDataProvider_Ability, AbilityTag) == 0x000028, "Member 'UFortAIDataProvider_Ability::AbilityTag' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Ability, AbilityBehaviorDistanceTag) == 0x000048, "Member 'UFortAIDataProvider_Ability::AbilityBehaviorDistanceTag' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Ability, BehaviorDistance) == 0x000068, "Member 'UFortAIDataProvider_Ability::BehaviorDistance' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Ability, MaxTargetSelectionRange) == 0x00006C, "Member 'UFortAIDataProvider_Ability::MaxTargetSelectionRange' has a wrong offset!");

// Class FortniteAI.FortCrowdManager
// 0x0008 (0x00F8 - 0x00F0)
class UFortCrowdManager final : public UCrowdManager
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCrowdManager">();
	}
	static class UFortCrowdManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCrowdManager>();
	}
};
static_assert(alignof(UFortCrowdManager) == 0x000008, "Wrong alignment on UFortCrowdManager");
static_assert(sizeof(UFortCrowdManager) == 0x0000F8, "Wrong size on UFortCrowdManager");

// Class FortniteAI.FortAIDataProvider_AIDirector
// 0x0008 (0x0030 - 0x0028)
class UFortAIDataProvider_AIDirector final : public UAIDataProvider
{
public:
	float                                         AIRelevantDistanceToPlayer;                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterRelevantDistanceToPlayer;                 // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_AIDirector">();
	}
	static class UFortAIDataProvider_AIDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_AIDirector>();
	}
};
static_assert(alignof(UFortAIDataProvider_AIDirector) == 0x000008, "Wrong alignment on UFortAIDataProvider_AIDirector");
static_assert(sizeof(UFortAIDataProvider_AIDirector) == 0x000030, "Wrong size on UFortAIDataProvider_AIDirector");
static_assert(offsetof(UFortAIDataProvider_AIDirector, AIRelevantDistanceToPlayer) == 0x000028, "Member 'UFortAIDataProvider_AIDirector::AIRelevantDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_AIDirector, EncounterRelevantDistanceToPlayer) == 0x00002C, "Member 'UFortAIDataProvider_AIDirector::EncounterRelevantDistanceToPlayer' has a wrong offset!");

// Class FortniteAI.FortAIDataProvider_FloatCurveOverGameDifficulty
// 0x0030 (0x0058 - 0x0028)
class UFortAIDataProvider_FloatCurveOverGameDifficulty final : public UAIDataProvider
{
public:
	struct FScalableFloat                         ScalableFloat;                                     // 0x0028(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         FloatValue;                                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_FloatCurveOverGameDifficulty">();
	}
	static class UFortAIDataProvider_FloatCurveOverGameDifficulty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_FloatCurveOverGameDifficulty>();
	}
};
static_assert(alignof(UFortAIDataProvider_FloatCurveOverGameDifficulty) == 0x000008, "Wrong alignment on UFortAIDataProvider_FloatCurveOverGameDifficulty");
static_assert(sizeof(UFortAIDataProvider_FloatCurveOverGameDifficulty) == 0x000058, "Wrong size on UFortAIDataProvider_FloatCurveOverGameDifficulty");
static_assert(offsetof(UFortAIDataProvider_FloatCurveOverGameDifficulty, ScalableFloat) == 0x000028, "Member 'UFortAIDataProvider_FloatCurveOverGameDifficulty::ScalableFloat' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_FloatCurveOverGameDifficulty, FloatValue) == 0x000050, "Member 'UFortAIDataProvider_FloatCurveOverGameDifficulty::FloatValue' has a wrong offset!");

// Class FortniteAI.FortEnvQueryManager
// 0x0040 (0x0198 - 0x0158)
class UFortEnvQueryManager final : public UEnvQueryManager
{
public:
	TArray<struct FEnvQueryManagerConfig>         EnvManagerConfigPerGamePhase;                      // 0x0158(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, Protected, NativeAccessSpecifierProtected)
	struct FEnvQueryManagerConfig                 EnvManagerConfigSTW;                               // 0x0168(0x0030)(Edit, Config, GlobalConfig, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnGamePhaseChanged(EAthenaGamePhase GamePhase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnvQueryManager">();
	}
	static class UFortEnvQueryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEnvQueryManager>();
	}
};
static_assert(alignof(UFortEnvQueryManager) == 0x000008, "Wrong alignment on UFortEnvQueryManager");
static_assert(sizeof(UFortEnvQueryManager) == 0x000198, "Wrong size on UFortEnvQueryManager");
static_assert(offsetof(UFortEnvQueryManager, EnvManagerConfigPerGamePhase) == 0x000158, "Member 'UFortEnvQueryManager::EnvManagerConfigPerGamePhase' has a wrong offset!");
static_assert(offsetof(UFortEnvQueryManager, EnvManagerConfigSTW) == 0x000168, "Member 'UFortEnvQueryManager::EnvManagerConfigSTW' has a wrong offset!");

// Class FortniteAI.FortAIDataProvider_GoalProviderAbility
// 0x0000 (0x0070 - 0x0070)
class UFortAIDataProvider_GoalProviderAbility final : public UFortAIDataProvider_Ability
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_GoalProviderAbility">();
	}
	static class UFortAIDataProvider_GoalProviderAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_GoalProviderAbility>();
	}
};
static_assert(alignof(UFortAIDataProvider_GoalProviderAbility) == 0x000008, "Wrong alignment on UFortAIDataProvider_GoalProviderAbility");
static_assert(sizeof(UFortAIDataProvider_GoalProviderAbility) == 0x000070, "Wrong size on UFortAIDataProvider_GoalProviderAbility");

// Class FortniteAI.FortQueryTest_ValidSurface
// 0x0120 (0x0318 - 0x01F8)
class UFortQueryTest_ValidSurface final : public UEnvQueryTest
{
public:
	struct FAIDataProviderFloatValue              Radius;                                            // 0x01F8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              TraceOffsetUp;                                     // 0x0230(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              TraceOffsetDown;                                   // 0x0268(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceCollisionChannel;                             // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              FlatSurfaceToleranceZ;                             // 0x02A8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UPhysicalMaterial>> SurfaceMaterials;                                  // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAreSurfaceMaterialsValid;                         // 0x02F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ValidHitActorClasses;                              // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           InvalidHitActorClasses;                            // 0x0308(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_ValidSurface">();
	}
	static class UFortQueryTest_ValidSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_ValidSurface>();
	}
};
static_assert(alignof(UFortQueryTest_ValidSurface) == 0x000008, "Wrong alignment on UFortQueryTest_ValidSurface");
static_assert(sizeof(UFortQueryTest_ValidSurface) == 0x000318, "Wrong size on UFortQueryTest_ValidSurface");
static_assert(offsetof(UFortQueryTest_ValidSurface, Radius) == 0x0001F8, "Member 'UFortQueryTest_ValidSurface::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_ValidSurface, TraceOffsetUp) == 0x000230, "Member 'UFortQueryTest_ValidSurface::TraceOffsetUp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_ValidSurface, TraceOffsetDown) == 0x000268, "Member 'UFortQueryTest_ValidSurface::TraceOffsetDown' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_ValidSurface, TraceCollisionChannel) == 0x0002A0, "Member 'UFortQueryTest_ValidSurface::TraceCollisionChannel' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_ValidSurface, FlatSurfaceToleranceZ) == 0x0002A8, "Member 'UFortQueryTest_ValidSurface::FlatSurfaceToleranceZ' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_ValidSurface, SurfaceMaterials) == 0x0002E0, "Member 'UFortQueryTest_ValidSurface::SurfaceMaterials' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_ValidSurface, bAreSurfaceMaterialsValid) == 0x0002F0, "Member 'UFortQueryTest_ValidSurface::bAreSurfaceMaterialsValid' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_ValidSurface, ValidHitActorClasses) == 0x0002F8, "Member 'UFortQueryTest_ValidSurface::ValidHitActorClasses' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_ValidSurface, InvalidHitActorClasses) == 0x000308, "Member 'UFortQueryTest_ValidSurface::InvalidHitActorClasses' has a wrong offset!");

// Class FortniteAI.FortAIDataProvider_Pawn
// 0x0038 (0x0060 - 0x0028)
class UFortAIDataProvider_Pawn final : public UAIDataProvider
{
public:
	float                                         SightRadius;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRadius;                                     // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewLocationOffsetFromGround;                      // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TetheredBoxCenterLocation;                         // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetheredBoxWidth;                                  // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetheredBoxHeight;                                 // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetheredBoxEQSGridSize;                            // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetheredBoxEQSSpaceBetween;                        // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_Pawn">();
	}
	static class UFortAIDataProvider_Pawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_Pawn>();
	}
};
static_assert(alignof(UFortAIDataProvider_Pawn) == 0x000008, "Wrong alignment on UFortAIDataProvider_Pawn");
static_assert(sizeof(UFortAIDataProvider_Pawn) == 0x000060, "Wrong size on UFortAIDataProvider_Pawn");
static_assert(offsetof(UFortAIDataProvider_Pawn, SightRadius) == 0x000028, "Member 'UFortAIDataProvider_Pawn::SightRadius' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, HearingRadius) == 0x00002C, "Member 'UFortAIDataProvider_Pawn::HearingRadius' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, ViewLocationOffsetFromGround) == 0x000030, "Member 'UFortAIDataProvider_Pawn::ViewLocationOffsetFromGround' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, MaxStepHeight) == 0x000034, "Member 'UFortAIDataProvider_Pawn::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxCenterLocation) == 0x000038, "Member 'UFortAIDataProvider_Pawn::TetheredBoxCenterLocation' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxWidth) == 0x000050, "Member 'UFortAIDataProvider_Pawn::TetheredBoxWidth' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxHeight) == 0x000054, "Member 'UFortAIDataProvider_Pawn::TetheredBoxHeight' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxEQSGridSize) == 0x000058, "Member 'UFortAIDataProvider_Pawn::TetheredBoxEQSGridSize' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxEQSSpaceBetween) == 0x00005C, "Member 'UFortAIDataProvider_Pawn::TetheredBoxEQSSpaceBetween' has a wrong offset!");

// Class FortniteAI.FortSpawnPointsPercentageCurveSequence
// 0x0018 (0x0048 - 0x0030)
class UFortSpawnPointsPercentageCurveSequence final : public UDataAsset
{
public:
	TArray<struct FDataTableRowHandle>            SpawnPointsPercentageCurves;                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EFortIntensityCurveSequenceType               SequenceType;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpawnPointsPercentageCurveSequence">();
	}
	static class UFortSpawnPointsPercentageCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSpawnPointsPercentageCurveSequence>();
	}
};
static_assert(alignof(UFortSpawnPointsPercentageCurveSequence) == 0x000008, "Wrong alignment on UFortSpawnPointsPercentageCurveSequence");
static_assert(sizeof(UFortSpawnPointsPercentageCurveSequence) == 0x000048, "Wrong size on UFortSpawnPointsPercentageCurveSequence");
static_assert(offsetof(UFortSpawnPointsPercentageCurveSequence, SpawnPointsPercentageCurves) == 0x000030, "Member 'UFortSpawnPointsPercentageCurveSequence::SpawnPointsPercentageCurves' has a wrong offset!");
static_assert(offsetof(UFortSpawnPointsPercentageCurveSequence, SequenceType) == 0x000040, "Member 'UFortSpawnPointsPercentageCurveSequence::SequenceType' has a wrong offset!");

// Class FortniteAI.FortAIDirectorLODAIConfig
// 0x0050 (0x0078 - 0x0028)
class UFortAIDirectorLODAIConfig final : public UObject
{
public:
	struct FScalableFloat                         SingleAIUnitCost;                                  // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Priority;                                          // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorLODAIConfig">();
	}
	static class UFortAIDirectorLODAIConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDirectorLODAIConfig>();
	}
};
static_assert(alignof(UFortAIDirectorLODAIConfig) == 0x000008, "Wrong alignment on UFortAIDirectorLODAIConfig");
static_assert(sizeof(UFortAIDirectorLODAIConfig) == 0x000078, "Wrong size on UFortAIDirectorLODAIConfig");
static_assert(offsetof(UFortAIDirectorLODAIConfig, SingleAIUnitCost) == 0x000028, "Member 'UFortAIDirectorLODAIConfig::SingleAIUnitCost' has a wrong offset!");
static_assert(offsetof(UFortAIDirectorLODAIConfig, Priority) == 0x000050, "Member 'UFortAIDirectorLODAIConfig::Priority' has a wrong offset!");

// Class FortniteAI.FortAIDirectorDataManager
// 0x00E0 (0x0350 - 0x0270)
class AFortAIDirectorDataManager final : public AActor
{
public:
	class UObject*                                OwnerObject;                                       // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAIDirectorEventData>           EventsToTrack;                                     // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIDirectorFactorData>      FactorsToTrack;                                    // 0x0288(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0xA0];                                     // 0x0298(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortAIDirectorFactor>                 FactorsBeingTracked;                               // 0x0338(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TriggerEvent(const struct FFortAIDirectorEvent& TriggeredEvent);

	float GetAIDirectorFactorValue(EFortAIDirectorFactor AIDirectorFactor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorDataManager">();
	}
	static class AFortAIDirectorDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIDirectorDataManager>();
	}
};
static_assert(alignof(AFortAIDirectorDataManager) == 0x000008, "Wrong alignment on AFortAIDirectorDataManager");
static_assert(sizeof(AFortAIDirectorDataManager) == 0x000350, "Wrong size on AFortAIDirectorDataManager");
static_assert(offsetof(AFortAIDirectorDataManager, OwnerObject) == 0x000270, "Member 'AFortAIDirectorDataManager::OwnerObject' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, EventsToTrack) == 0x000278, "Member 'AFortAIDirectorDataManager::EventsToTrack' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, FactorsToTrack) == 0x000288, "Member 'AFortAIDirectorDataManager::FactorsToTrack' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, FactorsBeingTracked) == 0x000338, "Member 'AFortAIDirectorDataManager::FactorsBeingTracked' has a wrong offset!");

// Class FortniteAI.FortAIDirectorDataTrackingSettings
// 0x0010 (0x0040 - 0x0030)
class UFortAIDirectorDataTrackingSettings final : public UDataAsset
{
public:
	TSubclassOf<class AFortAIDirectorDataManager> PlayerDataManager;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortAIDirectorDataManager> EncounterDataManager;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorDataTrackingSettings">();
	}
	static class UFortAIDirectorDataTrackingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDirectorDataTrackingSettings>();
	}
};
static_assert(alignof(UFortAIDirectorDataTrackingSettings) == 0x000008, "Wrong alignment on UFortAIDirectorDataTrackingSettings");
static_assert(sizeof(UFortAIDirectorDataTrackingSettings) == 0x000040, "Wrong size on UFortAIDirectorDataTrackingSettings");
static_assert(offsetof(UFortAIDirectorDataTrackingSettings, PlayerDataManager) == 0x000030, "Member 'UFortAIDirectorDataTrackingSettings::PlayerDataManager' has a wrong offset!");
static_assert(offsetof(UFortAIDirectorDataTrackingSettings, EncounterDataManager) == 0x000038, "Member 'UFortAIDirectorDataTrackingSettings::EncounterDataManager' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_SteerMovement
// 0x0030 (0x00A0 - 0x0070)
class UFortAthenaBTTask_SteerMovement final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 SteerDirectionKeySelector;                         // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         bSetControlRotation : 1;                           // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_SteerMovement">();
	}
	static class UFortAthenaBTTask_SteerMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_SteerMovement>();
	}
};
static_assert(alignof(UFortAthenaBTTask_SteerMovement) == 0x000008, "Wrong alignment on UFortAthenaBTTask_SteerMovement");
static_assert(sizeof(UFortAthenaBTTask_SteerMovement) == 0x0000A0, "Wrong size on UFortAthenaBTTask_SteerMovement");
static_assert(offsetof(UFortAthenaBTTask_SteerMovement, SteerDirectionKeySelector) == 0x000070, "Member 'UFortAthenaBTTask_SteerMovement::SteerDirectionKeySelector' has a wrong offset!");

// Class FortniteAI.FortAIDirectorEventManager
// 0x0050 (0x02C0 - 0x0270)
class AFortAIDirectorEventManager final : public AActor
{
public:
	uint8                                         Pad_270[0x50];                                     // 0x0270(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorEventManager">();
	}
	static class AFortAIDirectorEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIDirectorEventManager>();
	}
};
static_assert(alignof(AFortAIDirectorEventManager) == 0x000008, "Wrong alignment on AFortAIDirectorEventManager");
static_assert(sizeof(AFortAIDirectorEventManager) == 0x0002C0, "Wrong size on AFortAIDirectorEventManager");

// Class FortniteAI.FortAIEncounterInfo
// 0x0D68 (0x0D90 - 0x0028)
class UFortAIEncounterInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAISpawnGroupProgressionInfo*       SpawnGroupProgressionInfo;                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortSpawnPointsPercentageCurveSequenceInstanceInfo SpawnPointsPercentageCurveSequence;                // 0x0040(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFortIntensityCurveSequenceInstanceInfo IntensityCurveSequence;                            // 0x0050(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BurstSpawnPointsPercentage;                        // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnPointsMultiplier;                             // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBreathers;                                     // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   LowPlayerPerformanceBreatherTimeSecondsCurve;      // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   NormalPlayerPerformanceBreatherTimeSecondsCurve;   // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   HighPlayerPerformanceBreatherTimeSecondsCurve;     // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EncounterTimeSeconds;                              // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          LockedUtilityValues;                               // 0x00A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         NumFreeUtilities;                                  // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UtilityAdjustmentPeriodSeconds;                    // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpawnDistance;                                  // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpawnDistance;                                  // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumDirections;                                     // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeDirectionsOnRest;                           // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnPointsPercentageLimit;                        // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PawnNumberLimit;                                   // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortEncounterPawnNumberCaps           PawnNumberCaps;                                    // 0x00D8(0x0018)(Protected, NativeAccessSpecifierProtected)
	float                                         SpawningIntervalSeconds;                           // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreSpawnRequeryTime;                               // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortEncounterSettingsFixedPace        EncounterSettingsFixed;                            // 0x00F8(0x0014)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterSpawnDirectionsChosen;                  // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         NextRiftReplacementTime;                           // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextSpawningTime;                                  // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnGroupCapsProfile  EncounterSpawnGroupCapsProfile;                    // 0x0128(0x0030)(NativeAccessSpecifierPublic)
	TArray<struct FFortAIEncounterSpawnGroupCapsCategory> AdditionalSpawnGroupCapsCategories;                // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnPointsProfile     EncounterSpawnPointsProfile;                       // 0x0168(0x0040)(NativeAccessSpecifierPublic)
	TArray<struct FFortAISpawnGroupUpgradeData>   AvailableUpgrades;                                 // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCurveTableRowHandle>           PawnDifficultyLevelModifiers;                      // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortAIBaseLootDropRow>         BaseLootDropRows;                                  // 0x01C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortAILootDropModifierRow>     LootDropModifierRows;                              // 0x01D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRequiresReinitializationFromProfile;              // 0x01E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   DesiredHostilityCurve;                             // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortIntensityCurveSequenceProgression* IntensitySequenceProgression;                      // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x70];                                     // 0x0208(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AliveMultiplier;                                   // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortEncounterSpawnLimitType                  SpawnLimitType;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnLimit;                                        // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnNumberLimitProgress;                           // 0x0284(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPointsLimitProgress;                          // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnLimitReached;                                // 0x028C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSpawnedAllBurstSpawnAI;                        // 0x028D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAliveCounts;                              // 0x028E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F[0x1];                                      // 0x028F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinAliveOverride;                                  // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAliveOverride;                                  // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityThreshold;                                // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeakTimeSeconds;                                   // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreatherTimeSeconds;                               // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRampTimeSeconds;                                // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenBreathesSeconds;                     // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFadeTimeSeconds;                                // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndIntensity;                                  // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndRemainingSpawnPointsPercentage;             // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompletionPercentageToDisableBreathers;            // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterAllEnemiesKilled;                       // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter, class AFortAIPawn* SpawnedEnemy)> OnEncounterEnemySpawned;                           // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterEnemySpawnFailed;                       // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterAllBurstEnemiesSpawned;                 // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter, bool bSuccessfullyCompleted)> OnEncounterCompleted;                              // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter, class AFortAIPawn* DeadPawn)> OnEncounterPawnDied;                               // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterSpawnedFinalEnemy;                      // 0x0320(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter, class ABuildingRift* Rift)> OnEncounterRiftSpawned;                            // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter, class ABuildingRift* Rift, class AController* EventInvestigator, class AActor* DamageCauser)> OnBuildingRiftBlockedShouldDie;                    // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x3];                                      // 0x0350(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisplayThreatVisuals;                             // 0x0353(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDesiredUtilities[0x10];                        // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  UtilitiesRequiredTags[0x10];                       // 0x0398(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InjectedTagForUtilityCheck;                        // 0x0598(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x4];                                      // 0x05B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLargeSpawnGroupDiscountInterval;                // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSelectionToSpawningDelay;                       // 0x05C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0x54];                                     // 0x05C4(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          CurrentDesiredUtilities;                           // 0x0618(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         UtilityRecentSelectionPenalties[0x10];             // 0x0628(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UtilityEffectivenessMeasurements[0x10];            // 0x0668(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   UtilityEffectivenessMultiplierCurve;               // 0x06A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UtilityEffectivenessInfluenceCap;                  // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BC[0x4];                                      // 0x06BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          CurrentTopUtilityPercentages;                      // 0x06C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EFortAIUtility>                        UsedTopUtilities;                                  // 0x06D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<EFortAIUtility>                        CurrentlySelectedFreeUtilities;                    // 0x06E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         NumUtilitiesConsidered;                            // 0x06F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactivityPercentage;                              // 0x06F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustUtilitiesDuringRest;                        // 0x06F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDespawnAIsDuringRest;                             // 0x06F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6FA[0x2];                                      // 0x06FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPlayerCombatFactorUpdateTime;                  // 0x06FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastUtilityAdjustTime;                             // 0x0700(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSpawnPointAdjustmentTime;                      // 0x0704(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastLargeGroupSpawnTime;                           // 0x0708(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIEncounterSpawnGroupWeights>  EnemySpawnData;                                    // 0x0710(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFortAIEncounterPIDController          EncounterPIDController;                            // 0x0720(0x0068)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CurrentSpawnPointsCap;                             // 0x0788(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentSpawnPointsUsed;                            // 0x078C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_790[0x8];                                      // 0x0790(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FailSafeMinSpawnPoints;                            // 0x0798(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79C[0x4];                                      // 0x079C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnGroupInstanceInfo>        ActiveSpawnGroups;                                 // 0x07A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         EncounterEngagementDistance;                       // 0x07B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRelevantBuildingDamagedDistance;                // 0x07B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRelevantBuildingDamagedDistance;                // 0x07B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BC[0x14];                                     // 0x07BC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentGroupSpawnPoint;                            // 0x07D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortEncounterState                           EncounterState;                                    // 0x07D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortEncounterPacingState                     PacingState;                                       // 0x07D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7DA[0x2];                                      // 0x07DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPacingStateTransitionTime;                     // 0x07DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortAIEncounterWaveProgressEstimation WaveProgressEstimate;                              // 0x07E0(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         DesiredDifficultyLevel;                            // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyLevelOverride;                           // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_804[0x4];                                      // 0x0804(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIDirector*                        MyAIDirector;                                      // 0x0808(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortGoalActorEncounterDataManagerPair> DataManagers;                                      // 0x0810(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 TargetObjective;                                   // 0x0820(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveAtNight;                                // 0x0828(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_829[0x3];                                      // 0x0829(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRiftsToUse;                                     // 0x082C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRiftsToUse;                                     // 0x0830(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRiftsUsed;                                      // 0x0834(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TStructCycleFixup<struct FFortEncounterSettings, 0x00B8, 0x08> EncounterSettings;                                 // 0x0838(0x00B8)(NativeAccessSpecifierPublic)
	float                                         EncounterStartTime;                                // 0x08F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityCurveStartTime;                           // 0x08F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TStructCycleFixup<struct FEncounterEnvironmentQueryInfo, 0x0028, 0x08> DefaultEnvironmentQueryInfo;                       // 0x08F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TStructCycleFixup<struct FEncounterEnvironmentQueryInfo, 0x0028, 0x08> FallbackEnvironmentQueryInfo;                      // 0x0920(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TStructCycleFixup<struct FEncounterEnvironmentQueryInfo, 0x0028, 0x08> OverrideEnvironmentQueryInfo;                      // 0x0948(0x0028)(NativeAccessSpecifierPublic)
	TStructCycleFixup<struct FEncounterEnvironmentQueryInfo, 0x0028, 0x08> CurrentEnvironmentQueryInfo;                       // 0x0970(0x0028)(NativeAccessSpecifierPublic)
	bool                                          bNukeWavesAtDaybreak;                              // 0x0998(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNukeWavesAtEncounterEnd;                          // 0x0999(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNukeWavesAtEncounterDeactivation;                 // 0x099A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99B[0x1];                                      // 0x099B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActiveEnemyCap;                                    // 0x099C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A0[0x8];                                      // 0x09A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentHostilityLevel;                             // 0x09A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9AC[0x4];                                      // 0x09AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterRampStarted;                            // 0x09B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterPeakStarted;                            // 0x09C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterFadeStarted;                            // 0x09D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterRestStarted;                            // 0x09E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterCombatParticipation;                    // 0x09F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFortAIEncounterInfo* Encounter)> OnEncounterOptionsChanged;                         // 0x0A00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class ABuildingRift>              RiftClassTemplate;                                 // 0x0A10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A18[0x20];                                     // 0x0A18(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AActor>, struct FFortAISpawnerData> ExternalAISpawners;                                // 0x0A38(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FFortAIEncounterQueryData              EncounterQueryData;                                // 0x0A88(0x0020)(NativeAccessSpecifierPrivate)
	class UFortAIEncounterRiftManager*            RiftManager;                                       // 0x0AA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AssociatedMissionName;                             // 0x0AB0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortMissionType                              AssociatedMissionType;                             // 0x0AC0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC1[0x3];                                      // 0x0AC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCanBeActive : 1;                                  // 0x0AC4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_AC5[0x3];                                      // 0x0AC5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAIAssignment*>              EncounterAssignments;                              // 0x0AC8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortAIAssignmentSettings*              DefaultEncounterAssignmentSettings;                // 0x0AD8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE0[0x30];                                     // 0x0AE0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxActiveAlive;                                    // 0x0B10(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnPointsUsed;                                // 0x0B14(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            OverrideSpawnPointsCurve;                          // 0x0B18(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B20[0x1F8];                                    // 0x0B20(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSendFullAnalyticsReport;                          // 0x0D18(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseAILifespans;                                   // 0x0D19(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrackCombatParticipation;                         // 0x0D1A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1B[0x5];                                      // 0x0D1B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ModifierTags;                                      // 0x0D20(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIEncounterTimedModifierTags> TimedModifierTags;                                 // 0x0D40(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GameContextTags;                                   // 0x0D50(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class AFortGameplayMutator_AILevelVariance*   AILevelMutator;                                    // 0x0D70(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortGameplayMutator_AIEncounterModifierTags*> EncounterModifierTagsMutators;                     // 0x0D78(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D88[0x8];                                      // 0x0D88(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFortAIAssignment* CreateEncounterAssignment(class UFortAIAssignmentSettings* AssignmentSettings, class AActor* GoalActor);
	void DespawnPendingAndCurrentAI();
	class AFortAIDirectorDataManager* GetEncounterDataManager();
	float GetEncounterTimeSeconds();
	bool GroupHasAIRemainingToSpawn(const struct FFortAISpawnerData& FortAISpawnerData);
	void NotifyRiftDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnEncounterPawnDamaged(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnFadeStarted();
	void OnGameDifficultyChanged();
	void OnGoalTakeDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnPeakStarted();
	void OnRampStarted();
	void OnRestStarted();
	void RegisterAISpawner(class AActor* InAISpawner);
	void RequestActivation(int32 ActivationDelay);
	void SetEncounterActivationState(bool bEncounterActivityState);
	void SetNukeWavesAtEncounterEnd(bool bNuke);
	void SetPawnNumberLimit(int32 InPawnNumberLimit);
	class AFortAIPawn* SpawnAIPawnReservedForEnemySpawner(class AActor* EnemySpawner, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	void SpawnTestAIGroup(const class UFortAISpawnGroup* SpawnGroupToSpawn, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, class AActor* SpawnSource, const TArray<class UFortAbilitySet*>& AbilitySetsToGrantOnSpawn, const struct FFortAISpawnGroupUpgradeData& UpgradeData, bool bAllowAssigningToExternalSpawners, float SecondsBetweenSpawns);
	void UnRegisterAISpawner(class AActor* InAISpawner);

	bool EncounterHasReservedSpawnRequestForEnemySpawner(class AActor* EnemySpawner) const;
	bool GetCurrentSpawnAreaDirections(TArray<EFortEncounterDirection>* OutDirections) const;
	void GetEncounterAssignmentGoalActors(TArray<class AActor*>* OutGoalActors) const;
	void GetEncounterGameplayTags(struct FGameplayTagContainer* OutEncounterTags) const;
	class AActor* GetEncounterQueryActor() const;
	void GetEncounterRifts(TArray<class ABuildingRift*>* OutRifts) const;
	int32 GetPawnNumberLimit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterInfo">();
	}
	static class UFortAIEncounterInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterInfo>();
	}
};
static_assert(alignof(UFortAIEncounterInfo) == 0x000008, "Wrong alignment on UFortAIEncounterInfo");
static_assert(sizeof(UFortAIEncounterInfo) == 0x000D90, "Wrong size on UFortAIEncounterInfo");
static_assert(offsetof(UFortAIEncounterInfo, SpawnGroupProgressionInfo) == 0x000038, "Member 'UFortAIEncounterInfo::SpawnGroupProgressionInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsPercentageCurveSequence) == 0x000040, "Member 'UFortAIEncounterInfo::SpawnPointsPercentageCurveSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, IntensityCurveSequence) == 0x000050, "Member 'UFortAIEncounterInfo::IntensityCurveSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BurstSpawnPointsPercentage) == 0x000060, "Member 'UFortAIEncounterInfo::BurstSpawnPointsPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsMultiplier) == 0x000064, "Member 'UFortAIEncounterInfo::SpawnPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bUseBreathers) == 0x000068, "Member 'UFortAIEncounterInfo::bUseBreathers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LowPlayerPerformanceBreatherTimeSecondsCurve) == 0x000070, "Member 'UFortAIEncounterInfo::LowPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NormalPlayerPerformanceBreatherTimeSecondsCurve) == 0x000080, "Member 'UFortAIEncounterInfo::NormalPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HighPlayerPerformanceBreatherTimeSecondsCurve) == 0x000090, "Member 'UFortAIEncounterInfo::HighPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterTimeSeconds) == 0x0000A0, "Member 'UFortAIEncounterInfo::EncounterTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LockedUtilityValues) == 0x0000A8, "Member 'UFortAIEncounterInfo::LockedUtilityValues' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumFreeUtilities) == 0x0000B8, "Member 'UFortAIEncounterInfo::NumFreeUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityAdjustmentPeriodSeconds) == 0x0000BC, "Member 'UFortAIEncounterInfo::UtilityAdjustmentPeriodSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinSpawnDistance) == 0x0000C0, "Member 'UFortAIEncounterInfo::MinSpawnDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxSpawnDistance) == 0x0000C4, "Member 'UFortAIEncounterInfo::MaxSpawnDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumDirections) == 0x0000C8, "Member 'UFortAIEncounterInfo::NumDirections' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bChangeDirectionsOnRest) == 0x0000CC, "Member 'UFortAIEncounterInfo::bChangeDirectionsOnRest' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsPercentageLimit) == 0x0000D0, "Member 'UFortAIEncounterInfo::SpawnPointsPercentageLimit' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnNumberLimit) == 0x0000D4, "Member 'UFortAIEncounterInfo::PawnNumberLimit' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnNumberCaps) == 0x0000D8, "Member 'UFortAIEncounterInfo::PawnNumberCaps' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawningIntervalSeconds) == 0x0000F0, "Member 'UFortAIEncounterInfo::SpawningIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PreSpawnRequeryTime) == 0x0000F4, "Member 'UFortAIEncounterInfo::PreSpawnRequeryTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSettingsFixed) == 0x0000F8, "Member 'UFortAIEncounterInfo::EncounterSettingsFixed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterSpawnDirectionsChosen) == 0x000110, "Member 'UFortAIEncounterInfo::OnEncounterSpawnDirectionsChosen' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NextRiftReplacementTime) == 0x000120, "Member 'UFortAIEncounterInfo::NextRiftReplacementTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NextSpawningTime) == 0x000124, "Member 'UFortAIEncounterInfo::NextSpawningTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSpawnGroupCapsProfile) == 0x000128, "Member 'UFortAIEncounterInfo::EncounterSpawnGroupCapsProfile' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AdditionalSpawnGroupCapsCategories) == 0x000158, "Member 'UFortAIEncounterInfo::AdditionalSpawnGroupCapsCategories' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSpawnPointsProfile) == 0x000168, "Member 'UFortAIEncounterInfo::EncounterSpawnPointsProfile' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AvailableUpgrades) == 0x0001A8, "Member 'UFortAIEncounterInfo::AvailableUpgrades' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnDifficultyLevelModifiers) == 0x0001B8, "Member 'UFortAIEncounterInfo::PawnDifficultyLevelModifiers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BaseLootDropRows) == 0x0001C8, "Member 'UFortAIEncounterInfo::BaseLootDropRows' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LootDropModifierRows) == 0x0001D8, "Member 'UFortAIEncounterInfo::LootDropModifierRows' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bRequiresReinitializationFromProfile) == 0x0001E8, "Member 'UFortAIEncounterInfo::bRequiresReinitializationFromProfile' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DesiredHostilityCurve) == 0x0001F0, "Member 'UFortAIEncounterInfo::DesiredHostilityCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, IntensitySequenceProgression) == 0x000200, "Member 'UFortAIEncounterInfo::IntensitySequenceProgression' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AliveMultiplier) == 0x000278, "Member 'UFortAIEncounterInfo::AliveMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnLimitType) == 0x00027C, "Member 'UFortAIEncounterInfo::SpawnLimitType' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnLimit) == 0x000280, "Member 'UFortAIEncounterInfo::SpawnLimit' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnNumberLimitProgress) == 0x000284, "Member 'UFortAIEncounterInfo::PawnNumberLimitProgress' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsLimitProgress) == 0x000288, "Member 'UFortAIEncounterInfo::SpawnPointsLimitProgress' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bSpawnLimitReached) == 0x00028C, "Member 'UFortAIEncounterInfo::bSpawnLimitReached' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bHasSpawnedAllBurstSpawnAI) == 0x00028D, "Member 'UFortAIEncounterInfo::bHasSpawnedAllBurstSpawnAI' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bOverrideAliveCounts) == 0x00028E, "Member 'UFortAIEncounterInfo::bOverrideAliveCounts' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinAliveOverride) == 0x000290, "Member 'UFortAIEncounterInfo::MinAliveOverride' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxAliveOverride) == 0x000294, "Member 'UFortAIEncounterInfo::MaxAliveOverride' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HostilityThreshold) == 0x000298, "Member 'UFortAIEncounterInfo::HostilityThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PeakTimeSeconds) == 0x00029C, "Member 'UFortAIEncounterInfo::PeakTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BreatherTimeSeconds) == 0x0002A0, "Member 'UFortAIEncounterInfo::BreatherTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxRampTimeSeconds) == 0x0002A4, "Member 'UFortAIEncounterInfo::MaxRampTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinTimeBetweenBreathesSeconds) == 0x0002A8, "Member 'UFortAIEncounterInfo::MinTimeBetweenBreathesSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxFadeTimeSeconds) == 0x0002AC, "Member 'UFortAIEncounterInfo::MaxFadeTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FadeEndIntensity) == 0x0002B0, "Member 'UFortAIEncounterInfo::FadeEndIntensity' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FadeEndRemainingSpawnPointsPercentage) == 0x0002B4, "Member 'UFortAIEncounterInfo::FadeEndRemainingSpawnPointsPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CompletionPercentageToDisableBreathers) == 0x0002B8, "Member 'UFortAIEncounterInfo::CompletionPercentageToDisableBreathers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterAllEnemiesKilled) == 0x0002C0, "Member 'UFortAIEncounterInfo::OnEncounterAllEnemiesKilled' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterEnemySpawned) == 0x0002D0, "Member 'UFortAIEncounterInfo::OnEncounterEnemySpawned' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterEnemySpawnFailed) == 0x0002E0, "Member 'UFortAIEncounterInfo::OnEncounterEnemySpawnFailed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterAllBurstEnemiesSpawned) == 0x0002F0, "Member 'UFortAIEncounterInfo::OnEncounterAllBurstEnemiesSpawned' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterCompleted) == 0x000300, "Member 'UFortAIEncounterInfo::OnEncounterCompleted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterPawnDied) == 0x000310, "Member 'UFortAIEncounterInfo::OnEncounterPawnDied' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterSpawnedFinalEnemy) == 0x000320, "Member 'UFortAIEncounterInfo::OnEncounterSpawnedFinalEnemy' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterRiftSpawned) == 0x000330, "Member 'UFortAIEncounterInfo::OnEncounterRiftSpawned' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnBuildingRiftBlockedShouldDie) == 0x000340, "Member 'UFortAIEncounterInfo::OnBuildingRiftBlockedShouldDie' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bDisplayThreatVisuals) == 0x000353, "Member 'UFortAIEncounterInfo::bDisplayThreatVisuals' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BaseDesiredUtilities) == 0x000354, "Member 'UFortAIEncounterInfo::BaseDesiredUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilitiesRequiredTags) == 0x000398, "Member 'UFortAIEncounterInfo::UtilitiesRequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, InjectedTagForUtilityCheck) == 0x000598, "Member 'UFortAIEncounterInfo::InjectedTagForUtilityCheck' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxLargeSpawnGroupDiscountInterval) == 0x0005BC, "Member 'UFortAIEncounterInfo::MaxLargeSpawnGroupDiscountInterval' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxSelectionToSpawningDelay) == 0x0005C0, "Member 'UFortAIEncounterInfo::MaxSelectionToSpawningDelay' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentDesiredUtilities) == 0x000618, "Member 'UFortAIEncounterInfo::CurrentDesiredUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityRecentSelectionPenalties) == 0x000628, "Member 'UFortAIEncounterInfo::UtilityRecentSelectionPenalties' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityEffectivenessMeasurements) == 0x000668, "Member 'UFortAIEncounterInfo::UtilityEffectivenessMeasurements' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityEffectivenessMultiplierCurve) == 0x0006A8, "Member 'UFortAIEncounterInfo::UtilityEffectivenessMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityEffectivenessInfluenceCap) == 0x0006B8, "Member 'UFortAIEncounterInfo::UtilityEffectivenessInfluenceCap' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentTopUtilityPercentages) == 0x0006C0, "Member 'UFortAIEncounterInfo::CurrentTopUtilityPercentages' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UsedTopUtilities) == 0x0006D0, "Member 'UFortAIEncounterInfo::UsedTopUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentlySelectedFreeUtilities) == 0x0006E0, "Member 'UFortAIEncounterInfo::CurrentlySelectedFreeUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumUtilitiesConsidered) == 0x0006F0, "Member 'UFortAIEncounterInfo::NumUtilitiesConsidered' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ReactivityPercentage) == 0x0006F4, "Member 'UFortAIEncounterInfo::ReactivityPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bAdjustUtilitiesDuringRest) == 0x0006F8, "Member 'UFortAIEncounterInfo::bAdjustUtilitiesDuringRest' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bDespawnAIsDuringRest) == 0x0006F9, "Member 'UFortAIEncounterInfo::bDespawnAIsDuringRest' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastPlayerCombatFactorUpdateTime) == 0x0006FC, "Member 'UFortAIEncounterInfo::LastPlayerCombatFactorUpdateTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastUtilityAdjustTime) == 0x000700, "Member 'UFortAIEncounterInfo::LastUtilityAdjustTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastSpawnPointAdjustmentTime) == 0x000704, "Member 'UFortAIEncounterInfo::LastSpawnPointAdjustmentTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastLargeGroupSpawnTime) == 0x000708, "Member 'UFortAIEncounterInfo::LastLargeGroupSpawnTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EnemySpawnData) == 0x000710, "Member 'UFortAIEncounterInfo::EnemySpawnData' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterPIDController) == 0x000720, "Member 'UFortAIEncounterInfo::EncounterPIDController' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentSpawnPointsCap) == 0x000788, "Member 'UFortAIEncounterInfo::CurrentSpawnPointsCap' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentSpawnPointsUsed) == 0x00078C, "Member 'UFortAIEncounterInfo::CurrentSpawnPointsUsed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FailSafeMinSpawnPoints) == 0x000798, "Member 'UFortAIEncounterInfo::FailSafeMinSpawnPoints' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ActiveSpawnGroups) == 0x0007A0, "Member 'UFortAIEncounterInfo::ActiveSpawnGroups' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterEngagementDistance) == 0x0007B0, "Member 'UFortAIEncounterInfo::EncounterEngagementDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinRelevantBuildingDamagedDistance) == 0x0007B4, "Member 'UFortAIEncounterInfo::MinRelevantBuildingDamagedDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxRelevantBuildingDamagedDistance) == 0x0007B8, "Member 'UFortAIEncounterInfo::MaxRelevantBuildingDamagedDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentGroupSpawnPoint) == 0x0007D0, "Member 'UFortAIEncounterInfo::CurrentGroupSpawnPoint' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterState) == 0x0007D8, "Member 'UFortAIEncounterInfo::EncounterState' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PacingState) == 0x0007D9, "Member 'UFortAIEncounterInfo::PacingState' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastPacingStateTransitionTime) == 0x0007DC, "Member 'UFortAIEncounterInfo::LastPacingStateTransitionTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, WaveProgressEstimate) == 0x0007E0, "Member 'UFortAIEncounterInfo::WaveProgressEstimate' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DesiredDifficultyLevel) == 0x0007FC, "Member 'UFortAIEncounterInfo::DesiredDifficultyLevel' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DifficultyLevelOverride) == 0x000800, "Member 'UFortAIEncounterInfo::DifficultyLevelOverride' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MyAIDirector) == 0x000808, "Member 'UFortAIEncounterInfo::MyAIDirector' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DataManagers) == 0x000810, "Member 'UFortAIEncounterInfo::DataManagers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, TargetObjective) == 0x000820, "Member 'UFortAIEncounterInfo::TargetObjective' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bOnlyActiveAtNight) == 0x000828, "Member 'UFortAIEncounterInfo::bOnlyActiveAtNight' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumRiftsToUse) == 0x00082C, "Member 'UFortAIEncounterInfo::NumRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinRiftsToUse) == 0x000830, "Member 'UFortAIEncounterInfo::MinRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumRiftsUsed) == 0x000834, "Member 'UFortAIEncounterInfo::NumRiftsUsed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSettings) == 0x000838, "Member 'UFortAIEncounterInfo::EncounterSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterStartTime) == 0x0008F0, "Member 'UFortAIEncounterInfo::EncounterStartTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HostilityCurveStartTime) == 0x0008F4, "Member 'UFortAIEncounterInfo::HostilityCurveStartTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DefaultEnvironmentQueryInfo) == 0x0008F8, "Member 'UFortAIEncounterInfo::DefaultEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FallbackEnvironmentQueryInfo) == 0x000920, "Member 'UFortAIEncounterInfo::FallbackEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OverrideEnvironmentQueryInfo) == 0x000948, "Member 'UFortAIEncounterInfo::OverrideEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentEnvironmentQueryInfo) == 0x000970, "Member 'UFortAIEncounterInfo::CurrentEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bNukeWavesAtDaybreak) == 0x000998, "Member 'UFortAIEncounterInfo::bNukeWavesAtDaybreak' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bNukeWavesAtEncounterEnd) == 0x000999, "Member 'UFortAIEncounterInfo::bNukeWavesAtEncounterEnd' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bNukeWavesAtEncounterDeactivation) == 0x00099A, "Member 'UFortAIEncounterInfo::bNukeWavesAtEncounterDeactivation' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ActiveEnemyCap) == 0x00099C, "Member 'UFortAIEncounterInfo::ActiveEnemyCap' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentHostilityLevel) == 0x0009A8, "Member 'UFortAIEncounterInfo::CurrentHostilityLevel' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterRampStarted) == 0x0009B0, "Member 'UFortAIEncounterInfo::OnEncounterRampStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterPeakStarted) == 0x0009C0, "Member 'UFortAIEncounterInfo::OnEncounterPeakStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterFadeStarted) == 0x0009D0, "Member 'UFortAIEncounterInfo::OnEncounterFadeStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterRestStarted) == 0x0009E0, "Member 'UFortAIEncounterInfo::OnEncounterRestStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterCombatParticipation) == 0x0009F0, "Member 'UFortAIEncounterInfo::OnEncounterCombatParticipation' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterOptionsChanged) == 0x000A00, "Member 'UFortAIEncounterInfo::OnEncounterOptionsChanged' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, RiftClassTemplate) == 0x000A10, "Member 'UFortAIEncounterInfo::RiftClassTemplate' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ExternalAISpawners) == 0x000A38, "Member 'UFortAIEncounterInfo::ExternalAISpawners' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterQueryData) == 0x000A88, "Member 'UFortAIEncounterInfo::EncounterQueryData' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, RiftManager) == 0x000AA8, "Member 'UFortAIEncounterInfo::RiftManager' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AssociatedMissionName) == 0x000AB0, "Member 'UFortAIEncounterInfo::AssociatedMissionName' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AssociatedMissionType) == 0x000AC0, "Member 'UFortAIEncounterInfo::AssociatedMissionType' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterAssignments) == 0x000AC8, "Member 'UFortAIEncounterInfo::EncounterAssignments' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DefaultEncounterAssignmentSettings) == 0x000AD8, "Member 'UFortAIEncounterInfo::DefaultEncounterAssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxActiveAlive) == 0x000B10, "Member 'UFortAIEncounterInfo::MaxActiveAlive' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxSpawnPointsUsed) == 0x000B14, "Member 'UFortAIEncounterInfo::MaxSpawnPointsUsed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OverrideSpawnPointsCurve) == 0x000B18, "Member 'UFortAIEncounterInfo::OverrideSpawnPointsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bSendFullAnalyticsReport) == 0x000D18, "Member 'UFortAIEncounterInfo::bSendFullAnalyticsReport' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bUseAILifespans) == 0x000D19, "Member 'UFortAIEncounterInfo::bUseAILifespans' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bTrackCombatParticipation) == 0x000D1A, "Member 'UFortAIEncounterInfo::bTrackCombatParticipation' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ModifierTags) == 0x000D20, "Member 'UFortAIEncounterInfo::ModifierTags' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, TimedModifierTags) == 0x000D40, "Member 'UFortAIEncounterInfo::TimedModifierTags' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, GameContextTags) == 0x000D50, "Member 'UFortAIEncounterInfo::GameContextTags' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AILevelMutator) == 0x000D70, "Member 'UFortAIEncounterInfo::AILevelMutator' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterModifierTagsMutators) == 0x000D78, "Member 'UFortAIEncounterInfo::EncounterModifierTagsMutators' has a wrong offset!");

// Class FortniteAI.FortPlacedPawnMarker
// 0x0000 (0x0298 - 0x0298)
class AFortPlacedPawnMarker final : public ANavigationObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlacedPawnMarker">();
	}
	static class AFortPlacedPawnMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlacedPawnMarker>();
	}
};
static_assert(alignof(AFortPlacedPawnMarker) == 0x000008, "Wrong alignment on AFortPlacedPawnMarker");
static_assert(sizeof(AFortPlacedPawnMarker) == 0x000298, "Wrong size on AFortPlacedPawnMarker");

// Class FortniteAI.FortAIEncounterRiftManager
// 0x0280 (0x02A8 - 0x0028)
class UFortAIEncounterRiftManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIEncounterInfo*                   MyEncounter;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortAIDirector*                        AIDirector;                                        // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnArea              CurrentSpawnArea;                                  // 0x0048(0x0058)(NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnArea              FutureSpawnArea;                                   // 0x00A0(0x0058)(NativeAccessSpecifierPublic)
	float                                         UpdateIntervalTimeSeconds;                         // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRiftsToUse;                                     // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRiftsToUse;                                     // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TStructCycleFixup<struct FFortEncounterSettings, 0x00B8, 0x08> EncounterSettings;                                 // 0x0108(0x00B8)(NativeAccessSpecifierPublic)
	float                                         ExtraSpawnLocationPercentage;                      // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TStructCycleFixup<struct FEncounterEnvironmentQueryInfo, 0x0028, 0x08> CurrentEnvironmentQueryInfo;                       // 0x01C8(0x0028)(NativeAccessSpecifierPublic)
	TStructCycleFixup<struct FEncounterEnvironmentQueryInfo, 0x0028, 0x08> FallbackEnvironmentQueryInfo;                      // 0x01F0(0x0028)(NativeAccessSpecifierPublic)
	struct FFortAIEncounterQueryDirectionTracker  EncounterQueryDirectionTracker;                    // 0x0218(0x0048)(NativeAccessSpecifierPublic)
	TSubclassOf<class ABuildingRift>              RiftClassTemplate;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastObjectiveBatchPathCostUpdateTime;              // 0x0268(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPlayerBatchPathCostUpdateTime;                 // 0x026C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x38];                                     // 0x0270(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AFortMission* GetAssociatedMission() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterRiftManager">();
	}
	static class UFortAIEncounterRiftManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterRiftManager>();
	}
};
static_assert(alignof(UFortAIEncounterRiftManager) == 0x000008, "Wrong alignment on UFortAIEncounterRiftManager");
static_assert(sizeof(UFortAIEncounterRiftManager) == 0x0002A8, "Wrong size on UFortAIEncounterRiftManager");
static_assert(offsetof(UFortAIEncounterRiftManager, MyEncounter) == 0x000038, "Member 'UFortAIEncounterRiftManager::MyEncounter' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, AIDirector) == 0x000040, "Member 'UFortAIEncounterRiftManager::AIDirector' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, CurrentSpawnArea) == 0x000048, "Member 'UFortAIEncounterRiftManager::CurrentSpawnArea' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, FutureSpawnArea) == 0x0000A0, "Member 'UFortAIEncounterRiftManager::FutureSpawnArea' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, UpdateIntervalTimeSeconds) == 0x0000F8, "Member 'UFortAIEncounterRiftManager::UpdateIntervalTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, NumRiftsToUse) == 0x0000FC, "Member 'UFortAIEncounterRiftManager::NumRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, MinRiftsToUse) == 0x000100, "Member 'UFortAIEncounterRiftManager::MinRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, EncounterSettings) == 0x000108, "Member 'UFortAIEncounterRiftManager::EncounterSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, ExtraSpawnLocationPercentage) == 0x0001C0, "Member 'UFortAIEncounterRiftManager::ExtraSpawnLocationPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, CurrentEnvironmentQueryInfo) == 0x0001C8, "Member 'UFortAIEncounterRiftManager::CurrentEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, FallbackEnvironmentQueryInfo) == 0x0001F0, "Member 'UFortAIEncounterRiftManager::FallbackEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, EncounterQueryDirectionTracker) == 0x000218, "Member 'UFortAIEncounterRiftManager::EncounterQueryDirectionTracker' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, RiftClassTemplate) == 0x000260, "Member 'UFortAIEncounterRiftManager::RiftClassTemplate' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, LastObjectiveBatchPathCostUpdateTime) == 0x000268, "Member 'UFortAIEncounterRiftManager::LastObjectiveBatchPathCostUpdateTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, LastPlayerBatchPathCostUpdateTime) == 0x00026C, "Member 'UFortAIEncounterRiftManager::LastPlayerBatchPathCostUpdateTime' has a wrong offset!");

// Class FortniteAI.FortAIEncounterSequence
// 0x0170 (0x0198 - 0x0028)
class UFortAIEncounterSequence final : public UObject
{
public:
	struct FFortGeneratedEncounterSequence        GeneratedEncounterSequence;                        // 0x0028(0x0030)(Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentEncounterIndexInSequence;                   // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIEncounterInfo*                   CurrentEncounter;                                  // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAIDirector*                        AssociatedAIDirector;                              // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMission*                           AssociatedMission;                                 // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         TargetActors;                                      // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UFortAIAssignmentSettings*              AssignmentSettings;                                // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TStructCycleFixup<struct FEncounterEnvironmentQueryInfo, 0x0028, 0x08> OverrideEnvironmentQueryInfo;                      // 0x0090(0x0028)(Protected, NativeAccessSpecifierProtected)
	class AActor*                                 OptionalQueryActor;                                // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InjectedTags;                                      // 0x00C0(0x0020)(Protected, NativeAccessSpecifierProtected)
	TStructCycleFixup<struct FFortEncounterSettings, 0x00B8, 0x08> EncounterSettings;                                 // 0x00E0(0x00B8)(Protected, NativeAccessSpecifierProtected)

public:
	EFortEncounterSequenceResult Last();
	EFortEncounterSequenceResult Next();
	EFortEncounterSequenceResult Previous();
	void SetEncounterStartingData(const TArray<class AActor*>& InTargetActors, class UFortAIAssignmentSettings* InAssignmentSettings, const struct FEncounterEnvironmentQueryInfo& InOverrideEnvironmentQueryInfo, class AActor* InOptionalQueryActor, const struct FGameplayTagContainer& InInjectedTags, const struct FFortEncounterSettings& InEncounterSettings);
	class UFortAIEncounterInfo* StartCurrentEncounter(EFortEncounterSequenceResult* OutRequestResult, const TArray<class AActor*>& InTargetActors, class UFortAIAssignmentSettings* InAssignmentSettings, const struct FEncounterEnvironmentQueryInfo& InOverrideEnvironmentQueryInfo, class AActor* InOptionalQueryActor, const struct FGameplayTagContainer& InInjectedTags, const struct FFortEncounterSettings& InEncounterSettings, int32 ActivationDelay);
	class UFortAIEncounterInfo* StartCurrentEncounterWithSavedData(EFortEncounterSequenceResult* OutRequestResult, int32 ActivationDelay);
	void StopCurrentEncounter();

	bool EncounterBelongsToSequence(class UFortAIEncounterInfo* InEncounter) const;
	class UFortAIEncounterInfo* GetCurrentEncounter() const;
	int32 GetEncounterIndexInSequence() const;
	int32 GetNumEncountersInSequence() const;
	bool HasEncounter() const;
	bool IsOnFinalIndexInSequence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterSequence">();
	}
	static class UFortAIEncounterSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterSequence>();
	}
};
static_assert(alignof(UFortAIEncounterSequence) == 0x000008, "Wrong alignment on UFortAIEncounterSequence");
static_assert(sizeof(UFortAIEncounterSequence) == 0x000198, "Wrong size on UFortAIEncounterSequence");
static_assert(offsetof(UFortAIEncounterSequence, GeneratedEncounterSequence) == 0x000028, "Member 'UFortAIEncounterSequence::GeneratedEncounterSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, CurrentEncounterIndexInSequence) == 0x000058, "Member 'UFortAIEncounterSequence::CurrentEncounterIndexInSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, CurrentEncounter) == 0x000060, "Member 'UFortAIEncounterSequence::CurrentEncounter' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, AssociatedAIDirector) == 0x000068, "Member 'UFortAIEncounterSequence::AssociatedAIDirector' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, AssociatedMission) == 0x000070, "Member 'UFortAIEncounterSequence::AssociatedMission' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, TargetActors) == 0x000078, "Member 'UFortAIEncounterSequence::TargetActors' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, AssignmentSettings) == 0x000088, "Member 'UFortAIEncounterSequence::AssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, OverrideEnvironmentQueryInfo) == 0x000090, "Member 'UFortAIEncounterSequence::OverrideEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, OptionalQueryActor) == 0x0000B8, "Member 'UFortAIEncounterSequence::OptionalQueryActor' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, InjectedTags) == 0x0000C0, "Member 'UFortAIEncounterSequence::InjectedTags' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, EncounterSettings) == 0x0000E0, "Member 'UFortAIEncounterSequence::EncounterSettings' has a wrong offset!");

// Class FortniteAI.FortAIEncounterTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAIEncounterTargetInterface final : public IInterface
{
public:
	float GetObjectiveCompletionPercentage();
	bool IsFloatingTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterTargetInterface">();
	}
	static class IFortAIEncounterTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIEncounterTargetInterface>();
	}
};
static_assert(alignof(IFortAIEncounterTargetInterface) == 0x000008, "Wrong alignment on IFortAIEncounterTargetInterface");
static_assert(sizeof(IFortAIEncounterTargetInterface) == 0x000028, "Wrong size on IFortAIEncounterTargetInterface");

// Class FortniteAI.FortAIEnvironmentalDangerSourceInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAIEnvironmentalDangerSourceInterface final : public IInterface
{
public:
	float GetDangerAtLocation(const struct FVector& Location) const;
	bool GetDangerSourceActive() const;
	struct FBox GetDangerSourceBounds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEnvironmentalDangerSourceInterface">();
	}
	static class IFortAIEnvironmentalDangerSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIEnvironmentalDangerSourceInterface>();
	}
};
static_assert(alignof(IFortAIEnvironmentalDangerSourceInterface) == 0x000008, "Wrong alignment on IFortAIEnvironmentalDangerSourceInterface");
static_assert(sizeof(IFortAIEnvironmentalDangerSourceInterface) == 0x000028, "Wrong size on IFortAIEnvironmentalDangerSourceInterface");

// Class FortniteAI.FortNavArea_WoodenWall
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_WoodenWall final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_WoodenWall">();
	}
	static class UFortNavArea_WoodenWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_WoodenWall>();
	}
};
static_assert(alignof(UFortNavArea_WoodenWall) == 0x000008, "Wrong alignment on UFortNavArea_WoodenWall");
static_assert(sizeof(UFortNavArea_WoodenWall) == 0x000050, "Wrong size on UFortNavArea_WoodenWall");

// Class FortniteAI.FortAIFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortAIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UAthenaAISpawner* GetAISpawner(class UObject* WorldContextObject);
	static class UFortAthenaAIRuntimeParameters* GetOrCreateAIRuntimeParameters(const class AAIController* AIController, const TSubclassOf<class UFortAthenaAIRuntimeParameters> ParametersClass);
	static bool IsConcealedByPerceptionModifiers(const class UObject* WorldContextObject, const struct FVector& ObserverLocation, const struct FVector& TargetLocation, float* OutConcealment);
	static void MakeNoiseEvent(class AActor* NoiseMaker, const float MaxRange, const class FName NoiseTag);
	static void MakeNoiseEventAtLocation(class AActor* NoiseMaker, const float MaxRange, const struct FVector& NoiseLocation, const class FName NoiseTag);
	static void RequestNavUpdateForBuilding(class ABuildingActor* BuildingActor);
	static void SetHearingRange(class AActor* AIAgent, float Range);
	static bool TeleportAIPawn(class AFortAIPawn* AIPawn, const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bIgnoreCollision);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFunctionLibrary">();
	}
	static class UFortAIFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFunctionLibrary>();
	}
};
static_assert(alignof(UFortAIFunctionLibrary) == 0x000008, "Wrong alignment on UFortAIFunctionLibrary");
static_assert(sizeof(UFortAIFunctionLibrary) == 0x000028, "Wrong size on UFortAIFunctionLibrary");

// Class FortniteAI.FortNavigationFilter_NoSmashing
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_NoSmashing final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_NoSmashing">();
	}
	static class UFortNavigationFilter_NoSmashing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_NoSmashing>();
	}
};
static_assert(alignof(UFortNavigationFilter_NoSmashing) == 0x000008, "Wrong alignment on UFortNavigationFilter_NoSmashing");
static_assert(sizeof(UFortNavigationFilter_NoSmashing) == 0x000048, "Wrong size on UFortNavigationFilter_NoSmashing");

// Class FortniteAI.FortAIGoalComponent
// 0x0050 (0x0158 - 0x0108)
class UFortAIGoalComponent : public UAIGoalComponent
{
public:
	TMap<EFortAILODLevel, struct FScalableFloat>  AssignmentUpdatePeriods;                           // 0x0108(0x0050)(Edit, EditFixedSize, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalComponent">();
	}
	static class UFortAIGoalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIGoalComponent>();
	}
};
static_assert(alignof(UFortAIGoalComponent) == 0x000008, "Wrong alignment on UFortAIGoalComponent");
static_assert(sizeof(UFortAIGoalComponent) == 0x000158, "Wrong size on UFortAIGoalComponent");
static_assert(offsetof(UFortAIGoalComponent, AssignmentUpdatePeriods) == 0x000108, "Member 'UFortAIGoalComponent::AssignmentUpdatePeriods' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_Glide
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTTask_Glide final : public UBTTaskNode
{
public:
	class FName                                   ExecutionStatusKeyName;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GlideDestinationKeyName;                           // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_Glide">();
	}
	static class UFortAthenaBTTask_Glide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_Glide>();
	}
};
static_assert(alignof(UFortAthenaBTTask_Glide) == 0x000008, "Wrong alignment on UFortAthenaBTTask_Glide");
static_assert(sizeof(UFortAthenaBTTask_Glide) == 0x000080, "Wrong size on UFortAthenaBTTask_Glide");
static_assert(offsetof(UFortAthenaBTTask_Glide, ExecutionStatusKeyName) == 0x000070, "Member 'UFortAthenaBTTask_Glide::ExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Glide, GlideDestinationKeyName) == 0x000074, "Member 'UFortAthenaBTTask_Glide::GlideDestinationKeyName' has a wrong offset!");

// Class FortniteAI.FortAIGoalManager
// 0x0168 (0x03D8 - 0x0270)
class AFortAIGoalManager final : public AActor
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAIAssignment*>              WorldAssignments;                                  // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFortAIAssignment*>              WorldEnemyAssignments;                             // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFortAIAssignment*                      DefaultAttackPlayersAssignment;                    // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x60];                                     // 0x02A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEnvQuery*>                      CombinedQueries;                                   // 0x0300(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x50];                                     // 0x0310(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIAssignmentSettings*              DefaultEncounterAssignmentSettings;                // 0x0360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIAssignmentSettings*              DefaultEnemyAssignmentSettings;                    // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPawnGoalSelectionTableEntry>   PawnGoalSelectionTable;                            // 0x0370(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x58];                                     // 0x0380(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddGoalsToWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	static void AddGoalToWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const struct FFortAIGoalInfo& GoalInfo);
	static void CreateWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& WorldAssignmentIdentifier, class UFortAIAssignmentSettings* AssignmentSettings, TSubclassOf<class UFortAIGoalProvider> GoalProvider, struct FFortAIAssignmentIdentifier* AssignmentIdentifier, EAssignmentCreationResult* CreationResult);
	static void MakeGoalFromActor(struct FFortAIGoalInfo* Goal, const class UObject* WorldContextObject, class AActor* GoalActor, bool bActorAlwaysPerceived, bool bGoalActorAllowsUndermining);
	static void MakeGoalFromLocation(struct FFortAIGoalInfo* Goal, const class UObject* WorldContextObject, const struct FVector& GoalLocation);
	static void MakeGoalsFromActors(TArray<struct FFortAIGoalInfo>* Goals, const class UObject* WorldContextObject, const TArray<class AActor*>& GoalActors, bool bActorsAlwaysPerceived, bool bGoalActorsAllowUndermining);
	static void MakeGoalsFromLocations(TArray<struct FFortAIGoalInfo>* Goals, const class UObject* WorldContextObject, const TArray<struct FVector>& GoalLocations);
	static void MakeGoalsFromLocationsAndActor(TArray<struct FFortAIGoalInfo>* Goals, const class UObject* WorldContextObject, const TArray<struct FVector>& GoalLocations, const class AActor* GoalActor);
	static void RemoveGoalFromWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const struct FFortAIGoalInfo& GoalInfo);
	static void RemoveGoalsFromWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	static void RemoveWorldAssignment(const class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier);
	static void SetCurrentGoalDiscouragement(class UObject* WorldContext, class AFortAIController* AI);

	void AddGoal(class AActor* GoalActor, class UFortAIAssignmentSettings* GoalSettings);
	void AddGoalActorToAssignment(class UFortAIAssignment* Assignment, class AActor* GoalActor);
	class UFortAIAssignment* AddWorldAssignment(class UFortAIAssignmentSettings* AssignmentSettings, class AActor* GoalActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalManager">();
	}
	static class AFortAIGoalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIGoalManager>();
	}
};
static_assert(alignof(AFortAIGoalManager) == 0x000008, "Wrong alignment on AFortAIGoalManager");
static_assert(sizeof(AFortAIGoalManager) == 0x0003D8, "Wrong size on AFortAIGoalManager");
static_assert(offsetof(AFortAIGoalManager, WorldAssignments) == 0x000278, "Member 'AFortAIGoalManager::WorldAssignments' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, WorldEnemyAssignments) == 0x000288, "Member 'AFortAIGoalManager::WorldEnemyAssignments' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultAttackPlayersAssignment) == 0x000298, "Member 'AFortAIGoalManager::DefaultAttackPlayersAssignment' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, CombinedQueries) == 0x000300, "Member 'AFortAIGoalManager::CombinedQueries' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultEncounterAssignmentSettings) == 0x000360, "Member 'AFortAIGoalManager::DefaultEncounterAssignmentSettings' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultEnemyAssignmentSettings) == 0x000368, "Member 'AFortAIGoalManager::DefaultEnemyAssignmentSettings' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, PawnGoalSelectionTable) == 0x000370, "Member 'AFortAIGoalManager::PawnGoalSelectionTable' has a wrong offset!");

// Class FortniteAI.FortAIGoalProvider
// 0x0020 (0x0048 - 0x0028)
class UFortAIGoalProvider : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIAssignment*                      AssignmentOwner;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIEncounterInfo*                   EncounterInfo;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool InitializeGoalProvider(class UWorld* ContextWorld, class UFortAIAssignment* Assignment);
	void UpdateGoals();

	class UFortAIEncounterInfo* GetEncounterInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalProvider">();
	}
	static class UFortAIGoalProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIGoalProvider>();
	}
};
static_assert(alignof(UFortAIGoalProvider) == 0x000008, "Wrong alignment on UFortAIGoalProvider");
static_assert(sizeof(UFortAIGoalProvider) == 0x000048, "Wrong size on UFortAIGoalProvider");
static_assert(offsetof(UFortAIGoalProvider, World) == 0x000030, "Member 'UFortAIGoalProvider::World' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider, AssignmentOwner) == 0x000038, "Member 'UFortAIGoalProvider::AssignmentOwner' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider, EncounterInfo) == 0x000040, "Member 'UFortAIGoalProvider::EncounterInfo' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_SetAggressiveDriving
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_SetAggressiveDriving final : public UBTTaskNode
{
public:
	bool                                          bAggressiveDriving;                                // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_SetAggressiveDriving">();
	}
	static class UFortAthenaBTTask_SetAggressiveDriving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_SetAggressiveDriving>();
	}
};
static_assert(alignof(UFortAthenaBTTask_SetAggressiveDriving) == 0x000008, "Wrong alignment on UFortAthenaBTTask_SetAggressiveDriving");
static_assert(sizeof(UFortAthenaBTTask_SetAggressiveDriving) == 0x000078, "Wrong size on UFortAthenaBTTask_SetAggressiveDriving");
static_assert(offsetof(UFortAthenaBTTask_SetAggressiveDriving, bAggressiveDriving) == 0x000070, "Member 'UFortAthenaBTTask_SetAggressiveDriving::bAggressiveDriving' has a wrong offset!");

// Class FortniteAI.FortThreatVisualsManager
// 0x02B8 (0x0528 - 0x0270)
class AFortThreatVisualsManager final : public AActor
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AThreatCloud>               CloudBlueprint;                                    // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudRadius;                                       // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ThreatBoxVolumeTopPadding;                         // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ThreatBoxVolumeBottomPadding;                      // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseLocalPlayersOnlyForCloudMinimumHeight;         // 0x028C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHideClouds;                                       // 0x028D(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E[0x2];                                      // 0x028E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloudMinimumHeightAbovePlayers;                    // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMinimumHeightAboveGround;                     // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMinimumAltitude;                              // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMaxVerticalDelta;                             // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMinSpeed;                                     // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMaxSpeed;                                     // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindCloudRadius;                              // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindGoalRadius;                               // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindFalloffRadius;                            // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindInactiveMagnitude;                        // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindActiveMagnitude;                          // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindDesiredDeltaBlendTime;                    // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindDirectionAdditionalAngle;                 // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FThreatLocationArray                   ThreatLocations;                                   // 0x02C8(0x0118)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FStormWindArray                        StormWindArray;                                    // 0x03E0(0x0118)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        GoalActorLocations;                                // 0x04F8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x20];                                     // 0x0508(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginThreatVisualsPrecursor(class AActor* SourceActor, const struct FVector& ThreatLocation);
	void OnBeginThreatVisualsPrecursor(class AActor* SourceActor, const struct FVector& EndLocation);
	void OnRep_GoalActorLocations();
	void OnRep_HideClouds();
	void OnRep_StormWinds();
	void OnRep_ThreatLocations();
	void OnThreatCloudsChanged(const TArray<struct FThreatLocationInfo>& ThreatLocationInfo);
	void OnWorldReady();
	void ResetMinimumCloudAltitude();
	void SetCloudsAreHidden(bool bHide);
	void SetMinimumCloudAltitude(float NewMinimumAltitude);

	bool GetCloudsAreHidden() const;
	class AThreatCloud* GetThreatCloud(const struct FThreatLocationInfo& ThreatLocInfo) const;
	const TArray<struct FThreatLocationInfo> GetThreatClouds() const;
	bool StormsExist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortThreatVisualsManager">();
	}
	static class AFortThreatVisualsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortThreatVisualsManager>();
	}
};
static_assert(alignof(AFortThreatVisualsManager) == 0x000008, "Wrong alignment on AFortThreatVisualsManager");
static_assert(sizeof(AFortThreatVisualsManager) == 0x000528, "Wrong size on AFortThreatVisualsManager");
static_assert(offsetof(AFortThreatVisualsManager, CloudBlueprint) == 0x000278, "Member 'AFortThreatVisualsManager::CloudBlueprint' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudRadius) == 0x000280, "Member 'AFortThreatVisualsManager::CloudRadius' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, ThreatBoxVolumeTopPadding) == 0x000284, "Member 'AFortThreatVisualsManager::ThreatBoxVolumeTopPadding' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, ThreatBoxVolumeBottomPadding) == 0x000288, "Member 'AFortThreatVisualsManager::ThreatBoxVolumeBottomPadding' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, bUseLocalPlayersOnlyForCloudMinimumHeight) == 0x00028C, "Member 'AFortThreatVisualsManager::bUseLocalPlayersOnlyForCloudMinimumHeight' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, bHideClouds) == 0x00028D, "Member 'AFortThreatVisualsManager::bHideClouds' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMinimumHeightAbovePlayers) == 0x000290, "Member 'AFortThreatVisualsManager::CloudMinimumHeightAbovePlayers' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMinimumHeightAboveGround) == 0x000294, "Member 'AFortThreatVisualsManager::CloudMinimumHeightAboveGround' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMinimumAltitude) == 0x000298, "Member 'AFortThreatVisualsManager::CloudMinimumAltitude' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMaxVerticalDelta) == 0x00029C, "Member 'AFortThreatVisualsManager::CloudMaxVerticalDelta' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMinSpeed) == 0x0002A0, "Member 'AFortThreatVisualsManager::CloudMinSpeed' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMaxSpeed) == 0x0002A4, "Member 'AFortThreatVisualsManager::CloudMaxSpeed' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindCloudRadius) == 0x0002A8, "Member 'AFortThreatVisualsManager::StormWindCloudRadius' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindGoalRadius) == 0x0002AC, "Member 'AFortThreatVisualsManager::StormWindGoalRadius' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindFalloffRadius) == 0x0002B0, "Member 'AFortThreatVisualsManager::StormWindFalloffRadius' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindInactiveMagnitude) == 0x0002B4, "Member 'AFortThreatVisualsManager::StormWindInactiveMagnitude' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindActiveMagnitude) == 0x0002B8, "Member 'AFortThreatVisualsManager::StormWindActiveMagnitude' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindDesiredDeltaBlendTime) == 0x0002BC, "Member 'AFortThreatVisualsManager::StormWindDesiredDeltaBlendTime' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindDirectionAdditionalAngle) == 0x0002C0, "Member 'AFortThreatVisualsManager::StormWindDirectionAdditionalAngle' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, ThreatLocations) == 0x0002C8, "Member 'AFortThreatVisualsManager::ThreatLocations' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindArray) == 0x0003E0, "Member 'AFortThreatVisualsManager::StormWindArray' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, GoalActorLocations) == 0x0004F8, "Member 'AFortThreatVisualsManager::GoalActorLocations' has a wrong offset!");

// Class FortniteAI.FortAIGoalProvider_EnvQuery
// 0x0090 (0x00D8 - 0x0048)
class UFortAIGoalProvider_EnvQuery : public UFortAIGoalProvider
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              GoalQuery;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutomaticUpdatePeriodInSeconds;                    // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAIAssignmentIdentifier            SpecificAssignmentContext;                         // 0x0060(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AIPawnContext;                                     // 0x0090(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalProvider_EnvQuery">();
	}
	static class UFortAIGoalProvider_EnvQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIGoalProvider_EnvQuery>();
	}
};
static_assert(alignof(UFortAIGoalProvider_EnvQuery) == 0x000008, "Wrong alignment on UFortAIGoalProvider_EnvQuery");
static_assert(sizeof(UFortAIGoalProvider_EnvQuery) == 0x0000D8, "Wrong size on UFortAIGoalProvider_EnvQuery");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, GoalQuery) == 0x000050, "Member 'UFortAIGoalProvider_EnvQuery::GoalQuery' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, AutomaticUpdatePeriodInSeconds) == 0x000058, "Member 'UFortAIGoalProvider_EnvQuery::AutomaticUpdatePeriodInSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, SpecificAssignmentContext) == 0x000060, "Member 'UFortAIGoalProvider_EnvQuery::SpecificAssignmentContext' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, AIPawnContext) == 0x000090, "Member 'UFortAIGoalProvider_EnvQuery::AIPawnContext' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_Dive
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTTask_Dive final : public UBTTaskNode
{
public:
	class FName                                   ExecutionStatusKeyName;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DiveDestinationKeyName;                            // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_Dive">();
	}
	static class UFortAthenaBTTask_Dive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_Dive>();
	}
};
static_assert(alignof(UFortAthenaBTTask_Dive) == 0x000008, "Wrong alignment on UFortAthenaBTTask_Dive");
static_assert(sizeof(UFortAthenaBTTask_Dive) == 0x000080, "Wrong size on UFortAthenaBTTask_Dive");
static_assert(offsetof(UFortAthenaBTTask_Dive, ExecutionStatusKeyName) == 0x000070, "Member 'UFortAthenaBTTask_Dive::ExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Dive, DiveDestinationKeyName) == 0x000074, "Member 'UFortAthenaBTTask_Dive::DiveDestinationKeyName' has a wrong offset!");

// Class FortniteAI.FortAIEncounterGoalSelectionTable
// 0x0010 (0x0040 - 0x0030)
class UFortAIEncounterGoalSelectionTable final : public UDataAsset
{
public:
	TArray<struct FEncounterGoalSelectionTableEntry> EncounterGoalSelectionCriteria;                    // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterGoalSelectionTable">();
	}
	static class UFortAIEncounterGoalSelectionTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterGoalSelectionTable>();
	}
};
static_assert(alignof(UFortAIEncounterGoalSelectionTable) == 0x000008, "Wrong alignment on UFortAIEncounterGoalSelectionTable");
static_assert(sizeof(UFortAIEncounterGoalSelectionTable) == 0x000040, "Wrong size on UFortAIEncounterGoalSelectionTable");
static_assert(offsetof(UFortAIEncounterGoalSelectionTable, EncounterGoalSelectionCriteria) == 0x000030, "Member 'UFortAIEncounterGoalSelectionTable::EncounterGoalSelectionCriteria' has a wrong offset!");

// Class FortniteAI.FortAIHotSpot
// 0x0028 (0x0448 - 0x0420)
class AFortAIHotSpot : public AAIHotSpot
{
public:
	uint8                                         Pad_420[0x28];                                     // 0x0420(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot">();
	}
	static class AFortAIHotSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot>();
	}
};
static_assert(alignof(AFortAIHotSpot) == 0x000008, "Wrong alignment on AFortAIHotSpot");
static_assert(sizeof(AFortAIHotSpot) == 0x000448, "Wrong size on AFortAIHotSpot");

// Class FortniteAI.FortAIHotSpotManager
// 0x0148 (0x01C8 - 0x0080)
class UFortAIHotSpotManager final : public UAIHotSpotManagerProxy
{
public:
	TSoftObjectPtr<class UBuildingActorHotSpotConfig> FallbackHotspotConfig;                             // 0x0080(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0xF0];                                      // 0x00A8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAutoAcquireSlot>               AutoAcquireSlots;                                  // 0x0198(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x20];                                     // 0x01A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotManager">();
	}
	static class UFortAIHotSpotManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotManager>();
	}
};
static_assert(alignof(UFortAIHotSpotManager) == 0x000008, "Wrong alignment on UFortAIHotSpotManager");
static_assert(sizeof(UFortAIHotSpotManager) == 0x0001C8, "Wrong size on UFortAIHotSpotManager");
static_assert(offsetof(UFortAIHotSpotManager, FallbackHotspotConfig) == 0x000080, "Member 'UFortAIHotSpotManager::FallbackHotspotConfig' has a wrong offset!");
static_assert(offsetof(UFortAIHotSpotManager, AutoAcquireSlots) == 0x000198, "Member 'UFortAIHotSpotManager::AutoAcquireSlots' has a wrong offset!");

// Class FortniteAI.FortAIHotSpotSlot
// 0x0010 (0x0130 - 0x0120)
class UFortAIHotSpotSlot final : public UAIHotSpotSlot
{
public:
	EFortHotSpotSlot                              SlotType;                                          // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHasProjectedLocation : 1;                         // 0x0124(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bProjectedOnLowArea : 1;                           // 0x0124(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsAutoGenerated : 1;                              // 0x0124(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanDuplicateOnProjection : 1;                     // 0x0124(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanProjectUp : 1;                                 // 0x0124(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_125[0xB];                                      // 0x0125(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlot">();
	}
	static class UFortAIHotSpotSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlot>();
	}
};
static_assert(alignof(UFortAIHotSpotSlot) == 0x000010, "Wrong alignment on UFortAIHotSpotSlot");
static_assert(sizeof(UFortAIHotSpotSlot) == 0x000130, "Wrong size on UFortAIHotSpotSlot");
static_assert(offsetof(UFortAIHotSpotSlot, SlotType) == 0x000120, "Member 'UFortAIHotSpotSlot::SlotType' has a wrong offset!");

// Class FortniteAI.FortNavArea_Stairs
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_Stairs final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_Stairs">();
	}
	static class UFortNavArea_Stairs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_Stairs>();
	}
};
static_assert(alignof(UFortNavArea_Stairs) == 0x000008, "Wrong alignment on UFortNavArea_Stairs");
static_assert(sizeof(UFortNavArea_Stairs) == 0x000050, "Wrong size on UFortNavArea_Stairs");

// Class FortniteAI.FortAIHotSpotSlotGenerator_FromConfig
// 0x0028 (0x0050 - 0x0028)
class UFortAIHotSpotSlotGenerator_FromConfig final : public UAIHotSpotSlotGenerator
{
public:
	class UAIHotSpotConfig*                       BuildingConfig;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0030(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMirrorX : 1;                                      // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMirrorY : 1;                                      // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlotGenerator_FromConfig">();
	}
	static class UFortAIHotSpotSlotGenerator_FromConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlotGenerator_FromConfig>();
	}
};
static_assert(alignof(UFortAIHotSpotSlotGenerator_FromConfig) == 0x000008, "Wrong alignment on UFortAIHotSpotSlotGenerator_FromConfig");
static_assert(sizeof(UFortAIHotSpotSlotGenerator_FromConfig) == 0x000050, "Wrong size on UFortAIHotSpotSlotGenerator_FromConfig");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_FromConfig, BuildingConfig) == 0x000028, "Member 'UFortAIHotSpotSlotGenerator_FromConfig::BuildingConfig' has a wrong offset!");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_FromConfig, Offset) == 0x000030, "Member 'UFortAIHotSpotSlotGenerator_FromConfig::Offset' has a wrong offset!");

// Class FortniteAI.FortAIHotSpotSlotGenerator_OnBoundingBox
// 0x0008 (0x00A0 - 0x0098)
class UFortAIHotSpotSlotGenerator_OnBoundingBox final : public UAIHotSpotSlotGenerator_OnBoundingBox
{
public:
	float                                         DistanceForRangedSlots;                            // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceForHugeSlots;                              // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlotGenerator_OnBoundingBox">();
	}
	static class UFortAIHotSpotSlotGenerator_OnBoundingBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlotGenerator_OnBoundingBox>();
	}
};
static_assert(alignof(UFortAIHotSpotSlotGenerator_OnBoundingBox) == 0x000008, "Wrong alignment on UFortAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(sizeof(UFortAIHotSpotSlotGenerator_OnBoundingBox) == 0x0000A0, "Wrong size on UFortAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_OnBoundingBox, DistanceForRangedSlots) == 0x000098, "Member 'UFortAIHotSpotSlotGenerator_OnBoundingBox::DistanceForRangedSlots' has a wrong offset!");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_OnBoundingBox, DistanceForHugeSlots) == 0x00009C, "Member 'UFortAIHotSpotSlotGenerator_OnBoundingBox::DistanceForHugeSlots' has a wrong offset!");

// Class FortniteAI.FortNavigationFilter_IgnoreSmashingCost
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_IgnoreSmashingCost final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_IgnoreSmashingCost">();
	}
	static class UFortNavigationFilter_IgnoreSmashingCost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_IgnoreSmashingCost>();
	}
};
static_assert(alignof(UFortNavigationFilter_IgnoreSmashingCost) == 0x000008, "Wrong alignment on UFortNavigationFilter_IgnoreSmashingCost");
static_assert(sizeof(UFortNavigationFilter_IgnoreSmashingCost) == 0x000048, "Wrong size on UFortNavigationFilter_IgnoreSmashingCost");

// Class FortniteAI.FortQueryTest_InsideBuilding
// 0x0000 (0x01F8 - 0x01F8)
class UFortQueryTest_InsideBuilding final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_InsideBuilding">();
	}
	static class UFortQueryTest_InsideBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_InsideBuilding>();
	}
};
static_assert(alignof(UFortQueryTest_InsideBuilding) == 0x000008, "Wrong alignment on UFortQueryTest_InsideBuilding");
static_assert(sizeof(UFortQueryTest_InsideBuilding) == 0x0001F8, "Wrong size on UFortQueryTest_InsideBuilding");

// Class FortniteAI.FortAIHotSpotSlotGenerator_RampTrace
// 0x0030 (0x0058 - 0x0028)
class UFortAIHotSpotSlotGenerator_RampTrace final : public UAIHotSpotSlotGenerator
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlotGenerator_RampTrace">();
	}
	static class UFortAIHotSpotSlotGenerator_RampTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlotGenerator_RampTrace>();
	}
};
static_assert(alignof(UFortAIHotSpotSlotGenerator_RampTrace) == 0x000008, "Wrong alignment on UFortAIHotSpotSlotGenerator_RampTrace");
static_assert(sizeof(UFortAIHotSpotSlotGenerator_RampTrace) == 0x000058, "Wrong size on UFortAIHotSpotSlotGenerator_RampTrace");

// Class FortniteAI.FortAIHotSpot_Building
// 0x00E8 (0x0530 - 0x0448)
class alignas(0x10) AFortAIHotSpot_Building final : public AFortAIHotSpot
{
public:
	class UAIHotSpotConfig*                       ExtraTypeConfig;                                   // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0xE0];                                     // 0x0450(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot_Building">();
	}
	static class AFortAIHotSpot_Building* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot_Building>();
	}
};
static_assert(alignof(AFortAIHotSpot_Building) == 0x000010, "Wrong alignment on AFortAIHotSpot_Building");
static_assert(sizeof(AFortAIHotSpot_Building) == 0x000530, "Wrong size on AFortAIHotSpot_Building");
static_assert(offsetof(AFortAIHotSpot_Building, ExtraTypeConfig) == 0x000448, "Member 'AFortAIHotSpot_Building::ExtraTypeConfig' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_DynamicBlueprint
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTTask_DynamicBlueprint final : public UBTTaskNode
{
public:
	class FName                                   DynamicBlueprintStatusKeyName;                     // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DynamicBlueprintActorKeyName;                      // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_DynamicBlueprint">();
	}
	static class UFortAthenaBTTask_DynamicBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_DynamicBlueprint>();
	}
};
static_assert(alignof(UFortAthenaBTTask_DynamicBlueprint) == 0x000008, "Wrong alignment on UFortAthenaBTTask_DynamicBlueprint");
static_assert(sizeof(UFortAthenaBTTask_DynamicBlueprint) == 0x000080, "Wrong size on UFortAthenaBTTask_DynamicBlueprint");
static_assert(offsetof(UFortAthenaBTTask_DynamicBlueprint, DynamicBlueprintStatusKeyName) == 0x000070, "Member 'UFortAthenaBTTask_DynamicBlueprint::DynamicBlueprintStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_DynamicBlueprint, DynamicBlueprintActorKeyName) == 0x000074, "Member 'UFortAthenaBTTask_DynamicBlueprint::DynamicBlueprintActorKeyName' has a wrong offset!");

// Class FortniteAI.FortQueryTest_InsideAIBotLeash
// 0x0000 (0x01F8 - 0x01F8)
class UFortQueryTest_InsideAIBotLeash final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_InsideAIBotLeash">();
	}
	static class UFortQueryTest_InsideAIBotLeash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_InsideAIBotLeash>();
	}
};
static_assert(alignof(UFortQueryTest_InsideAIBotLeash) == 0x000008, "Wrong alignment on UFortQueryTest_InsideAIBotLeash");
static_assert(sizeof(UFortQueryTest_InsideAIBotLeash) == 0x0001F8, "Wrong size on UFortQueryTest_InsideAIBotLeash");

// Class FortniteAI.FortAIHotSpot_FakeBuilding
// 0x0000 (0x0448 - 0x0448)
class AFortAIHotSpot_FakeBuilding final : public AFortAIHotSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot_FakeBuilding">();
	}
	static class AFortAIHotSpot_FakeBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot_FakeBuilding>();
	}
};
static_assert(alignof(AFortAIHotSpot_FakeBuilding) == 0x000008, "Wrong alignment on AFortAIHotSpot_FakeBuilding");
static_assert(sizeof(AFortAIHotSpot_FakeBuilding) == 0x000448, "Wrong size on AFortAIHotSpot_FakeBuilding");

// Class FortniteAI.FortAthenaAIRuntimeParameters_Leash
// 0x0028 (0x0058 - 0x0030)
class UFortAthenaAIRuntimeParameters_Leash final : public UFortAthenaAIRuntimeParameters
{
public:
	struct FVector                                LeashLocation;                                     // 0x0030(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeashInnerRadius;                                  // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeashOuterRadius;                                  // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELeashReturnLocationMode                      LeashReturnLocationMode;                           // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_Leash">();
	}
	static class UFortAthenaAIRuntimeParameters_Leash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_Leash>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_Leash) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_Leash");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_Leash) == 0x000058, "Wrong size on UFortAthenaAIRuntimeParameters_Leash");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Leash, LeashLocation) == 0x000030, "Member 'UFortAthenaAIRuntimeParameters_Leash::LeashLocation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Leash, LeashInnerRadius) == 0x000048, "Member 'UFortAthenaAIRuntimeParameters_Leash::LeashInnerRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Leash, LeashOuterRadius) == 0x00004C, "Member 'UFortAthenaAIRuntimeParameters_Leash::LeashOuterRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Leash, LeashReturnLocationMode) == 0x000050, "Member 'UFortAthenaAIRuntimeParameters_Leash::LeashReturnLocationMode' has a wrong offset!");

// Class FortniteAI.FortAIHotSpot_Shooting
// 0x0000 (0x0448 - 0x0448)
class AFortAIHotSpot_Shooting final : public AFortAIHotSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot_Shooting">();
	}
	static class AFortAIHotSpot_Shooting* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot_Shooting>();
	}
};
static_assert(alignof(AFortAIHotSpot_Shooting) == 0x000008, "Wrong alignment on AFortAIHotSpot_Shooting");
static_assert(sizeof(AFortAIHotSpot_Shooting) == 0x000448, "Wrong size on AFortAIHotSpot_Shooting");

// Class FortniteAI.FortAIManagerMinigameComponent
// 0x0070 (0x0110 - 0x00A0)
class UFortAIManagerMinigameComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   SpawnableAITypeTags;                               // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void HandleMinigameStarted();
	void OnPawnDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnPawnSpawned(class APawn* Pawn, const int32 RequestId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIManagerMinigameComponent">();
	}
	static class UFortAIManagerMinigameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIManagerMinigameComponent>();
	}
};
static_assert(alignof(UFortAIManagerMinigameComponent) == 0x000008, "Wrong alignment on UFortAIManagerMinigameComponent");
static_assert(sizeof(UFortAIManagerMinigameComponent) == 0x000110, "Wrong size on UFortAIManagerMinigameComponent");
static_assert(offsetof(UFortAIManagerMinigameComponent, SpawnableAITypeTags) == 0x000100, "Member 'UFortAIManagerMinigameComponent::SpawnableAITypeTags' has a wrong offset!");

// Class FortniteAI.FortQueryData_CurvesAroundLine
// 0x0070 (0x00A0 - 0x0030)
class UFortQueryData_CurvesAroundLine final : public UDataAsset
{
public:
	struct FFortPointsOnCurve                     PointsOnSideA;                                     // 0x0030(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortPointsOnCurve                     PointsOnSideB;                                     // 0x0068(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryData_CurvesAroundLine">();
	}
	static class UFortQueryData_CurvesAroundLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryData_CurvesAroundLine>();
	}
};
static_assert(alignof(UFortQueryData_CurvesAroundLine) == 0x000008, "Wrong alignment on UFortQueryData_CurvesAroundLine");
static_assert(sizeof(UFortQueryData_CurvesAroundLine) == 0x0000A0, "Wrong size on UFortQueryData_CurvesAroundLine");
static_assert(offsetof(UFortQueryData_CurvesAroundLine, PointsOnSideA) == 0x000030, "Member 'UFortQueryData_CurvesAroundLine::PointsOnSideA' has a wrong offset!");
static_assert(offsetof(UFortQueryData_CurvesAroundLine, PointsOnSideB) == 0x000068, "Member 'UFortQueryData_CurvesAroundLine::PointsOnSideB' has a wrong offset!");

// Class FortniteAI.FortAINearbyActorsPerceptionComponent
// 0x0018 (0x00E0 - 0x00C8)
class UFortAINearbyActorsPerceptionComponent final : public TObjectBasedCycleFixup<class UFortNearbyActorsPerceptionComponent, 0x00A0, 0x08>
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IFortAthenaAILODSettings> CachedLODSettingsManager;                          // 0x00D0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAINearbyActorsPerceptionComponent">();
	}
	static class UFortAINearbyActorsPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAINearbyActorsPerceptionComponent>();
	}
};
static_assert(alignof(UFortAINearbyActorsPerceptionComponent) == 0x000008, "Wrong alignment on UFortAINearbyActorsPerceptionComponent");
static_assert(sizeof(UFortAINearbyActorsPerceptionComponent) == 0x0000E0, "Wrong size on UFortAINearbyActorsPerceptionComponent");
static_assert(offsetof(UFortAINearbyActorsPerceptionComponent, CachedLODSettingsManager) == 0x0000D0, "Member 'UFortAINearbyActorsPerceptionComponent::CachedLODSettingsManager' has a wrong offset!");

// Class FortniteAI.FortBTDecorator_GameplayAbility_CanActivate
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_CanActivate final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_CanActivate">();
	}
	static class UFortBTDecorator_GameplayAbility_CanActivate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_CanActivate>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_CanActivate) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_CanActivate");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_CanActivate) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_CanActivate");

// Class FortniteAI.FortAIObjectiveInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAIObjectiveInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIObjectiveInterface">();
	}
	static class IFortAIObjectiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIObjectiveInterface>();
	}
};
static_assert(alignof(IFortAIObjectiveInterface) == 0x000008, "Wrong alignment on IFortAIObjectiveInterface");
static_assert(sizeof(IFortAIObjectiveInterface) == 0x000028, "Wrong size on IFortAIObjectiveInterface");

// Class FortniteAI.FortQueryGenerator_InfluenceMapPoints
// 0x0048 (0x00D0 - 0x0088)
class UFortQueryGenerator_InfluenceMapPoints final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderIntValue                Density;                                           // 0x0088(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bOnlyFlatSurface : 1;                              // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_InfluenceMapPoints">();
	}
	static class UFortQueryGenerator_InfluenceMapPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_InfluenceMapPoints>();
	}
};
static_assert(alignof(UFortQueryGenerator_InfluenceMapPoints) == 0x000008, "Wrong alignment on UFortQueryGenerator_InfluenceMapPoints");
static_assert(sizeof(UFortQueryGenerator_InfluenceMapPoints) == 0x0000D0, "Wrong size on UFortQueryGenerator_InfluenceMapPoints");
static_assert(offsetof(UFortQueryGenerator_InfluenceMapPoints, Density) == 0x000088, "Member 'UFortQueryGenerator_InfluenceMapPoints::Density' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_InfluenceMapPoints, GenerateAround) == 0x0000C8, "Member 'UFortQueryGenerator_InfluenceMapPoints::GenerateAround' has a wrong offset!");

// Class FortniteAI.FortAIPawnCustomizationDefinition
// 0x0078 (0x00A8 - 0x0030)
class UFortAIPawnCustomizationDefinition final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortAIPawnMaterialDefinition>  OverrideMaterials;                                 // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimationBP;                                       // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCustomCharacterPart*>           CharacterParts;                                    // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPawnCustomizationDefinition">();
	}
	static class UFortAIPawnCustomizationDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPawnCustomizationDefinition>();
	}
};
static_assert(alignof(UFortAIPawnCustomizationDefinition) == 0x000008, "Wrong alignment on UFortAIPawnCustomizationDefinition");
static_assert(sizeof(UFortAIPawnCustomizationDefinition) == 0x0000A8, "Wrong size on UFortAIPawnCustomizationDefinition");
static_assert(offsetof(UFortAIPawnCustomizationDefinition, SkeletalMesh) == 0x000038, "Member 'UFortAIPawnCustomizationDefinition::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UFortAIPawnCustomizationDefinition, OverrideMaterials) == 0x000060, "Member 'UFortAIPawnCustomizationDefinition::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(UFortAIPawnCustomizationDefinition, AnimationBP) == 0x000070, "Member 'UFortAIPawnCustomizationDefinition::AnimationBP' has a wrong offset!");
static_assert(offsetof(UFortAIPawnCustomizationDefinition, CharacterParts) == 0x000098, "Member 'UFortAIPawnCustomizationDefinition::CharacterParts' has a wrong offset!");

// Class FortniteAI.FortAIPawnVariant
// 0x0048 (0x0070 - 0x0028)
class UFortAIPawnVariant final : public UObject
{
public:
	TArray<TSubclassOf<class AFortAIPawn>>        PawnClasses;                                       // 0x0028(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FFortAIPawnVariantDefinition>   PawnVariantDefinitions;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MinPlayersToSpawnVariant;                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    SpawnPointValueHandle;                             // 0x0050(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         CachedSpawnPointValue;                             // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EncounterExpectedLifespan;                         // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VersionNum;                                        // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPawnVariant">();
	}
	static class UFortAIPawnVariant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPawnVariant>();
	}
};
static_assert(alignof(UFortAIPawnVariant) == 0x000008, "Wrong alignment on UFortAIPawnVariant");
static_assert(sizeof(UFortAIPawnVariant) == 0x000070, "Wrong size on UFortAIPawnVariant");
static_assert(offsetof(UFortAIPawnVariant, PawnClasses) == 0x000028, "Member 'UFortAIPawnVariant::PawnClasses' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, PawnVariantDefinitions) == 0x000038, "Member 'UFortAIPawnVariant::PawnVariantDefinitions' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, MinPlayersToSpawnVariant) == 0x000048, "Member 'UFortAIPawnVariant::MinPlayersToSpawnVariant' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, SpawnPointValueHandle) == 0x000050, "Member 'UFortAIPawnVariant::SpawnPointValueHandle' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, CachedSpawnPointValue) == 0x000060, "Member 'UFortAIPawnVariant::CachedSpawnPointValue' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, EncounterExpectedLifespan) == 0x000064, "Member 'UFortAIPawnVariant::EncounterExpectedLifespan' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, VersionNum) == 0x000068, "Member 'UFortAIPawnVariant::VersionNum' has a wrong offset!");

// Class FortniteAI.FortAIPerceptionSystem
// 0x0000 (0x0128 - 0x0128)
class UFortAIPerceptionSystem final : public UAIPerceptionSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPerceptionSystem">();
	}
	static class UFortAIPerceptionSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPerceptionSystem>();
	}
};
static_assert(alignof(UFortAIPerceptionSystem) == 0x000008, "Wrong alignment on UFortAIPerceptionSystem");
static_assert(sizeof(UFortAIPerceptionSystem) == 0x000128, "Wrong size on UFortAIPerceptionSystem");

// Class FortniteAI.FortAIPerkBase
// 0x0140 (0x0168 - 0x0028)
class UFortAIPerkBase : public UObject
{
public:
	struct FScalableFloat                         CooldownDuration;                                  // 0x0028(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CooldownDurationRandomDeviation;                   // 0x0050(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ActivationCountBeforeCooldown;                     // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ActivationDuration;                                // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ActivationDurationRandomDeviation;                 // 0x00C8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         OddsToActivate;                                    // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         FailedActivationCooldownDuration;                  // 0x0118(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         FailedActivationCooldownDurationRandomDeviation;   // 0x0140(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPerkBase">();
	}
	static class UFortAIPerkBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPerkBase>();
	}
};
static_assert(alignof(UFortAIPerkBase) == 0x000008, "Wrong alignment on UFortAIPerkBase");
static_assert(sizeof(UFortAIPerkBase) == 0x000168, "Wrong size on UFortAIPerkBase");
static_assert(offsetof(UFortAIPerkBase, CooldownDuration) == 0x000028, "Member 'UFortAIPerkBase::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UFortAIPerkBase, CooldownDurationRandomDeviation) == 0x000050, "Member 'UFortAIPerkBase::CooldownDurationRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAIPerkBase, ActivationCountBeforeCooldown) == 0x000078, "Member 'UFortAIPerkBase::ActivationCountBeforeCooldown' has a wrong offset!");
static_assert(offsetof(UFortAIPerkBase, ActivationDuration) == 0x0000A0, "Member 'UFortAIPerkBase::ActivationDuration' has a wrong offset!");
static_assert(offsetof(UFortAIPerkBase, ActivationDurationRandomDeviation) == 0x0000C8, "Member 'UFortAIPerkBase::ActivationDurationRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAIPerkBase, OddsToActivate) == 0x0000F0, "Member 'UFortAIPerkBase::OddsToActivate' has a wrong offset!");
static_assert(offsetof(UFortAIPerkBase, FailedActivationCooldownDuration) == 0x000118, "Member 'UFortAIPerkBase::FailedActivationCooldownDuration' has a wrong offset!");
static_assert(offsetof(UFortAIPerkBase, FailedActivationCooldownDurationRandomDeviation) == 0x000140, "Member 'UFortAIPerkBase::FailedActivationCooldownDurationRandomDeviation' has a wrong offset!");

// Class FortniteAI.FortNavArea_LowJump
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_LowJump final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_LowJump">();
	}
	static class UFortNavArea_LowJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_LowJump>();
	}
};
static_assert(alignof(UFortNavArea_LowJump) == 0x000008, "Wrong alignment on UFortNavArea_LowJump");
static_assert(sizeof(UFortNavArea_LowJump) == 0x000050, "Wrong size on UFortNavArea_LowJump");

// Class FortniteAI.FortAIRootAssignmentProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAIRootAssignmentProviderInterface final : public IInterface
{
public:
	const struct FFortAIAssignmentIdentifier GetRootAssignmentIdentifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIRootAssignmentProviderInterface">();
	}
	static class IFortAIRootAssignmentProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIRootAssignmentProviderInterface>();
	}
};
static_assert(alignof(IFortAIRootAssignmentProviderInterface) == 0x000008, "Wrong alignment on IFortAIRootAssignmentProviderInterface");
static_assert(sizeof(IFortAIRootAssignmentProviderInterface) == 0x000028, "Wrong size on IFortAIRootAssignmentProviderInterface");

// Class FortniteAI.FortAISpawnerActorBase
// 0x0000 (0x0270 - 0x0270)
class AFortAISpawnerActorBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnerActorBase">();
	}
	static class AFortAISpawnerActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAISpawnerActorBase>();
	}
};
static_assert(alignof(AFortAISpawnerActorBase) == 0x000008, "Wrong alignment on AFortAISpawnerActorBase");
static_assert(sizeof(AFortAISpawnerActorBase) == 0x000270, "Wrong size on AFortAISpawnerActorBase");

// Class FortniteAI.FortNavAgentCostData
// 0x0018 (0x0048 - 0x0030)
class UFortNavAgentCostData final : public UPrimaryDataAsset
{
public:
	class FName                                   NavAgentName;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UNavArea>>           NavAreaStrengthBuckets;                            // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavAgentCostData">();
	}
	static class UFortNavAgentCostData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavAgentCostData>();
	}
};
static_assert(alignof(UFortNavAgentCostData) == 0x000008, "Wrong alignment on UFortNavAgentCostData");
static_assert(sizeof(UFortNavAgentCostData) == 0x000048, "Wrong size on UFortNavAgentCostData");
static_assert(offsetof(UFortNavAgentCostData, NavAgentName) == 0x000030, "Member 'UFortNavAgentCostData::NavAgentName' has a wrong offset!");
static_assert(offsetof(UFortNavAgentCostData, NavAreaStrengthBuckets) == 0x000038, "Member 'UFortNavAgentCostData::NavAreaStrengthBuckets' has a wrong offset!");

// Class FortniteAI.FortAISpawnerInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAISpawnerInterface final : public IInterface
{
public:
	bool IsReadyToReceiveNewSpawnGroup();
	bool OnReceiveSpawnGroup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnerInterface">();
	}
	static class IFortAISpawnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAISpawnerInterface>();
	}
};
static_assert(alignof(IFortAISpawnerInterface) == 0x000008, "Wrong alignment on IFortAISpawnerInterface");
static_assert(sizeof(IFortAISpawnerInterface) == 0x000028, "Wrong size on IFortAISpawnerInterface");

// Class FortniteAI.FortAISpawnerUtilityComponent
// 0x0090 (0x0130 - 0x00A0)
class UFortAISpawnerUtilityComponent final : public UActorComponent
{
public:
	struct FGameplayTag                           AIPawnSpawnTypeTag;                                // 0x00A0(0x0004)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              EnvironmentQuery;                                  // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEnvNamedValue>                 QueryParams;                                       // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         QueryRadius;                                       // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QueryMinDistance;                                  // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(TArray<struct FVector>& QueryResultLocations)> OnEnvironmentQueryFinishedDelegate;                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AFortPawn* FortPawn)> OnUnownedPawnDiedDelegate;                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        FreeSpawnSlots;                                    // 0x00F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IFortSpatialGameplayInterface> CachedFortSpatialGameplay;                         // 0x0120(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleUnownedPawnSpawned(class AFortPawn* FortPawn);
	void OnUnownedPawnDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	int32 RequestSpawn(class UFortAthenaAISpawnerDataComponentList* AISpawnerComponentList, const struct FTransform& SpawnTransform);
	void SetEQSQuery(TSoftObjectPtr<class UEnvQuery> SelectedEQSQuery);
	void SetMinigame(const class AFortMinigame* Minigame);
	void SetQueryRadius(float Radius);
	void StartEnvironmentQuery();

	bool IsSpawnCountCapped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnerUtilityComponent">();
	}
	static class UFortAISpawnerUtilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnerUtilityComponent>();
	}
};
static_assert(alignof(UFortAISpawnerUtilityComponent) == 0x000008, "Wrong alignment on UFortAISpawnerUtilityComponent");
static_assert(sizeof(UFortAISpawnerUtilityComponent) == 0x000130, "Wrong size on UFortAISpawnerUtilityComponent");
static_assert(offsetof(UFortAISpawnerUtilityComponent, AIPawnSpawnTypeTag) == 0x0000A0, "Member 'UFortAISpawnerUtilityComponent::AIPawnSpawnTypeTag' has a wrong offset!");
static_assert(offsetof(UFortAISpawnerUtilityComponent, EnvironmentQuery) == 0x0000A8, "Member 'UFortAISpawnerUtilityComponent::EnvironmentQuery' has a wrong offset!");
static_assert(offsetof(UFortAISpawnerUtilityComponent, QueryParams) == 0x0000B0, "Member 'UFortAISpawnerUtilityComponent::QueryParams' has a wrong offset!");
static_assert(offsetof(UFortAISpawnerUtilityComponent, QueryRadius) == 0x0000C0, "Member 'UFortAISpawnerUtilityComponent::QueryRadius' has a wrong offset!");
static_assert(offsetof(UFortAISpawnerUtilityComponent, QueryMinDistance) == 0x0000C4, "Member 'UFortAISpawnerUtilityComponent::QueryMinDistance' has a wrong offset!");
static_assert(offsetof(UFortAISpawnerUtilityComponent, OnEnvironmentQueryFinishedDelegate) == 0x0000C8, "Member 'UFortAISpawnerUtilityComponent::OnEnvironmentQueryFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UFortAISpawnerUtilityComponent, OnUnownedPawnDiedDelegate) == 0x0000D8, "Member 'UFortAISpawnerUtilityComponent::OnUnownedPawnDiedDelegate' has a wrong offset!");
static_assert(offsetof(UFortAISpawnerUtilityComponent, FreeSpawnSlots) == 0x0000F8, "Member 'UFortAISpawnerUtilityComponent::FreeSpawnSlots' has a wrong offset!");
static_assert(offsetof(UFortAISpawnerUtilityComponent, CachedFortSpatialGameplay) == 0x000120, "Member 'UFortAISpawnerUtilityComponent::CachedFortSpatialGameplay' has a wrong offset!");

// Class FortniteAI.FortNavArea_DefaultSmashable
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_DefaultSmashable : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_DefaultSmashable">();
	}
	static class UFortNavArea_DefaultSmashable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_DefaultSmashable>();
	}
};
static_assert(alignof(UFortNavArea_DefaultSmashable) == 0x000008, "Wrong alignment on UFortNavArea_DefaultSmashable");
static_assert(sizeof(UFortNavArea_DefaultSmashable) == 0x000050, "Wrong size on UFortNavArea_DefaultSmashable");

// Class FortniteAI.FortAthenaBTService_ManageWeapon
// 0x0038 (0x00A8 - 0x0070)
class UFortAthenaBTService_ManageWeapon : public UBTService
{
public:
	class FName                                   WeaponFireName;                                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponTriggerMeleeName;                            // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponTriggerThrowableName;                        // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponReloadName;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponName;                                        // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponTargetingName;                               // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SprintExecutionStatusName;                         // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TacticalSprintExecutionStatusName;                 // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   HealingStatusKeyName;                              // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BlockWeaponActionsKeyName;                         // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0xA];                                       // 0x0098(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEndChargeOnFireStop;                              // 0x00A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ManageWeaponTargeting(class UBehaviorTreeComponent* OwnerComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_ManageWeapon">();
	}
	static class UFortAthenaBTService_ManageWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_ManageWeapon>();
	}
};
static_assert(alignof(UFortAthenaBTService_ManageWeapon) == 0x000008, "Wrong alignment on UFortAthenaBTService_ManageWeapon");
static_assert(sizeof(UFortAthenaBTService_ManageWeapon) == 0x0000A8, "Wrong size on UFortAthenaBTService_ManageWeapon");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, WeaponFireName) == 0x000070, "Member 'UFortAthenaBTService_ManageWeapon::WeaponFireName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, WeaponTriggerMeleeName) == 0x000074, "Member 'UFortAthenaBTService_ManageWeapon::WeaponTriggerMeleeName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, WeaponTriggerThrowableName) == 0x000078, "Member 'UFortAthenaBTService_ManageWeapon::WeaponTriggerThrowableName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, WeaponReloadName) == 0x00007C, "Member 'UFortAthenaBTService_ManageWeapon::WeaponReloadName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, WeaponName) == 0x000080, "Member 'UFortAthenaBTService_ManageWeapon::WeaponName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, WeaponTargetingName) == 0x000084, "Member 'UFortAthenaBTService_ManageWeapon::WeaponTargetingName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, SprintExecutionStatusName) == 0x000088, "Member 'UFortAthenaBTService_ManageWeapon::SprintExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, TacticalSprintExecutionStatusName) == 0x00008C, "Member 'UFortAthenaBTService_ManageWeapon::TacticalSprintExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, HealingStatusKeyName) == 0x000090, "Member 'UFortAthenaBTService_ManageWeapon::HealingStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, BlockWeaponActionsKeyName) == 0x000094, "Member 'UFortAthenaBTService_ManageWeapon::BlockWeaponActionsKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ManageWeapon, bEndChargeOnFireStop) == 0x0000A2, "Member 'UFortAthenaBTService_ManageWeapon::bEndChargeOnFireStop' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_ManageVehicleWeapon
// 0x0000 (0x00A8 - 0x00A8)
class UFortAthenaBTService_ManageVehicleWeapon final : public UFortAthenaBTService_ManageWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_ManageVehicleWeapon">();
	}
	static class UFortAthenaBTService_ManageVehicleWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_ManageVehicleWeapon>();
	}
};
static_assert(alignof(UFortAthenaBTService_ManageVehicleWeapon) == 0x000008, "Wrong alignment on UFortAthenaBTService_ManageVehicleWeapon");
static_assert(sizeof(UFortAthenaBTService_ManageVehicleWeapon) == 0x0000A8, "Wrong size on UFortAthenaBTService_ManageVehicleWeapon");

// Class FortniteAI.FortAISpawnGroup
// 0x0160 (0x0190 - 0x0030)
class UFortAISpawnGroup final : public UPrimaryDataAsset
{
public:
	float                                         EnemyUtilities[0x10];                              // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnGroupEnemy>               EnemiesToSpawn;                                    // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsPrototype;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsValidForEnemySpawners;                          // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLargeSpawnGroup;                                // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_83[0x1];                                       // 0x0083(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDiscountRatio;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseWeightSystem;                                  // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         Weight;                                            // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinNumber;                                         // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxNumber;                                         // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   MaxGroupCategoryPopulationDensityCurve;            // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortSpawnGroupEncounterTypeData> EncounterTypeData;                                 // 0x0118(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SpawnGroupGameplayTags;                            // 0x0128(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      RequiredTagQuery;                                  // 0x0148(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	TSubclassOf<class UFortAIPawnVariant> GetEnemy(int32 EnemyIndex) const;
	int32 GetNumberOfEnemies() const;
	bool IsLargeSpawnGroup() const;
	bool IsPrototype() const;
	bool IsValidForEnemySpawners() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnGroup">();
	}
	static class UFortAISpawnGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnGroup>();
	}
};
static_assert(alignof(UFortAISpawnGroup) == 0x000008, "Wrong alignment on UFortAISpawnGroup");
static_assert(sizeof(UFortAISpawnGroup) == 0x000190, "Wrong size on UFortAISpawnGroup");
static_assert(offsetof(UFortAISpawnGroup, EnemyUtilities) == 0x000030, "Member 'UFortAISpawnGroup::EnemyUtilities' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, EnemiesToSpawn) == 0x000070, "Member 'UFortAISpawnGroup::EnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bIsPrototype) == 0x000080, "Member 'UFortAISpawnGroup::bIsPrototype' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bIsValidForEnemySpawners) == 0x000081, "Member 'UFortAISpawnGroup::bIsValidForEnemySpawners' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bIsLargeSpawnGroup) == 0x000082, "Member 'UFortAISpawnGroup::bIsLargeSpawnGroup' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, MaxDiscountRatio) == 0x000084, "Member 'UFortAISpawnGroup::MaxDiscountRatio' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bUseWeightSystem) == 0x000088, "Member 'UFortAISpawnGroup::bUseWeightSystem' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, Weight) == 0x000090, "Member 'UFortAISpawnGroup::Weight' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, MinNumber) == 0x0000B8, "Member 'UFortAISpawnGroup::MinNumber' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, MaxNumber) == 0x0000E0, "Member 'UFortAISpawnGroup::MaxNumber' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, MaxGroupCategoryPopulationDensityCurve) == 0x000108, "Member 'UFortAISpawnGroup::MaxGroupCategoryPopulationDensityCurve' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, EncounterTypeData) == 0x000118, "Member 'UFortAISpawnGroup::EncounterTypeData' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, SpawnGroupGameplayTags) == 0x000128, "Member 'UFortAISpawnGroup::SpawnGroupGameplayTags' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, RequiredTagQuery) == 0x000148, "Member 'UFortAISpawnGroup::RequiredTagQuery' has a wrong offset!");

// Class FortniteAI.FortAISpawnGroupCapsCategorySet
// 0x0010 (0x0038 - 0x0028)
class UFortAISpawnGroupCapsCategorySet final : public UObject
{
public:
	TArray<struct FFortAIEncounterSpawnGroupCapsCategory> SpawnGroupCapsCategories;                          // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnGroupCapsCategorySet">();
	}
	static class UFortAISpawnGroupCapsCategorySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnGroupCapsCategorySet>();
	}
};
static_assert(alignof(UFortAISpawnGroupCapsCategorySet) == 0x000008, "Wrong alignment on UFortAISpawnGroupCapsCategorySet");
static_assert(sizeof(UFortAISpawnGroupCapsCategorySet) == 0x000038, "Wrong size on UFortAISpawnGroupCapsCategorySet");
static_assert(offsetof(UFortAISpawnGroupCapsCategorySet, SpawnGroupCapsCategories) == 0x000028, "Member 'UFortAISpawnGroupCapsCategorySet::SpawnGroupCapsCategories' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_SetBlackboardBool
// 0x0030 (0x00A0 - 0x0070)
class UFortAthenaBTService_SetBlackboardBool final : public UBTService
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bBlackboardValue;                                  // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_SetBlackboardBool">();
	}
	static class UFortAthenaBTService_SetBlackboardBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_SetBlackboardBool>();
	}
};
static_assert(alignof(UFortAthenaBTService_SetBlackboardBool) == 0x000008, "Wrong alignment on UFortAthenaBTService_SetBlackboardBool");
static_assert(sizeof(UFortAthenaBTService_SetBlackboardBool) == 0x0000A0, "Wrong size on UFortAthenaBTService_SetBlackboardBool");
static_assert(offsetof(UFortAthenaBTService_SetBlackboardBool, BlackboardKey) == 0x000070, "Member 'UFortAthenaBTService_SetBlackboardBool::BlackboardKey' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_SetBlackboardBool, bBlackboardValue) == 0x000098, "Member 'UFortAthenaBTService_SetBlackboardBool::bBlackboardValue' has a wrong offset!");

// Class FortniteAI.FortAISpawnGroupProgressionInfo
// 0x0010 (0x0040 - 0x0030)
class UFortAISpawnGroupProgressionInfo final : public UDataAsset
{
public:
	TArray<struct FSpawnGroupProgression>         SpawnGroups;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnGroupProgressionInfo">();
	}
	static class UFortAISpawnGroupProgressionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnGroupProgressionInfo>();
	}
};
static_assert(alignof(UFortAISpawnGroupProgressionInfo) == 0x000008, "Wrong alignment on UFortAISpawnGroupProgressionInfo");
static_assert(sizeof(UFortAISpawnGroupProgressionInfo) == 0x000040, "Wrong size on UFortAISpawnGroupProgressionInfo");
static_assert(offsetof(UFortAISpawnGroupProgressionInfo, SpawnGroups) == 0x000030, "Member 'UFortAISpawnGroupProgressionInfo::SpawnGroups' has a wrong offset!");

// Class FortniteAI.FortAISpawnGroupUpgradeProbabilities
// 0x0018 (0x0040 - 0x0028)
class UFortAISpawnGroupUpgradeProbabilities final : public UObject
{
public:
	bool                                          bIsGuaranteedUpgrade;                              // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAIPawnUpgradeProbability>  UpgradeProbabilities;                              // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnGroupUpgradeProbabilities">();
	}
	static class UFortAISpawnGroupUpgradeProbabilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnGroupUpgradeProbabilities>();
	}
};
static_assert(alignof(UFortAISpawnGroupUpgradeProbabilities) == 0x000008, "Wrong alignment on UFortAISpawnGroupUpgradeProbabilities");
static_assert(sizeof(UFortAISpawnGroupUpgradeProbabilities) == 0x000040, "Wrong size on UFortAISpawnGroupUpgradeProbabilities");
static_assert(offsetof(UFortAISpawnGroupUpgradeProbabilities, bIsGuaranteedUpgrade) == 0x000028, "Member 'UFortAISpawnGroupUpgradeProbabilities::bIsGuaranteedUpgrade' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroupUpgradeProbabilities, UpgradeProbabilities) == 0x000030, "Member 'UFortAISpawnGroupUpgradeProbabilities::UpgradeProbabilities' has a wrong offset!");

// Class FortniteAI.FortAITask_ExecuteAbility
// 0x0028 (0x00B8 - 0x0090)
class UFortAITask_ExecuteAbility final : public UAITask_ExecuteAbility
{
public:
	uint8                                         Pad_90[0x28];                                      // 0x0090(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInjectedHitResultDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_ExecuteAbility">();
	}
	static class UFortAITask_ExecuteAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_ExecuteAbility>();
	}
};
static_assert(alignof(UFortAITask_ExecuteAbility) == 0x000008, "Wrong alignment on UFortAITask_ExecuteAbility");
static_assert(sizeof(UFortAITask_ExecuteAbility) == 0x0000B8, "Wrong size on UFortAITask_ExecuteAbility");

// Class FortniteAI.FortGameplayAbility_TeleportToActor
// 0x0030 (0x0B40 - 0x0B10)
class UFortGameplayAbility_TeleportToActor final : public TObjectBasedCycleFixup<class UFortGameplayAbility, 0x0AE8, 0x08>
{
public:
	uint8                                         Pad_B10[0x4];                                      // 0x0B10(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCheckPlayerLOSWhenTeleporting;                    // 0x0B14(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B15[0x3];                                      // 0x0B15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToConsiderLOS;                          // 0x0B18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayerFOV;                                         // 0x0B1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TeleportRetries;                                   // 0x0B20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RetryDelay;                                        // 0x0B24(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B28[0x10];                                     // 0x0B28(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              FindTeleportSpotEQSQuery;                          // 0x0B38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_TeleportToActor">();
	}
	static class UFortGameplayAbility_TeleportToActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_TeleportToActor>();
	}
};
static_assert(alignof(UFortGameplayAbility_TeleportToActor) == 0x000008, "Wrong alignment on UFortGameplayAbility_TeleportToActor");
static_assert(sizeof(UFortGameplayAbility_TeleportToActor) == 0x000B40, "Wrong size on UFortGameplayAbility_TeleportToActor");
static_assert(offsetof(UFortGameplayAbility_TeleportToActor, bCheckPlayerLOSWhenTeleporting) == 0x000B14, "Member 'UFortGameplayAbility_TeleportToActor::bCheckPlayerLOSWhenTeleporting' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_TeleportToActor, MaxDistanceToConsiderLOS) == 0x000B18, "Member 'UFortGameplayAbility_TeleportToActor::MaxDistanceToConsiderLOS' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_TeleportToActor, PlayerFOV) == 0x000B1C, "Member 'UFortGameplayAbility_TeleportToActor::PlayerFOV' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_TeleportToActor, TeleportRetries) == 0x000B20, "Member 'UFortGameplayAbility_TeleportToActor::TeleportRetries' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_TeleportToActor, RetryDelay) == 0x000B24, "Member 'UFortGameplayAbility_TeleportToActor::RetryDelay' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_TeleportToActor, FindTeleportSpotEQSQuery) == 0x000B38, "Member 'UFortGameplayAbility_TeleportToActor::FindTeleportSpotEQSQuery' has a wrong offset!");

// Class FortniteAI.FortAITask_RotateToFace
// 0x0028 (0x0090 - 0x0068)
class UFortAITask_RotateToFace final : public UAITask
{
public:
	class AActor*                                 FocusTarget;                                       // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FocalPoint;                                        // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_RotateToFace">();
	}
	static class UFortAITask_RotateToFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_RotateToFace>();
	}
};
static_assert(alignof(UFortAITask_RotateToFace) == 0x000008, "Wrong alignment on UFortAITask_RotateToFace");
static_assert(sizeof(UFortAITask_RotateToFace) == 0x000090, "Wrong size on UFortAITask_RotateToFace");
static_assert(offsetof(UFortAITask_RotateToFace, FocusTarget) == 0x000068, "Member 'UFortAITask_RotateToFace::FocusTarget' has a wrong offset!");
static_assert(offsetof(UFortAITask_RotateToFace, FocalPoint) == 0x000070, "Member 'UFortAITask_RotateToFace::FocalPoint' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_JumpOffBus
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTService_JumpOffBus final : public UBTService
{
public:
	class FName                                   JumpOffBusExecutionStatusName;                     // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_JumpOffBus">();
	}
	static class UFortAthenaBTService_JumpOffBus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_JumpOffBus>();
	}
};
static_assert(alignof(UFortAthenaBTService_JumpOffBus) == 0x000008, "Wrong alignment on UFortAthenaBTService_JumpOffBus");
static_assert(sizeof(UFortAthenaBTService_JumpOffBus) == 0x000078, "Wrong size on UFortAthenaBTService_JumpOffBus");
static_assert(offsetof(UFortAthenaBTService_JumpOffBus, JumpOffBusExecutionStatusName) == 0x000070, "Member 'UFortAthenaBTService_JumpOffBus::JumpOffBusExecutionStatusName' has a wrong offset!");

// Class FortniteAI.FortAITask_StepAside
// 0x0048 (0x01A0 - 0x0158)
class UFortAITask_StepAside final : public UFortAITask_Move
{
public:
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GoalActor;                                         // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x28];                                     // 0x0178(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_StepAside">();
	}
	static class UFortAITask_StepAside* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_StepAside>();
	}
};
static_assert(alignof(UFortAITask_StepAside) == 0x000008, "Wrong alignment on UFortAITask_StepAside");
static_assert(sizeof(UFortAITask_StepAside) == 0x0001A0, "Wrong size on UFortAITask_StepAside");
static_assert(offsetof(UFortAITask_StepAside, GoalActor) == 0x000170, "Member 'UFortAITask_StepAside::GoalActor' has a wrong offset!");

// Class FortniteAI.FortIntensityCurveSequence
// 0x0018 (0x0048 - 0x0030)
class UFortIntensityCurveSequence final : public UDataAsset
{
public:
	TArray<struct FDataTableRowHandle>            IntensityCurves;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EFortIntensityCurveSequenceType               SequenceType;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIntensityCurveSequence">();
	}
	static class UFortIntensityCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIntensityCurveSequence>();
	}
};
static_assert(alignof(UFortIntensityCurveSequence) == 0x000008, "Wrong alignment on UFortIntensityCurveSequence");
static_assert(sizeof(UFortIntensityCurveSequence) == 0x000048, "Wrong size on UFortIntensityCurveSequence");
static_assert(offsetof(UFortIntensityCurveSequence, IntensityCurves) == 0x000030, "Member 'UFortIntensityCurveSequence::IntensityCurves' has a wrong offset!");
static_assert(offsetof(UFortIntensityCurveSequence, SequenceType) == 0x000040, "Member 'UFortIntensityCurveSequence::SequenceType' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_AIEvaluator
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTService_AIEvaluator final : public UBTService
{
public:
	TSubclassOf<class UFortAthenaAIEvaluator>     AIEvaluatorClass;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_AIEvaluator">();
	}
	static class UFortAthenaBTService_AIEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_AIEvaluator>();
	}
};
static_assert(alignof(UFortAthenaBTService_AIEvaluator) == 0x000008, "Wrong alignment on UFortAthenaBTService_AIEvaluator");
static_assert(sizeof(UFortAthenaBTService_AIEvaluator) == 0x000078, "Wrong size on UFortAthenaBTService_AIEvaluator");
static_assert(offsetof(UFortAthenaBTService_AIEvaluator, AIEvaluatorClass) == 0x000070, "Member 'UFortAthenaBTService_AIEvaluator::AIEvaluatorClass' has a wrong offset!");

// Class FortniteAI.FortAITetheringBoxBoundsInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAITetheringBoxBoundsInterface final : public IInterface
{
public:
	struct FVector GetTetheredBoxBoundsCenter();
	float GetTetheredBoxBoundsEQSGridSize();
	float GetTetheredBoxBoundsEQSSpaceBetween();
	float GetTetheredBoxBoundsHeight();
	float GetTetheredBoxBoundsWidth();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITetheringBoxBoundsInterface">();
	}
	static class IFortAITetheringBoxBoundsInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAITetheringBoxBoundsInterface>();
	}
};
static_assert(alignof(IFortAITetheringBoxBoundsInterface) == 0x000008, "Wrong alignment on IFortAITetheringBoxBoundsInterface");
static_assert(sizeof(IFortAITetheringBoxBoundsInterface) == 0x000028, "Wrong size on IFortAITetheringBoxBoundsInterface");

// Class FortniteAI.FortAsyncAction_MakeTieredWaveEncounterSettings
// 0x02A0 (0x02D0 - 0x0030)
class UFortAsyncAction_MakeTieredWaveEncounterSettings final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FFortEncounterSettings& EncounterSettings)> OnComplete;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTieredWaveSetData                     WaveData;                                          // 0x0040(0x01C8)(Transient, NativeAccessSpecifierPrivate)
	TStructCycleFixup<struct FFortEncounterSettings, 0x00B8, 0x08> EncounterSettings;                                 // 0x0208(0x00B8)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAsyncAction_MakeTieredWaveEncounterSettings* CreateAsyncAction_MakeTieredWaveEncounterSettings(const struct FTieredWaveSetData& WaveData_0, const struct FFortEncounterSettings& InEncounterSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_MakeTieredWaveEncounterSettings">();
	}
	static class UFortAsyncAction_MakeTieredWaveEncounterSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_MakeTieredWaveEncounterSettings>();
	}
};
static_assert(alignof(UFortAsyncAction_MakeTieredWaveEncounterSettings) == 0x000008, "Wrong alignment on UFortAsyncAction_MakeTieredWaveEncounterSettings");
static_assert(sizeof(UFortAsyncAction_MakeTieredWaveEncounterSettings) == 0x0002D0, "Wrong size on UFortAsyncAction_MakeTieredWaveEncounterSettings");
static_assert(offsetof(UFortAsyncAction_MakeTieredWaveEncounterSettings, OnComplete) == 0x000030, "Member 'UFortAsyncAction_MakeTieredWaveEncounterSettings::OnComplete' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MakeTieredWaveEncounterSettings, WaveData) == 0x000040, "Member 'UFortAsyncAction_MakeTieredWaveEncounterSettings::WaveData' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MakeTieredWaveEncounterSettings, EncounterSettings) == 0x000208, "Member 'UFortAsyncAction_MakeTieredWaveEncounterSettings::EncounterSettings' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GameplayTagsPerDifficulty
// 0x0010 (0x0208 - 0x01F8)
class UFortQueryTest_GameplayTagsPerDifficulty final : public UEnvQueryTest
{
public:
	TArray<struct FFortGameplayTagQueryPerDifficulty> TagQueriesPerDifficulty;                           // 0x01F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GameplayTagsPerDifficulty">();
	}
	static class UFortQueryTest_GameplayTagsPerDifficulty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GameplayTagsPerDifficulty>();
	}
};
static_assert(alignof(UFortQueryTest_GameplayTagsPerDifficulty) == 0x000008, "Wrong alignment on UFortQueryTest_GameplayTagsPerDifficulty");
static_assert(sizeof(UFortQueryTest_GameplayTagsPerDifficulty) == 0x000208, "Wrong size on UFortQueryTest_GameplayTagsPerDifficulty");
static_assert(offsetof(UFortQueryTest_GameplayTagsPerDifficulty, TagQueriesPerDifficulty) == 0x0001F8, "Member 'UFortQueryTest_GameplayTagsPerDifficulty::TagQueriesPerDifficulty' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalType
// 0x0000 (0x0220 - 0x0220)
class UFortQueryTest_GoalType final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalType">();
	}
	static class UFortQueryTest_GoalType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalType>();
	}
};
static_assert(alignof(UFortQueryTest_GoalType) == 0x000008, "Wrong alignment on UFortQueryTest_GoalType");
static_assert(sizeof(UFortQueryTest_GoalType) == 0x000220, "Wrong size on UFortQueryTest_GoalType");

// Class FortniteAI.FortAthenaAIBotAimingDigestedSkillSet
// 0x0468 (0x0498 - 0x0030)
class UFortAthenaAIBotAimingDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	struct FDigestedFocusSetting                  DefaultFocusSetting;                               // 0x0030(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDigestedFocusSetting>          FocusSettings;                                     // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FLookAtDigestedSetting                 LookAtSettings[0x4];                               // 0x00A0(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowScanAroundWhileSwimming;                     // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrackingReactionTime;                              // 0x00E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackingInterpTime;                                // 0x00E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackingInterpTimeMultForGroundVehicles;           // 0x00EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackingInterpTimeMultForFlyingVehicles;           // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTrackingPredictionError;                        // 0x00F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTrackingOffsetErrorMultiplier;                  // 0x00F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdjustedTrackingOffsetErrorMultiplierAgainstAIs;   // 0x00FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackingErrorUpdateInterval;                       // 0x0100(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackingInAirVelocityThreshold;                    // 0x0104(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackingInAirHeightDeltaThreshold;                 // 0x0108(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetAcquisitionRate;                             // 0x010C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceEvaluationErrorRatio;                   // 0x0110(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingUpdateInterval;                           // 0x0114(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingUpdateIntervalMaxDeviation;               // 0x0118(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReachLeashLimitToleranceDistance;                  // 0x011C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShootFloorTrapOnlyWhenHigherThanTrap;             // 0x0120(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetingRotationSpeedLimit;                       // 0x0124(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingRotationSnapThreshold;                    // 0x0128(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDigestedWeaponAccuracy                NoWeaponAccuracy;                                  // 0x0130(0x01E8)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDigestedWeaponAccuracyCategory> WeaponAccuracies;                                  // 0x0318(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDigestedTargetBasedAccuracyCategory> DigestedTargetBasedAccuracies;                     // 0x0328(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FDigestedTrackingOffsetModifiers       TrackingOffsetModifiers;                           // 0x0338(0x0120)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDigestedAimingCircleSettings          DefaultAimingCircleSettings;                       // 0x0458(0x002C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortWeapon*                            CachedWeaponUsedToCalculateAccuracy;               // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotAimingDigestedSkillSet">();
	}
	static class UFortAthenaAIBotAimingDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotAimingDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotAimingDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotAimingDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotAimingDigestedSkillSet) == 0x000498, "Wrong size on UFortAthenaAIBotAimingDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, DefaultFocusSetting) == 0x000030, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::DefaultFocusSetting' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, FocusSettings) == 0x000090, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::FocusSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, LookAtSettings) == 0x0000A0, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::LookAtSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, bAllowScanAroundWhileSwimming) == 0x0000E0, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::bAllowScanAroundWhileSwimming' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TrackingReactionTime) == 0x0000E4, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TrackingReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TrackingInterpTime) == 0x0000E8, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TrackingInterpTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TrackingInterpTimeMultForGroundVehicles) == 0x0000EC, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TrackingInterpTimeMultForGroundVehicles' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TrackingInterpTimeMultForFlyingVehicles) == 0x0000F0, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TrackingInterpTimeMultForFlyingVehicles' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, MaxTrackingPredictionError) == 0x0000F4, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::MaxTrackingPredictionError' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, MaxTrackingOffsetErrorMultiplier) == 0x0000F8, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::MaxTrackingOffsetErrorMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, AdjustedTrackingOffsetErrorMultiplierAgainstAIs) == 0x0000FC, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::AdjustedTrackingOffsetErrorMultiplierAgainstAIs' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TrackingErrorUpdateInterval) == 0x000100, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TrackingErrorUpdateInterval' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TrackingInAirVelocityThreshold) == 0x000104, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TrackingInAirVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TrackingInAirHeightDeltaThreshold) == 0x000108, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TrackingInAirHeightDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TargetAcquisitionRate) == 0x00010C, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TargetAcquisitionRate' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, MaxDistanceEvaluationErrorRatio) == 0x000110, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::MaxDistanceEvaluationErrorRatio' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TargetingUpdateInterval) == 0x000114, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TargetingUpdateInterval' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TargetingUpdateIntervalMaxDeviation) == 0x000118, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TargetingUpdateIntervalMaxDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, ReachLeashLimitToleranceDistance) == 0x00011C, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::ReachLeashLimitToleranceDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, bShootFloorTrapOnlyWhenHigherThanTrap) == 0x000120, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::bShootFloorTrapOnlyWhenHigherThanTrap' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TargetingRotationSpeedLimit) == 0x000124, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TargetingRotationSpeedLimit' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TargetingRotationSnapThreshold) == 0x000128, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TargetingRotationSnapThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, NoWeaponAccuracy) == 0x000130, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::NoWeaponAccuracy' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, WeaponAccuracies) == 0x000318, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::WeaponAccuracies' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, DigestedTargetBasedAccuracies) == 0x000328, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::DigestedTargetBasedAccuracies' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, TrackingOffsetModifiers) == 0x000338, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::TrackingOffsetModifiers' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, DefaultAimingCircleSettings) == 0x000458, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::DefaultAimingCircleSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingDigestedSkillSet, CachedWeaponUsedToCalculateAccuracy) == 0x000488, "Member 'UFortAthenaAIBotAimingDigestedSkillSet::CachedWeaponUsedToCalculateAccuracy' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotAimingSkillSet
// 0x0D70 (0x0DA0 - 0x0030)
class UFortAthenaAIBotAimingSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FFocusSetting                          DefaultFocusSetting;                               // 0x0030(0x00F0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFocusSetting>                  FocusSettings;                                     // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FLookAtSetting                         LookAtSettings[0x4];                               // 0x0130(0x00A0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AllowScanAroundWhileSwimming;                      // 0x03B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrackingReactionTime;                              // 0x03D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrackingInterpTime;                                // 0x0400(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrackingInterpTimeMultForGroundVehicles;           // 0x0428(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrackingInterpTimeMultForFlyingVehicles;           // 0x0450(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxTrackingPredictionError;                        // 0x0478(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxTrackingOffsetErrorMultiplier;                  // 0x04A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AdjustedTrackingOffsetErrorMultiplierAgainstAIs;   // 0x04C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrackingErrorUpdateInterval;                       // 0x04F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrackingInAirVelocityThreshold;                    // 0x0518(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrackingInAirHeightDeltaThreshold;                 // 0x0540(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TargetAcquisitionRate;                             // 0x0568(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxDistanceEvaluationErrorRatio;                   // 0x0590(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TargetingUpdateInterval;                           // 0x05B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TargetingUpdateIntervalMaxDeviation;               // 0x05E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ReachLeashLimitToleranceDistance;                  // 0x0608(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ShootFloorTrapOnlyWhenHigherThanTrap;              // 0x0630(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TargetingRotationSpeedLimit;                       // 0x0658(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TargetingRotationSnapThreshold;                    // 0x0680(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FWeaponAccuracy                        NoWeaponAccuracy;                                  // 0x06A8(0x0508)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeaponAccuracyCategory>        WeaponAccuracies;                                  // 0x0BB0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTargetBasedAccuracyCategory>   TargetBasedAccuracies;                             // 0x0BC0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bDigestTrackingOffsetModifiersWithAvgMatchMMR : 1; // 0x0BD0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_BD1[0x7];                                      // 0x0BD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTrackingOffsetModifierInfo>    TrackingOffsetModifiers;                           // 0x0BD8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAimingCircleSettings                  DefaultAimingCircleSettings;                       // 0x0BE8(0x01B8)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotAimingSkillSet">();
	}
	static class UFortAthenaAIBotAimingSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotAimingSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotAimingSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotAimingSkillSet");
static_assert(sizeof(UFortAthenaAIBotAimingSkillSet) == 0x000DA0, "Wrong size on UFortAthenaAIBotAimingSkillSet");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, DefaultFocusSetting) == 0x000030, "Member 'UFortAthenaAIBotAimingSkillSet::DefaultFocusSetting' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, FocusSettings) == 0x000120, "Member 'UFortAthenaAIBotAimingSkillSet::FocusSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, LookAtSettings) == 0x000130, "Member 'UFortAthenaAIBotAimingSkillSet::LookAtSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, AllowScanAroundWhileSwimming) == 0x0003B0, "Member 'UFortAthenaAIBotAimingSkillSet::AllowScanAroundWhileSwimming' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TrackingReactionTime) == 0x0003D8, "Member 'UFortAthenaAIBotAimingSkillSet::TrackingReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TrackingInterpTime) == 0x000400, "Member 'UFortAthenaAIBotAimingSkillSet::TrackingInterpTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TrackingInterpTimeMultForGroundVehicles) == 0x000428, "Member 'UFortAthenaAIBotAimingSkillSet::TrackingInterpTimeMultForGroundVehicles' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TrackingInterpTimeMultForFlyingVehicles) == 0x000450, "Member 'UFortAthenaAIBotAimingSkillSet::TrackingInterpTimeMultForFlyingVehicles' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, MaxTrackingPredictionError) == 0x000478, "Member 'UFortAthenaAIBotAimingSkillSet::MaxTrackingPredictionError' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, MaxTrackingOffsetErrorMultiplier) == 0x0004A0, "Member 'UFortAthenaAIBotAimingSkillSet::MaxTrackingOffsetErrorMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, AdjustedTrackingOffsetErrorMultiplierAgainstAIs) == 0x0004C8, "Member 'UFortAthenaAIBotAimingSkillSet::AdjustedTrackingOffsetErrorMultiplierAgainstAIs' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TrackingErrorUpdateInterval) == 0x0004F0, "Member 'UFortAthenaAIBotAimingSkillSet::TrackingErrorUpdateInterval' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TrackingInAirVelocityThreshold) == 0x000518, "Member 'UFortAthenaAIBotAimingSkillSet::TrackingInAirVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TrackingInAirHeightDeltaThreshold) == 0x000540, "Member 'UFortAthenaAIBotAimingSkillSet::TrackingInAirHeightDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TargetAcquisitionRate) == 0x000568, "Member 'UFortAthenaAIBotAimingSkillSet::TargetAcquisitionRate' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, MaxDistanceEvaluationErrorRatio) == 0x000590, "Member 'UFortAthenaAIBotAimingSkillSet::MaxDistanceEvaluationErrorRatio' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TargetingUpdateInterval) == 0x0005B8, "Member 'UFortAthenaAIBotAimingSkillSet::TargetingUpdateInterval' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TargetingUpdateIntervalMaxDeviation) == 0x0005E0, "Member 'UFortAthenaAIBotAimingSkillSet::TargetingUpdateIntervalMaxDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, ReachLeashLimitToleranceDistance) == 0x000608, "Member 'UFortAthenaAIBotAimingSkillSet::ReachLeashLimitToleranceDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, ShootFloorTrapOnlyWhenHigherThanTrap) == 0x000630, "Member 'UFortAthenaAIBotAimingSkillSet::ShootFloorTrapOnlyWhenHigherThanTrap' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TargetingRotationSpeedLimit) == 0x000658, "Member 'UFortAthenaAIBotAimingSkillSet::TargetingRotationSpeedLimit' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TargetingRotationSnapThreshold) == 0x000680, "Member 'UFortAthenaAIBotAimingSkillSet::TargetingRotationSnapThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, NoWeaponAccuracy) == 0x0006A8, "Member 'UFortAthenaAIBotAimingSkillSet::NoWeaponAccuracy' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, WeaponAccuracies) == 0x000BB0, "Member 'UFortAthenaAIBotAimingSkillSet::WeaponAccuracies' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TargetBasedAccuracies) == 0x000BC0, "Member 'UFortAthenaAIBotAimingSkillSet::TargetBasedAccuracies' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, TrackingOffsetModifiers) == 0x000BD8, "Member 'UFortAthenaAIBotAimingSkillSet::TrackingOffsetModifiers' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAimingSkillSet, DefaultAimingCircleSettings) == 0x000BE8, "Member 'UFortAthenaAIBotAimingSkillSet::DefaultAimingCircleSettings' has a wrong offset!");

// Class FortniteAI.AISenseScalableConfig_Sight
// 0x00C8 (0x00F0 - 0x0028)
class UAISenseScalableConfig_Sight final : public UAISenseScalableConfig
{
public:
	struct FScalableFloat                         SightRadius;                                       // 0x0028(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LoseSightRadius;                                   // 0x0050(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PeripheralVisionAngleDegrees;                      // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PointOfViewBackwardOffset;                         // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         NearClippingRadius;                                // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseScalableConfig_Sight">();
	}
	static class UAISenseScalableConfig_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseScalableConfig_Sight>();
	}
};
static_assert(alignof(UAISenseScalableConfig_Sight) == 0x000008, "Wrong alignment on UAISenseScalableConfig_Sight");
static_assert(sizeof(UAISenseScalableConfig_Sight) == 0x0000F0, "Wrong size on UAISenseScalableConfig_Sight");
static_assert(offsetof(UAISenseScalableConfig_Sight, SightRadius) == 0x000028, "Member 'UAISenseScalableConfig_Sight::SightRadius' has a wrong offset!");
static_assert(offsetof(UAISenseScalableConfig_Sight, LoseSightRadius) == 0x000050, "Member 'UAISenseScalableConfig_Sight::LoseSightRadius' has a wrong offset!");
static_assert(offsetof(UAISenseScalableConfig_Sight, PeripheralVisionAngleDegrees) == 0x000078, "Member 'UAISenseScalableConfig_Sight::PeripheralVisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(UAISenseScalableConfig_Sight, PointOfViewBackwardOffset) == 0x0000A0, "Member 'UAISenseScalableConfig_Sight::PointOfViewBackwardOffset' has a wrong offset!");
static_assert(offsetof(UAISenseScalableConfig_Sight, NearClippingRadius) == 0x0000C8, "Member 'UAISenseScalableConfig_Sight::NearClippingRadius' has a wrong offset!");

// Class FortniteAI.AISenseScalableConfig_Hearing
// 0x0028 (0x0050 - 0x0028)
class UAISenseScalableConfig_Hearing final : public UAISenseScalableConfig
{
public:
	struct FScalableFloat                         HearingRange;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseScalableConfig_Hearing">();
	}
	static class UAISenseScalableConfig_Hearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseScalableConfig_Hearing>();
	}
};
static_assert(alignof(UAISenseScalableConfig_Hearing) == 0x000008, "Wrong alignment on UAISenseScalableConfig_Hearing");
static_assert(sizeof(UAISenseScalableConfig_Hearing) == 0x000050, "Wrong size on UAISenseScalableConfig_Hearing");
static_assert(offsetof(UAISenseScalableConfig_Hearing, HearingRange) == 0x000028, "Member 'UAISenseScalableConfig_Hearing::HearingRange' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotAlertLevelConfig
// 0x0010 (0x0038 - 0x0028)
class UFortAthenaAIBotAlertLevelConfig final : public UObject
{
public:
	int32                                         AlertLevels;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISenseScalableConfig*                 ScalableSenseConfig;                               // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotAlertLevelConfig">();
	}
	static class UFortAthenaAIBotAlertLevelConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotAlertLevelConfig>();
	}
};
static_assert(alignof(UFortAthenaAIBotAlertLevelConfig) == 0x000008, "Wrong alignment on UFortAthenaAIBotAlertLevelConfig");
static_assert(sizeof(UFortAthenaAIBotAlertLevelConfig) == 0x000038, "Wrong size on UFortAthenaAIBotAlertLevelConfig");
static_assert(offsetof(UFortAthenaAIBotAlertLevelConfig, AlertLevels) == 0x000028, "Member 'UFortAthenaAIBotAlertLevelConfig::AlertLevels' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAlertLevelConfig, ScalableSenseConfig) == 0x000030, "Member 'UFortAthenaAIBotAlertLevelConfig::ScalableSenseConfig' has a wrong offset!");

// Class FortniteAI.FortBTTask_TakerMoveToNavmesh
// 0x0000 (0x00B0 - 0x00B0)
class UFortBTTask_TakerMoveToNavmesh final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_TakerMoveToNavmesh">();
	}
	static class UFortBTTask_TakerMoveToNavmesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_TakerMoveToNavmesh>();
	}
};
static_assert(alignof(UFortBTTask_TakerMoveToNavmesh) == 0x000008, "Wrong alignment on UFortBTTask_TakerMoveToNavmesh");
static_assert(sizeof(UFortBTTask_TakerMoveToNavmesh) == 0x0000B0, "Wrong size on UFortBTTask_TakerMoveToNavmesh");

// Class FortniteAI.FortAthenaAIBotAttackingDigestedSkillSet
// 0x00B0 (0x00E0 - 0x0030)
class UFortAthenaAIBotAttackingDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         MaxDistanceToEngageMeleeSq;                        // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceToGiveUpMeleeSq;                        // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceToThrowMeleeAttackSq;                   // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseContinuousMeleeAttack;                         // 0x003C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyEngageMeleeAgainstThreatThatHasNoRangeWeapon; // 0x003D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToConsiderAsAnAlternateTargetSq;        // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAlternateTargetRequiredTags;                // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AlternateTargetRequiredTags;                       // 0x0048(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableWTFBehavior;                                // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinCooldownDelayBetweenMeleeAttackAttempts;        // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCooldownDelayBetweenMeleeAttackAttempts;        // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ThrowableGameplayTags;                             // 0x0078(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         MinThrowableCount;                                 // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxThrowableCount;                                 // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowableCooldownMin;                              // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowableCooldownMax;                              // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowableMinimumRangeSquared;                      // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bThrowableEvaluatorActive;                         // 0x00AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RetreatMinHealthRange;                             // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RetreatMaxHealthRange;                             // 0x00B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RetreatProbability;                                // 0x00B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RetreatRangeMinSquared;                            // 0x00BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RetreatRangeMaxSquared;                            // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RetreatMaxDuration;                                // 0x00C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RetreatPositionBoxExtent;                          // 0x00C8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotAttackingDigestedSkillSet">();
	}
	static class UFortAthenaAIBotAttackingDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotAttackingDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotAttackingDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotAttackingDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotAttackingDigestedSkillSet) == 0x0000E0, "Wrong size on UFortAthenaAIBotAttackingDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, MaxDistanceToEngageMeleeSq) == 0x000030, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::MaxDistanceToEngageMeleeSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, MinDistanceToGiveUpMeleeSq) == 0x000034, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::MinDistanceToGiveUpMeleeSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, MaxDistanceToThrowMeleeAttackSq) == 0x000038, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::MaxDistanceToThrowMeleeAttackSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, bUseContinuousMeleeAttack) == 0x00003C, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::bUseContinuousMeleeAttack' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, bOnlyEngageMeleeAgainstThreatThatHasNoRangeWeapon) == 0x00003D, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::bOnlyEngageMeleeAgainstThreatThatHasNoRangeWeapon' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, MaxDistanceToConsiderAsAnAlternateTargetSq) == 0x000040, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::MaxDistanceToConsiderAsAnAlternateTargetSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, bEnableAlternateTargetRequiredTags) == 0x000044, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::bEnableAlternateTargetRequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, AlternateTargetRequiredTags) == 0x000048, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::AlternateTargetRequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, bEnableWTFBehavior) == 0x000068, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::bEnableWTFBehavior' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, MinCooldownDelayBetweenMeleeAttackAttempts) == 0x00006C, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::MinCooldownDelayBetweenMeleeAttackAttempts' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, MaxCooldownDelayBetweenMeleeAttackAttempts) == 0x000070, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::MaxCooldownDelayBetweenMeleeAttackAttempts' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, ThrowableGameplayTags) == 0x000078, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::ThrowableGameplayTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, MinThrowableCount) == 0x000098, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::MinThrowableCount' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, MaxThrowableCount) == 0x00009C, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::MaxThrowableCount' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, ThrowableCooldownMin) == 0x0000A0, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::ThrowableCooldownMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, ThrowableCooldownMax) == 0x0000A4, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::ThrowableCooldownMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, ThrowableMinimumRangeSquared) == 0x0000A8, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::ThrowableMinimumRangeSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, bThrowableEvaluatorActive) == 0x0000AC, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::bThrowableEvaluatorActive' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, RetreatMinHealthRange) == 0x0000B0, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::RetreatMinHealthRange' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, RetreatMaxHealthRange) == 0x0000B4, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::RetreatMaxHealthRange' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, RetreatProbability) == 0x0000B8, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::RetreatProbability' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, RetreatRangeMinSquared) == 0x0000BC, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::RetreatRangeMinSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, RetreatRangeMaxSquared) == 0x0000C0, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::RetreatRangeMaxSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, RetreatMaxDuration) == 0x0000C4, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::RetreatMaxDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingDigestedSkillSet, RetreatPositionBoxExtent) == 0x0000C8, "Member 'UFortAthenaAIBotAttackingDigestedSkillSet::RetreatPositionBoxExtent' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotAttackingSkillSet
// 0x03C8 (0x03F8 - 0x0030)
class UFortAthenaAIBotAttackingSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         MaxDistanceToEngageMelee;                          // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinDistanceToGiveUpMelee;                          // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxDistanceToThrowMeleeAttack;                     // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         UseContinuousMeleeAttack;                          // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         OnlyEngageMeleeAgainstThreatThatHasNoRangeWeapon;  // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxDistanceToConsiderAsAnAlternateTarget;          // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         EnableAlternateTargetRequiredTags;                 // 0x0120(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AlternateTargetRequiredTags;                       // 0x0148(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         EnableWTFBehavior;                                 // 0x0168(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinCooldownDelayBetweenMeleeAttackAttempts;        // 0x0190(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxCooldownDelayBetweenMeleeAttackAttempts;        // 0x01B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ThrowableGameplayTags;                             // 0x01E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinThrowableCount;                                 // 0x0200(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxThrowableCount;                                 // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThrowableCooldownMin;                              // 0x0250(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThrowableCooldownMax;                              // 0x0278(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThrowableMinimumRange;                             // 0x02A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThrowableEvaluatorActive;                          // 0x02C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RetreatMinHealthRange;                             // 0x02F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RetreatMaxHealthRange;                             // 0x0318(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RetreatProbability;                                // 0x0340(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RetreatRangeMin;                                   // 0x0368(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RetreatRangeMax;                                   // 0x0390(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RetreatMaxDuration;                                // 0x03B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                RetreatPositionBoxExtent;                          // 0x03E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotAttackingSkillSet">();
	}
	static class UFortAthenaAIBotAttackingSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotAttackingSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotAttackingSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotAttackingSkillSet");
static_assert(sizeof(UFortAthenaAIBotAttackingSkillSet) == 0x0003F8, "Wrong size on UFortAthenaAIBotAttackingSkillSet");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, MaxDistanceToEngageMelee) == 0x000030, "Member 'UFortAthenaAIBotAttackingSkillSet::MaxDistanceToEngageMelee' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, MinDistanceToGiveUpMelee) == 0x000058, "Member 'UFortAthenaAIBotAttackingSkillSet::MinDistanceToGiveUpMelee' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, MaxDistanceToThrowMeleeAttack) == 0x000080, "Member 'UFortAthenaAIBotAttackingSkillSet::MaxDistanceToThrowMeleeAttack' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, UseContinuousMeleeAttack) == 0x0000A8, "Member 'UFortAthenaAIBotAttackingSkillSet::UseContinuousMeleeAttack' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, OnlyEngageMeleeAgainstThreatThatHasNoRangeWeapon) == 0x0000D0, "Member 'UFortAthenaAIBotAttackingSkillSet::OnlyEngageMeleeAgainstThreatThatHasNoRangeWeapon' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, MaxDistanceToConsiderAsAnAlternateTarget) == 0x0000F8, "Member 'UFortAthenaAIBotAttackingSkillSet::MaxDistanceToConsiderAsAnAlternateTarget' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, EnableAlternateTargetRequiredTags) == 0x000120, "Member 'UFortAthenaAIBotAttackingSkillSet::EnableAlternateTargetRequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, AlternateTargetRequiredTags) == 0x000148, "Member 'UFortAthenaAIBotAttackingSkillSet::AlternateTargetRequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, EnableWTFBehavior) == 0x000168, "Member 'UFortAthenaAIBotAttackingSkillSet::EnableWTFBehavior' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, MinCooldownDelayBetweenMeleeAttackAttempts) == 0x000190, "Member 'UFortAthenaAIBotAttackingSkillSet::MinCooldownDelayBetweenMeleeAttackAttempts' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, MaxCooldownDelayBetweenMeleeAttackAttempts) == 0x0001B8, "Member 'UFortAthenaAIBotAttackingSkillSet::MaxCooldownDelayBetweenMeleeAttackAttempts' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, ThrowableGameplayTags) == 0x0001E0, "Member 'UFortAthenaAIBotAttackingSkillSet::ThrowableGameplayTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, MinThrowableCount) == 0x000200, "Member 'UFortAthenaAIBotAttackingSkillSet::MinThrowableCount' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, MaxThrowableCount) == 0x000228, "Member 'UFortAthenaAIBotAttackingSkillSet::MaxThrowableCount' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, ThrowableCooldownMin) == 0x000250, "Member 'UFortAthenaAIBotAttackingSkillSet::ThrowableCooldownMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, ThrowableCooldownMax) == 0x000278, "Member 'UFortAthenaAIBotAttackingSkillSet::ThrowableCooldownMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, ThrowableMinimumRange) == 0x0002A0, "Member 'UFortAthenaAIBotAttackingSkillSet::ThrowableMinimumRange' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, ThrowableEvaluatorActive) == 0x0002C8, "Member 'UFortAthenaAIBotAttackingSkillSet::ThrowableEvaluatorActive' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, RetreatMinHealthRange) == 0x0002F0, "Member 'UFortAthenaAIBotAttackingSkillSet::RetreatMinHealthRange' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, RetreatMaxHealthRange) == 0x000318, "Member 'UFortAthenaAIBotAttackingSkillSet::RetreatMaxHealthRange' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, RetreatProbability) == 0x000340, "Member 'UFortAthenaAIBotAttackingSkillSet::RetreatProbability' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, RetreatRangeMin) == 0x000368, "Member 'UFortAthenaAIBotAttackingSkillSet::RetreatRangeMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, RetreatRangeMax) == 0x000390, "Member 'UFortAthenaAIBotAttackingSkillSet::RetreatRangeMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, RetreatMaxDuration) == 0x0003B8, "Member 'UFortAthenaAIBotAttackingSkillSet::RetreatMaxDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotAttackingSkillSet, RetreatPositionBoxExtent) == 0x0003E0, "Member 'UFortAthenaAIBotAttackingSkillSet::RetreatPositionBoxExtent' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotBuildingComponent
// 0x0030 (0x00D0 - 0x00A0)
class UFortAthenaAIBotBuildingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotBuildingComponent">();
	}
	static class UFortAthenaAIBotBuildingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotBuildingComponent>();
	}
};
static_assert(alignof(UFortAthenaAIBotBuildingComponent) == 0x000008, "Wrong alignment on UFortAthenaAIBotBuildingComponent");
static_assert(sizeof(UFortAthenaAIBotBuildingComponent) == 0x0000D0, "Wrong size on UFortAthenaAIBotBuildingComponent");

// Class FortniteAI.FortAthenaAIBotBuildingDigestedSkillSet
// 0x0040 (0x0070 - 0x0030)
class UFortAthenaAIBotBuildingDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         DefensiveBuildingDelayBetweenBuilds;               // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefensiveBuildingDelayDeviationBetweenBuilds;      // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenBuildPieces;                           // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceEquipBuildToolDuration;                       // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StealWallTurboBuildDetectionTime;                  // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StealWallAfterNumberOfTurboBuiltWall;              // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StealWallEfficiency;                               // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StealWallBuildingTemplateWeights[0x5];             // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAthenaFortAIBotDigestedWeightedBuildingList> WeightedBuildingLists;                             // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotBuildingDigestedSkillSet">();
	}
	static class UFortAthenaAIBotBuildingDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotBuildingDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotBuildingDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotBuildingDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotBuildingDigestedSkillSet) == 0x000070, "Wrong size on UFortAthenaAIBotBuildingDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotBuildingDigestedSkillSet, DefensiveBuildingDelayBetweenBuilds) == 0x000030, "Member 'UFortAthenaAIBotBuildingDigestedSkillSet::DefensiveBuildingDelayBetweenBuilds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingDigestedSkillSet, DefensiveBuildingDelayDeviationBetweenBuilds) == 0x000034, "Member 'UFortAthenaAIBotBuildingDigestedSkillSet::DefensiveBuildingDelayDeviationBetweenBuilds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingDigestedSkillSet, DelayBetweenBuildPieces) == 0x000038, "Member 'UFortAthenaAIBotBuildingDigestedSkillSet::DelayBetweenBuildPieces' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingDigestedSkillSet, ForceEquipBuildToolDuration) == 0x00003C, "Member 'UFortAthenaAIBotBuildingDigestedSkillSet::ForceEquipBuildToolDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingDigestedSkillSet, StealWallTurboBuildDetectionTime) == 0x000040, "Member 'UFortAthenaAIBotBuildingDigestedSkillSet::StealWallTurboBuildDetectionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingDigestedSkillSet, StealWallAfterNumberOfTurboBuiltWall) == 0x000044, "Member 'UFortAthenaAIBotBuildingDigestedSkillSet::StealWallAfterNumberOfTurboBuiltWall' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingDigestedSkillSet, StealWallEfficiency) == 0x000048, "Member 'UFortAthenaAIBotBuildingDigestedSkillSet::StealWallEfficiency' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingDigestedSkillSet, StealWallBuildingTemplateWeights) == 0x00004C, "Member 'UFortAthenaAIBotBuildingDigestedSkillSet::StealWallBuildingTemplateWeights' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingDigestedSkillSet, WeightedBuildingLists) == 0x000060, "Member 'UFortAthenaAIBotBuildingDigestedSkillSet::WeightedBuildingLists' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_AIAnalytic
// 0x0028 (0x0078 - 0x0050)
class UFortAthenaAIRuntimeParameters_AIAnalytic final : public UFortAthenaAIRuntimeParameters_Analytic
{
public:
	class FString                                 AnalyticUniqueID;                                  // 0x0050(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AIType;                                            // 0x0060(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bShouldSendSpawnEvents : 1;                        // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldRecordGrabbedPickups : 1;                   // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldRecordDroppedPickups : 1;                   // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldRecordDeathInstigator : 1;                  // 0x0070(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldRecordRegularDowns : 1;                     // 0x0070(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldRecordTetheredDowns : 1;                    // 0x0070(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_AIAnalytic">();
	}
	static class UFortAthenaAIRuntimeParameters_AIAnalytic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_AIAnalytic>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_AIAnalytic) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_AIAnalytic");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_AIAnalytic) == 0x000078, "Wrong size on UFortAthenaAIRuntimeParameters_AIAnalytic");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIAnalytic, AnalyticUniqueID) == 0x000050, "Member 'UFortAthenaAIRuntimeParameters_AIAnalytic::AnalyticUniqueID' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIAnalytic, AIType) == 0x000060, "Member 'UFortAthenaAIRuntimeParameters_AIAnalytic::AIType' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotBuildingSkillSet
// 0x01F0 (0x0220 - 0x0030)
class UFortAthenaAIBotBuildingSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         DefensiveBuildingDelayBetweenBuilds;               // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DefensiveBuildingDelayDeviationBetweenBuilds;      // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DelayBetweenBuildPieces;                           // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ForceEquipBuildToolDuration;                       // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAthenaFortAIBotWeightedBuildingList> WeightedBuildingLists;                             // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealWallTurboBuildDetectionTime;                  // 0x00E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealWallAfterNumberOfTurboBuiltWall;              // 0x0108(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealWallEfficiency;                               // 0x0130(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealWallBuildingTemplateWeights[0x5];             // 0x0158(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotBuildingSkillSet">();
	}
	static class UFortAthenaAIBotBuildingSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotBuildingSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotBuildingSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotBuildingSkillSet");
static_assert(sizeof(UFortAthenaAIBotBuildingSkillSet) == 0x000220, "Wrong size on UFortAthenaAIBotBuildingSkillSet");
static_assert(offsetof(UFortAthenaAIBotBuildingSkillSet, DefensiveBuildingDelayBetweenBuilds) == 0x000030, "Member 'UFortAthenaAIBotBuildingSkillSet::DefensiveBuildingDelayBetweenBuilds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingSkillSet, DefensiveBuildingDelayDeviationBetweenBuilds) == 0x000058, "Member 'UFortAthenaAIBotBuildingSkillSet::DefensiveBuildingDelayDeviationBetweenBuilds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingSkillSet, DelayBetweenBuildPieces) == 0x000080, "Member 'UFortAthenaAIBotBuildingSkillSet::DelayBetweenBuildPieces' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingSkillSet, ForceEquipBuildToolDuration) == 0x0000A8, "Member 'UFortAthenaAIBotBuildingSkillSet::ForceEquipBuildToolDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingSkillSet, WeightedBuildingLists) == 0x0000D0, "Member 'UFortAthenaAIBotBuildingSkillSet::WeightedBuildingLists' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingSkillSet, StealWallTurboBuildDetectionTime) == 0x0000E0, "Member 'UFortAthenaAIBotBuildingSkillSet::StealWallTurboBuildDetectionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingSkillSet, StealWallAfterNumberOfTurboBuiltWall) == 0x000108, "Member 'UFortAthenaAIBotBuildingSkillSet::StealWallAfterNumberOfTurboBuiltWall' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingSkillSet, StealWallEfficiency) == 0x000130, "Member 'UFortAthenaAIBotBuildingSkillSet::StealWallEfficiency' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotBuildingSkillSet, StealWallBuildingTemplateWeights) == 0x000158, "Member 'UFortAthenaAIBotBuildingSkillSet::StealWallBuildingTemplateWeights' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_LODBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_LODBase : public UFortAthenaAISpawnerDataComponent
{
public:
	class UFortAthenaAILODSettingsContainer* GetAILODSettingsContainer() const;
	struct FClientAILODSettings GetClientAILODSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_LODBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_LODBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_LODBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_LODBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_LODBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_LODBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_LODBase");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_LOD
// 0x02F8 (0x0328 - 0x0030)
class UFortAthenaAISpawnerDataComponent_LOD final : public UFortAthenaAISpawnerDataComponent_LODBase
{
public:
	TSubclassOf<class UFortAthenaAILODSettingsContainer> LODSettings;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientAILODSettings                   ClientLODSettings;                                 // 0x0038(0x02F0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_LOD">();
	}
	static class UFortAthenaAISpawnerDataComponent_LOD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_LOD>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_LOD) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_LOD");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_LOD) == 0x000328, "Wrong size on UFortAthenaAISpawnerDataComponent_LOD");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_LOD, LODSettings) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_LOD::LODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_LOD, ClientLODSettings) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_LOD::ClientLODSettings' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotCharacterCustomization
// 0x0168 (0x0190 - 0x0028)
class UFortAthenaAIBotCharacterCustomization final : public UObject
{
public:
	TStructCycleFixup<struct FFortAthenaLoadout, 0x0168, 0x08> CustomizationLoadout;                              // 0x0028(0x0168)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotCharacterCustomization">();
	}
	static class UFortAthenaAIBotCharacterCustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotCharacterCustomization>();
	}
};
static_assert(alignof(UFortAthenaAIBotCharacterCustomization) == 0x000008, "Wrong alignment on UFortAthenaAIBotCharacterCustomization");
static_assert(sizeof(UFortAthenaAIBotCharacterCustomization) == 0x000190, "Wrong size on UFortAthenaAIBotCharacterCustomization");
static_assert(offsetof(UFortAthenaAIBotCharacterCustomization, CustomizationLoadout) == 0x000028, "Member 'UFortAthenaAIBotCharacterCustomization::CustomizationLoadout' has a wrong offset!");

// Class FortniteAI.FortBotNameSettings
// 0x0028 (0x0050 - 0x0028)
class UFortBotNameSettings final : public UObject
{
public:
	EBotNamingMode                                NamingMode;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OverrideName;                                      // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAddPlayerIDSuffix;                                // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotNameSettings">();
	}
	static class UFortBotNameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBotNameSettings>();
	}
};
static_assert(alignof(UFortBotNameSettings) == 0x000008, "Wrong alignment on UFortBotNameSettings");
static_assert(sizeof(UFortBotNameSettings) == 0x000050, "Wrong size on UFortBotNameSettings");
static_assert(offsetof(UFortBotNameSettings, NamingMode) == 0x000028, "Member 'UFortBotNameSettings::NamingMode' has a wrong offset!");
static_assert(offsetof(UFortBotNameSettings, OverrideName) == 0x000030, "Member 'UFortBotNameSettings::OverrideName' has a wrong offset!");
static_assert(offsetof(UFortBotNameSettings, bAddPlayerIDSuffix) == 0x000048, "Member 'UFortBotNameSettings::bAddPlayerIDSuffix' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIPawnCosmeticBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIPawnCosmeticBase : public UFortAthenaAISpawnerDataComponent_CosmeticBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIPawnCosmeticBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIPawnCosmeticBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIPawnCosmeticBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIPawnCosmeticBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIPawnCosmeticBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIPawnCosmeticBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_AIPawnCosmeticBase");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization
// 0x0018 (0x0048 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization final : public UFortAthenaAISpawnerDataComponent_AIPawnCosmeticBase
{
public:
	struct FGameplayTag                           FallbackTag;                                       // 0x0030(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIPawnCustomizationDefinition*     CustomizationDefinition;                           // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanUnloadCustomization;                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization) == 0x000048, "Wrong size on UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization, FallbackTag) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization::FallbackTag' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization, CustomizationDefinition) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization::CustomizationDefinition' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization, bCanUnloadCustomization) == 0x000040, "Member 'UFortAthenaAISpawnerDataComponent_AIPawnCosmeticCustomization::bCanUnloadCustomization' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_PointsOnWaterShoreLine
// 0x0030 (0x00B8 - 0x0088)
class UFortQueryGenerator_PointsOnWaterShoreLine final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortQueryData_CurvesAroundLine> CurvesAroundLineAsset;                             // 0x0090(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsOnWaterShoreLine">();
	}
	static class UFortQueryGenerator_PointsOnWaterShoreLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsOnWaterShoreLine>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsOnWaterShoreLine) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsOnWaterShoreLine");
static_assert(sizeof(UFortQueryGenerator_PointsOnWaterShoreLine) == 0x0000B8, "Wrong size on UFortQueryGenerator_PointsOnWaterShoreLine");
static_assert(offsetof(UFortQueryGenerator_PointsOnWaterShoreLine, GenerateAround) == 0x000088, "Member 'UFortQueryGenerator_PointsOnWaterShoreLine::GenerateAround' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnWaterShoreLine, CurvesAroundLineAsset) == 0x000090, "Member 'UFortQueryGenerator_PointsOnWaterShoreLine::CurvesAroundLineAsset' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotCosmeticData
// 0x0010 (0x0040 - 0x0030)
class UFortAthenaAIBotCosmeticData final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UFortAthenaAIBotCosmeticLibraryData>> CosmeticLibraries;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	TSoftObjectPtr<class UFortAthenaAIBotCosmeticLibraryData> FindLibraryDataFromName(const class FString& PartialName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotCosmeticData">();
	}
	static class UFortAthenaAIBotCosmeticData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotCosmeticData>();
	}
};
static_assert(alignof(UFortAthenaAIBotCosmeticData) == 0x000008, "Wrong alignment on UFortAthenaAIBotCosmeticData");
static_assert(sizeof(UFortAthenaAIBotCosmeticData) == 0x000040, "Wrong size on UFortAthenaAIBotCosmeticData");
static_assert(offsetof(UFortAthenaAIBotCosmeticData, CosmeticLibraries) == 0x000030, "Member 'UFortAthenaAIBotCosmeticData::CosmeticLibraries' has a wrong offset!");

// Class FortniteAI.FortBTTask_Sleep
// 0x0000 (0x0070 - 0x0070)
class UFortBTTask_Sleep final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_Sleep">();
	}
	static class UFortBTTask_Sleep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_Sleep>();
	}
};
static_assert(alignof(UFortBTTask_Sleep) == 0x000008, "Wrong alignment on UFortBTTask_Sleep");
static_assert(sizeof(UFortBTTask_Sleep) == 0x000070, "Wrong size on UFortBTTask_Sleep");

// Class FortniteAI.FortQueryGenerator_MutatorActorQueryResults
// 0x0000 (0x0050 - 0x0050)
class UFortQueryGenerator_MutatorActorQueryResults final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_MutatorActorQueryResults">();
	}
	static class UFortQueryGenerator_MutatorActorQueryResults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_MutatorActorQueryResults>();
	}
};
static_assert(alignof(UFortQueryGenerator_MutatorActorQueryResults) == 0x000008, "Wrong alignment on UFortQueryGenerator_MutatorActorQueryResults");
static_assert(sizeof(UFortQueryGenerator_MutatorActorQueryResults) == 0x000050, "Wrong size on UFortQueryGenerator_MutatorActorQueryResults");

// Class FortniteAI.FortAthenaAIBotCosmeticLibraryData
// 0x0118 (0x0148 - 0x0030)
class UFortAthenaAIBotCosmeticLibraryData final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UDataTable>              PredefineSetsDataTable;                            // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              CharactersDataTable;                               // 0x0058(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              GlidersDataTable;                                  // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              SkyDiveContrailsDataTable;                         // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              BackpacksDataTable;                                // 0x00D0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              PickaxesDataTable;                                 // 0x00F8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              FallbackCharactersDataTable;                       // 0x0120(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool FillDataTableValuesFromSourceLibrary(const class UFortAthenaAIBotCosmeticLibraryData* SourceLibrary);
	class UDataTable* FindDataTableFromAssetType(const class FString& AssetType);

	TArray<class UDataTable*> RetrieveDataTables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotCosmeticLibraryData">();
	}
	static class UFortAthenaAIBotCosmeticLibraryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotCosmeticLibraryData>();
	}
};
static_assert(alignof(UFortAthenaAIBotCosmeticLibraryData) == 0x000008, "Wrong alignment on UFortAthenaAIBotCosmeticLibraryData");
static_assert(sizeof(UFortAthenaAIBotCosmeticLibraryData) == 0x000148, "Wrong size on UFortAthenaAIBotCosmeticLibraryData");
static_assert(offsetof(UFortAthenaAIBotCosmeticLibraryData, PredefineSetsDataTable) == 0x000030, "Member 'UFortAthenaAIBotCosmeticLibraryData::PredefineSetsDataTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCosmeticLibraryData, CharactersDataTable) == 0x000058, "Member 'UFortAthenaAIBotCosmeticLibraryData::CharactersDataTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCosmeticLibraryData, GlidersDataTable) == 0x000080, "Member 'UFortAthenaAIBotCosmeticLibraryData::GlidersDataTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCosmeticLibraryData, SkyDiveContrailsDataTable) == 0x0000A8, "Member 'UFortAthenaAIBotCosmeticLibraryData::SkyDiveContrailsDataTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCosmeticLibraryData, BackpacksDataTable) == 0x0000D0, "Member 'UFortAthenaAIBotCosmeticLibraryData::BackpacksDataTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCosmeticLibraryData, PickaxesDataTable) == 0x0000F8, "Member 'UFortAthenaAIBotCosmeticLibraryData::PickaxesDataTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCosmeticLibraryData, FallbackCharactersDataTable) == 0x000120, "Member 'UFortAthenaAIBotCosmeticLibraryData::FallbackCharactersDataTable' has a wrong offset!");

// Class FortniteAI.BotCosmeticBlueprintHelperLibrary
// 0x0000 (0x0028 - 0x0028)
class UBotCosmeticBlueprintHelperLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ExportDataTableToSourceCSV(const class UDataTable* DataTable, const bool bCanCheckOutFile);
	static bool GenerateWeightedCSV(const class FString& AssetTypeName, const TArray<class FString>& AssetNames, const TArray<int32>& AssetWeight, class FString* CSV);
	static bool LoadDataFromCSV(const class FString& FilePath, const TArray<class FString>& ForbiddenAssetNames, TArray<class FString>* AssetNames, TArray<class FString>* AssetTypes, TArray<int32>* AssetUsageCounts, TArray<int32>* AssetTypeSplitIndices);
	static TArray<class FString> OpenCSVFileDialog(const class FString& TitleDetails, const bool bAllowMultipleFiles);
	static bool SplitDataArrayByType(const TArray<class FString>& InAssetNames, const TArray<class FString>& InAssetTypes, const TArray<int32>& InAssetUsageCounts, const TArray<int32>& InAssetTypeSplitIndices, int32 CurrentSplitIndex, class FString* OutAssetType, TArray<class FString>* OutAssetNames, TArray<int32>* OutAssetUsageCounts);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotCosmeticBlueprintHelperLibrary">();
	}
	static class UBotCosmeticBlueprintHelperLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotCosmeticBlueprintHelperLibrary>();
	}
};
static_assert(alignof(UBotCosmeticBlueprintHelperLibrary) == 0x000008, "Wrong alignment on UBotCosmeticBlueprintHelperLibrary");
static_assert(sizeof(UBotCosmeticBlueprintHelperLibrary) == 0x000028, "Wrong size on UBotCosmeticBlueprintHelperLibrary");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_CoverBase
// 0x0028 (0x0058 - 0x0030)
class UFortAthenaAISpawnerDataComponent_CoverBase final : public UFortAthenaAISpawnerDataComponent
{
public:
	TSubclassOf<class UNavigationQueryFilter>     CoverPositionFilterClass;                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CoverBoxExtent;                                    // 0x0038(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverOffset;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_CoverBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_CoverBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_CoverBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_CoverBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_CoverBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_CoverBase) == 0x000058, "Wrong size on UFortAthenaAISpawnerDataComponent_CoverBase");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CoverBase, CoverPositionFilterClass) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_CoverBase::CoverPositionFilterClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CoverBase, CoverBoxExtent) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_CoverBase::CoverBoxExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CoverBase, CoverOffset) == 0x000050, "Member 'UFortAthenaAISpawnerDataComponent_CoverBase::CoverOffset' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotCustomizationData
// 0x0160 (0x0190 - 0x0030)
class UFortAthenaAIBotCustomizationData final : public UPrimaryDataAsset
{
public:
	TSubclassOf<class AFortPlayerPawnAthena>      PawnClass;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bRequiresUniqueNetId : 1;                          // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bHasCustomSquadId : 1;                             // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         CustomSquadId;                                     // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bOverrideCanRespawnOnDeath : 1;                    // 0x003A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCanRespawnOnDeath : 1;                            // 0x003A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideBehaviorTree : 1;                         // 0x003A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideCharacterCustomization : 1;               // 0x003A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideDBNOPlayStyle : 1;                        // 0x003A(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideSkillLevel : 1;                           // 0x003A(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bUseMatchMMRToOverrideSkillLevel : 1;              // 0x003A(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideSkillSets : 1;                            // 0x003A(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideStartupInventory : 1;                     // 0x003B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideBotNameSettings : 1;                      // 0x003B(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideBotIDAnalyticsSuffix : 1;                 // 0x003B(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideConstructionBuildingInfo : 1;             // 0x003B(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              OverrideSkillLevelMMRTable;                        // 0x0040(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBotDataOverrideCosmeticMode                  OverrideCosmeticMode;                              // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotCharacterCustomization* CharacterCustomization;                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UFortAthenaAIBotCosmeticLibraryData> CosmeticCustomizationLibrary;                      // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDBNOPlayStyle                                DBNOPlayStyle;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillLevel;                                        // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UFortAthenaAIBotSkillSet>> SkillSetOverrideClasses;                           // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotInventoryItems*         StartupInventory;                                  // 0x00C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortBotNameSettings*                   BotNameSettings;                                   // 0x00D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 BotAnalyticsSuffix;                                // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpawnTracePadding;                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConstructionBuildingInfo              OverrideConstructionBuildingInfo[0x6];             // 0x00F0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaAILODSettingsContainer> AILODSettingsContainer;                            // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAILODSettingsContainer*      AILODSettingsContainerLoaded;                      // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetCharacterCustomizationFromPlayerPawn(const class AFortPlayerPawn* InFortPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotCustomizationData">();
	}
	static class UFortAthenaAIBotCustomizationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotCustomizationData>();
	}
};
static_assert(alignof(UFortAthenaAIBotCustomizationData) == 0x000008, "Wrong alignment on UFortAthenaAIBotCustomizationData");
static_assert(sizeof(UFortAthenaAIBotCustomizationData) == 0x000190, "Wrong size on UFortAthenaAIBotCustomizationData");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, PawnClass) == 0x000030, "Member 'UFortAthenaAIBotCustomizationData::PawnClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, CustomSquadId) == 0x000039, "Member 'UFortAthenaAIBotCustomizationData::CustomSquadId' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, OverrideSkillLevelMMRTable) == 0x000040, "Member 'UFortAthenaAIBotCustomizationData::OverrideSkillLevelMMRTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, BehaviorTree) == 0x000068, "Member 'UFortAthenaAIBotCustomizationData::BehaviorTree' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, OverrideCosmeticMode) == 0x000070, "Member 'UFortAthenaAIBotCustomizationData::OverrideCosmeticMode' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, CharacterCustomization) == 0x000078, "Member 'UFortAthenaAIBotCustomizationData::CharacterCustomization' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, CosmeticCustomizationLibrary) == 0x000080, "Member 'UFortAthenaAIBotCustomizationData::CosmeticCustomizationLibrary' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, DBNOPlayStyle) == 0x0000A8, "Member 'UFortAthenaAIBotCustomizationData::DBNOPlayStyle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, SkillLevel) == 0x0000AC, "Member 'UFortAthenaAIBotCustomizationData::SkillLevel' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, SkillSetOverrideClasses) == 0x0000B8, "Member 'UFortAthenaAIBotCustomizationData::SkillSetOverrideClasses' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, StartupInventory) == 0x0000C8, "Member 'UFortAthenaAIBotCustomizationData::StartupInventory' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, BotNameSettings) == 0x0000D0, "Member 'UFortAthenaAIBotCustomizationData::BotNameSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, BotAnalyticsSuffix) == 0x0000D8, "Member 'UFortAthenaAIBotCustomizationData::BotAnalyticsSuffix' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, SpawnTracePadding) == 0x0000E8, "Member 'UFortAthenaAIBotCustomizationData::SpawnTracePadding' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, OverrideConstructionBuildingInfo) == 0x0000F0, "Member 'UFortAthenaAIBotCustomizationData::OverrideConstructionBuildingInfo' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, AILODSettingsContainer) == 0x000180, "Member 'UFortAthenaAIBotCustomizationData::AILODSettingsContainer' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotCustomizationData, AILODSettingsContainerLoaded) == 0x000188, "Member 'UFortAthenaAIBotCustomizationData::AILODSettingsContainerLoaded' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotDBNODigestedSkillSet
// 0x0020 (0x0050 - 0x0030)
class UFortAthenaAIBotDBNODigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         MaxDBNOCrawlingResponseTime;                       // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDBNOCrawlingResponseTimeDeviation;              // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AllyEvaluationTime;                                // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AllyEvaluationTimeDeviation;                       // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AllyEvaluationMaxDistanceSquared;                  // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OddsToLookForCover;                                // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverEvaluationTime;                               // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverEvaluationTimeDeviation;                      // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotDBNODigestedSkillSet">();
	}
	static class UFortAthenaAIBotDBNODigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotDBNODigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotDBNODigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotDBNODigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotDBNODigestedSkillSet) == 0x000050, "Wrong size on UFortAthenaAIBotDBNODigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotDBNODigestedSkillSet, MaxDBNOCrawlingResponseTime) == 0x000030, "Member 'UFortAthenaAIBotDBNODigestedSkillSet::MaxDBNOCrawlingResponseTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNODigestedSkillSet, MaxDBNOCrawlingResponseTimeDeviation) == 0x000034, "Member 'UFortAthenaAIBotDBNODigestedSkillSet::MaxDBNOCrawlingResponseTimeDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNODigestedSkillSet, AllyEvaluationTime) == 0x000038, "Member 'UFortAthenaAIBotDBNODigestedSkillSet::AllyEvaluationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNODigestedSkillSet, AllyEvaluationTimeDeviation) == 0x00003C, "Member 'UFortAthenaAIBotDBNODigestedSkillSet::AllyEvaluationTimeDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNODigestedSkillSet, AllyEvaluationMaxDistanceSquared) == 0x000040, "Member 'UFortAthenaAIBotDBNODigestedSkillSet::AllyEvaluationMaxDistanceSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNODigestedSkillSet, OddsToLookForCover) == 0x000044, "Member 'UFortAthenaAIBotDBNODigestedSkillSet::OddsToLookForCover' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNODigestedSkillSet, CoverEvaluationTime) == 0x000048, "Member 'UFortAthenaAIBotDBNODigestedSkillSet::CoverEvaluationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNODigestedSkillSet, CoverEvaluationTimeDeviation) == 0x00004C, "Member 'UFortAthenaAIBotDBNODigestedSkillSet::CoverEvaluationTimeDeviation' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotDBNOSkillSet
// 0x0140 (0x0170 - 0x0030)
class UFortAthenaAIBotDBNOSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         MaxDBNOCrawlingResponseTime;                       // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxDBNOCrawlingResponseTimeDeviation;              // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AllyEvaluationTime;                                // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AllyEvaluationTimeDeviation;                       // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AllyEvaluationMaxDistance;                         // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         OddsToLookForCover;                                // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CoverEvaluationTime;                               // 0x0120(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CoverEvaluationTimeDeviation;                      // 0x0148(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotDBNOSkillSet">();
	}
	static class UFortAthenaAIBotDBNOSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotDBNOSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotDBNOSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotDBNOSkillSet");
static_assert(sizeof(UFortAthenaAIBotDBNOSkillSet) == 0x000170, "Wrong size on UFortAthenaAIBotDBNOSkillSet");
static_assert(offsetof(UFortAthenaAIBotDBNOSkillSet, MaxDBNOCrawlingResponseTime) == 0x000030, "Member 'UFortAthenaAIBotDBNOSkillSet::MaxDBNOCrawlingResponseTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNOSkillSet, MaxDBNOCrawlingResponseTimeDeviation) == 0x000058, "Member 'UFortAthenaAIBotDBNOSkillSet::MaxDBNOCrawlingResponseTimeDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNOSkillSet, AllyEvaluationTime) == 0x000080, "Member 'UFortAthenaAIBotDBNOSkillSet::AllyEvaluationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNOSkillSet, AllyEvaluationTimeDeviation) == 0x0000A8, "Member 'UFortAthenaAIBotDBNOSkillSet::AllyEvaluationTimeDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNOSkillSet, AllyEvaluationMaxDistance) == 0x0000D0, "Member 'UFortAthenaAIBotDBNOSkillSet::AllyEvaluationMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNOSkillSet, OddsToLookForCover) == 0x0000F8, "Member 'UFortAthenaAIBotDBNOSkillSet::OddsToLookForCover' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNOSkillSet, CoverEvaluationTime) == 0x000120, "Member 'UFortAthenaAIBotDBNOSkillSet::CoverEvaluationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotDBNOSkillSet, CoverEvaluationTimeDeviation) == 0x000148, "Member 'UFortAthenaAIBotDBNOSkillSet::CoverEvaluationTimeDeviation' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEmoteDigestedSkillSet
// 0x0020 (0x0050 - 0x0030)
class UFortAthenaAIBotEmoteDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         InfiniteEmoteMinDuration;                          // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InfiniteEmoteMaxDuration;                          // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EmotesMaxCount;                                    // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DanceOnKillMaxDistanceFromKillSqr;                 // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DanceOnKillMaxTimeFromKill;                        // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DanceOnKillMinTimeFromLastTry;                     // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DanceOnKillChanceToDanceOnBots;                    // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DanceOnKillChanceToDanceOnPlayers;                 // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEmoteDigestedSkillSet">();
	}
	static class UFortAthenaAIBotEmoteDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEmoteDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotEmoteDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotEmoteDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotEmoteDigestedSkillSet) == 0x000050, "Wrong size on UFortAthenaAIBotEmoteDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotEmoteDigestedSkillSet, InfiniteEmoteMinDuration) == 0x000030, "Member 'UFortAthenaAIBotEmoteDigestedSkillSet::InfiniteEmoteMinDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteDigestedSkillSet, InfiniteEmoteMaxDuration) == 0x000034, "Member 'UFortAthenaAIBotEmoteDigestedSkillSet::InfiniteEmoteMaxDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteDigestedSkillSet, EmotesMaxCount) == 0x000038, "Member 'UFortAthenaAIBotEmoteDigestedSkillSet::EmotesMaxCount' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteDigestedSkillSet, DanceOnKillMaxDistanceFromKillSqr) == 0x00003C, "Member 'UFortAthenaAIBotEmoteDigestedSkillSet::DanceOnKillMaxDistanceFromKillSqr' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteDigestedSkillSet, DanceOnKillMaxTimeFromKill) == 0x000040, "Member 'UFortAthenaAIBotEmoteDigestedSkillSet::DanceOnKillMaxTimeFromKill' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteDigestedSkillSet, DanceOnKillMinTimeFromLastTry) == 0x000044, "Member 'UFortAthenaAIBotEmoteDigestedSkillSet::DanceOnKillMinTimeFromLastTry' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteDigestedSkillSet, DanceOnKillChanceToDanceOnBots) == 0x000048, "Member 'UFortAthenaAIBotEmoteDigestedSkillSet::DanceOnKillChanceToDanceOnBots' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteDigestedSkillSet, DanceOnKillChanceToDanceOnPlayers) == 0x00004C, "Member 'UFortAthenaAIBotEmoteDigestedSkillSet::DanceOnKillChanceToDanceOnPlayers' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEmoteSkillSet
// 0x0118 (0x0148 - 0x0030)
class UFortAthenaAIBotEmoteSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         InfiniteEmoteMinDuration;                          // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         InfiniteEmoteMaxDuration;                          // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DanceOnKillMaxDistanceFromKill;                    // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DanceOnKillMaxTimeFromKill;                        // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DanceOnKillMinTimeFromLastTry;                     // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DanceOnKillChanceToDanceOnBots;                    // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DanceOnKillChanceToDanceOnPlayers;                 // 0x0120(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEmoteSkillSet">();
	}
	static class UFortAthenaAIBotEmoteSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEmoteSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotEmoteSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotEmoteSkillSet");
static_assert(sizeof(UFortAthenaAIBotEmoteSkillSet) == 0x000148, "Wrong size on UFortAthenaAIBotEmoteSkillSet");
static_assert(offsetof(UFortAthenaAIBotEmoteSkillSet, InfiniteEmoteMinDuration) == 0x000030, "Member 'UFortAthenaAIBotEmoteSkillSet::InfiniteEmoteMinDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteSkillSet, InfiniteEmoteMaxDuration) == 0x000058, "Member 'UFortAthenaAIBotEmoteSkillSet::InfiniteEmoteMaxDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteSkillSet, DanceOnKillMaxDistanceFromKill) == 0x000080, "Member 'UFortAthenaAIBotEmoteSkillSet::DanceOnKillMaxDistanceFromKill' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteSkillSet, DanceOnKillMaxTimeFromKill) == 0x0000A8, "Member 'UFortAthenaAIBotEmoteSkillSet::DanceOnKillMaxTimeFromKill' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteSkillSet, DanceOnKillMinTimeFromLastTry) == 0x0000D0, "Member 'UFortAthenaAIBotEmoteSkillSet::DanceOnKillMinTimeFromLastTry' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteSkillSet, DanceOnKillChanceToDanceOnBots) == 0x0000F8, "Member 'UFortAthenaAIBotEmoteSkillSet::DanceOnKillChanceToDanceOnBots' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEmoteSkillSet, DanceOnKillChanceToDanceOnPlayers) == 0x000120, "Member 'UFortAthenaAIBotEmoteSkillSet::DanceOnKillChanceToDanceOnPlayers' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_InventoryBase
// 0x0070 (0x00A0 - 0x0030)
class UFortAthenaAISpawnerDataComponent_InventoryBase : public UFortAthenaAISpawnerDataComponent
{
public:
	struct FScalableFloat                         ShouldDropCurrencyOnDeath;                         // 0x0030(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         DefaultInventoryIgnoresRestrictions;               // 0x0058(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   CurrencyPayoutRowName;                             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    LootInfo;                                          // 0x0088(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bUseDefenderInventoryManagement;                   // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetInventoryItems(TArray<struct FItemAndCount>* OutList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_InventoryBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_InventoryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_InventoryBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_InventoryBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_InventoryBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_InventoryBase) == 0x0000A0, "Wrong size on UFortAthenaAISpawnerDataComponent_InventoryBase");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_InventoryBase, ShouldDropCurrencyOnDeath) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_InventoryBase::ShouldDropCurrencyOnDeath' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_InventoryBase, DefaultInventoryIgnoresRestrictions) == 0x000058, "Member 'UFortAthenaAISpawnerDataComponent_InventoryBase::DefaultInventoryIgnoresRestrictions' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_InventoryBase, CurrencyPayoutRowName) == 0x000080, "Member 'UFortAthenaAISpawnerDataComponent_InventoryBase::CurrencyPayoutRowName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_InventoryBase, LootInfo) == 0x000088, "Member 'UFortAthenaAISpawnerDataComponent_InventoryBase::LootInfo' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_InventoryBase, bUseDefenderInventoryManagement) == 0x000098, "Member 'UFortAthenaAISpawnerDataComponent_InventoryBase::bUseDefenderInventoryManagement' has a wrong offset!");

// Class FortniteAI.FortBTService_UpdateBotMissionGoal
// 0x0008 (0x00A0 - 0x0098)
class UFortBTService_UpdateBotMissionGoal final : public UBTService_BlackboardBase
{
public:
	uint8                                         bRequireInteraction : 1;                           // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequireInteractionOrLocator : 1;                  // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequireEncounter : 1;                             // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPickClosest : 1;                                  // 0x0098(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTService_UpdateBotMissionGoal">();
	}
	static class UFortBTService_UpdateBotMissionGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTService_UpdateBotMissionGoal>();
	}
};
static_assert(alignof(UFortBTService_UpdateBotMissionGoal) == 0x000008, "Wrong alignment on UFortBTService_UpdateBotMissionGoal");
static_assert(sizeof(UFortBTService_UpdateBotMissionGoal) == 0x0000A0, "Wrong size on UFortBTService_UpdateBotMissionGoal");

// Class FortniteAI.FortAthenaAIBotEvaluator_Ambush
// 0x0068 (0x0280 - 0x0218)
class UFortAthenaAIBotEvaluator_Ambush final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   LastKnownPositionName;                             // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DestinationKeyName;                                // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MoveToDestinationKeyName;                          // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AggressivenessName;                                // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x58];                                     // 0x0228(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Ambush">();
	}
	static class UFortAthenaAIBotEvaluator_Ambush* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Ambush>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Ambush) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Ambush");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Ambush) == 0x000280, "Wrong size on UFortAthenaAIBotEvaluator_Ambush");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Ambush, LastKnownPositionName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Ambush::LastKnownPositionName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Ambush, DestinationKeyName) == 0x00021C, "Member 'UFortAthenaAIBotEvaluator_Ambush::DestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Ambush, MoveToDestinationKeyName) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_Ambush::MoveToDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Ambush, AggressivenessName) == 0x000224, "Member 'UFortAthenaAIBotEvaluator_Ambush::AggressivenessName' has a wrong offset!");

// Class FortniteAI.FortBTTask_RotateToFaceBBEntryWithTags
// 0x0020 (0x00C0 - 0x00A0)
class UFortBTTask_RotateToFaceBBEntryWithTags final : public UBTTask_RotateToFaceBBEntry
{
public:
	struct FGameplayTagContainer                  TagsToApply;                                       // 0x00A0(0x0020)(Edit, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_RotateToFaceBBEntryWithTags">();
	}
	static class UFortBTTask_RotateToFaceBBEntryWithTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_RotateToFaceBBEntryWithTags>();
	}
};
static_assert(alignof(UFortBTTask_RotateToFaceBBEntryWithTags) == 0x000008, "Wrong alignment on UFortBTTask_RotateToFaceBBEntryWithTags");
static_assert(sizeof(UFortBTTask_RotateToFaceBBEntryWithTags) == 0x0000C0, "Wrong size on UFortBTTask_RotateToFaceBBEntryWithTags");
static_assert(offsetof(UFortBTTask_RotateToFaceBBEntryWithTags, TagsToApply) == 0x0000A0, "Member 'UFortBTTask_RotateToFaceBBEntryWithTags::TagsToApply' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_CosmeticLibrary
// 0x0090 (0x00C0 - 0x0030)
class UFortAthenaAISpawnerDataComponent_CosmeticLibrary final : public UFortAthenaAISpawnerDataComponent_AIBotCosmeticBase
{
public:
	TArray<TSoftObjectPtr<class UFortAthenaAIBotCosmeticLibraryData>> CosmeticLibraries;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         DefaultCosmeticLibraryWeight;                      // 0x0040(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           PredefinedCosmeticSetTag;                          // 0x0068(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              EmotesDataTable;                                   // 0x0070(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EmotesMaxCount;                                    // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	class UFortAthenaAIBotCosmeticLibraryData* GetAICosmeticLibraryData() const;
	int32 GetAICosmeticLibraryDataIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_CosmeticLibrary">();
	}
	static class UFortAthenaAISpawnerDataComponent_CosmeticLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_CosmeticLibrary>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_CosmeticLibrary) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_CosmeticLibrary");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_CosmeticLibrary) == 0x0000C0, "Wrong size on UFortAthenaAISpawnerDataComponent_CosmeticLibrary");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLibrary, CosmeticLibraries) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLibrary::CosmeticLibraries' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLibrary, DefaultCosmeticLibraryWeight) == 0x000040, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLibrary::DefaultCosmeticLibraryWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLibrary, PredefinedCosmeticSetTag) == 0x000068, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLibrary::PredefinedCosmeticSetTag' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLibrary, EmotesDataTable) == 0x000070, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLibrary::EmotesDataTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_CosmeticLibrary, EmotesMaxCount) == 0x000098, "Member 'UFortAthenaAISpawnerDataComponent_CosmeticLibrary::EmotesMaxCount' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Attack
// 0x0018 (0x0230 - 0x0218)
class UFortAthenaAIBotEvaluator_Attack : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   WeaponKeyName;                                     // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortWorldItem*                         Weapon;                                            // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MoveToDestinationKeyName;                          // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Attack">();
	}
	static class UFortAthenaAIBotEvaluator_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Attack>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Attack) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Attack");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Attack) == 0x000230, "Wrong size on UFortAthenaAIBotEvaluator_Attack");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Attack, WeaponKeyName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Attack::WeaponKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Attack, Weapon) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_Attack::Weapon' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Attack, MoveToDestinationKeyName) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_Attack::MoveToDestinationKeyName' has a wrong offset!");

// Class FortniteAI.FortBTDecorator_WeaponStatus
// 0x0030 (0x0098 - 0x0068)
class UFortBTDecorator_WeaponStatus final : public UBTDecorator
{
public:
	float                                         WeaponStatusUpdateRate;                            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bTestIfCurrentWeaponIsValid : 1;                   // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentWeaponShouldBeValid : 1;                   // 0x006C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTestAllowedCurrentWeaponTags : 1;                 // 0x006C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AllowedCurrentWeaponTags;                          // 0x0070(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bTestIfCurrentWeaponIsReloading : 1;               // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentWeaponShouldBeReloading : 1;               // 0x0090(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTestIfCurrentWeaponHasAmmoInMagazine : 1;         // 0x0090(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentWeaponShouldHaveAmmoInMagazine : 1;        // 0x0090(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTestIfCurrentWeaponHasExtraAmmo : 1;              // 0x0090(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentWeaponShouldHaveExtraAmmo : 1;             // 0x0090(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllInterestedTestsMustPass : 1;                   // 0x0090(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_WeaponStatus">();
	}
	static class UFortBTDecorator_WeaponStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_WeaponStatus>();
	}
};
static_assert(alignof(UFortBTDecorator_WeaponStatus) == 0x000008, "Wrong alignment on UFortBTDecorator_WeaponStatus");
static_assert(sizeof(UFortBTDecorator_WeaponStatus) == 0x000098, "Wrong size on UFortBTDecorator_WeaponStatus");
static_assert(offsetof(UFortBTDecorator_WeaponStatus, WeaponStatusUpdateRate) == 0x000068, "Member 'UFortBTDecorator_WeaponStatus::WeaponStatusUpdateRate' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_WeaponStatus, AllowedCurrentWeaponTags) == 0x000070, "Member 'UFortBTDecorator_WeaponStatus::AllowedCurrentWeaponTags' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_Buildings
// 0x0190 (0x01E0 - 0x0050)
class UFortQueryGenerator_Buildings final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           BuildingGridVolumeCenter;                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                HorizontalBuildingCellRadius;                      // 0x0058(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                BuildingCellsAbove;                                // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                BuildingCellsBelow;                                // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeWalls;                                     // 0x0100(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeFloors;                                    // 0x0138(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeCenterCell;                                // 0x0170(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                MaxBuildingActorsPerVolumeCenterToCollect;         // 0x01A8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_Buildings">();
	}
	static class UFortQueryGenerator_Buildings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_Buildings>();
	}
};
static_assert(alignof(UFortQueryGenerator_Buildings) == 0x000008, "Wrong alignment on UFortQueryGenerator_Buildings");
static_assert(sizeof(UFortQueryGenerator_Buildings) == 0x0001E0, "Wrong size on UFortQueryGenerator_Buildings");
static_assert(offsetof(UFortQueryGenerator_Buildings, BuildingGridVolumeCenter) == 0x000050, "Member 'UFortQueryGenerator_Buildings::BuildingGridVolumeCenter' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, HorizontalBuildingCellRadius) == 0x000058, "Member 'UFortQueryGenerator_Buildings::HorizontalBuildingCellRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, BuildingCellsAbove) == 0x000090, "Member 'UFortQueryGenerator_Buildings::BuildingCellsAbove' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, BuildingCellsBelow) == 0x0000C8, "Member 'UFortQueryGenerator_Buildings::BuildingCellsBelow' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, bIncludeWalls) == 0x000100, "Member 'UFortQueryGenerator_Buildings::bIncludeWalls' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, bIncludeFloors) == 0x000138, "Member 'UFortQueryGenerator_Buildings::bIncludeFloors' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, bIncludeCenterCell) == 0x000170, "Member 'UFortQueryGenerator_Buildings::bIncludeCenterCell' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, MaxBuildingActorsPerVolumeCenterToCollect) == 0x0001A8, "Member 'UFortQueryGenerator_Buildings::MaxBuildingActorsPerVolumeCenterToCollect' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_AvoidThreat
// 0x0020 (0x0238 - 0x0218)
class UFortAthenaAIBotEvaluator_AvoidThreat final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   AvoidThreatKeyName;                                // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AvoidThreatMovementStateKeyName;                   // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AvoidThreatDestinationKeyName;                     // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentThreatActorAvoiding;                        // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotEvasiveManeuversDigestedSkillSet* CacheEMDigestedSkillSet;                           // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_AvoidThreat">();
	}
	static class UFortAthenaAIBotEvaluator_AvoidThreat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_AvoidThreat>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_AvoidThreat) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_AvoidThreat");
static_assert(sizeof(UFortAthenaAIBotEvaluator_AvoidThreat) == 0x000238, "Wrong size on UFortAthenaAIBotEvaluator_AvoidThreat");
static_assert(offsetof(UFortAthenaAIBotEvaluator_AvoidThreat, AvoidThreatKeyName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_AvoidThreat::AvoidThreatKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_AvoidThreat, AvoidThreatMovementStateKeyName) == 0x00021C, "Member 'UFortAthenaAIBotEvaluator_AvoidThreat::AvoidThreatMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_AvoidThreat, AvoidThreatDestinationKeyName) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_AvoidThreat::AvoidThreatDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_AvoidThreat, CurrentThreatActorAvoiding) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_AvoidThreat::CurrentThreatActorAvoiding' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_AvoidThreat, CacheEMDigestedSkillSet) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_AvoidThreat::CacheEMDigestedSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Bunker
// 0x0038 (0x0250 - 0x0218)
class UFortAthenaAIBotEvaluator_Bunker final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   BuildExecutionStatusKeyName;                       // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C[0x34];                                     // 0x021C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Bunker">();
	}
	static class UFortAthenaAIBotEvaluator_Bunker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Bunker>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Bunker) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Bunker");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Bunker) == 0x000250, "Wrong size on UFortAthenaAIBotEvaluator_Bunker");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Bunker, BuildExecutionStatusKeyName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Bunker::BuildExecutionStatusKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_Sight
// 0x0010 (0x0040 - 0x0030)
class UFortAthenaAIRuntimeParameters_Sight final : public UFortAthenaAIRuntimeParameters
{
public:
	bool                                          bOverrideVisibilityRange;                          // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightRadius;                                       // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoseSightRadius;                                   // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_Sight">();
	}
	static class UFortAthenaAIRuntimeParameters_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_Sight>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_Sight) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_Sight");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_Sight) == 0x000040, "Wrong size on UFortAthenaAIRuntimeParameters_Sight");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Sight, bOverrideVisibilityRange) == 0x000030, "Member 'UFortAthenaAIRuntimeParameters_Sight::bOverrideVisibilityRange' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Sight, SightRadius) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_Sight::SightRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Sight, LoseSightRadius) == 0x000038, "Member 'UFortAthenaAIRuntimeParameters_Sight::LoseSightRadius' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_CanMove
// 0x0008 (0x0090 - 0x0088)
class UFortAthenaAIBotEvaluator_CanMove final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   CanMoveKeyName;                                    // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_CanMove">();
	}
	static class UFortAthenaAIBotEvaluator_CanMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_CanMove>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_CanMove) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_CanMove");
static_assert(sizeof(UFortAthenaAIBotEvaluator_CanMove) == 0x000090, "Wrong size on UFortAthenaAIBotEvaluator_CanMove");
static_assert(offsetof(UFortAthenaAIBotEvaluator_CanMove, CanMoveKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_CanMove::CanMoveKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_CharacterLaunched
// 0x0040 (0x00C8 - 0x0088)
class UFortAthenaAIBotEvaluator_CharacterLaunched final : public UFortAthenaAIBotEvaluator
{
public:
	bool                                          bSteerInSameDirectionAsLaunchVelocity;             // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharacterLaunchedExecutionStatusKeyName;           // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SteerDirectionKeyName;                             // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastLaunchVelocity;                                // 0x0098(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotMovementDigestedSkillSet* CachedMovementSkillSet;                            // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_CharacterLaunched">();
	}
	static class UFortAthenaAIBotEvaluator_CharacterLaunched* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_CharacterLaunched>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_CharacterLaunched) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_CharacterLaunched");
static_assert(sizeof(UFortAthenaAIBotEvaluator_CharacterLaunched) == 0x0000C8, "Wrong size on UFortAthenaAIBotEvaluator_CharacterLaunched");
static_assert(offsetof(UFortAthenaAIBotEvaluator_CharacterLaunched, bSteerInSameDirectionAsLaunchVelocity) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_CharacterLaunched::bSteerInSameDirectionAsLaunchVelocity' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_CharacterLaunched, CharacterLaunchedExecutionStatusKeyName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_CharacterLaunched::CharacterLaunchedExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_CharacterLaunched, SteerDirectionKeyName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_CharacterLaunched::SteerDirectionKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_CharacterLaunched, LastLaunchVelocity) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_CharacterLaunched::LastLaunchVelocity' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_CharacterLaunched, CachedMovementSkillSet) == 0x0000B0, "Member 'UFortAthenaAIBotEvaluator_CharacterLaunched::CachedMovementSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_GameplayAbilityBase
// 0x0040 (0x0070 - 0x0030)
class UFortAthenaAISpawnerDataComponent_GameplayAbilityBase : public UFortAthenaAISpawnerDataComponent
{
public:
	TArray<struct FInitialGameplayEffectInfo>     InitialGameplayEffect;                             // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UFortAbilitySet*>                InitialGameplayAbilitiesSet;                       // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  LooseTagsToApplyToPawn;                            // 0x0050(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void SetLooseTagsToApplyToPawn(const struct FGameplayTagContainer& InGameplayTagContainer);

	void GetInitialGameplayAbilities(TArray<class UFortAbilitySet*>* OutGASets) const;
	void GetInitialGameplayEffects(TArray<struct FInitialGameplayEffectInfo>* OutGEs) const;
	struct FGameplayTagContainer GetLooseTagsToApplyToPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_GameplayAbilityBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_GameplayAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_GameplayAbilityBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_GameplayAbilityBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_GameplayAbilityBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_GameplayAbilityBase) == 0x000070, "Wrong size on UFortAthenaAISpawnerDataComponent_GameplayAbilityBase");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayAbilityBase, InitialGameplayEffect) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_GameplayAbilityBase::InitialGameplayEffect' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayAbilityBase, InitialGameplayAbilitiesSet) == 0x000040, "Member 'UFortAthenaAISpawnerDataComponent_GameplayAbilityBase::InitialGameplayAbilitiesSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayAbilityBase, LooseTagsToApplyToPawn) == 0x000050, "Member 'UFortAthenaAISpawnerDataComponent_GameplayAbilityBase::LooseTagsToApplyToPawn' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotGameplayAbilityBase
// 0x0000 (0x0070 - 0x0070)
class UFortAthenaAISpawnerDataComponent_AIBotGameplayAbilityBase final : public UFortAthenaAISpawnerDataComponent_GameplayAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotGameplayAbilityBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotGameplayAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotGameplayAbilityBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotGameplayAbilityBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotGameplayAbilityBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotGameplayAbilityBase) == 0x000070, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotGameplayAbilityBase");

// Class FortniteAI.FortAthenaAIBotEvaluator_Conversation
// 0x0118 (0x01A0 - 0x0088)
class alignas(0x10) UFortAthenaAIBotEvaluator_Conversation final : public UFortAthenaAIBotEvaluator
{
public:
	class UFortAthenaAIRuntimeParameters_Conversation* ConversationRuntimeParameters;                     // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 ActorToFocus;                                      // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         LastReceivedUpdateFromNearbyActorsPerceptionComp;  // 0x0098(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0xF8];                                      // 0x00A8(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Conversation">();
	}
	static class UFortAthenaAIBotEvaluator_Conversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Conversation>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Conversation) == 0x000010, "Wrong alignment on UFortAthenaAIBotEvaluator_Conversation");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Conversation) == 0x0001A0, "Wrong size on UFortAthenaAIBotEvaluator_Conversation");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Conversation, ConversationRuntimeParameters) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_Conversation::ConversationRuntimeParameters' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Conversation, ActorToFocus) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_Conversation::ActorToFocus' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Conversation, LastReceivedUpdateFromNearbyActorsPerceptionComp) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_Conversation::LastReceivedUpdateFromNearbyActorsPerceptionComp' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Converted
// 0x0050 (0x0268 - 0x0218)
class UFortAthenaAIBotEvaluator_Converted final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   ShouldMoveTowardsConverterName;                    // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ShouldTeleportTowardsConverterName;                // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ConvertedAllowPatrolAroundName;                    // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ConvertedAllowScanAroundWhenWaitingName;           // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ConvertedDestinationName;                          // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CrouchExecutionStatusName;                         // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SprintExecutionStatusName;                         // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TeleportLocationProjectionExtent;                  // 0x0238(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPawn*                              ConverterPawn;                                     // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIRuntimeParameters_AIBotConvert* CachedAIBotConvertParameters;                      // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConvertedEvent(class AFortPawn* InstigatorPawn, class AFortPawn* ConvertedPawn);
	void OnUnconvertedEvent(class AFortPawn* UnconvertedPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Converted">();
	}
	static class UFortAthenaAIBotEvaluator_Converted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Converted>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Converted) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Converted");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Converted) == 0x000268, "Wrong size on UFortAthenaAIBotEvaluator_Converted");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, ShouldMoveTowardsConverterName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Converted::ShouldMoveTowardsConverterName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, ShouldTeleportTowardsConverterName) == 0x00021C, "Member 'UFortAthenaAIBotEvaluator_Converted::ShouldTeleportTowardsConverterName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, ConvertedAllowPatrolAroundName) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_Converted::ConvertedAllowPatrolAroundName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, ConvertedAllowScanAroundWhenWaitingName) == 0x000224, "Member 'UFortAthenaAIBotEvaluator_Converted::ConvertedAllowScanAroundWhenWaitingName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, ConvertedDestinationName) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_Converted::ConvertedDestinationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, CrouchExecutionStatusName) == 0x00022C, "Member 'UFortAthenaAIBotEvaluator_Converted::CrouchExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, SprintExecutionStatusName) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_Converted::SprintExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, TeleportLocationProjectionExtent) == 0x000238, "Member 'UFortAthenaAIBotEvaluator_Converted::TeleportLocationProjectionExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, ConverterPawn) == 0x000250, "Member 'UFortAthenaAIBotEvaluator_Converted::ConverterPawn' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Converted, CachedAIBotConvertParameters) == 0x000258, "Member 'UFortAthenaAIBotEvaluator_Converted::CachedAIBotConvertParameters' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_DanceOnKill
// 0x0020 (0x00A8 - 0x0088)
class UFortAthenaAIBotEvaluator_DanceOnKill final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   LastKillPositionKeyName;                           // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LastKillTimeKeyName;                               // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LastKillWasABotKeyName;                            // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PlayEmoteExecutionStatusKeyName;                   // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotEmoteDigestedSkillSet*  CacheEmoteDigestedSkillSet;                        // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_DanceOnKill">();
	}
	static class UFortAthenaAIBotEvaluator_DanceOnKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_DanceOnKill>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_DanceOnKill) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_DanceOnKill");
static_assert(sizeof(UFortAthenaAIBotEvaluator_DanceOnKill) == 0x0000A8, "Wrong size on UFortAthenaAIBotEvaluator_DanceOnKill");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DanceOnKill, LastKillPositionKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_DanceOnKill::LastKillPositionKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DanceOnKill, LastKillTimeKeyName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_DanceOnKill::LastKillTimeKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DanceOnKill, LastKillWasABotKeyName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_DanceOnKill::LastKillWasABotKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DanceOnKill, PlayEmoteExecutionStatusKeyName) == 0x000094, "Member 'UFortAthenaAIBotEvaluator_DanceOnKill::PlayEmoteExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DanceOnKill, CacheEmoteDigestedSkillSet) == 0x0000A0, "Member 'UFortAthenaAIBotEvaluator_DanceOnKill::CacheEmoteDigestedSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_TagQuery
// 0x0050 (0x00D8 - 0x0088)
class UFortAthenaAIBotEvaluator_TagQuery : public UFortAthenaAIBotEvaluator
{
public:
	struct FGameplayTagQuery                      TagQuery;                                          // 0x0088(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                CachedAbilitySystemComponent;                      // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_TagQuery">();
	}
	static class UFortAthenaAIBotEvaluator_TagQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_TagQuery>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_TagQuery) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_TagQuery");
static_assert(sizeof(UFortAthenaAIBotEvaluator_TagQuery) == 0x0000D8, "Wrong size on UFortAthenaAIBotEvaluator_TagQuery");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TagQuery, TagQuery) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_TagQuery::TagQuery' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TagQuery, CachedAbilitySystemComponent) == 0x0000D0, "Member 'UFortAthenaAIBotEvaluator_TagQuery::CachedAbilitySystemComponent' has a wrong offset!");

// Class FortniteAI.FortBTService_ActivateAbility
// 0x0060 (0x00D0 - 0x0070)
class UFortBTService_ActivateAbility final : public UBTService
{
public:
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0070(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bRequireCanHitTargetWithAbility;                   // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPawnTargetsOnly;                                  // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ProhibitedTargetTags;                              // 0x0098(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanActivateWhenMoving;                            // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDistanceToTargetComparison>    DistanceChecks;                                    // 0x00C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTService_ActivateAbility">();
	}
	static class UFortBTService_ActivateAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTService_ActivateAbility>();
	}
};
static_assert(alignof(UFortBTService_ActivateAbility) == 0x000008, "Wrong alignment on UFortBTService_ActivateAbility");
static_assert(sizeof(UFortBTService_ActivateAbility) == 0x0000D0, "Wrong size on UFortBTService_ActivateAbility");
static_assert(offsetof(UFortBTService_ActivateAbility, AbilityTags) == 0x000070, "Member 'UFortBTService_ActivateAbility::AbilityTags' has a wrong offset!");
static_assert(offsetof(UFortBTService_ActivateAbility, bRequireCanHitTargetWithAbility) == 0x000090, "Member 'UFortBTService_ActivateAbility::bRequireCanHitTargetWithAbility' has a wrong offset!");
static_assert(offsetof(UFortBTService_ActivateAbility, bPawnTargetsOnly) == 0x000091, "Member 'UFortBTService_ActivateAbility::bPawnTargetsOnly' has a wrong offset!");
static_assert(offsetof(UFortBTService_ActivateAbility, ProhibitedTargetTags) == 0x000098, "Member 'UFortBTService_ActivateAbility::ProhibitedTargetTags' has a wrong offset!");
static_assert(offsetof(UFortBTService_ActivateAbility, bCanActivateWhenMoving) == 0x0000B8, "Member 'UFortBTService_ActivateAbility::bCanActivateWhenMoving' has a wrong offset!");
static_assert(offsetof(UFortBTService_ActivateAbility, DistanceChecks) == 0x0000C0, "Member 'UFortBTService_ActivateAbility::DistanceChecks' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_DangerDetection
// 0x0048 (0x0120 - 0x00D8)
class UFortAthenaAIBotEvaluator_DangerDetection final : public UFortAthenaAIBotEvaluator_TagQuery
{
public:
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortNavArea>               DangerNavAreaClass;                                // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeToCheckForDangerAfterValidQuery;               // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxRadiusToSearchForSafePlace;                     // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DangerZoneDetectedExecutionStatusName;             // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DangerZoneDetectedSafeLocationKeyName;             // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotMovementDigestedSkillSet* CachedMovementSkillSet;                            // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_DangerDetection">();
	}
	static class UFortAthenaAIBotEvaluator_DangerDetection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_DangerDetection>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_DangerDetection) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_DangerDetection");
static_assert(sizeof(UFortAthenaAIBotEvaluator_DangerDetection) == 0x000120, "Wrong size on UFortAthenaAIBotEvaluator_DangerDetection");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DangerDetection, DangerNavAreaClass) == 0x0000E8, "Member 'UFortAthenaAIBotEvaluator_DangerDetection::DangerNavAreaClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DangerDetection, TimeToCheckForDangerAfterValidQuery) == 0x0000F0, "Member 'UFortAthenaAIBotEvaluator_DangerDetection::TimeToCheckForDangerAfterValidQuery' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DangerDetection, MaxRadiusToSearchForSafePlace) == 0x0000F4, "Member 'UFortAthenaAIBotEvaluator_DangerDetection::MaxRadiusToSearchForSafePlace' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DangerDetection, DangerZoneDetectedExecutionStatusName) == 0x0000F8, "Member 'UFortAthenaAIBotEvaluator_DangerDetection::DangerZoneDetectedExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DangerDetection, DangerZoneDetectedSafeLocationKeyName) == 0x0000FC, "Member 'UFortAthenaAIBotEvaluator_DangerDetection::DangerZoneDetectedSafeLocationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DangerDetection, CachedMovementSkillSet) == 0x000108, "Member 'UFortAthenaAIBotEvaluator_DangerDetection::CachedMovementSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_WaitForPassengers
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTService_WaitForPassengers final : public UBTService
{
public:
	class FName                                   WaitForPassengersStatusKeyName;                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_WaitForPassengers">();
	}
	static class UFortAthenaBTService_WaitForPassengers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_WaitForPassengers>();
	}
};
static_assert(alignof(UFortAthenaBTService_WaitForPassengers) == 0x000008, "Wrong alignment on UFortAthenaBTService_WaitForPassengers");
static_assert(sizeof(UFortAthenaBTService_WaitForPassengers) == 0x000078, "Wrong size on UFortAthenaBTService_WaitForPassengers");
static_assert(offsetof(UFortAthenaBTService_WaitForPassengers, WaitForPassengersStatusKeyName) == 0x000070, "Member 'UFortAthenaBTService_WaitForPassengers::WaitForPassengersStatusKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_DBNO
// 0x0058 (0x0270 - 0x0218)
class UFortAthenaAIBotEvaluator_DBNO final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   DBNODestinationKeyName;                            // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C[0x1];                                      // 0x021C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllowReachSquadmates : 1;                         // 0x021D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bAllowReachSameFactionNPCs : 1;                    // 0x021D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_21E[0x2];                                      // 0x021E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPlayerPawnAthena*>          AllyPawns;                                         // 0x0220(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FVector                                CachedCurrentDestination;                          // 0x0230(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotDBNODigestedSkillSet*   DBNOSkillSet;                                      // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAICoverComponent*            CachedCoverComponent;                              // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIRuntimeParameters_DBNOBehavior* DBNOBehaviorRuntimeParameters;                     // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllyPawnDBNOStateChanged(class AFortPawn* InPlayer, bool bInIsDBNO);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_DBNO">();
	}
	static class UFortAthenaAIBotEvaluator_DBNO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_DBNO>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_DBNO) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_DBNO");
static_assert(sizeof(UFortAthenaAIBotEvaluator_DBNO) == 0x000270, "Wrong size on UFortAthenaAIBotEvaluator_DBNO");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DBNO, DBNODestinationKeyName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_DBNO::DBNODestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DBNO, AllyPawns) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_DBNO::AllyPawns' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DBNO, CachedCurrentDestination) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_DBNO::CachedCurrentDestination' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DBNO, DBNOSkillSet) == 0x000248, "Member 'UFortAthenaAIBotEvaluator_DBNO::DBNOSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DBNO, CachedCoverComponent) == 0x000250, "Member 'UFortAthenaAIBotEvaluator_DBNO::CachedCoverComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DBNO, DBNOBehaviorRuntimeParameters) == 0x000258, "Member 'UFortAthenaAIBotEvaluator_DBNO::DBNOBehaviorRuntimeParameters' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_DefensiveBuilding
// 0x0018 (0x00A0 - 0x0088)
class UFortAthenaAIBotEvaluator_DefensiveBuilding final : public UFortAthenaAIBotEvaluator
{
public:
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotBuildingDigestedSkillSet* CachedBuildingDigestedSkillSet;                    // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotBuildingComponent*      CachedBuildingComponent;                           // 0x0098(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_DefensiveBuilding">();
	}
	static class UFortAthenaAIBotEvaluator_DefensiveBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_DefensiveBuilding>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_DefensiveBuilding) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_DefensiveBuilding");
static_assert(sizeof(UFortAthenaAIBotEvaluator_DefensiveBuilding) == 0x0000A0, "Wrong size on UFortAthenaAIBotEvaluator_DefensiveBuilding");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DefensiveBuilding, CachedBuildingDigestedSkillSet) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_DefensiveBuilding::CachedBuildingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_DefensiveBuilding, CachedBuildingComponent) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_DefensiveBuilding::CachedBuildingComponent' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_Conversation
// 0x0028 (0x0058 - 0x0030)
class UFortAthenaAIRuntimeParameters_Conversation final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bEnterBTTaskConversationIfPlayerAround : 1;        // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnterBTTaskConversationIfPlayerAroundDistSqr;      // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAthenaDanceItemDefinition*>     GreetingEmotes;                                    // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         GreetingEmoteMaxDuration;                          // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortTandemCharacterData*               CharacterData;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_Conversation">();
	}
	static class UFortAthenaAIRuntimeParameters_Conversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_Conversation>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_Conversation) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_Conversation");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_Conversation) == 0x000058, "Wrong size on UFortAthenaAIRuntimeParameters_Conversation");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Conversation, EnterBTTaskConversationIfPlayerAroundDistSqr) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_Conversation::EnterBTTaskConversationIfPlayerAroundDistSqr' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Conversation, GreetingEmotes) == 0x000038, "Member 'UFortAthenaAIRuntimeParameters_Conversation::GreetingEmotes' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Conversation, GreetingEmoteMaxDuration) == 0x000048, "Member 'UFortAthenaAIRuntimeParameters_Conversation::GreetingEmoteMaxDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Conversation, CharacterData) == 0x000050, "Member 'UFortAthenaAIRuntimeParameters_Conversation::CharacterData' has a wrong offset!");

// Class FortniteAI.FortQueryTest_InsideWater
// 0x0008 (0x0200 - 0x01F8)
class UFortQueryTest_InsideWater final : public UEnvQueryTest
{
public:
	float                                         TestRadius;                                        // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_InsideWater">();
	}
	static class UFortQueryTest_InsideWater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_InsideWater>();
	}
};
static_assert(alignof(UFortQueryTest_InsideWater) == 0x000008, "Wrong alignment on UFortQueryTest_InsideWater");
static_assert(sizeof(UFortQueryTest_InsideWater) == 0x000200, "Wrong size on UFortQueryTest_InsideWater");
static_assert(offsetof(UFortQueryTest_InsideWater, TestRadius) == 0x0001F8, "Member 'UFortQueryTest_InsideWater::TestRadius' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Escape
// 0x0030 (0x0248 - 0x0218)
class UFortAthenaAIBotEvaluator_Escape final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	struct FGameplayTagContainer                  EscapeTags;                                        // 0x0218(0x0020)(Edit, NativeAccessSpecifierPrivate)
	float                                         CooldownBetweenAggressivenessChanges;              // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AggressivenessName;                                // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Escape">();
	}
	static class UFortAthenaAIBotEvaluator_Escape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Escape>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Escape) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Escape");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Escape) == 0x000248, "Wrong size on UFortAthenaAIBotEvaluator_Escape");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Escape, EscapeTags) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Escape::EscapeTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Escape, CooldownBetweenAggressivenessChanges) == 0x000238, "Member 'UFortAthenaAIBotEvaluator_Escape::CooldownBetweenAggressivenessChanges' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Escape, AggressivenessName) == 0x00023C, "Member 'UFortAthenaAIBotEvaluator_Escape::AggressivenessName' has a wrong offset!");

// Class FortniteAI.FortNavArea_SmashableJump
// 0x0008 (0x0058 - 0x0050)
class UFortNavArea_SmashableJump : public UFortNavArea
{
public:
	int32                                         Strength;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_SmashableJump">();
	}
	static class UFortNavArea_SmashableJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_SmashableJump>();
	}
};
static_assert(alignof(UFortNavArea_SmashableJump) == 0x000008, "Wrong alignment on UFortNavArea_SmashableJump");
static_assert(sizeof(UFortNavArea_SmashableJump) == 0x000058, "Wrong size on UFortNavArea_SmashableJump");
static_assert(offsetof(UFortNavArea_SmashableJump, Strength) == 0x000050, "Member 'UFortNavArea_SmashableJump::Strength' has a wrong offset!");

// Class FortniteAI.FortQueryContext_NearbyFriends
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_NearbyFriends final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_NearbyFriends">();
	}
	static class UFortQueryContext_NearbyFriends* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_NearbyFriends>();
	}
};
static_assert(alignof(UFortQueryContext_NearbyFriends) == 0x000008, "Wrong alignment on UFortQueryContext_NearbyFriends");
static_assert(sizeof(UFortQueryContext_NearbyFriends) == 0x000028, "Wrong size on UFortQueryContext_NearbyFriends");

// Class FortniteAI.FortAthenaAIBotEvaluator_EvasiveManeuvers
// 0x01D0 (0x0258 - 0x0088)
class UFortAthenaAIBotEvaluator_EvasiveManeuvers final : public UFortAthenaAIBotEvaluator
{
public:
	uint8                                         Pad_88[0xA8];                                      // 0x0088(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CrouchExecutionStatusName;                         // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   JumpExecutionStatusName;                           // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   JetpackStrafeExecutionStatusName;                  // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DodgeName;                                         // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DestinationKeyName;                                // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   UrgentMoveKeyName;                                 // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x6];                                      // 0x0148(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDoCrouching;                                      // 0x014E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoDodging;                                        // 0x014F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoJumping;                                        // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoJumpingDistanceCheck;                           // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoJetpackStrafing;                                // 0x0152(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoJetpackStrafingDistanceCheck;                   // 0x0153(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JetpackStrafingRequiredFuelPercent;                // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JetpackStrafeNavPadding;                           // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      RequiredTagQuery;                                  // 0x0160(0x0048)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      JetpackRequiredTagQuery;                           // 0x01A8(0x0048)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      JumpRequiredTagQuery;                              // 0x01F0(0x0048)(Edit, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotEvasiveManeuversDigestedSkillSet* CacheEMDigestedSkillSet;                           // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x18];                                     // 0x0240(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveCompleted(const struct FAIRequestID& RequestId, EPathFollowingResult MovementResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_EvasiveManeuvers">();
	}
	static class UFortAthenaAIBotEvaluator_EvasiveManeuvers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_EvasiveManeuvers>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_EvasiveManeuvers) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_EvasiveManeuvers");
static_assert(sizeof(UFortAthenaAIBotEvaluator_EvasiveManeuvers) == 0x000258, "Wrong size on UFortAthenaAIBotEvaluator_EvasiveManeuvers");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, CrouchExecutionStatusName) == 0x000130, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::CrouchExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, JumpExecutionStatusName) == 0x000134, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::JumpExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, JetpackStrafeExecutionStatusName) == 0x000138, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::JetpackStrafeExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, DodgeName) == 0x00013C, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::DodgeName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, DestinationKeyName) == 0x000140, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::DestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, UrgentMoveKeyName) == 0x000144, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::UrgentMoveKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, bDoCrouching) == 0x00014E, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::bDoCrouching' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, bDoDodging) == 0x00014F, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::bDoDodging' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, bDoJumping) == 0x000150, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::bDoJumping' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, bDoJumpingDistanceCheck) == 0x000151, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::bDoJumpingDistanceCheck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, bDoJetpackStrafing) == 0x000152, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::bDoJetpackStrafing' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, bDoJetpackStrafingDistanceCheck) == 0x000153, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::bDoJetpackStrafingDistanceCheck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, JetpackStrafingRequiredFuelPercent) == 0x000154, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::JetpackStrafingRequiredFuelPercent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, JetpackStrafeNavPadding) == 0x000158, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::JetpackStrafeNavPadding' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, RequiredTagQuery) == 0x000160, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::RequiredTagQuery' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, JetpackRequiredTagQuery) == 0x0001A8, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::JetpackRequiredTagQuery' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, JumpRequiredTagQuery) == 0x0001F0, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::JumpRequiredTagQuery' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_EvasiveManeuvers, CacheEMDigestedSkillSet) == 0x000238, "Member 'UFortAthenaAIBotEvaluator_EvasiveManeuvers::CacheEMDigestedSkillSet' has a wrong offset!");

// Class FortniteAI.FortQueryTest_PerceptionExists
// 0x0010 (0x0208 - 0x01F8)
class UFortQueryTest_PerceptionExists final : public UEnvQueryTest
{
public:
	ECorePerceptionTypes                          Sense;                                             // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAISense>                   SenseClass;                                        // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PerceptionExists">();
	}
	static class UFortQueryTest_PerceptionExists* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PerceptionExists>();
	}
};
static_assert(alignof(UFortQueryTest_PerceptionExists) == 0x000008, "Wrong alignment on UFortQueryTest_PerceptionExists");
static_assert(sizeof(UFortQueryTest_PerceptionExists) == 0x000208, "Wrong size on UFortQueryTest_PerceptionExists");
static_assert(offsetof(UFortQueryTest_PerceptionExists, Sense) == 0x0001F8, "Member 'UFortQueryTest_PerceptionExists::Sense' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionExists, SenseClass) == 0x000200, "Member 'UFortQueryTest_PerceptionExists::SenseClass' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_FreeFalling
// 0x0108 (0x0190 - 0x0088)
class UFortAthenaAIBotEvaluator_FreeFalling final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   DiveExecutionStatusKeyName;                        // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DiveDestinationKeyName;                            // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GlideExecutionStatusKeyName;                       // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GlideDestinationKeyName;                           // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   JumpOffBusDestinationName;                         // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x5];                                       // 0x009C(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRandomlySelectFreeFallingMode;                    // 0x00A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         IdleWeight;                                        // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RandomWeight;                                      // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TowardNearestAllyWeight;                           // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EFreeFallingMode                              FreeFallingMode;                                   // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxOffsetRangeFromNearestAlly;                     // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bShouldRecomputeDestinationWhenTowardNearestAlly : 1; // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldSearchAllyInSquad : 1;                      // 0x0128(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldSearchAllyInTeam : 1;                       // 0x0128(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bGlideAllowed : 1;                                 // 0x0128(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkyTubeDivingStuckTimeThreshold;                   // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x20];                                     // 0x0130(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerStateAthena*                 NearestAlly;                                       // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CachedLatestDestination;                           // 0x0158(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotMovementDigestedSkillSet* CacheMovementDigestedSkillSet;                     // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortSkyTube*                           CachedSkyTube;                                     // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_FreeFalling">();
	}
	static class UFortAthenaAIBotEvaluator_FreeFalling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_FreeFalling>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_FreeFalling) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_FreeFalling");
static_assert(sizeof(UFortAthenaAIBotEvaluator_FreeFalling) == 0x000190, "Wrong size on UFortAthenaAIBotEvaluator_FreeFalling");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, DiveExecutionStatusKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::DiveExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, DiveDestinationKeyName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::DiveDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, GlideExecutionStatusKeyName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::GlideExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, GlideDestinationKeyName) == 0x000094, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::GlideDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, JumpOffBusDestinationName) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::JumpOffBusDestinationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, bRandomlySelectFreeFallingMode) == 0x0000A1, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::bRandomlySelectFreeFallingMode' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, IdleWeight) == 0x0000A8, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::IdleWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, RandomWeight) == 0x0000D0, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::RandomWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, TowardNearestAllyWeight) == 0x0000F8, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::TowardNearestAllyWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, FreeFallingMode) == 0x000120, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::FreeFallingMode' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, MaxOffsetRangeFromNearestAlly) == 0x000124, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::MaxOffsetRangeFromNearestAlly' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, SkyTubeDivingStuckTimeThreshold) == 0x00012C, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::SkyTubeDivingStuckTimeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, NearestAlly) == 0x000150, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::NearestAlly' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, CachedLatestDestination) == 0x000158, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::CachedLatestDestination' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, CacheMovementDigestedSkillSet) == 0x000170, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::CacheMovementDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_FreeFalling, CachedSkyTube) == 0x000180, "Member 'UFortAthenaAIBotEvaluator_FreeFalling::CachedSkyTube' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Ground
// 0x0088 (0x0110 - 0x0088)
class UFortAthenaAIBotEvaluator_Ground final : public UFortAthenaAIBotEvaluator
{
public:
	struct FVector                                SurfaceTypeRaycastDir;                             // 0x0088(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x68];                                      // 0x00A0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIRuntimeParameters_Behavior* CachedBehaviorRuntimeParameters;                   // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Ground">();
	}
	static class UFortAthenaAIBotEvaluator_Ground* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Ground>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Ground) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Ground");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Ground) == 0x000110, "Wrong size on UFortAthenaAIBotEvaluator_Ground");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Ground, SurfaceTypeRaycastDir) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_Ground::SurfaceTypeRaycastDir' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Ground, CachedBehaviorRuntimeParameters) == 0x000108, "Member 'UFortAthenaAIBotEvaluator_Ground::CachedBehaviorRuntimeParameters' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_HandleFocusing
// 0x0088 (0x0110 - 0x0088)
class UFortAthenaAIBotEvaluator_HandleFocusing final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   TargetActorName;                                   // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TargetLocationName;                                // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FocusActorName;                                    // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FocalPointName;                                    // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponFireName;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponTriggerMeleeName;                            // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LastKnownPositionName;                             // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TacticalSprintExecutionStatusName;                 // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFocusingBehavior                             FocusingBehavior;                                  // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFocusingBehavior                             NoRangedWeaponFocusBehavior;                       // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPrioritizeThreatOverCurrentTarget;                // 0x00B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseTargetActorKeyAsFocusTarget;                   // 0x00B3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFocusOnTargetLocation;                            // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmbushMaxLKPLookAtAngleDegree;                     // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopFocusingWhenMoving;                           // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResumeFocusingWhenMovingDist;                      // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StopFocusingWhenMovingDist;                        // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotAimingDigestedSkillSet* CacheAimingDigestedSkillSet;                       // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 LastTargetedThreat;                                // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FocusActor;                                        // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x28];                                      // 0x00E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_HandleFocusing">();
	}
	static class UFortAthenaAIBotEvaluator_HandleFocusing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_HandleFocusing>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_HandleFocusing) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_HandleFocusing");
static_assert(sizeof(UFortAthenaAIBotEvaluator_HandleFocusing) == 0x000110, "Wrong size on UFortAthenaAIBotEvaluator_HandleFocusing");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, TargetActorName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::TargetActorName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, TargetLocationName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::TargetLocationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, FocusActorName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::FocusActorName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, FocalPointName) == 0x000094, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::FocalPointName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, WeaponFireName) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::WeaponFireName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, WeaponTriggerMeleeName) == 0x00009C, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::WeaponTriggerMeleeName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, LastKnownPositionName) == 0x0000A0, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::LastKnownPositionName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, TacticalSprintExecutionStatusName) == 0x0000A4, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::TacticalSprintExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, FocusingBehavior) == 0x0000B0, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::FocusingBehavior' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, NoRangedWeaponFocusBehavior) == 0x0000B1, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::NoRangedWeaponFocusBehavior' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, bPrioritizeThreatOverCurrentTarget) == 0x0000B2, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::bPrioritizeThreatOverCurrentTarget' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, bUseTargetActorKeyAsFocusTarget) == 0x0000B3, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::bUseTargetActorKeyAsFocusTarget' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, bFocusOnTargetLocation) == 0x0000B4, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::bFocusOnTargetLocation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, AmbushMaxLKPLookAtAngleDegree) == 0x0000B8, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::AmbushMaxLKPLookAtAngleDegree' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, bStopFocusingWhenMoving) == 0x0000BC, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::bStopFocusingWhenMoving' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, ResumeFocusingWhenMovingDist) == 0x0000C0, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::ResumeFocusingWhenMovingDist' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, StopFocusingWhenMovingDist) == 0x0000C4, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::StopFocusingWhenMovingDist' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, CacheAimingDigestedSkillSet) == 0x0000C8, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::CacheAimingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, LastTargetedThreat) == 0x0000D0, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::LastTargetedThreat' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HandleFocusing, FocusActor) == 0x0000E0, "Member 'UFortAthenaAIBotEvaluator_HandleFocusing::FocusActor' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Heal
// 0x0068 (0x00F0 - 0x0088)
class UFortAthenaAIBotEvaluator_Heal final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   HealingObjectKeyName;                              // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x14];                                      // 0x008C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      RequiredTagQuery;                                  // 0x00A0(0x0048)(Edit, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotHealingDigestedSkillSet* HealingSkillSet;                                   // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandlePlayerHealthOrShieldChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Heal">();
	}
	static class UFortAthenaAIBotEvaluator_Heal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Heal>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Heal) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Heal");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Heal) == 0x0000F0, "Wrong size on UFortAthenaAIBotEvaluator_Heal");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Heal, HealingObjectKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_Heal::HealingObjectKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Heal, RequiredTagQuery) == 0x0000A0, "Member 'UFortAthenaAIBotEvaluator_Heal::RequiredTagQuery' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Heal, HealingSkillSet) == 0x0000E8, "Member 'UFortAthenaAIBotEvaluator_Heal::HealingSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_HitAndRun
// 0x00F8 (0x0310 - 0x0218)
class UFortAthenaAIBotEvaluator_HitAndRun final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	struct FScalableFloat                         AttackDurationBeforeEvade;                         // 0x0218(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MeleeAttackMaxDistToEvade;                         // 0x0240(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ClampEvadeDistanceEnable;                          // 0x0268(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MinDistanceToEvade;                                // 0x0290(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MaxDistanceToEvade;                                // 0x02B8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class FName                                   EvadeKeyName;                                      // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EvadeMovementStateKeyName;                         // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EvadeDestinationKeyName;                           // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponTriggerMeleeName;                            // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleeAttackMaxDistToEvadeSqr;                      // 0x0300(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDistanceToEvadeSqr;                             // 0x0304(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_HitAndRun">();
	}
	static class UFortAthenaAIBotEvaluator_HitAndRun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_HitAndRun>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_HitAndRun) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_HitAndRun");
static_assert(sizeof(UFortAthenaAIBotEvaluator_HitAndRun) == 0x000310, "Wrong size on UFortAthenaAIBotEvaluator_HitAndRun");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, AttackDurationBeforeEvade) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::AttackDurationBeforeEvade' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, MeleeAttackMaxDistToEvade) == 0x000240, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::MeleeAttackMaxDistToEvade' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, ClampEvadeDistanceEnable) == 0x000268, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::ClampEvadeDistanceEnable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, MinDistanceToEvade) == 0x000290, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::MinDistanceToEvade' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, MaxDistanceToEvade) == 0x0002B8, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::MaxDistanceToEvade' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, EvadeKeyName) == 0x0002E0, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::EvadeKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, EvadeMovementStateKeyName) == 0x0002E4, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::EvadeMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, EvadeDestinationKeyName) == 0x0002E8, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::EvadeDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, WeaponTriggerMeleeName) == 0x0002EC, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::WeaponTriggerMeleeName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, MeleeAttackMaxDistToEvadeSqr) == 0x000300, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::MeleeAttackMaxDistToEvadeSqr' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HitAndRun, MaxDistanceToEvadeSqr) == 0x000304, "Member 'UFortAthenaAIBotEvaluator_HitAndRun::MaxDistanceToEvadeSqr' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_HolsterWeapon
// 0x0008 (0x0090 - 0x0088)
class UFortAthenaAIBotEvaluator_HolsterWeapon final : public UFortAthenaAIBotEvaluator
{
public:
	class UFortAthenaAIRuntimeParameters_NPCBehavior* CachedNPCBehaviorParameters;                       // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_HolsterWeapon">();
	}
	static class UFortAthenaAIBotEvaluator_HolsterWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_HolsterWeapon>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_HolsterWeapon) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_HolsterWeapon");
static_assert(sizeof(UFortAthenaAIBotEvaluator_HolsterWeapon) == 0x000090, "Wrong size on UFortAthenaAIBotEvaluator_HolsterWeapon");
static_assert(offsetof(UFortAthenaAIBotEvaluator_HolsterWeapon, CachedNPCBehaviorParameters) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_HolsterWeapon::CachedNPCBehaviorParameters' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Investigate
// 0x0098 (0x02B0 - 0x0218)
class UFortAthenaAIBotEvaluator_Investigate final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   LastKnownPositionName;                             // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DestinationKeyName;                                // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MoveToDestinationKeyName;                          // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AggressivenessName;                                // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotAimingDigestedSkillSet* CacheAimingDigestedSkillSet;                       // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x38];                                     // 0x0238(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InvestigatingSupportingActor;                      // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingSMActor*                       UnderminingBuildingActor;                          // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 BlacklistReachingTarget;                           // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Investigate">();
	}
	static class UFortAthenaAIBotEvaluator_Investigate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Investigate>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Investigate) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Investigate");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Investigate) == 0x0002B0, "Wrong size on UFortAthenaAIBotEvaluator_Investigate");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Investigate, LastKnownPositionName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Investigate::LastKnownPositionName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Investigate, DestinationKeyName) == 0x00021C, "Member 'UFortAthenaAIBotEvaluator_Investigate::DestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Investigate, MoveToDestinationKeyName) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_Investigate::MoveToDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Investigate, AggressivenessName) == 0x000224, "Member 'UFortAthenaAIBotEvaluator_Investigate::AggressivenessName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Investigate, CacheAimingDigestedSkillSet) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_Investigate::CacheAimingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Investigate, InvestigatingSupportingActor) == 0x000270, "Member 'UFortAthenaAIBotEvaluator_Investigate::InvestigatingSupportingActor' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Investigate, UnderminingBuildingActor) == 0x000280, "Member 'UFortAthenaAIBotEvaluator_Investigate::UnderminingBuildingActor' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Investigate, BlacklistReachingTarget) == 0x000288, "Member 'UFortAthenaAIBotEvaluator_Investigate::BlacklistReachingTarget' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_Behavior
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAIRuntimeParameters_Behavior final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bSurfaceTypeCheckEnabled : 1;                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_Behavior">();
	}
	static class UFortAthenaAIRuntimeParameters_Behavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_Behavior>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_Behavior) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_Behavior");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_Behavior) == 0x000038, "Wrong size on UFortAthenaAIRuntimeParameters_Behavior");

// Class FortniteAI.FortAthenaAIBotEvaluator_JumpOffBus
// 0x0048 (0x00D0 - 0x0088)
class UFortAthenaAIBotEvaluator_JumpOffBus final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   JumpOffBusDestinationName;                         // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   JumpOffBusDestinationVolumeKeyName;                // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPoiVolume*                         BusDroppingVolume;                                 // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortGameStateAthena*                   CachedAthenaGameState;                             // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotMovementDigestedSkillSet* CacheMovementDigestedSkillSet;                     // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_JumpOffBus">();
	}
	static class UFortAthenaAIBotEvaluator_JumpOffBus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_JumpOffBus>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_JumpOffBus) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_JumpOffBus");
static_assert(sizeof(UFortAthenaAIBotEvaluator_JumpOffBus) == 0x0000D0, "Wrong size on UFortAthenaAIBotEvaluator_JumpOffBus");
static_assert(offsetof(UFortAthenaAIBotEvaluator_JumpOffBus, JumpOffBusDestinationName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_JumpOffBus::JumpOffBusDestinationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_JumpOffBus, JumpOffBusDestinationVolumeKeyName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_JumpOffBus::JumpOffBusDestinationVolumeKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_JumpOffBus, BusDroppingVolume) == 0x0000B0, "Member 'UFortAthenaAIBotEvaluator_JumpOffBus::BusDroppingVolume' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_JumpOffBus, CachedAthenaGameState) == 0x0000B8, "Member 'UFortAthenaAIBotEvaluator_JumpOffBus::CachedAthenaGameState' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_JumpOffBus, CacheMovementDigestedSkillSet) == 0x0000C0, "Member 'UFortAthenaAIBotEvaluator_JumpOffBus::CacheMovementDigestedSkillSet' has a wrong offset!");

// Class FortniteAI.FortBotMissionManager
// 0x00A8 (0x00D0 - 0x0028)
class UFortBotMissionManager final : public UObject
{
public:
	TSoftClassPtr<class UClass>                   BotPawnClass;                                      // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFortPawn*>                      BotPawns;                                          // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortBotMissionLogic*>           ActiveMissionsLogicData;                           // 0x0060(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UFortBotMissionLogic*                   PrimaryMissionLogicData;                           // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x58];                                      // 0x0078(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotMissionManager">();
	}
	static class UFortBotMissionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBotMissionManager>();
	}
};
static_assert(alignof(UFortBotMissionManager) == 0x000008, "Wrong alignment on UFortBotMissionManager");
static_assert(sizeof(UFortBotMissionManager) == 0x0000D0, "Wrong size on UFortBotMissionManager");
static_assert(offsetof(UFortBotMissionManager, BotPawnClass) == 0x000028, "Member 'UFortBotMissionManager::BotPawnClass' has a wrong offset!");
static_assert(offsetof(UFortBotMissionManager, BotPawns) == 0x000050, "Member 'UFortBotMissionManager::BotPawns' has a wrong offset!");
static_assert(offsetof(UFortBotMissionManager, ActiveMissionsLogicData) == 0x000060, "Member 'UFortBotMissionManager::ActiveMissionsLogicData' has a wrong offset!");
static_assert(offsetof(UFortBotMissionManager, PrimaryMissionLogicData) == 0x000070, "Member 'UFortBotMissionManager::PrimaryMissionLogicData' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Loot
// 0x01D0 (0x03E8 - 0x0218)
class UFortAthenaAIBotEvaluator_Loot final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class UAthenaAIServiceLoot*                   CachedAIServiceLoot;                               // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAthenaAIBotLootingDigestedSkillSet* LootingSkillSet;                                   // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LootDestinationKeyName;                            // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LootObjectKeyName;                                 // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LootTypeKeyName;                                   // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   POINavigationExecutionStatusKeyName;               // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x4];                                      // 0x0248(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EExecutionStatus                              POINavigationExecutionStatus;                      // 0x024C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D[0x183];                                    // 0x024D(0x0183)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CurrentLootOctreeElementId;                        // 0x03D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentLootActor;                                  // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortTeamInfoAthena*                    CachedTeamInfo;                                    // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Loot">();
	}
	static class UFortAthenaAIBotEvaluator_Loot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Loot>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Loot) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Loot");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Loot) == 0x0003E8, "Wrong size on UFortAthenaAIBotEvaluator_Loot");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, CachedAIServiceLoot) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Loot::CachedAIServiceLoot' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, LootingSkillSet) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_Loot::LootingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, LootDestinationKeyName) == 0x000238, "Member 'UFortAthenaAIBotEvaluator_Loot::LootDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, LootObjectKeyName) == 0x00023C, "Member 'UFortAthenaAIBotEvaluator_Loot::LootObjectKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, LootTypeKeyName) == 0x000240, "Member 'UFortAthenaAIBotEvaluator_Loot::LootTypeKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, POINavigationExecutionStatusKeyName) == 0x000244, "Member 'UFortAthenaAIBotEvaluator_Loot::POINavigationExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, POINavigationExecutionStatus) == 0x00024C, "Member 'UFortAthenaAIBotEvaluator_Loot::POINavigationExecutionStatus' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, CurrentLootOctreeElementId) == 0x0003D0, "Member 'UFortAthenaAIBotEvaluator_Loot::CurrentLootOctreeElementId' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, CurrentLootActor) == 0x0003D8, "Member 'UFortAthenaAIBotEvaluator_Loot::CurrentLootActor' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Loot, CachedTeamInfo) == 0x0003E0, "Member 'UFortAthenaAIBotEvaluator_Loot::CachedTeamInfo' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_MeleeAttack
// 0x0028 (0x0258 - 0x0230)
class UFortAthenaAIBotEvaluator_MeleeAttack final : public UFortAthenaAIBotEvaluator_Attack
{
public:
	uint8                                         Pad_230[0x4];                                      // 0x0230(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponTriggerMeleeName;                            // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TargetActorName;                                   // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C[0x3];                                      // 0x023C(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPrioritizeMovingTowardsThreatOverCurrentTarget;   // 0x023F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotAttackingDigestedSkillSet* AttackingSkillSet;                                 // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 BlacklistReachingTarget;                           // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_MeleeAttack">();
	}
	static class UFortAthenaAIBotEvaluator_MeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_MeleeAttack>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_MeleeAttack) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_MeleeAttack");
static_assert(sizeof(UFortAthenaAIBotEvaluator_MeleeAttack) == 0x000258, "Wrong size on UFortAthenaAIBotEvaluator_MeleeAttack");
static_assert(offsetof(UFortAthenaAIBotEvaluator_MeleeAttack, WeaponTriggerMeleeName) == 0x000234, "Member 'UFortAthenaAIBotEvaluator_MeleeAttack::WeaponTriggerMeleeName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_MeleeAttack, TargetActorName) == 0x000238, "Member 'UFortAthenaAIBotEvaluator_MeleeAttack::TargetActorName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_MeleeAttack, bPrioritizeMovingTowardsThreatOverCurrentTarget) == 0x00023F, "Member 'UFortAthenaAIBotEvaluator_MeleeAttack::bPrioritizeMovingTowardsThreatOverCurrentTarget' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_MeleeAttack, AttackingSkillSet) == 0x000240, "Member 'UFortAthenaAIBotEvaluator_MeleeAttack::AttackingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_MeleeAttack, BlacklistReachingTarget) == 0x000248, "Member 'UFortAthenaAIBotEvaluator_MeleeAttack::BlacklistReachingTarget' has a wrong offset!");

// Class FortniteAI.FortBTDecorator_DistanceBetween
// 0x0068 (0x00D0 - 0x0068)
class UFortBTDecorator_DistanceBetween final : public UBTDecorator
{
public:
	EArithmeticKeyOperation                       Operator;                                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BlackboardKeyA;                                    // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BlackboardKeyB;                                    // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         SpecifiedDistance;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSelf : 1;                                      // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCalculateAs2D : 1;                                // 0x00C4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceCalculationUpdateRate;                     // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_DistanceBetween">();
	}
	static class UFortBTDecorator_DistanceBetween* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_DistanceBetween>();
	}
};
static_assert(alignof(UFortBTDecorator_DistanceBetween) == 0x000008, "Wrong alignment on UFortBTDecorator_DistanceBetween");
static_assert(sizeof(UFortBTDecorator_DistanceBetween) == 0x0000D0, "Wrong size on UFortBTDecorator_DistanceBetween");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, Operator) == 0x000068, "Member 'UFortBTDecorator_DistanceBetween::Operator' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, BlackboardKeyA) == 0x000070, "Member 'UFortBTDecorator_DistanceBetween::BlackboardKeyA' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, BlackboardKeyB) == 0x000098, "Member 'UFortBTDecorator_DistanceBetween::BlackboardKeyB' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, SpecifiedDistance) == 0x0000C0, "Member 'UFortBTDecorator_DistanceBetween::SpecifiedDistance' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, DistanceCalculationUpdateRate) == 0x0000C8, "Member 'UFortBTDecorator_DistanceBetween::DistanceCalculationUpdateRate' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Observe
// 0x0018 (0x00A0 - 0x0088)
class UFortAthenaAIBotEvaluator_Observe final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   AggressivenessName;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ObserveDestinationKeyName;                         // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x2];                                       // 0x0090(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bContinueMovementOnStart;                          // 0x0092(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_93[0x1];                                       // 0x0093(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxMovementDuration;                               // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Observe">();
	}
	static class UFortAthenaAIBotEvaluator_Observe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Observe>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Observe) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Observe");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Observe) == 0x0000A0, "Wrong size on UFortAthenaAIBotEvaluator_Observe");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Observe, AggressivenessName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_Observe::AggressivenessName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Observe, ObserveDestinationKeyName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_Observe::ObserveDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Observe, bContinueMovementOnStart) == 0x000092, "Member 'UFortAthenaAIBotEvaluator_Observe::bContinueMovementOnStart' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Observe, MaxMovementDuration) == 0x000094, "Member 'UFortAthenaAIBotEvaluator_Observe::MaxMovementDuration' has a wrong offset!");

// Class FortniteAI.FortAthenaTrackableAIObjectVehicleComponent
// 0x0000 (0x00E0 - 0x00E0)
class UFortAthenaTrackableAIObjectVehicleComponent final : public UFortAthenaTrackableAIObjectComponent
{
public:
	void HandleSleepStateChanged(const bool bIsAwake);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaTrackableAIObjectVehicleComponent">();
	}
	static class UFortAthenaTrackableAIObjectVehicleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaTrackableAIObjectVehicleComponent>();
	}
};
static_assert(alignof(UFortAthenaTrackableAIObjectVehicleComponent) == 0x000008, "Wrong alignment on UFortAthenaTrackableAIObjectVehicleComponent");
static_assert(sizeof(UFortAthenaTrackableAIObjectVehicleComponent) == 0x0000E0, "Wrong size on UFortAthenaTrackableAIObjectVehicleComponent");

// Class FortniteAI.FortQueryContext_EncounterPrimaryAssignmentGoals
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterPrimaryAssignmentGoals final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterPrimaryAssignmentGoals">();
	}
	static class UFortQueryContext_EncounterPrimaryAssignmentGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterPrimaryAssignmentGoals>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterPrimaryAssignmentGoals) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterPrimaryAssignmentGoals");
static_assert(sizeof(UFortQueryContext_EncounterPrimaryAssignmentGoals) == 0x000028, "Wrong size on UFortQueryContext_EncounterPrimaryAssignmentGoals");

// Class FortniteAI.FortAthenaAIBotEvaluator_PathExists
// 0x0020 (0x00A8 - 0x0088)
class UFortAthenaAIBotEvaluator_PathExists final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   PathExistsKeyName;                                 // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GoalKeyName;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptableRadius;                                  // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathTestQueryType                            PathQueryType;                                     // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bProjectGoalLocation : 1;                          // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReachTestIncludesAgentRadius : 1;                 // 0x00A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReachTestIncludesGoalRadius : 1;                  // 0x00A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_PathExists">();
	}
	static class UFortAthenaAIBotEvaluator_PathExists* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_PathExists>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_PathExists) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_PathExists");
static_assert(sizeof(UFortAthenaAIBotEvaluator_PathExists) == 0x0000A8, "Wrong size on UFortAthenaAIBotEvaluator_PathExists");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PathExists, PathExistsKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_PathExists::PathExistsKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PathExists, GoalKeyName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_PathExists::GoalKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PathExists, AcceptableRadius) == 0x000094, "Member 'UFortAthenaAIBotEvaluator_PathExists::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PathExists, FilterClass) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_PathExists::FilterClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PathExists, PathQueryType) == 0x0000A0, "Member 'UFortAthenaAIBotEvaluator_PathExists::PathQueryType' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_PatrolAround
// 0x0018 (0x0230 - 0x0218)
class UFortAthenaAIBotEvaluator_PatrolAround final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   PatrolDestinationName;                             // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortGameModeAthena*                    CacheAthenaGameMode;                               // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_PatrolAround">();
	}
	static class UFortAthenaAIBotEvaluator_PatrolAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_PatrolAround>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_PatrolAround) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_PatrolAround");
static_assert(sizeof(UFortAthenaAIBotEvaluator_PatrolAround) == 0x000230, "Wrong size on UFortAthenaAIBotEvaluator_PatrolAround");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PatrolAround, PatrolDestinationName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_PatrolAround::PatrolDestinationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PatrolAround, CacheAthenaGameMode) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_PatrolAround::CacheAthenaGameMode' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_PlayEmote
// 0x0020 (0x0238 - 0x0218)
class UFortAthenaAIBotEvaluator_PlayEmote final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   PlayEmoteExecutionStatusKeyName;                   // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PlayEmoteDestinationKeyName;                       // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BlacklistReachingTarget;                           // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_PlayEmote">();
	}
	static class UFortAthenaAIBotEvaluator_PlayEmote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_PlayEmote>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_PlayEmote) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_PlayEmote");
static_assert(sizeof(UFortAthenaAIBotEvaluator_PlayEmote) == 0x000238, "Wrong size on UFortAthenaAIBotEvaluator_PlayEmote");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PlayEmote, PlayEmoteExecutionStatusKeyName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_PlayEmote::PlayEmoteExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PlayEmote, PlayEmoteDestinationKeyName) == 0x00021C, "Member 'UFortAthenaAIBotEvaluator_PlayEmote::PlayEmoteDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PlayEmote, BlacklistReachingTarget) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_PlayEmote::BlacklistReachingTarget' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_PropagateAwareness
// 0x0088 (0x0110 - 0x0088)
class UFortAthenaAIBotEvaluator_PropagateAwareness final : public UFortAthenaAIBotEvaluator
{
public:
	struct FGameplayTagQuery                      AwarenessTagQuery;                                 // 0x0088(0x0048)(Edit, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            AwarenessGameplayEffectClass;                      // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AFortPlayerPawnAthena*>          AwareAllyPawns;                                    // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AFortPlayerPawnAthena*>          AlreadyTestedPawns;                                // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotPropagateAwarenessDigestedSkillSet* PropagateAwarenessSkillSet;                        // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIRuntimeParameters_BehaviorTreeControl* BehaviorControlsRuntimeParameters;                 // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIRuntimeParameters_AffiliationBase* AffiliationRuntimeParameters;                      // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_PropagateAwareness">();
	}
	static class UFortAthenaAIBotEvaluator_PropagateAwareness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_PropagateAwareness>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_PropagateAwareness) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_PropagateAwareness");
static_assert(sizeof(UFortAthenaAIBotEvaluator_PropagateAwareness) == 0x000110, "Wrong size on UFortAthenaAIBotEvaluator_PropagateAwareness");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PropagateAwareness, AwarenessTagQuery) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_PropagateAwareness::AwarenessTagQuery' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PropagateAwareness, AwarenessGameplayEffectClass) == 0x0000D0, "Member 'UFortAthenaAIBotEvaluator_PropagateAwareness::AwarenessGameplayEffectClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PropagateAwareness, AwareAllyPawns) == 0x0000D8, "Member 'UFortAthenaAIBotEvaluator_PropagateAwareness::AwareAllyPawns' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PropagateAwareness, AlreadyTestedPawns) == 0x0000E8, "Member 'UFortAthenaAIBotEvaluator_PropagateAwareness::AlreadyTestedPawns' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PropagateAwareness, PropagateAwarenessSkillSet) == 0x0000F8, "Member 'UFortAthenaAIBotEvaluator_PropagateAwareness::PropagateAwarenessSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PropagateAwareness, BehaviorControlsRuntimeParameters) == 0x000100, "Member 'UFortAthenaAIBotEvaluator_PropagateAwareness::BehaviorControlsRuntimeParameters' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_PropagateAwareness, AffiliationRuntimeParameters) == 0x000108, "Member 'UFortAthenaAIBotEvaluator_PropagateAwareness::AffiliationRuntimeParameters' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_NPCBehavior
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAIRuntimeParameters_NPCBehavior final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bSupportsHolsteredWeapon : 1;                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_NPCBehavior">();
	}
	static class UFortAthenaAIRuntimeParameters_NPCBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_NPCBehavior>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_NPCBehavior) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_NPCBehavior");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_NPCBehavior) == 0x000038, "Wrong size on UFortAthenaAIRuntimeParameters_NPCBehavior");

// Class FortniteAI.FortAthenaAIBotEvaluator_RangeAttack
// 0x0128 (0x0358 - 0x0230)
class UFortAthenaAIBotEvaluator_RangeAttack final : public UFortAthenaAIBotEvaluator_Attack
{
public:
	class FName                                   WeaponReloadName;                                  // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponFireName;                                    // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponTargetingName;                               // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TargetActorName;                                   // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AggressivenessName;                                // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   HasLoSOnThreatName;                                // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   UrgentMovementKeyName;                             // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24C[0x7];                                      // 0x024C(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAlwaysAllowTargetingEvaluation;                   // 0x0253(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bConsiderLoF;                                      // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangeReachHysteresisRatio;                         // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0x24];                                     // 0x025C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotRangeAttackDigestedSkillSet* CacheRangeAttackDigestedSkillSet;                  // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotAimingDigestedSkillSet* CacheAimingDigestedSkillSet;                       // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotPerceptionDigestedSkillSet* CachePerceptionDigestedSkillSet;                   // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotAttackingDigestedSkillSet* CacheAttackingDigestedSkillSet;                    // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAthenaAIServiceLOFOccluder*            CacheLOFOccluderTracker;                           // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 BlacklistReachingTarget;                           // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x38];                                     // 0x02B0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CachedLastMoveToRangeTarget;                       // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x68];                                     // 0x02F0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_RangeAttack">();
	}
	static class UFortAthenaAIBotEvaluator_RangeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_RangeAttack>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_RangeAttack) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_RangeAttack");
static_assert(sizeof(UFortAthenaAIBotEvaluator_RangeAttack) == 0x000358, "Wrong size on UFortAthenaAIBotEvaluator_RangeAttack");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, WeaponReloadName) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::WeaponReloadName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, WeaponFireName) == 0x000234, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::WeaponFireName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, WeaponTargetingName) == 0x000238, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::WeaponTargetingName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, TargetActorName) == 0x00023C, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::TargetActorName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, AggressivenessName) == 0x000240, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::AggressivenessName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, HasLoSOnThreatName) == 0x000244, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::HasLoSOnThreatName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, UrgentMovementKeyName) == 0x000248, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::UrgentMovementKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, bAlwaysAllowTargetingEvaluation) == 0x000253, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::bAlwaysAllowTargetingEvaluation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, bConsiderLoF) == 0x000254, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::bConsiderLoF' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, RangeReachHysteresisRatio) == 0x000258, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::RangeReachHysteresisRatio' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, CacheRangeAttackDigestedSkillSet) == 0x000280, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::CacheRangeAttackDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, CacheAimingDigestedSkillSet) == 0x000288, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::CacheAimingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, CachePerceptionDigestedSkillSet) == 0x000290, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::CachePerceptionDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, CacheAttackingDigestedSkillSet) == 0x000298, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::CacheAttackingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, CacheLOFOccluderTracker) == 0x0002A0, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::CacheLOFOccluderTracker' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, BlacklistReachingTarget) == 0x0002A8, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::BlacklistReachingTarget' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_RangeAttack, CachedLastMoveToRangeTarget) == 0x0002E8, "Member 'UFortAthenaAIBotEvaluator_RangeAttack::CachedLastMoveToRangeTarget' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_ReachBeacon
// 0x0018 (0x0230 - 0x0218)
class UFortAthenaAIBotEvaluator_ReachBeacon final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   ReachBeaconStatusKeyName;                          // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ReachBeaconMovementStateKeyName;                   // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ReachBeaconTargetKeyName;                          // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UFortAthenaBeaconComponent> CurrentBeacon;                                     // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_ReachBeacon">();
	}
	static class UFortAthenaAIBotEvaluator_ReachBeacon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_ReachBeacon>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_ReachBeacon) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_ReachBeacon");
static_assert(sizeof(UFortAthenaAIBotEvaluator_ReachBeacon) == 0x000230, "Wrong size on UFortAthenaAIBotEvaluator_ReachBeacon");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ReachBeacon, ReachBeaconStatusKeyName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_ReachBeacon::ReachBeaconStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ReachBeacon, ReachBeaconMovementStateKeyName) == 0x00021C, "Member 'UFortAthenaAIBotEvaluator_ReachBeacon::ReachBeaconMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ReachBeacon, ReachBeaconTargetKeyName) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_ReachBeacon::ReachBeaconTargetKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ReachBeacon, CurrentBeacon) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_ReachBeacon::CurrentBeacon' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Retreat
// 0x0028 (0x0240 - 0x0218)
class UFortAthenaAIBotEvaluator_Retreat final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   RetreatDestinationName;                            // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotAttackingDigestedSkillSet* CacheAttackingDigestedSkillSet;                    // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAICoverComponent*            CachedCoverComponent;                              // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePlayerHealthOrShieldChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Retreat">();
	}
	static class UFortAthenaAIBotEvaluator_Retreat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Retreat>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Retreat) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Retreat");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Retreat) == 0x000240, "Wrong size on UFortAthenaAIBotEvaluator_Retreat");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Retreat, RetreatDestinationName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Retreat::RetreatDestinationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Retreat, CacheAttackingDigestedSkillSet) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_Retreat::CacheAttackingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Retreat, CachedCoverComponent) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_Retreat::CachedCoverComponent' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Revive
// 0x0038 (0x0250 - 0x0218)
class UFortAthenaAIBotEvaluator_Revive final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   ReviveTargetKeyName;                               // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIRuntimeParameters_ReviveBehavior* ReviveBehaviorRuntimeParameters;                   // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPlayerPawnAthena*                  CurrentReviveTarget;                               // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AFortPlayerPawnAthena*>          DBNOAllyPawns;                                     // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotReviveDigestedSkillSet* ReviveSkillSet;                                    // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Revive">();
	}
	static class UFortAthenaAIBotEvaluator_Revive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Revive>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Revive) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Revive");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Revive) == 0x000250, "Wrong size on UFortAthenaAIBotEvaluator_Revive");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Revive, ReviveTargetKeyName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Revive::ReviveTargetKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Revive, ReviveBehaviorRuntimeParameters) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_Revive::ReviveBehaviorRuntimeParameters' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Revive, CurrentReviveTarget) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_Revive::CurrentReviveTarget' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Revive, DBNOAllyPawns) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_Revive::DBNOAllyPawns' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Revive, ReviveSkillSet) == 0x000240, "Member 'UFortAthenaAIBotEvaluator_Revive::ReviveSkillSet' has a wrong offset!");

// Class FortniteAI.FortBotController
// 0x0008 (0x04F0 - 0x04E8)
class AFortBotController final : public AFortAIController
{
public:
	class UFortBotMissionLogic*                   CurrentMissionLogic;                               // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotController">();
	}
	static class AFortBotController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortBotController>();
	}
};
static_assert(alignof(AFortBotController) == 0x000008, "Wrong alignment on AFortBotController");
static_assert(sizeof(AFortBotController) == 0x0004F0, "Wrong size on AFortBotController");
static_assert(offsetof(AFortBotController, CurrentMissionLogic) == 0x0004E8, "Member 'AFortBotController::CurrentMissionLogic' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_SandTunnel
// 0x0078 (0x0150 - 0x00D8)
class UFortAthenaAIBotEvaluator_SandTunnel final : public UFortAthenaAIBotEvaluator_TagQuery
{
public:
	class FName                                   JumpExecutionStatusName;                           // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LootInteractionExecutionStatusName;                // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponTriggerMeleeName;                            // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponFireName;                                    // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      BuriedTagQuery;                                    // 0x00F0(0x0048)(Edit, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotMovementDigestedSkillSet* CacheMovementDigestedSkillSet;                     // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Jump();
	void OnBotControllerAlertLevelChanged(class AFortAthenaAIBotController* BotController, EAlertLevel OldAlertLevel, EAlertLevel NewAlertLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_SandTunnel">();
	}
	static class UFortAthenaAIBotEvaluator_SandTunnel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_SandTunnel>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_SandTunnel) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_SandTunnel");
static_assert(sizeof(UFortAthenaAIBotEvaluator_SandTunnel) == 0x000150, "Wrong size on UFortAthenaAIBotEvaluator_SandTunnel");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SandTunnel, JumpExecutionStatusName) == 0x0000D8, "Member 'UFortAthenaAIBotEvaluator_SandTunnel::JumpExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SandTunnel, LootInteractionExecutionStatusName) == 0x0000DC, "Member 'UFortAthenaAIBotEvaluator_SandTunnel::LootInteractionExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SandTunnel, WeaponTriggerMeleeName) == 0x0000E0, "Member 'UFortAthenaAIBotEvaluator_SandTunnel::WeaponTriggerMeleeName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SandTunnel, WeaponFireName) == 0x0000E4, "Member 'UFortAthenaAIBotEvaluator_SandTunnel::WeaponFireName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SandTunnel, BuriedTagQuery) == 0x0000F0, "Member 'UFortAthenaAIBotEvaluator_SandTunnel::BuriedTagQuery' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SandTunnel, CacheMovementDigestedSkillSet) == 0x000138, "Member 'UFortAthenaAIBotEvaluator_SandTunnel::CacheMovementDigestedSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaNpcPatrollingComponent
// 0x0040 (0x00E0 - 0x00A0)
class UFortAthenaNpcPatrollingComponent final : public UActorComponent
{
public:
	class AFortAthenaAIBotController*             CachedBotController;                               // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnStartPatrollingEvent;                            // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnStopPatrollingEvent;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class AFortAthenaPatrolPath*                  PatrolPath;                                        // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPatrolPath(const class AFortAthenaPatrolPath* NewPatrolPath, const bool bOrientationAlreadyRandomized);

	const class AFortAthenaPatrolPath* GetPatrolPath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNpcPatrollingComponent">();
	}
	static class UFortAthenaNpcPatrollingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNpcPatrollingComponent>();
	}
};
static_assert(alignof(UFortAthenaNpcPatrollingComponent) == 0x000008, "Wrong alignment on UFortAthenaNpcPatrollingComponent");
static_assert(sizeof(UFortAthenaNpcPatrollingComponent) == 0x0000E0, "Wrong size on UFortAthenaNpcPatrollingComponent");
static_assert(offsetof(UFortAthenaNpcPatrollingComponent, CachedBotController) == 0x0000A0, "Member 'UFortAthenaNpcPatrollingComponent::CachedBotController' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcPatrollingComponent, OnStartPatrollingEvent) == 0x0000A8, "Member 'UFortAthenaNpcPatrollingComponent::OnStartPatrollingEvent' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcPatrollingComponent, OnStopPatrollingEvent) == 0x0000B8, "Member 'UFortAthenaNpcPatrollingComponent::OnStopPatrollingEvent' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcPatrollingComponent, PatrolPath) == 0x0000C8, "Member 'UFortAthenaNpcPatrollingComponent::PatrolPath' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_SelectNextPOI
// 0x0038 (0x0250 - 0x0218)
class UFortAthenaAIBotEvaluator_SelectNextPOI final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   NextPOIKeyName;                                    // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MarkerLocationKeyName;                             // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPoiVolume*                         StartingGroundPOI;                                 // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckForStartingGroundPOI;                        // 0x0230(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentPOICompletionTime;                          // 0x0234(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DurationInsideCurrentPOI;                          // 0x0238(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortTeamInfoAthena*                    CachedTeamInfo;                                    // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotLootingDigestedSkillSet* CachedLootingSkillSet;                             // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_SelectNextPOI">();
	}
	static class UFortAthenaAIBotEvaluator_SelectNextPOI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_SelectNextPOI>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_SelectNextPOI) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_SelectNextPOI");
static_assert(sizeof(UFortAthenaAIBotEvaluator_SelectNextPOI) == 0x000250, "Wrong size on UFortAthenaAIBotEvaluator_SelectNextPOI");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectNextPOI, NextPOIKeyName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_SelectNextPOI::NextPOIKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectNextPOI, MarkerLocationKeyName) == 0x00021C, "Member 'UFortAthenaAIBotEvaluator_SelectNextPOI::MarkerLocationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectNextPOI, StartingGroundPOI) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_SelectNextPOI::StartingGroundPOI' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectNextPOI, bCheckForStartingGroundPOI) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_SelectNextPOI::bCheckForStartingGroundPOI' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectNextPOI, CurrentPOICompletionTime) == 0x000234, "Member 'UFortAthenaAIBotEvaluator_SelectNextPOI::CurrentPOICompletionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectNextPOI, DurationInsideCurrentPOI) == 0x000238, "Member 'UFortAthenaAIBotEvaluator_SelectNextPOI::DurationInsideCurrentPOI' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectNextPOI, CachedTeamInfo) == 0x000240, "Member 'UFortAthenaAIBotEvaluator_SelectNextPOI::CachedTeamInfo' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectNextPOI, CachedLootingSkillSet) == 0x000248, "Member 'UFortAthenaAIBotEvaluator_SelectNextPOI::CachedLootingSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_SelectVehicle
// 0x0040 (0x0258 - 0x0218)
class UFortAthenaAIBotEvaluator_SelectVehicle final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   VehicleDestinationKeyName;                         // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelectVehicleMovementStateKeyName;                 // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelectVehicleStatusKeyName;                        // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelectedVehicleKeyName;                            // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x4];                                      // 0x0228(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VehicleSearchRadius;                               // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEnterOnlyMatchingPatrols;                      // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEnterVehiclesInWater;                          // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEnterOutOfFuelVehicles;                        // 0x0232(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_233[0x5];                                      // 0x0233(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DesiredVehicleTags;                                // 0x0238(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_SelectVehicle">();
	}
	static class UFortAthenaAIBotEvaluator_SelectVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_SelectVehicle>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_SelectVehicle) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_SelectVehicle");
static_assert(sizeof(UFortAthenaAIBotEvaluator_SelectVehicle) == 0x000258, "Wrong size on UFortAthenaAIBotEvaluator_SelectVehicle");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectVehicle, VehicleDestinationKeyName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_SelectVehicle::VehicleDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectVehicle, SelectVehicleMovementStateKeyName) == 0x00021C, "Member 'UFortAthenaAIBotEvaluator_SelectVehicle::SelectVehicleMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectVehicle, SelectVehicleStatusKeyName) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_SelectVehicle::SelectVehicleStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectVehicle, SelectedVehicleKeyName) == 0x000224, "Member 'UFortAthenaAIBotEvaluator_SelectVehicle::SelectedVehicleKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectVehicle, VehicleSearchRadius) == 0x00022C, "Member 'UFortAthenaAIBotEvaluator_SelectVehicle::VehicleSearchRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectVehicle, bCanEnterOnlyMatchingPatrols) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_SelectVehicle::bCanEnterOnlyMatchingPatrols' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectVehicle, bCanEnterVehiclesInWater) == 0x000231, "Member 'UFortAthenaAIBotEvaluator_SelectVehicle::bCanEnterVehiclesInWater' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectVehicle, bCanEnterOutOfFuelVehicles) == 0x000232, "Member 'UFortAthenaAIBotEvaluator_SelectVehicle::bCanEnterOutOfFuelVehicles' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SelectVehicle, DesiredVehicleTags) == 0x000238, "Member 'UFortAthenaAIBotEvaluator_SelectVehicle::DesiredVehicleTags' has a wrong offset!");

// Class FortniteAI.FortAthenaNavArea_ShallowWater
// 0x0000 (0x0050 - 0x0050)
class UFortAthenaNavArea_ShallowWater final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNavArea_ShallowWater">();
	}
	static class UFortAthenaNavArea_ShallowWater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNavArea_ShallowWater>();
	}
};
static_assert(alignof(UFortAthenaNavArea_ShallowWater) == 0x000008, "Wrong alignment on UFortAthenaNavArea_ShallowWater");
static_assert(sizeof(UFortAthenaNavArea_ShallowWater) == 0x000050, "Wrong size on UFortAthenaNavArea_ShallowWater");

// Class FortniteAI.FortAthenaAISpawnerDataComponentList
// 0x0030 (0x0058 - 0x0028)
class UFortAthenaAISpawnerDataComponentList final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UFortAthenaAISpawnerDataComponent*> GetList();
	class UFortAthenaAISpawnerDataComponentList* OverrideComponent(const class UFortAthenaAISpawnerDataComponent* NewComponent);
	class UFortAthenaAISpawnerDataComponentList* OverrideComponentClass(const TSubclassOf<class UFortAthenaAISpawnerDataComponent> NewComponentSubClass);

	class UFortAthenaAISpawnerDataComponent* GetOrCreateComponentClassForModification(class UObject* ComponentOuter, const TSubclassOf<class UFortAthenaAISpawnerDataComponent> ClassToClone) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponentList">();
	}
	static class UFortAthenaAISpawnerDataComponentList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponentList>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponentList) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponentList");
static_assert(sizeof(UFortAthenaAISpawnerDataComponentList) == 0x000058, "Wrong size on UFortAthenaAISpawnerDataComponentList");

// Class FortniteAI.FortAthenaAIBotEvaluator_SmartObjects
// 0x0028 (0x0240 - 0x0218)
class UFortAthenaAIBotEvaluator_SmartObjects final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class UFortAthenaAIRuntimeParameters_SmartObjectBase* SmartObjectRuntimeParameters;                      // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USmartObjectSubsystem*                  SmartObjectSubsystem;                              // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SmartObjectExecutionStatusKeyName;                 // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SmartObjectMovementStateKeyName;                   // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SmartObjectDestinationKeyName;                     // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SmartObjectShouldMoveKeyName;                      // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_SmartObjects">();
	}
	static class UFortAthenaAIBotEvaluator_SmartObjects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_SmartObjects>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_SmartObjects) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_SmartObjects");
static_assert(sizeof(UFortAthenaAIBotEvaluator_SmartObjects) == 0x000240, "Wrong size on UFortAthenaAIBotEvaluator_SmartObjects");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SmartObjects, SmartObjectRuntimeParameters) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_SmartObjects::SmartObjectRuntimeParameters' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SmartObjects, SmartObjectSubsystem) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_SmartObjects::SmartObjectSubsystem' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SmartObjects, SmartObjectExecutionStatusKeyName) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_SmartObjects::SmartObjectExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SmartObjects, SmartObjectMovementStateKeyName) == 0x00022C, "Member 'UFortAthenaAIBotEvaluator_SmartObjects::SmartObjectMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SmartObjects, SmartObjectDestinationKeyName) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_SmartObjects::SmartObjectDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_SmartObjects, SmartObjectShouldMoveKeyName) == 0x000234, "Member 'UFortAthenaAIBotEvaluator_SmartObjects::SmartObjectShouldMoveKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Sprinting
// 0x0060 (0x00E8 - 0x0088)
class UFortAthenaAIBotEvaluator_Sprinting final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   JumpExecutionStatusName;                           // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TacticalSprintExecutionStatusName;                 // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SlideExecutionStatusName;                          // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   UrgentMovementKeyName;                             // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RangeAttackExecutionStatusName;                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MeleeAttackExecutionStatusName;                    // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ThrowableAttackExecutionStatusName;                // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x7];                                       // 0x00A4(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSprintOnlyInWater;                                // 0x00AB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotMovementDigestedSkillSet* MovementSkillSet;                                  // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotAimingDigestedSkillSet* AimingSkillSet;                                    // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TacticalSprintTriggerChance;                       // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TacticalSprintTriggerChanceInUrgentMovement;       // 0x00C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlidingTriggerChance;                              // 0x00C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlidingDuringUrgentMovementTriggerChance;          // 0x00CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Sprinting">();
	}
	static class UFortAthenaAIBotEvaluator_Sprinting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Sprinting>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Sprinting) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Sprinting");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Sprinting) == 0x0000E8, "Wrong size on UFortAthenaAIBotEvaluator_Sprinting");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, JumpExecutionStatusName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_Sprinting::JumpExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, TacticalSprintExecutionStatusName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_Sprinting::TacticalSprintExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, SlideExecutionStatusName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_Sprinting::SlideExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, UrgentMovementKeyName) == 0x000094, "Member 'UFortAthenaAIBotEvaluator_Sprinting::UrgentMovementKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, RangeAttackExecutionStatusName) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_Sprinting::RangeAttackExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, MeleeAttackExecutionStatusName) == 0x00009C, "Member 'UFortAthenaAIBotEvaluator_Sprinting::MeleeAttackExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, ThrowableAttackExecutionStatusName) == 0x0000A0, "Member 'UFortAthenaAIBotEvaluator_Sprinting::ThrowableAttackExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, bSprintOnlyInWater) == 0x0000AB, "Member 'UFortAthenaAIBotEvaluator_Sprinting::bSprintOnlyInWater' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, MovementSkillSet) == 0x0000B0, "Member 'UFortAthenaAIBotEvaluator_Sprinting::MovementSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, AimingSkillSet) == 0x0000B8, "Member 'UFortAthenaAIBotEvaluator_Sprinting::AimingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, TacticalSprintTriggerChance) == 0x0000C0, "Member 'UFortAthenaAIBotEvaluator_Sprinting::TacticalSprintTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, TacticalSprintTriggerChanceInUrgentMovement) == 0x0000C4, "Member 'UFortAthenaAIBotEvaluator_Sprinting::TacticalSprintTriggerChanceInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, SlidingTriggerChance) == 0x0000C8, "Member 'UFortAthenaAIBotEvaluator_Sprinting::SlidingTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Sprinting, SlidingDuringUrgentMovementTriggerChance) == 0x0000CC, "Member 'UFortAthenaAIBotEvaluator_Sprinting::SlidingDuringUrgentMovementTriggerChance' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AnalyticBase
// 0x0030 (0x0060 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AnalyticBase : public UFortAthenaAISpawnerDataComponent
{
public:
	struct FGameplayTagContainer                  OnDeathGameplayTags;                               // 0x0030(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AnalyticBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_AnalyticBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AnalyticBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AnalyticBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AnalyticBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AnalyticBase) == 0x000060, "Wrong size on UFortAthenaAISpawnerDataComponent_AnalyticBase");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AnalyticBase, OnDeathGameplayTags) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_AnalyticBase::OnDeathGameplayTags' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIAnalytic
// 0x0100 (0x0160 - 0x0060)
class UFortAthenaAISpawnerDataComponent_AIAnalytic final : public UFortAthenaAISpawnerDataComponent_AnalyticBase
{
public:
	class FString                                 AIType;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldSendSpawnEvents;                             // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldRecordGrabbedPickups;                        // 0x0098(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldRecordDroppedPickups;                        // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldRecordDeathInstigator;                       // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldRecordRegularDowns;                          // 0x0110(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldRecordTetheredDowns;                         // 0x0138(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIAnalytic">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIAnalytic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIAnalytic>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIAnalytic) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIAnalytic");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIAnalytic) == 0x000160, "Wrong size on UFortAthenaAISpawnerDataComponent_AIAnalytic");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIAnalytic, AIType) == 0x000060, "Member 'UFortAthenaAISpawnerDataComponent_AIAnalytic::AIType' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIAnalytic, ShouldSendSpawnEvents) == 0x000070, "Member 'UFortAthenaAISpawnerDataComponent_AIAnalytic::ShouldSendSpawnEvents' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIAnalytic, ShouldRecordGrabbedPickups) == 0x000098, "Member 'UFortAthenaAISpawnerDataComponent_AIAnalytic::ShouldRecordGrabbedPickups' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIAnalytic, ShouldRecordDroppedPickups) == 0x0000C0, "Member 'UFortAthenaAISpawnerDataComponent_AIAnalytic::ShouldRecordDroppedPickups' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIAnalytic, ShouldRecordDeathInstigator) == 0x0000E8, "Member 'UFortAthenaAISpawnerDataComponent_AIAnalytic::ShouldRecordDeathInstigator' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIAnalytic, ShouldRecordRegularDowns) == 0x000110, "Member 'UFortAthenaAISpawnerDataComponent_AIAnalytic::ShouldRecordRegularDowns' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIAnalytic, ShouldRecordTetheredDowns) == 0x000138, "Member 'UFortAthenaAISpawnerDataComponent_AIAnalytic::ShouldRecordTetheredDowns' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_StealWall
// 0x00A8 (0x0130 - 0x0088)
class alignas(0x10) UFortAthenaAIBotEvaluator_StealWall final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   StealWallBuildTypeName;                            // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StealWallBuildGridCoordName;                       // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TargetActorName;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotBuildingDigestedSkillSet* CacheBuildingDigestedSkillSet;                     // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABuildingActor*                         CurrentBuildingTarget;                             // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x80];                                      // 0x00B0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_StealWall">();
	}
	static class UFortAthenaAIBotEvaluator_StealWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_StealWall>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_StealWall) == 0x000010, "Wrong alignment on UFortAthenaAIBotEvaluator_StealWall");
static_assert(sizeof(UFortAthenaAIBotEvaluator_StealWall) == 0x000130, "Wrong size on UFortAthenaAIBotEvaluator_StealWall");
static_assert(offsetof(UFortAthenaAIBotEvaluator_StealWall, StealWallBuildTypeName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_StealWall::StealWallBuildTypeName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_StealWall, StealWallBuildGridCoordName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_StealWall::StealWallBuildGridCoordName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_StealWall, TargetActorName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_StealWall::TargetActorName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_StealWall, CacheBuildingDigestedSkillSet) == 0x0000A0, "Member 'UFortAthenaAIBotEvaluator_StealWall::CacheBuildingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_StealWall, CurrentBuildingTarget) == 0x0000A8, "Member 'UFortAthenaAIBotEvaluator_StealWall::CurrentBuildingTarget' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Storm
// 0x0040 (0x0258 - 0x0218)
class UFortAthenaAIBotEvaluator_Storm final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   StormDestinationName;                              // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C[0xC];                                      // 0x021C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortGameModeAthena*                    CacheAthenaGameMode;                               // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTreeComponent*                 CachedBTComp;                                      // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x20];                                     // 0x0238(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSafeZonePhaseChanged();
	void OnSafezoneStateChanged(const EFortSafeZoneState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Storm">();
	}
	static class UFortAthenaAIBotEvaluator_Storm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Storm>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Storm) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Storm");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Storm) == 0x000258, "Wrong size on UFortAthenaAIBotEvaluator_Storm");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Storm, StormDestinationName) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_Storm::StormDestinationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Storm, CacheAthenaGameMode) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_Storm::CacheAthenaGameMode' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Storm, CachedBTComp) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_Storm::CachedBTComp' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_ReviveBehavior
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAIRuntimeParameters_ReviveBehavior final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bAllowReviveSquadmates : 1;                        // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bAllowReviveSameFactionNPCs : 1;                   // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bUseReviveToken : 1;                               // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToRevive;                               // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_ReviveBehavior">();
	}
	static class UFortAthenaAIRuntimeParameters_ReviveBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_ReviveBehavior>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_ReviveBehavior) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_ReviveBehavior");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_ReviveBehavior) == 0x000038, "Wrong size on UFortAthenaAIRuntimeParameters_ReviveBehavior");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_ReviveBehavior, MaxDistanceToRevive) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_ReviveBehavior::MaxDistanceToRevive' has a wrong offset!");

// Class FortniteAI.FortQueryContext_Goal_SpawnLocation
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_Goal_SpawnLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_Goal_SpawnLocation">();
	}
	static class UFortQueryContext_Goal_SpawnLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_Goal_SpawnLocation>();
	}
};
static_assert(alignof(UFortQueryContext_Goal_SpawnLocation) == 0x000008, "Wrong alignment on UFortQueryContext_Goal_SpawnLocation");
static_assert(sizeof(UFortQueryContext_Goal_SpawnLocation) == 0x000028, "Wrong size on UFortQueryContext_Goal_SpawnLocation");

// Class FortniteAI.FortAthenaAIBotEvaluator_TagQueryToBBKey
// 0x0008 (0x00E0 - 0x00D8)
class UFortAthenaAIBotEvaluator_TagQueryToBBKey final : public UFortAthenaAIBotEvaluator_TagQuery
{
public:
	class FName                                   LinkedBBKeyName;                                   // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_TagQueryToBBKey">();
	}
	static class UFortAthenaAIBotEvaluator_TagQueryToBBKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_TagQueryToBBKey>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_TagQueryToBBKey) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_TagQueryToBBKey");
static_assert(sizeof(UFortAthenaAIBotEvaluator_TagQueryToBBKey) == 0x0000E0, "Wrong size on UFortAthenaAIBotEvaluator_TagQueryToBBKey");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TagQueryToBBKey, LinkedBBKeyName) == 0x0000D8, "Member 'UFortAthenaAIBotEvaluator_TagQueryToBBKey::LinkedBBKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_VoiceBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_VoiceBase : public UFortAthenaAISpawnerDataComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_VoiceBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_VoiceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_VoiceBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_VoiceBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_VoiceBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_VoiceBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_VoiceBase");

// Class FortniteAI.FortAthenaAIBotEvaluator_TakeCover
// 0x0070 (0x0288 - 0x0218)
class UFortAthenaAIBotEvaluator_TakeCover final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class UFortAthenaAIBotRangeAttackDigestedSkillSet* CacheRangeAttackDigestedSkillSet;                  // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotAimingDigestedSkillSet* CacheAimingDigestedSkillSet;                       // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAthenaAIServiceCover*                  CachedAIServiceCover;                              // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DestinationKeyName;                                // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   HealingStatusKeyName;                              // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingActor*                         CachedCoverBuildingActor;                          // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ABuildingActor*>                 BlacklistedBuildingActors;                         // 0x0248(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x30];                                     // 0x0258(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_TakeCover">();
	}
	static class UFortAthenaAIBotEvaluator_TakeCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_TakeCover>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_TakeCover) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_TakeCover");
static_assert(sizeof(UFortAthenaAIBotEvaluator_TakeCover) == 0x000288, "Wrong size on UFortAthenaAIBotEvaluator_TakeCover");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TakeCover, CacheRangeAttackDigestedSkillSet) == 0x000218, "Member 'UFortAthenaAIBotEvaluator_TakeCover::CacheRangeAttackDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TakeCover, CacheAimingDigestedSkillSet) == 0x000220, "Member 'UFortAthenaAIBotEvaluator_TakeCover::CacheAimingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TakeCover, CachedAIServiceCover) == 0x000228, "Member 'UFortAthenaAIBotEvaluator_TakeCover::CachedAIServiceCover' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TakeCover, DestinationKeyName) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_TakeCover::DestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TakeCover, HealingStatusKeyName) == 0x000234, "Member 'UFortAthenaAIBotEvaluator_TakeCover::HealingStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TakeCover, CachedCoverBuildingActor) == 0x000240, "Member 'UFortAthenaAIBotEvaluator_TakeCover::CachedCoverBuildingActor' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TakeCover, BlacklistedBuildingActors) == 0x000248, "Member 'UFortAthenaAIBotEvaluator_TakeCover::BlacklistedBuildingActors' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_ThrowableAttack
// 0x0050 (0x0280 - 0x0230)
class UFortAthenaAIBotEvaluator_ThrowableAttack final : public UFortAthenaAIBotEvaluator_Attack
{
public:
	class FName                                   WeaponTriggerThrowableName;                        // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TargetActorName;                                   // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotAttackingDigestedSkillSet* AttackingSkillSet;                                 // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotRangeAttackDigestedSkillSet* RangeAttackSkillSet;                               // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotAimingDigestedSkillSet* AimingSkillSet;                                    // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortWorldItem*                         BestWeapon;                                        // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPawn*                              CachedFortPawn;                                    // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x18];                                     // 0x0268(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_ThrowableAttack">();
	}
	static class UFortAthenaAIBotEvaluator_ThrowableAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_ThrowableAttack>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_ThrowableAttack) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_ThrowableAttack");
static_assert(sizeof(UFortAthenaAIBotEvaluator_ThrowableAttack) == 0x000280, "Wrong size on UFortAthenaAIBotEvaluator_ThrowableAttack");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ThrowableAttack, WeaponTriggerThrowableName) == 0x000230, "Member 'UFortAthenaAIBotEvaluator_ThrowableAttack::WeaponTriggerThrowableName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ThrowableAttack, TargetActorName) == 0x000234, "Member 'UFortAthenaAIBotEvaluator_ThrowableAttack::TargetActorName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ThrowableAttack, AttackingSkillSet) == 0x000240, "Member 'UFortAthenaAIBotEvaluator_ThrowableAttack::AttackingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ThrowableAttack, RangeAttackSkillSet) == 0x000248, "Member 'UFortAthenaAIBotEvaluator_ThrowableAttack::RangeAttackSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ThrowableAttack, AimingSkillSet) == 0x000250, "Member 'UFortAthenaAIBotEvaluator_ThrowableAttack::AimingSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ThrowableAttack, BestWeapon) == 0x000258, "Member 'UFortAthenaAIBotEvaluator_ThrowableAttack::BestWeapon' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_ThrowableAttack, CachedFortPawn) == 0x000260, "Member 'UFortAthenaAIBotEvaluator_ThrowableAttack::CachedFortPawn' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_TrapOnPathDetected
// 0x0028 (0x00B0 - 0x0088)
class UFortAthenaAIBotEvaluator_TrapOnPathDetected final : public UFortAthenaAIBotEvaluator
{
public:
	class UFortAthenaAIBotAimingDigestedSkillSet* CacheAimingDigestedSkillSet;                       // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TrapOnPathKeyName;                                 // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TrapActorOnPathKeyName;                            // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetActorName;                                   // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AlertLevelName;                                    // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RangeAttackExecutionStatusName;                    // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingTrap*                          CurrentTrapTarget;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_TrapOnPathDetected">();
	}
	static class UFortAthenaAIBotEvaluator_TrapOnPathDetected* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_TrapOnPathDetected>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_TrapOnPathDetected) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_TrapOnPathDetected");
static_assert(sizeof(UFortAthenaAIBotEvaluator_TrapOnPathDetected) == 0x0000B0, "Wrong size on UFortAthenaAIBotEvaluator_TrapOnPathDetected");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TrapOnPathDetected, CacheAimingDigestedSkillSet) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_TrapOnPathDetected::CacheAimingDigestedSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TrapOnPathDetected, TrapOnPathKeyName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_TrapOnPathDetected::TrapOnPathKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TrapOnPathDetected, TrapActorOnPathKeyName) == 0x000094, "Member 'UFortAthenaAIBotEvaluator_TrapOnPathDetected::TrapActorOnPathKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TrapOnPathDetected, TargetActorName) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_TrapOnPathDetected::TargetActorName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TrapOnPathDetected, AlertLevelName) == 0x00009C, "Member 'UFortAthenaAIBotEvaluator_TrapOnPathDetected::AlertLevelName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TrapOnPathDetected, RangeAttackExecutionStatusName) == 0x0000A0, "Member 'UFortAthenaAIBotEvaluator_TrapOnPathDetected::RangeAttackExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_TrapOnPathDetected, CurrentTrapTarget) == 0x0000A8, "Member 'UFortAthenaAIBotEvaluator_TrapOnPathDetected::CurrentTrapTarget' has a wrong offset!");

// Class FortniteAI.FortPathCostEstimator
// 0x0080 (0x00A8 - 0x0028)
class UFortPathCostEstimator final : public UObject
{
public:
	class AActor*                                 GoalActor;                                         // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortNavigationGraph*                   NavGraph;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPathCostEstimator">();
	}
	static class UFortPathCostEstimator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPathCostEstimator>();
	}
};
static_assert(alignof(UFortPathCostEstimator) == 0x000008, "Wrong alignment on UFortPathCostEstimator");
static_assert(sizeof(UFortPathCostEstimator) == 0x0000A8, "Wrong size on UFortPathCostEstimator");
static_assert(offsetof(UFortPathCostEstimator, GoalActor) == 0x000028, "Member 'UFortPathCostEstimator::GoalActor' has a wrong offset!");
static_assert(offsetof(UFortPathCostEstimator, NavGraph) == 0x000030, "Member 'UFortPathCostEstimator::NavGraph' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_VehicleLeaveSeat
// 0x0008 (0x0090 - 0x0088)
class UFortAthenaAIBotEvaluator_VehicleLeaveSeat final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   LeaveSeatStatusKeyName;                            // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x1];                                       // 0x008C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLeaveSeatWhenPlayerInVehicle;                     // 0x008D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_VehicleLeaveSeat">();
	}
	static class UFortAthenaAIBotEvaluator_VehicleLeaveSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_VehicleLeaveSeat>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_VehicleLeaveSeat) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_VehicleLeaveSeat");
static_assert(sizeof(UFortAthenaAIBotEvaluator_VehicleLeaveSeat) == 0x000090, "Wrong size on UFortAthenaAIBotEvaluator_VehicleLeaveSeat");
static_assert(offsetof(UFortAthenaAIBotEvaluator_VehicleLeaveSeat, LeaveSeatStatusKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_VehicleLeaveSeat::LeaveSeatStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_VehicleLeaveSeat, bLeaveSeatWhenPlayerInVehicle) == 0x00008D, "Member 'UFortAthenaAIBotEvaluator_VehicleLeaveSeat::bLeaveSeatWhenPlayerInVehicle' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_VehicleSwitchSeat
// 0x0008 (0x0090 - 0x0088)
class UFortAthenaAIBotEvaluator_VehicleSwitchSeat final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   SwitchSeatStatusKeyName;                           // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x1];                                       // 0x008C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSwitchToEmptyDriverSeat;                          // 0x008D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_VehicleSwitchSeat">();
	}
	static class UFortAthenaAIBotEvaluator_VehicleSwitchSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_VehicleSwitchSeat>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_VehicleSwitchSeat) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_VehicleSwitchSeat");
static_assert(sizeof(UFortAthenaAIBotEvaluator_VehicleSwitchSeat) == 0x000090, "Wrong size on UFortAthenaAIBotEvaluator_VehicleSwitchSeat");
static_assert(offsetof(UFortAthenaAIBotEvaluator_VehicleSwitchSeat, SwitchSeatStatusKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_VehicleSwitchSeat::SwitchSeatStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_VehicleSwitchSeat, bSwitchToEmptyDriverSeat) == 0x00008D, "Member 'UFortAthenaAIBotEvaluator_VehicleSwitchSeat::bSwitchToEmptyDriverSeat' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_WaitForPassengers
// 0x0008 (0x0090 - 0x0088)
class UFortAthenaAIBotEvaluator_WaitForPassengers final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   WaitForPassengersStatusKeyName;                    // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_WaitForPassengers">();
	}
	static class UFortAthenaAIBotEvaluator_WaitForPassengers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_WaitForPassengers>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_WaitForPassengers) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_WaitForPassengers");
static_assert(sizeof(UFortAthenaAIBotEvaluator_WaitForPassengers) == 0x000090, "Wrong size on UFortAthenaAIBotEvaluator_WaitForPassengers");
static_assert(offsetof(UFortAthenaAIBotEvaluator_WaitForPassengers, WaitForPassengersStatusKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_WaitForPassengers::WaitForPassengersStatusKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvaluator_Warmup
// 0x0028 (0x00B0 - 0x0088)
class UFortAthenaAIBotEvaluator_Warmup final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   WarmupPlayEmoteExecutionStatusKeyName;             // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WarmupLootAndShootExecutionStatusKeyName;          // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WarmupIdleExecutionStatusKeyName;                  // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotWarmupDigestedSkillSet* CacheWarmupDigestedSkillSet;                       // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvaluator_Warmup">();
	}
	static class UFortAthenaAIBotEvaluator_Warmup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvaluator_Warmup>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvaluator_Warmup) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvaluator_Warmup");
static_assert(sizeof(UFortAthenaAIBotEvaluator_Warmup) == 0x0000B0, "Wrong size on UFortAthenaAIBotEvaluator_Warmup");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Warmup, WarmupPlayEmoteExecutionStatusKeyName) == 0x000088, "Member 'UFortAthenaAIBotEvaluator_Warmup::WarmupPlayEmoteExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Warmup, WarmupLootAndShootExecutionStatusKeyName) == 0x00008C, "Member 'UFortAthenaAIBotEvaluator_Warmup::WarmupLootAndShootExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Warmup, WarmupIdleExecutionStatusKeyName) == 0x000090, "Member 'UFortAthenaAIBotEvaluator_Warmup::WarmupIdleExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvaluator_Warmup, CacheWarmupDigestedSkillSet) == 0x000098, "Member 'UFortAthenaAIBotEvaluator_Warmup::CacheWarmupDigestedSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvasiveManeuversDigestedSkillSet
// 0x0118 (0x0148 - 0x0030)
class UFortAthenaAIBotEvasiveManeuversDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDigestedEvasiveManeuverSkillSettings  DefaultEvasiveManeuverSkillSettings;               // 0x0038(0x0058)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDigestedEvasiveManeuverSkillSettingsSpecialization> EvasiveManeuverSkillSettingsSpecializations;       // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeDelay;                                // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeRandomDeviationDelay;                 // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeOverlayWeight;                        // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeDistanceMax;                          // 0x00AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeDistanceMin;                          // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeActivationTime;                       // 0x00B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeActivationTimeRandomDeviation;        // 0x00B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeTime;                                 // 0x00BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeTimeRandomDeviation;                  // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DodgeMaxDistanceSquared;                           // 0x00C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchMaxDistanceSquared;                          // 0x00C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpMaxDistanceSquared;                            // 0x00CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JetpackStrafeMaxDistanceSquared;                   // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AvoidProjectilesReactionDistanceSqr;               // 0x00D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AvoidProjectilesReactionTimeMin;                   // 0x00D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AvoidProjectilesReactionTimeMax;                   // 0x00DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AvoidProjectilesEvasiveDistanceMin;                // 0x00E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AvoidProjectilesEvasiveDistanceMax;                // 0x00E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AvoidPhysicsObjectsReactionDistanceMin;            // 0x00E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AvoidPhysicsObjectsReactionDistanceMax;            // 0x00EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AvoidPhysicsObjectsSpeedMin;                       // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AvoidPhysicsObjectsSpeedMax;                       // 0x00F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      CanUseEvasiveManeuversTagQuery;                    // 0x00F8(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanCrouchInUrgentMovement;                        // 0x0140(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanDodgeInUrgentMovement;                         // 0x0141(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanJumpInUrgentMovement;                          // 0x0142(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_143[0x5];                                      // 0x0143(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvasiveManeuversDigestedSkillSet">();
	}
	static class UFortAthenaAIBotEvasiveManeuversDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvasiveManeuversDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvasiveManeuversDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet) == 0x000148, "Wrong size on UFortAthenaAIBotEvasiveManeuversDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, DefaultEvasiveManeuverSkillSettings) == 0x000038, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::DefaultEvasiveManeuverSkillSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, EvasiveManeuverSkillSettingsSpecializations) == 0x000090, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::EvasiveManeuverSkillSettingsSpecializations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeDelay) == 0x0000A0, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeRandomDeviationDelay) == 0x0000A4, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeRandomDeviationDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeOverlayWeight) == 0x0000A8, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeOverlayWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeDistanceMax) == 0x0000AC, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeDistanceMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeDistanceMin) == 0x0000B0, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeDistanceMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeActivationTime) == 0x0000B4, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeActivationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeActivationTimeRandomDeviation) == 0x0000B8, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeActivationTimeRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeTime) == 0x0000BC, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeTimeRandomDeviation) == 0x0000C0, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeTimeRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, DodgeMaxDistanceSquared) == 0x0000C4, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::DodgeMaxDistanceSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, CrouchMaxDistanceSquared) == 0x0000C8, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::CrouchMaxDistanceSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JumpMaxDistanceSquared) == 0x0000CC, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JumpMaxDistanceSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, JetpackStrafeMaxDistanceSquared) == 0x0000D0, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::JetpackStrafeMaxDistanceSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, AvoidProjectilesReactionDistanceSqr) == 0x0000D4, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::AvoidProjectilesReactionDistanceSqr' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, AvoidProjectilesReactionTimeMin) == 0x0000D8, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::AvoidProjectilesReactionTimeMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, AvoidProjectilesReactionTimeMax) == 0x0000DC, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::AvoidProjectilesReactionTimeMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, AvoidProjectilesEvasiveDistanceMin) == 0x0000E0, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::AvoidProjectilesEvasiveDistanceMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, AvoidProjectilesEvasiveDistanceMax) == 0x0000E4, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::AvoidProjectilesEvasiveDistanceMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, AvoidPhysicsObjectsReactionDistanceMin) == 0x0000E8, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::AvoidPhysicsObjectsReactionDistanceMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, AvoidPhysicsObjectsReactionDistanceMax) == 0x0000EC, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::AvoidPhysicsObjectsReactionDistanceMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, AvoidPhysicsObjectsSpeedMin) == 0x0000F0, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::AvoidPhysicsObjectsSpeedMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, AvoidPhysicsObjectsSpeedMax) == 0x0000F4, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::AvoidPhysicsObjectsSpeedMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, CanUseEvasiveManeuversTagQuery) == 0x0000F8, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::CanUseEvasiveManeuversTagQuery' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, bCanCrouchInUrgentMovement) == 0x000140, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::bCanCrouchInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, bCanDodgeInUrgentMovement) == 0x000141, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::bCanDodgeInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversDigestedSkillSet, bCanJumpInUrgentMovement) == 0x000142, "Member 'UFortAthenaAIBotEvasiveManeuversDigestedSkillSet::bCanJumpInUrgentMovement' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_Voice
// 0x0020 (0x0050 - 0x0030)
class UFortAthenaAISpawnerDataComponent_Voice final : public UFortAthenaAISpawnerDataComponent_VoiceBase
{
public:
	TSubclassOf<class UFortAIComponent_Voice>     VoiceComponentClass;                               // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortTaggedSoundBank*                   SoundBank;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortTaggedSoundBank*                   MaleSoundBankOverride;                             // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortTaggedSoundBank*                   FemaleSoundBankOverride;                           // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_Voice">();
	}
	static class UFortAthenaAISpawnerDataComponent_Voice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_Voice>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_Voice) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_Voice");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_Voice) == 0x000050, "Wrong size on UFortAthenaAISpawnerDataComponent_Voice");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_Voice, VoiceComponentClass) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_Voice::VoiceComponentClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_Voice, SoundBank) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_Voice::SoundBank' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_Voice, MaleSoundBankOverride) == 0x000040, "Member 'UFortAthenaAISpawnerDataComponent_Voice::MaleSoundBankOverride' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_Voice, FemaleSoundBankOverride) == 0x000048, "Member 'UFortAthenaAISpawnerDataComponent_Voice::FemaleSoundBankOverride' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotEvasiveManeuversSkillSet
// 0x0698 (0x06C8 - 0x0030)
class UFortAthenaAIBotEvasiveManeuversSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FEvasiveManeuverSkillSettings          DefaultEvasiveManeuverSkillSettings;               // 0x0030(0x0258)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEvasiveManeuverSkillSettingsSpecialization> EvasiveManeuverSkillSettingsSpecializations;       // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeOverlayWeight;                        // 0x0298(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeDelay;                                // 0x02C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeRandomDeviationDelay;                 // 0x02E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeDistanceMax;                          // 0x0310(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeDistanceMin;                          // 0x0338(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeActivationTime;                       // 0x0360(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeActivationTimeRandomDeviation;        // 0x0388(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeTime;                                 // 0x03B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeTimeRandomDeviation;                  // 0x03D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DodgeMaxDistance;                                  // 0x0400(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CanDodgeInUrgentMovement;                          // 0x0428(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CrouchMaxDistance;                                 // 0x0450(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CanCrouchInUrgentMovement;                         // 0x0478(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JumpMaxDistance;                                   // 0x04A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CanJumpInUrgentMovement;                           // 0x04C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JetpackStrafeMaxDistance;                          // 0x04F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AvoidProjectilesReactionDistanceMax;               // 0x0518(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AvoidProjectilesReactionTimeMin;                   // 0x0540(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AvoidProjectilesReactionTimeMax;                   // 0x0568(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AvoidProjectilesEvasiveDistanceMin;                // 0x0590(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AvoidProjectilesEvasiveDistanceMax;                // 0x05B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AvoidPhysicsObjectsReactionDistanceMin;            // 0x05E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AvoidPhysicsObjectsReactionDistanceMax;            // 0x0608(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AvoidPhysicsObjectsSpeedMin;                       // 0x0630(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AvoidPhysicsObjectsSpeedMax;                       // 0x0658(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      CanUseEvasiveManeuversTagQuery;                    // 0x0680(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotEvasiveManeuversSkillSet">();
	}
	static class UFortAthenaAIBotEvasiveManeuversSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotEvasiveManeuversSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotEvasiveManeuversSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotEvasiveManeuversSkillSet");
static_assert(sizeof(UFortAthenaAIBotEvasiveManeuversSkillSet) == 0x0006C8, "Wrong size on UFortAthenaAIBotEvasiveManeuversSkillSet");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, DefaultEvasiveManeuverSkillSettings) == 0x000030, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::DefaultEvasiveManeuverSkillSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, EvasiveManeuverSkillSettingsSpecializations) == 0x000288, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::EvasiveManeuverSkillSettingsSpecializations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeOverlayWeight) == 0x000298, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeOverlayWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeDelay) == 0x0002C0, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeRandomDeviationDelay) == 0x0002E8, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeRandomDeviationDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeDistanceMax) == 0x000310, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeDistanceMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeDistanceMin) == 0x000338, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeDistanceMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeActivationTime) == 0x000360, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeActivationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeActivationTimeRandomDeviation) == 0x000388, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeActivationTimeRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeTime) == 0x0003B0, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeTimeRandomDeviation) == 0x0003D8, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeTimeRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, DodgeMaxDistance) == 0x000400, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::DodgeMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, CanDodgeInUrgentMovement) == 0x000428, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::CanDodgeInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, CrouchMaxDistance) == 0x000450, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::CrouchMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, CanCrouchInUrgentMovement) == 0x000478, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::CanCrouchInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JumpMaxDistance) == 0x0004A0, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JumpMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, CanJumpInUrgentMovement) == 0x0004C8, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::CanJumpInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, JetpackStrafeMaxDistance) == 0x0004F0, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::JetpackStrafeMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, AvoidProjectilesReactionDistanceMax) == 0x000518, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::AvoidProjectilesReactionDistanceMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, AvoidProjectilesReactionTimeMin) == 0x000540, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::AvoidProjectilesReactionTimeMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, AvoidProjectilesReactionTimeMax) == 0x000568, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::AvoidProjectilesReactionTimeMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, AvoidProjectilesEvasiveDistanceMin) == 0x000590, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::AvoidProjectilesEvasiveDistanceMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, AvoidProjectilesEvasiveDistanceMax) == 0x0005B8, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::AvoidProjectilesEvasiveDistanceMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, AvoidPhysicsObjectsReactionDistanceMin) == 0x0005E0, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::AvoidPhysicsObjectsReactionDistanceMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, AvoidPhysicsObjectsReactionDistanceMax) == 0x000608, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::AvoidPhysicsObjectsReactionDistanceMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, AvoidPhysicsObjectsSpeedMin) == 0x000630, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::AvoidPhysicsObjectsSpeedMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, AvoidPhysicsObjectsSpeedMax) == 0x000658, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::AvoidPhysicsObjectsSpeedMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotEvasiveManeuversSkillSet, CanUseEvasiveManeuversTagQuery) == 0x000680, "Member 'UFortAthenaAIBotEvasiveManeuversSkillSet::CanUseEvasiveManeuversTagQuery' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotHarvestSkillSet
// 0x00A0 (0x00D0 - 0x0030)
class UFortAthenaAIBotHarvestSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         DelayBetweenHarvest;                               // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DeviationTimeBetweenHarvest;                       // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HarvestingMaxDistance;                             // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WeakSpotHitProbability;                            // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotHarvestSkillSet">();
	}
	static class UFortAthenaAIBotHarvestSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotHarvestSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotHarvestSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotHarvestSkillSet");
static_assert(sizeof(UFortAthenaAIBotHarvestSkillSet) == 0x0000D0, "Wrong size on UFortAthenaAIBotHarvestSkillSet");
static_assert(offsetof(UFortAthenaAIBotHarvestSkillSet, DelayBetweenHarvest) == 0x000030, "Member 'UFortAthenaAIBotHarvestSkillSet::DelayBetweenHarvest' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHarvestSkillSet, DeviationTimeBetweenHarvest) == 0x000058, "Member 'UFortAthenaAIBotHarvestSkillSet::DeviationTimeBetweenHarvest' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHarvestSkillSet, HarvestingMaxDistance) == 0x000080, "Member 'UFortAthenaAIBotHarvestSkillSet::HarvestingMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHarvestSkillSet, WeakSpotHitProbability) == 0x0000A8, "Member 'UFortAthenaAIBotHarvestSkillSet::WeakSpotHitProbability' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_ModulateVehicleSpeed
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_ModulateVehicleSpeed final : public UBTTaskNode
{
public:
	float                                         NewDrivingSpeed;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_ModulateVehicleSpeed">();
	}
	static class UFortAthenaBTTask_ModulateVehicleSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_ModulateVehicleSpeed>();
	}
};
static_assert(alignof(UFortAthenaBTTask_ModulateVehicleSpeed) == 0x000008, "Wrong alignment on UFortAthenaBTTask_ModulateVehicleSpeed");
static_assert(sizeof(UFortAthenaBTTask_ModulateVehicleSpeed) == 0x000078, "Wrong size on UFortAthenaBTTask_ModulateVehicleSpeed");
static_assert(offsetof(UFortAthenaBTTask_ModulateVehicleSpeed, NewDrivingSpeed) == 0x000070, "Member 'UFortAthenaBTTask_ModulateVehicleSpeed::NewDrivingSpeed' has a wrong offset!");

// Class FortniteAI.FortQueryTwoPointSolver
// 0x0118 (0x0140 - 0x0028)
class UFortQueryTwoPointSolver final : public UObject
{
public:
	class UEnvQuery*                              QueryPointA;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnvQuery*                              QueryPointB;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEnvNamedValue>                 QueryParamsA;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEnvNamedValue>                 QueryParamsB;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FVector& PointA, const struct FVector& PointB)> OnFinished;                                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnFailed;                                          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	ETwoPointSolverRotationA                      RotationMode;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MinRotationOffset;                                 // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               MaxRotationOffset;                                 // 0x0098(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUseNegativeAngleOffsets : 1;                      // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUsePositiveAngleOffsets : 1;                      // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B1[0x7F];                                      // 0x00B1(0x007F)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAISystem*                          AISys;                                             // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                CachedQuerier;                                     // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddNamedFloatParamA(class FName ParamName, float Value);
	void AddNamedFloatParamB(class FName ParamName, float Value);
	void OnCustomRotationMode(const struct FVector& InPointA, const struct FVector& Querier);
	void SetCustomRotationA(const struct FRotator& Rotation);
	void SkipToNextPointA();
	void Start(class UObject* Querier);

	struct FRotator GetRandomRotationOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTwoPointSolver">();
	}
	static class UFortQueryTwoPointSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTwoPointSolver>();
	}
};
static_assert(alignof(UFortQueryTwoPointSolver) == 0x000008, "Wrong alignment on UFortQueryTwoPointSolver");
static_assert(sizeof(UFortQueryTwoPointSolver) == 0x000140, "Wrong size on UFortQueryTwoPointSolver");
static_assert(offsetof(UFortQueryTwoPointSolver, QueryPointA) == 0x000028, "Member 'UFortQueryTwoPointSolver::QueryPointA' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, QueryPointB) == 0x000030, "Member 'UFortQueryTwoPointSolver::QueryPointB' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, QueryParamsA) == 0x000038, "Member 'UFortQueryTwoPointSolver::QueryParamsA' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, QueryParamsB) == 0x000048, "Member 'UFortQueryTwoPointSolver::QueryParamsB' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, OnFinished) == 0x000058, "Member 'UFortQueryTwoPointSolver::OnFinished' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, OnFailed) == 0x000068, "Member 'UFortQueryTwoPointSolver::OnFailed' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, RotationMode) == 0x000078, "Member 'UFortQueryTwoPointSolver::RotationMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, MinRotationOffset) == 0x000080, "Member 'UFortQueryTwoPointSolver::MinRotationOffset' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, MaxRotationOffset) == 0x000098, "Member 'UFortQueryTwoPointSolver::MaxRotationOffset' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, AISys) == 0x000130, "Member 'UFortQueryTwoPointSolver::AISys' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, CachedQuerier) == 0x000138, "Member 'UFortQueryTwoPointSolver::CachedQuerier' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotHealingDigestedSkillSet
// 0x0040 (0x0070 - 0x0030)
class UFortAthenaAIBotHealingDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	struct FFortBotDigestedHealingItemsList       HealthItemsList;                                   // 0x0030(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortBotDigestedHealingItemsSpec> HealthItemsSpecializations;                        // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FFortBotDigestedHealingItemsList       ShieldItemsList;                                   // 0x0050(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortBotDigestedHealingItemsSpec> ShieldItemsSpecializations;                        // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotHealingDigestedSkillSet">();
	}
	static class UFortAthenaAIBotHealingDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotHealingDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotHealingDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotHealingDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotHealingDigestedSkillSet) == 0x000070, "Wrong size on UFortAthenaAIBotHealingDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotHealingDigestedSkillSet, HealthItemsList) == 0x000030, "Member 'UFortAthenaAIBotHealingDigestedSkillSet::HealthItemsList' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHealingDigestedSkillSet, HealthItemsSpecializations) == 0x000040, "Member 'UFortAthenaAIBotHealingDigestedSkillSet::HealthItemsSpecializations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHealingDigestedSkillSet, ShieldItemsList) == 0x000050, "Member 'UFortAthenaAIBotHealingDigestedSkillSet::ShieldItemsList' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHealingDigestedSkillSet, ShieldItemsSpecializations) == 0x000060, "Member 'UFortAthenaAIBotHealingDigestedSkillSet::ShieldItemsSpecializations' has a wrong offset!");

// Class FortniteAI.FortQueryTest_PrimaryAssignment
// 0x0120 (0x0340 - 0x0220)
class UFortQueryTest_PrimaryAssignment final : public UFortQueryTest_GoalBase
{
public:
	bool                                          bUseItemActorLocation;                             // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              DistanceClose;                                     // 0x0228(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              DistanceFar;                                       // 0x0260(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              PercentValueClose;                                 // 0x0298(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              PercentValueRegular;                               // 0x02D0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              PercentValueFar;                                   // 0x0308(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PrimaryAssignment">();
	}
	static class UFortQueryTest_PrimaryAssignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PrimaryAssignment>();
	}
};
static_assert(alignof(UFortQueryTest_PrimaryAssignment) == 0x000008, "Wrong alignment on UFortQueryTest_PrimaryAssignment");
static_assert(sizeof(UFortQueryTest_PrimaryAssignment) == 0x000340, "Wrong size on UFortQueryTest_PrimaryAssignment");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, bUseItemActorLocation) == 0x000220, "Member 'UFortQueryTest_PrimaryAssignment::bUseItemActorLocation' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, DistanceClose) == 0x000228, "Member 'UFortQueryTest_PrimaryAssignment::DistanceClose' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, DistanceFar) == 0x000260, "Member 'UFortQueryTest_PrimaryAssignment::DistanceFar' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueClose) == 0x000298, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueClose' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueRegular) == 0x0002D0, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueRegular' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueFar) == 0x000308, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueFar' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotHealingSkillSet
// 0x0040 (0x0070 - 0x0030)
class UFortAthenaAIBotHealingSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FFortBotHealingItemsList               HealthItemsList;                                   // 0x0030(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortBotHealingItemsSpec>       HealthItemsSpecializations;                        // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFortBotHealingItemsList               ShieldItemsList;                                   // 0x0050(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortBotHealingItemsSpec>       ShieldItemsSpecializations;                        // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotHealingSkillSet">();
	}
	static class UFortAthenaAIBotHealingSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotHealingSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotHealingSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotHealingSkillSet");
static_assert(sizeof(UFortAthenaAIBotHealingSkillSet) == 0x000070, "Wrong size on UFortAthenaAIBotHealingSkillSet");
static_assert(offsetof(UFortAthenaAIBotHealingSkillSet, HealthItemsList) == 0x000030, "Member 'UFortAthenaAIBotHealingSkillSet::HealthItemsList' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHealingSkillSet, HealthItemsSpecializations) == 0x000040, "Member 'UFortAthenaAIBotHealingSkillSet::HealthItemsSpecializations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHealingSkillSet, ShieldItemsList) == 0x000050, "Member 'UFortAthenaAIBotHealingSkillSet::ShieldItemsList' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotHealingSkillSet, ShieldItemsSpecializations) == 0x000060, "Member 'UFortAthenaAIBotHealingSkillSet::ShieldItemsSpecializations' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotInventoryItems
// 0x0010 (0x0038 - 0x0028)
class UFortAthenaAIBotInventoryItems final : public UObject
{
public:
	TArray<struct FItemAndCount>                  Items;                                             // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotInventoryItems">();
	}
	static class UFortAthenaAIBotInventoryItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotInventoryItems>();
	}
};
static_assert(alignof(UFortAthenaAIBotInventoryItems) == 0x000008, "Wrong alignment on UFortAthenaAIBotInventoryItems");
static_assert(sizeof(UFortAthenaAIBotInventoryItems) == 0x000038, "Wrong size on UFortAthenaAIBotInventoryItems");
static_assert(offsetof(UFortAthenaAIBotInventoryItems, Items) == 0x000028, "Member 'UFortAthenaAIBotInventoryItems::Items' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_ShootTrap
// 0x0030 (0x00A8 - 0x0078)
class UFortAthenaBTTask_ShootTrap final : public UBTTask_Wait
{
public:
	struct FBlackboardKeySelector                 TargetActorKey;                                    // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class FName                                   TrapOnPathKeyName;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_ShootTrap">();
	}
	static class UFortAthenaBTTask_ShootTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_ShootTrap>();
	}
};
static_assert(alignof(UFortAthenaBTTask_ShootTrap) == 0x000008, "Wrong alignment on UFortAthenaBTTask_ShootTrap");
static_assert(sizeof(UFortAthenaBTTask_ShootTrap) == 0x0000A8, "Wrong size on UFortAthenaBTTask_ShootTrap");
static_assert(offsetof(UFortAthenaBTTask_ShootTrap, TargetActorKey) == 0x000078, "Member 'UFortAthenaBTTask_ShootTrap::TargetActorKey' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_ShootTrap, TrapOnPathKeyName) == 0x0000A0, "Member 'UFortAthenaBTTask_ShootTrap::TrapOnPathKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotInventoryDigestedSkillSet
// 0x0168 (0x0198 - 0x0030)
class UFortAthenaAIBotInventoryDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         DefaultWeaponSelectionDistance;                    // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultWeaponSelectionDistanceDeviation;           // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasInfiniteResources;                             // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasInfiniteAmmoForAllWeapons;                     // 0x0039(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  InventorySlotPreference[0x6];                      // 0x0040(0x0020)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDigestedBotEquipWeaponInfo>    EquipWeaponInfo;                                   // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  InfiniteAmmoCheats;                                // 0x0110(0x0020)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FItemAndCount>                  MaterialItems;                                     // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         GiveMaterialsToBotFrequency;                       // 0x0140(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CheckLoadedAmmoForInfiniteAmmoCheats;              // 0x0148(0x0020)(Transient, NativeAccessSpecifierPrivate)
	float                                         NoWeaponGiveWeaponAfterTime;                       // 0x0168(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NoWeaponNoPlayerConeDistance;                      // 0x016C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NoWeaponNoPlayerConeFOV;                           // 0x0170(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   NoWeaponLootTierGroup;                             // 0x0174(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  IgnoredAsWeaponTags;                               // 0x0178(0x0020)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotInventoryDigestedSkillSet">();
	}
	static class UFortAthenaAIBotInventoryDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotInventoryDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotInventoryDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotInventoryDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotInventoryDigestedSkillSet) == 0x000198, "Wrong size on UFortAthenaAIBotInventoryDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, DefaultWeaponSelectionDistance) == 0x000030, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::DefaultWeaponSelectionDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, DefaultWeaponSelectionDistanceDeviation) == 0x000034, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::DefaultWeaponSelectionDistanceDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, bHasInfiniteResources) == 0x000038, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::bHasInfiniteResources' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, bHasInfiniteAmmoForAllWeapons) == 0x000039, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::bHasInfiniteAmmoForAllWeapons' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, InventorySlotPreference) == 0x000040, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::InventorySlotPreference' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, EquipWeaponInfo) == 0x000100, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::EquipWeaponInfo' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, InfiniteAmmoCheats) == 0x000110, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::InfiniteAmmoCheats' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, MaterialItems) == 0x000130, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::MaterialItems' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, GiveMaterialsToBotFrequency) == 0x000140, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::GiveMaterialsToBotFrequency' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, CheckLoadedAmmoForInfiniteAmmoCheats) == 0x000148, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::CheckLoadedAmmoForInfiniteAmmoCheats' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, NoWeaponGiveWeaponAfterTime) == 0x000168, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::NoWeaponGiveWeaponAfterTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, NoWeaponNoPlayerConeDistance) == 0x00016C, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::NoWeaponNoPlayerConeDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, NoWeaponNoPlayerConeFOV) == 0x000170, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::NoWeaponNoPlayerConeFOV' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, NoWeaponLootTierGroup) == 0x000174, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::NoWeaponLootTierGroup' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventoryDigestedSkillSet, IgnoredAsWeaponTags) == 0x000178, "Member 'UFortAthenaAIBotInventoryDigestedSkillSet::IgnoredAsWeaponTags' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotInventorySkillSet
// 0x0258 (0x0288 - 0x0030)
class UFortAthenaAIBotInventorySkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         DefaultWeaponSelectionDistance;                    // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DefaultWeaponSelectionDistanceDeviation;           // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HasInfiniteResources;                              // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  InventorySlotPreference[0x6];                      // 0x00A8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBotEquipWeaponInfo>            EquipWeaponInfo;                                   // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HasInfiniteAmmoForAllWeapons;                      // 0x0178(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeaponAmmoCheat>               AmmoCheats;                                        // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FItemAndCount>                  MaterialItems;                                     // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         GiveMaterialsToBotFrequency;                       // 0x01C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         NoWeaponGiveWeaponAfterTime;                       // 0x01E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         NoWeaponNoPlayerConeDistance;                      // 0x0210(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         NoWeaponNoPlayerConeFOV;                           // 0x0238(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   NoWeaponLootTierGroup;                             // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoredAsWeaponTags;                               // 0x0268(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotInventorySkillSet">();
	}
	static class UFortAthenaAIBotInventorySkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotInventorySkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotInventorySkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotInventorySkillSet");
static_assert(sizeof(UFortAthenaAIBotInventorySkillSet) == 0x000288, "Wrong size on UFortAthenaAIBotInventorySkillSet");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, DefaultWeaponSelectionDistance) == 0x000030, "Member 'UFortAthenaAIBotInventorySkillSet::DefaultWeaponSelectionDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, DefaultWeaponSelectionDistanceDeviation) == 0x000058, "Member 'UFortAthenaAIBotInventorySkillSet::DefaultWeaponSelectionDistanceDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, HasInfiniteResources) == 0x000080, "Member 'UFortAthenaAIBotInventorySkillSet::HasInfiniteResources' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, InventorySlotPreference) == 0x0000A8, "Member 'UFortAthenaAIBotInventorySkillSet::InventorySlotPreference' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, EquipWeaponInfo) == 0x000168, "Member 'UFortAthenaAIBotInventorySkillSet::EquipWeaponInfo' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, HasInfiniteAmmoForAllWeapons) == 0x000178, "Member 'UFortAthenaAIBotInventorySkillSet::HasInfiniteAmmoForAllWeapons' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, AmmoCheats) == 0x0001A0, "Member 'UFortAthenaAIBotInventorySkillSet::AmmoCheats' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, MaterialItems) == 0x0001B0, "Member 'UFortAthenaAIBotInventorySkillSet::MaterialItems' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, GiveMaterialsToBotFrequency) == 0x0001C0, "Member 'UFortAthenaAIBotInventorySkillSet::GiveMaterialsToBotFrequency' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, NoWeaponGiveWeaponAfterTime) == 0x0001E8, "Member 'UFortAthenaAIBotInventorySkillSet::NoWeaponGiveWeaponAfterTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, NoWeaponNoPlayerConeDistance) == 0x000210, "Member 'UFortAthenaAIBotInventorySkillSet::NoWeaponNoPlayerConeDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, NoWeaponNoPlayerConeFOV) == 0x000238, "Member 'UFortAthenaAIBotInventorySkillSet::NoWeaponNoPlayerConeFOV' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, NoWeaponLootTierGroup) == 0x000260, "Member 'UFortAthenaAIBotInventorySkillSet::NoWeaponLootTierGroup' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotInventorySkillSet, IgnoredAsWeaponTags) == 0x000268, "Member 'UFortAthenaAIBotInventorySkillSet::IgnoredAsWeaponTags' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotLootingDigestedSkillSet
// 0x0080 (0x00B0 - 0x0030)
class UFortAthenaAIBotLootingDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         ThresholdDistanceToSwitchLootItem;                 // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThresholdDistanceSquaredToRescanForBetterLoot;     // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThresholdTimeToRescanForBetterLoot;                // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OctreeBoxHalfExtent;                               // 0x0040(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LootStateEvaluationRadiusSq;                       // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinLootDurationPerPOI;                             // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLootDurationPerPOI;                             // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LootPickupInteractionTime;                         // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LootPickupInteractionDeviationTime;                // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance2DScore;                                   // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeightScore;                                       // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThreatMaxScore;                                    // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThreatProximityScoreTable;                         // 0x0078(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         PrioritizeWeaponScore;                             // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PoiSelectionDistanceScore;                         // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PoiSelectionBotPresenceScore;                      // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotLootingDigestedSkillSet">();
	}
	static class UFortAthenaAIBotLootingDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotLootingDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotLootingDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotLootingDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotLootingDigestedSkillSet) == 0x0000B0, "Wrong size on UFortAthenaAIBotLootingDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, ThresholdDistanceToSwitchLootItem) == 0x000030, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::ThresholdDistanceToSwitchLootItem' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, ThresholdDistanceSquaredToRescanForBetterLoot) == 0x000034, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::ThresholdDistanceSquaredToRescanForBetterLoot' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, ThresholdTimeToRescanForBetterLoot) == 0x000038, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::ThresholdTimeToRescanForBetterLoot' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, OctreeBoxHalfExtent) == 0x000040, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::OctreeBoxHalfExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, LootStateEvaluationRadiusSq) == 0x000058, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::LootStateEvaluationRadiusSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, MinLootDurationPerPOI) == 0x00005C, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::MinLootDurationPerPOI' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, MaxLootDurationPerPOI) == 0x000060, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::MaxLootDurationPerPOI' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, LootPickupInteractionTime) == 0x000064, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::LootPickupInteractionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, LootPickupInteractionDeviationTime) == 0x000068, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::LootPickupInteractionDeviationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, Distance2DScore) == 0x00006C, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::Distance2DScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, HeightScore) == 0x000070, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::HeightScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, ThreatMaxScore) == 0x000074, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::ThreatMaxScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, ThreatProximityScoreTable) == 0x000078, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::ThreatProximityScoreTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, PrioritizeWeaponScore) == 0x0000A0, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::PrioritizeWeaponScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, PoiSelectionDistanceScore) == 0x0000A4, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::PoiSelectionDistanceScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingDigestedSkillSet, PoiSelectionBotPresenceScore) == 0x0000A8, "Member 'UFortAthenaAIBotLootingDigestedSkillSet::PoiSelectionBotPresenceScore' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotLootingSkillSet
// 0x0270 (0x02A0 - 0x0030)
class UFortAthenaAIBotLootingSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         ThresholdDistanceToSwitchLootItem;                 // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThresholdDistanceToRescanForBetterLoot;            // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThresholdTimeToRescanForBetterLoot;                // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                OctreeBoxExtent;                                   // 0x00A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LootStateEvaluationRadius;                         // 0x00C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinLootDurationPerPOI;                             // 0x00E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxLootDurationPerPOI;                             // 0x0110(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LootPickupInteractionTime;                         // 0x0138(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LootPickupInteractionDeviationTime;                // 0x0160(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         Distance2DScore;                                   // 0x0188(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HeightScore;                                       // 0x01B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThreatMaxScore;                                    // 0x01D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThreatProximityScoreTable;                         // 0x0200(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PrioritizeWeaponScore;                             // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PoiSelectionDistanceScore;                         // 0x0250(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PoiSelectionBotPresenceScore;                      // 0x0278(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotLootingSkillSet">();
	}
	static class UFortAthenaAIBotLootingSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotLootingSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotLootingSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotLootingSkillSet");
static_assert(sizeof(UFortAthenaAIBotLootingSkillSet) == 0x0002A0, "Wrong size on UFortAthenaAIBotLootingSkillSet");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, ThresholdDistanceToSwitchLootItem) == 0x000030, "Member 'UFortAthenaAIBotLootingSkillSet::ThresholdDistanceToSwitchLootItem' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, ThresholdDistanceToRescanForBetterLoot) == 0x000058, "Member 'UFortAthenaAIBotLootingSkillSet::ThresholdDistanceToRescanForBetterLoot' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, ThresholdTimeToRescanForBetterLoot) == 0x000080, "Member 'UFortAthenaAIBotLootingSkillSet::ThresholdTimeToRescanForBetterLoot' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, OctreeBoxExtent) == 0x0000A8, "Member 'UFortAthenaAIBotLootingSkillSet::OctreeBoxExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, LootStateEvaluationRadius) == 0x0000C0, "Member 'UFortAthenaAIBotLootingSkillSet::LootStateEvaluationRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, MinLootDurationPerPOI) == 0x0000E8, "Member 'UFortAthenaAIBotLootingSkillSet::MinLootDurationPerPOI' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, MaxLootDurationPerPOI) == 0x000110, "Member 'UFortAthenaAIBotLootingSkillSet::MaxLootDurationPerPOI' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, LootPickupInteractionTime) == 0x000138, "Member 'UFortAthenaAIBotLootingSkillSet::LootPickupInteractionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, LootPickupInteractionDeviationTime) == 0x000160, "Member 'UFortAthenaAIBotLootingSkillSet::LootPickupInteractionDeviationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, Distance2DScore) == 0x000188, "Member 'UFortAthenaAIBotLootingSkillSet::Distance2DScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, HeightScore) == 0x0001B0, "Member 'UFortAthenaAIBotLootingSkillSet::HeightScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, ThreatMaxScore) == 0x0001D8, "Member 'UFortAthenaAIBotLootingSkillSet::ThreatMaxScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, ThreatProximityScoreTable) == 0x000200, "Member 'UFortAthenaAIBotLootingSkillSet::ThreatProximityScoreTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, PrioritizeWeaponScore) == 0x000228, "Member 'UFortAthenaAIBotLootingSkillSet::PrioritizeWeaponScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, PoiSelectionDistanceScore) == 0x000250, "Member 'UFortAthenaAIBotLootingSkillSet::PoiSelectionDistanceScore' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotLootingSkillSet, PoiSelectionBotPresenceScore) == 0x000278, "Member 'UFortAthenaAIBotLootingSkillSet::PoiSelectionBotPresenceScore' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotMovementDigestedSkillSet
// 0x01D8 (0x0208 - 0x0030)
class UFortAthenaAIBotMovementDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         SlowDownDistanceSquared;                           // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraversalSpeedEstimation;                          // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraversalSpeedEstimationWithThreat;                // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GliderDeployMinAngle;                              // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GliderDeployMaxAngle;                              // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GliderNoiseMinDistance;                            // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GliderNoiseMaxDistance;                            // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GliderNoiseMinDelay;                               // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GliderNoiseMaxDelay;                               // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GliderNoiseDistanceTreshold;                       // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GliderStopRotationDistance;                        // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpOffMinAngle;                                   // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpOffMaxAngle;                                   // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPatrolDistance;                                 // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPatrolDistanceRandomDeviation;                  // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WobbleProbability;                                 // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDelayBetweenWobblingMovement;                   // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDelayBetweenWobblingMovementRandomDeviation;    // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowSwimWobble;                                  // 0x0078(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxWobblingDuration;                               // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWobblingDurationRandomDeviation;                // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWobblingIntensity;                              // 0x0084(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WobblingIntensityDeviation;                        // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWobblingFrequency;                              // 0x008C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WobblingFrequencyDeviation;                        // 0x0090(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WobblingStickToPathCorridorStrength;               // 0x0094(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAfterLaunchedPauseTime;                         // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAfterLaunchedFromVortexPauseTime;               // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AfterLaunchedPauseTimeDeviation;                   // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSteerMovementWhenLaunched;                        // 0x00A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SteerMovementWhenLaunchedDirectionUpdateTime;      // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxReactionTimeToDangerZone;                       // 0x00AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxReactionTimeToDangerZoneDeviation;              // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitBlockingObstacleAngle;                       // 0x00B4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableSwimSprintJump;                             // 0x00B5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwimSprintJumpDelay;                               // 0x00B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwimSprintJumpDelayDeviation;                      // 0x00BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwimUnblockJumpHeightThreshold;                    // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwimSprintJumpNav2D;                              // 0x00C4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TacticalSprintEvaluationMinTime;                   // 0x00C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintEvaluationMaxTime;                   // 0x00CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintMinTriggerChance;                    // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintMaxTriggerChance;                    // 0x00D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintMinTriggerChanceInUrgentMovement;    // 0x00D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintMaxTriggerChanceInUrgentMovement;    // 0x00DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintMaxSlopeAngle;                       // 0x00E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintMinPathTargetDistance;               // 0x00E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintMaxPathAlignmentAngle;               // 0x00E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintMaxPathConeAngle;                    // 0x00EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TacticalSprintPathConeRearOffset;                  // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TacticalSprintUsageEnabled;                        // 0x00F4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlidingBoxExtent;                                  // 0x00F8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingEnabled[0x4];                               // 0x0110(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingEvaluationMinTime;                          // 0x0120(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingEvaluationMaxTime;                          // 0x0124(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingMinTriggerChance;                           // 0x0128(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingMaxTriggerChance;                           // 0x012C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingDuringUrgentMovementMinTriggerChance;       // 0x0130(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingDuringUrgentMovementMaxTriggerChance;       // 0x0134(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSlidingSlopeAngle;                              // 0x0138(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSlidingDuration;                                // 0x013C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingCooldownMinTime;                            // 0x0140(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingCooldownMaxTime;                            // 0x0144(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingStopMinDelay;                               // 0x0148(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingStopMaxDelay;                               // 0x014C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveToRangeAttackMinOffset;                        // 0x0150(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveToRangeAttackMaxOffset;                        // 0x0154(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LKPMinOffset;                                      // 0x0158(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LKPMaxOffset;                                      // 0x015C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SandTunnelJumpMinTime;                             // 0x0160(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SandTunnelJumpMaxTime;                             // 0x0164(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SandTunnelBurrowedAndHiddenChance;                 // 0x0168(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SandTunnelBurrowedAndHiddenMinTime;                // 0x016C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SandTunnelBurrowedAndHiddenMaxTime;                // 0x0170(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ZiplineOctreeBoxExtent;                            // 0x0178(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThresholdDistanceToRescanForZiplines;              // 0x0190(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownBetweenZiplineUsages;                      // 0x0194(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToAddToZiplineStartPosition;               // 0x0198(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadiusFromZiplineEnterPointToLookAtExit;           // 0x019C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ZiplineUsageEnabled;                               // 0x01A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDigestedBotKnockbackSettings          DefaultKnockbackSettings;                          // 0x01A8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDigestedBotKnockbackSettings>  KnockbackSettingsSpecializations;                  // 0x01F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotMovementDigestedSkillSet">();
	}
	static class UFortAthenaAIBotMovementDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotMovementDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotMovementDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotMovementDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotMovementDigestedSkillSet) == 0x000208, "Wrong size on UFortAthenaAIBotMovementDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlowDownDistanceSquared) == 0x000030, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlowDownDistanceSquared' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TraversalSpeedEstimation) == 0x000034, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TraversalSpeedEstimation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TraversalSpeedEstimationWithThreat) == 0x000038, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TraversalSpeedEstimationWithThreat' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, GliderDeployMinAngle) == 0x00003C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::GliderDeployMinAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, GliderDeployMaxAngle) == 0x000040, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::GliderDeployMaxAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, GliderNoiseMinDistance) == 0x000044, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::GliderNoiseMinDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, GliderNoiseMaxDistance) == 0x000048, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::GliderNoiseMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, GliderNoiseMinDelay) == 0x00004C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::GliderNoiseMinDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, GliderNoiseMaxDelay) == 0x000050, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::GliderNoiseMaxDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, GliderNoiseDistanceTreshold) == 0x000054, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::GliderNoiseDistanceTreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, GliderStopRotationDistance) == 0x000058, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::GliderStopRotationDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, JumpOffMinAngle) == 0x00005C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::JumpOffMinAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, JumpOffMaxAngle) == 0x000060, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::JumpOffMaxAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxPatrolDistance) == 0x000064, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxPatrolDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxPatrolDistanceRandomDeviation) == 0x000068, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxPatrolDistanceRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, WobbleProbability) == 0x00006C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::WobbleProbability' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxDelayBetweenWobblingMovement) == 0x000070, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxDelayBetweenWobblingMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxDelayBetweenWobblingMovementRandomDeviation) == 0x000074, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxDelayBetweenWobblingMovementRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, bAllowSwimWobble) == 0x000078, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::bAllowSwimWobble' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxWobblingDuration) == 0x00007C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxWobblingDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxWobblingDurationRandomDeviation) == 0x000080, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxWobblingDurationRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxWobblingIntensity) == 0x000084, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxWobblingIntensity' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, WobblingIntensityDeviation) == 0x000088, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::WobblingIntensityDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxWobblingFrequency) == 0x00008C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxWobblingFrequency' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, WobblingFrequencyDeviation) == 0x000090, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::WobblingFrequencyDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, WobblingStickToPathCorridorStrength) == 0x000094, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::WobblingStickToPathCorridorStrength' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxAfterLaunchedPauseTime) == 0x000098, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxAfterLaunchedPauseTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxAfterLaunchedFromVortexPauseTime) == 0x00009C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxAfterLaunchedFromVortexPauseTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, AfterLaunchedPauseTimeDeviation) == 0x0000A0, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::AfterLaunchedPauseTimeDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, bSteerMovementWhenLaunched) == 0x0000A4, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::bSteerMovementWhenLaunched' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SteerMovementWhenLaunchedDirectionUpdateTime) == 0x0000A8, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SteerMovementWhenLaunchedDirectionUpdateTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxReactionTimeToDangerZone) == 0x0000AC, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxReactionTimeToDangerZone' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MaxReactionTimeToDangerZoneDeviation) == 0x0000B0, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MaxReactionTimeToDangerZoneDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, bLimitBlockingObstacleAngle) == 0x0000B4, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::bLimitBlockingObstacleAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, bEnableSwimSprintJump) == 0x0000B5, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::bEnableSwimSprintJump' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SwimSprintJumpDelay) == 0x0000B8, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SwimSprintJumpDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SwimSprintJumpDelayDeviation) == 0x0000BC, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SwimSprintJumpDelayDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SwimUnblockJumpHeightThreshold) == 0x0000C0, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SwimUnblockJumpHeightThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, bSwimSprintJumpNav2D) == 0x0000C4, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::bSwimSprintJumpNav2D' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintEvaluationMinTime) == 0x0000C8, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintEvaluationMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintEvaluationMaxTime) == 0x0000CC, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintEvaluationMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintMinTriggerChance) == 0x0000D0, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintMinTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintMaxTriggerChance) == 0x0000D4, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintMaxTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintMinTriggerChanceInUrgentMovement) == 0x0000D8, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintMinTriggerChanceInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintMaxTriggerChanceInUrgentMovement) == 0x0000DC, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintMaxTriggerChanceInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintMaxSlopeAngle) == 0x0000E0, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintMaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintMinPathTargetDistance) == 0x0000E4, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintMinPathTargetDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintMaxPathAlignmentAngle) == 0x0000E8, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintMaxPathAlignmentAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintMaxPathConeAngle) == 0x0000EC, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintMaxPathConeAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintPathConeRearOffset) == 0x0000F0, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintPathConeRearOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, TacticalSprintUsageEnabled) == 0x0000F4, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::TacticalSprintUsageEnabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingBoxExtent) == 0x0000F8, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingBoxExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingEnabled) == 0x000110, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingEnabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingEvaluationMinTime) == 0x000120, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingEvaluationMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingEvaluationMaxTime) == 0x000124, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingEvaluationMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingMinTriggerChance) == 0x000128, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingMinTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingMaxTriggerChance) == 0x00012C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingMaxTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingDuringUrgentMovementMinTriggerChance) == 0x000130, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingDuringUrgentMovementMinTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingDuringUrgentMovementMaxTriggerChance) == 0x000134, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingDuringUrgentMovementMaxTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MinSlidingSlopeAngle) == 0x000138, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MinSlidingSlopeAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MinSlidingDuration) == 0x00013C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MinSlidingDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingCooldownMinTime) == 0x000140, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingCooldownMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingCooldownMaxTime) == 0x000144, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingCooldownMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingStopMinDelay) == 0x000148, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingStopMinDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SlidingStopMaxDelay) == 0x00014C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SlidingStopMaxDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MoveToRangeAttackMinOffset) == 0x000150, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MoveToRangeAttackMinOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, MoveToRangeAttackMaxOffset) == 0x000154, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::MoveToRangeAttackMaxOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, LKPMinOffset) == 0x000158, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::LKPMinOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, LKPMaxOffset) == 0x00015C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::LKPMaxOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SandTunnelJumpMinTime) == 0x000160, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SandTunnelJumpMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SandTunnelJumpMaxTime) == 0x000164, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SandTunnelJumpMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SandTunnelBurrowedAndHiddenChance) == 0x000168, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SandTunnelBurrowedAndHiddenChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SandTunnelBurrowedAndHiddenMinTime) == 0x00016C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SandTunnelBurrowedAndHiddenMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, SandTunnelBurrowedAndHiddenMaxTime) == 0x000170, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::SandTunnelBurrowedAndHiddenMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, ZiplineOctreeBoxExtent) == 0x000178, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::ZiplineOctreeBoxExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, ThresholdDistanceToRescanForZiplines) == 0x000190, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::ThresholdDistanceToRescanForZiplines' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, CooldownBetweenZiplineUsages) == 0x000194, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::CooldownBetweenZiplineUsages' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, DistanceToAddToZiplineStartPosition) == 0x000198, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::DistanceToAddToZiplineStartPosition' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, RadiusFromZiplineEnterPointToLookAtExit) == 0x00019C, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::RadiusFromZiplineEnterPointToLookAtExit' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, ZiplineUsageEnabled) == 0x0001A0, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::ZiplineUsageEnabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, DefaultKnockbackSettings) == 0x0001A8, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::DefaultKnockbackSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementDigestedSkillSet, KnockbackSettingsSpecializations) == 0x0001F8, "Member 'UFortAthenaAIBotMovementDigestedSkillSet::KnockbackSettingsSpecializations' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotMovementSkillSet
// 0x0CE8 (0x0D18 - 0x0030)
class UFortAthenaAIBotMovementSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         SlowDownDistance;                                  // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TraversalSpeedEstimation;                          // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TraversalSpeedEstimationWithThreat;                // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         GliderDeployMinAngle;                              // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         GliderDeployMaxAngle;                              // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         GliderNoiseMinDistance;                            // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         GliderNoiseMaxDistance;                            // 0x0120(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         GliderNoiseMinDelay;                               // 0x0148(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         GliderNoiseMaxDelay;                               // 0x0170(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         GliderNoiseDistanceTreshold;                       // 0x0198(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         GliderStopRotationDistance;                        // 0x01C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JumpOffMinAngle;                                   // 0x01E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         JumpOffMaxAngle;                                   // 0x0210(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxPatrolDistance;                                 // 0x0238(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxPatrolDistanceRandomDeviation;                  // 0x0260(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MoveToRangeAttackMinOffset;                        // 0x0288(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MoveToRangeAttackMaxOffset;                        // 0x02B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LKPMinOffset;                                      // 0x02D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LKPMaxOffset;                                      // 0x0300(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SandTunnelJumpMinTime;                             // 0x0328(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SandTunnelJumpMaxTime;                             // 0x0350(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SandTunnelBurrowedAndHiddenChance;                 // 0x0378(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SandTunnelBurrowedAndHiddenMinTime;                // 0x03A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SandTunnelBurrowedAndHiddenMaxTime;                // 0x03C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WobblingProbability;                               // 0x03F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxDelayBetweenWobblingMovement;                   // 0x0418(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxDelayBetweenWobblingMovementRandomDeviation;    // 0x0440(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxWobblingDuration;                               // 0x0468(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxWobblingDurationRandomDeviation;                // 0x0490(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxWobblingIntensity;                              // 0x04B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WobblingIntensityDeviation;                        // 0x04E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxWobblingFrequency;                              // 0x0508(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WobblingFrequencyDeviation;                        // 0x0530(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WobblingStickToPathCorridorStrength;               // 0x0558(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LimitBlockingObstacleAngle;                        // 0x0580(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxAfterLaunchedPauseTime;                         // 0x05A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxAfterLaunchedFromVortexPauseTime;               // 0x05D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AfterLaunchedPauseTimeDeviation;                   // 0x05F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SteerMovementWhenLaunched;                         // 0x0620(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SteerMovementWhenLaunchedDirectionUpdateTime;      // 0x0648(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxReactionTimeToDangerZone;                       // 0x0670(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxReactionTimeToDangerZoneDeviation;              // 0x0698(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AllowSwimWobble;                                   // 0x06C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         EnableSwimSprintJump;                              // 0x06E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SwimSprintJumpDelay;                               // 0x0710(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SwimSprintJumpDelayDeviation;                      // 0x0738(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SwimUnblockJumpHeightThreshold;                    // 0x0760(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SwimSprintJumpNav2D;                               // 0x0788(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintEvaluationMinTime;                   // 0x07B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintEvaluationMaxTime;                   // 0x07D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintMinTriggerChance;                    // 0x0800(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintMaxTriggerChance;                    // 0x0828(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintMinTriggerChanceInUrgentMovement;    // 0x0850(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintMaxTriggerChanceInUrgentMovement;    // 0x0878(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintMaxSlopeAngle;                       // 0x08A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintMinPathTargetDistance;               // 0x08C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintMaxPathAlignmentAngle;               // 0x08F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintMaxPathConeAngle;                    // 0x0918(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintPathConeRearOffset;                  // 0x0940(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TacticalSprintUsageEnabled;                        // 0x0968(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                SlidingBoxExtent;                                  // 0x0990(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingEnabled[0x4];                               // 0x09A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingEvaluationMinTime;                          // 0x0A48(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingEvaluationMaxTime;                          // 0x0A70(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingMinTriggerChance;                           // 0x0A98(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingMaxTriggerChance;                           // 0x0AC0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingDuringUrgentMovementMinTriggerChance;       // 0x0AE8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingDuringUrgentMovementMaxTriggerChance;       // 0x0B10(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingSlopeMinAngle;                              // 0x0B38(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinSlidingDuration;                                // 0x0B60(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingCooldownMinTime;                            // 0x0B88(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingCooldownMaxTime;                            // 0x0BB0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingStopMinDelay;                               // 0x0BD8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SlidingStopMaxDelay;                               // 0x0C00(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                ZiplineOctreeBoxExtent;                            // 0x0C28(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThresholdDistanceToRescanForZiplines;              // 0x0C40(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CooldownBetweenZiplineUsages;                      // 0x0C68(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DistanceToAddToZiplineStartPosition;               // 0x0C90(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RadiusFromZiplineEnterPointToLookAtExit;           // 0x0CB8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ZiplineUsageEnabled;                               // 0x0CE0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBotKnockbackSettings>          KnockbackSettings;                                 // 0x0D08(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotMovementSkillSet">();
	}
	static class UFortAthenaAIBotMovementSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotMovementSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotMovementSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotMovementSkillSet");
static_assert(sizeof(UFortAthenaAIBotMovementSkillSet) == 0x000D18, "Wrong size on UFortAthenaAIBotMovementSkillSet");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlowDownDistance) == 0x000030, "Member 'UFortAthenaAIBotMovementSkillSet::SlowDownDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TraversalSpeedEstimation) == 0x000058, "Member 'UFortAthenaAIBotMovementSkillSet::TraversalSpeedEstimation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TraversalSpeedEstimationWithThreat) == 0x000080, "Member 'UFortAthenaAIBotMovementSkillSet::TraversalSpeedEstimationWithThreat' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, GliderDeployMinAngle) == 0x0000A8, "Member 'UFortAthenaAIBotMovementSkillSet::GliderDeployMinAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, GliderDeployMaxAngle) == 0x0000D0, "Member 'UFortAthenaAIBotMovementSkillSet::GliderDeployMaxAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, GliderNoiseMinDistance) == 0x0000F8, "Member 'UFortAthenaAIBotMovementSkillSet::GliderNoiseMinDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, GliderNoiseMaxDistance) == 0x000120, "Member 'UFortAthenaAIBotMovementSkillSet::GliderNoiseMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, GliderNoiseMinDelay) == 0x000148, "Member 'UFortAthenaAIBotMovementSkillSet::GliderNoiseMinDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, GliderNoiseMaxDelay) == 0x000170, "Member 'UFortAthenaAIBotMovementSkillSet::GliderNoiseMaxDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, GliderNoiseDistanceTreshold) == 0x000198, "Member 'UFortAthenaAIBotMovementSkillSet::GliderNoiseDistanceTreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, GliderStopRotationDistance) == 0x0001C0, "Member 'UFortAthenaAIBotMovementSkillSet::GliderStopRotationDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, JumpOffMinAngle) == 0x0001E8, "Member 'UFortAthenaAIBotMovementSkillSet::JumpOffMinAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, JumpOffMaxAngle) == 0x000210, "Member 'UFortAthenaAIBotMovementSkillSet::JumpOffMaxAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxPatrolDistance) == 0x000238, "Member 'UFortAthenaAIBotMovementSkillSet::MaxPatrolDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxPatrolDistanceRandomDeviation) == 0x000260, "Member 'UFortAthenaAIBotMovementSkillSet::MaxPatrolDistanceRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MoveToRangeAttackMinOffset) == 0x000288, "Member 'UFortAthenaAIBotMovementSkillSet::MoveToRangeAttackMinOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MoveToRangeAttackMaxOffset) == 0x0002B0, "Member 'UFortAthenaAIBotMovementSkillSet::MoveToRangeAttackMaxOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, LKPMinOffset) == 0x0002D8, "Member 'UFortAthenaAIBotMovementSkillSet::LKPMinOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, LKPMaxOffset) == 0x000300, "Member 'UFortAthenaAIBotMovementSkillSet::LKPMaxOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SandTunnelJumpMinTime) == 0x000328, "Member 'UFortAthenaAIBotMovementSkillSet::SandTunnelJumpMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SandTunnelJumpMaxTime) == 0x000350, "Member 'UFortAthenaAIBotMovementSkillSet::SandTunnelJumpMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SandTunnelBurrowedAndHiddenChance) == 0x000378, "Member 'UFortAthenaAIBotMovementSkillSet::SandTunnelBurrowedAndHiddenChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SandTunnelBurrowedAndHiddenMinTime) == 0x0003A0, "Member 'UFortAthenaAIBotMovementSkillSet::SandTunnelBurrowedAndHiddenMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SandTunnelBurrowedAndHiddenMaxTime) == 0x0003C8, "Member 'UFortAthenaAIBotMovementSkillSet::SandTunnelBurrowedAndHiddenMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, WobblingProbability) == 0x0003F0, "Member 'UFortAthenaAIBotMovementSkillSet::WobblingProbability' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxDelayBetweenWobblingMovement) == 0x000418, "Member 'UFortAthenaAIBotMovementSkillSet::MaxDelayBetweenWobblingMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxDelayBetweenWobblingMovementRandomDeviation) == 0x000440, "Member 'UFortAthenaAIBotMovementSkillSet::MaxDelayBetweenWobblingMovementRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxWobblingDuration) == 0x000468, "Member 'UFortAthenaAIBotMovementSkillSet::MaxWobblingDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxWobblingDurationRandomDeviation) == 0x000490, "Member 'UFortAthenaAIBotMovementSkillSet::MaxWobblingDurationRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxWobblingIntensity) == 0x0004B8, "Member 'UFortAthenaAIBotMovementSkillSet::MaxWobblingIntensity' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, WobblingIntensityDeviation) == 0x0004E0, "Member 'UFortAthenaAIBotMovementSkillSet::WobblingIntensityDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxWobblingFrequency) == 0x000508, "Member 'UFortAthenaAIBotMovementSkillSet::MaxWobblingFrequency' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, WobblingFrequencyDeviation) == 0x000530, "Member 'UFortAthenaAIBotMovementSkillSet::WobblingFrequencyDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, WobblingStickToPathCorridorStrength) == 0x000558, "Member 'UFortAthenaAIBotMovementSkillSet::WobblingStickToPathCorridorStrength' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, LimitBlockingObstacleAngle) == 0x000580, "Member 'UFortAthenaAIBotMovementSkillSet::LimitBlockingObstacleAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxAfterLaunchedPauseTime) == 0x0005A8, "Member 'UFortAthenaAIBotMovementSkillSet::MaxAfterLaunchedPauseTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxAfterLaunchedFromVortexPauseTime) == 0x0005D0, "Member 'UFortAthenaAIBotMovementSkillSet::MaxAfterLaunchedFromVortexPauseTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, AfterLaunchedPauseTimeDeviation) == 0x0005F8, "Member 'UFortAthenaAIBotMovementSkillSet::AfterLaunchedPauseTimeDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SteerMovementWhenLaunched) == 0x000620, "Member 'UFortAthenaAIBotMovementSkillSet::SteerMovementWhenLaunched' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SteerMovementWhenLaunchedDirectionUpdateTime) == 0x000648, "Member 'UFortAthenaAIBotMovementSkillSet::SteerMovementWhenLaunchedDirectionUpdateTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxReactionTimeToDangerZone) == 0x000670, "Member 'UFortAthenaAIBotMovementSkillSet::MaxReactionTimeToDangerZone' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MaxReactionTimeToDangerZoneDeviation) == 0x000698, "Member 'UFortAthenaAIBotMovementSkillSet::MaxReactionTimeToDangerZoneDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, AllowSwimWobble) == 0x0006C0, "Member 'UFortAthenaAIBotMovementSkillSet::AllowSwimWobble' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, EnableSwimSprintJump) == 0x0006E8, "Member 'UFortAthenaAIBotMovementSkillSet::EnableSwimSprintJump' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SwimSprintJumpDelay) == 0x000710, "Member 'UFortAthenaAIBotMovementSkillSet::SwimSprintJumpDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SwimSprintJumpDelayDeviation) == 0x000738, "Member 'UFortAthenaAIBotMovementSkillSet::SwimSprintJumpDelayDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SwimUnblockJumpHeightThreshold) == 0x000760, "Member 'UFortAthenaAIBotMovementSkillSet::SwimUnblockJumpHeightThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SwimSprintJumpNav2D) == 0x000788, "Member 'UFortAthenaAIBotMovementSkillSet::SwimSprintJumpNav2D' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintEvaluationMinTime) == 0x0007B0, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintEvaluationMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintEvaluationMaxTime) == 0x0007D8, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintEvaluationMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintMinTriggerChance) == 0x000800, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintMinTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintMaxTriggerChance) == 0x000828, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintMaxTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintMinTriggerChanceInUrgentMovement) == 0x000850, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintMinTriggerChanceInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintMaxTriggerChanceInUrgentMovement) == 0x000878, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintMaxTriggerChanceInUrgentMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintMaxSlopeAngle) == 0x0008A0, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintMaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintMinPathTargetDistance) == 0x0008C8, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintMinPathTargetDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintMaxPathAlignmentAngle) == 0x0008F0, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintMaxPathAlignmentAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintMaxPathConeAngle) == 0x000918, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintMaxPathConeAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintPathConeRearOffset) == 0x000940, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintPathConeRearOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, TacticalSprintUsageEnabled) == 0x000968, "Member 'UFortAthenaAIBotMovementSkillSet::TacticalSprintUsageEnabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingBoxExtent) == 0x000990, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingBoxExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingEnabled) == 0x0009A8, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingEnabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingEvaluationMinTime) == 0x000A48, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingEvaluationMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingEvaluationMaxTime) == 0x000A70, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingEvaluationMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingMinTriggerChance) == 0x000A98, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingMinTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingMaxTriggerChance) == 0x000AC0, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingMaxTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingDuringUrgentMovementMinTriggerChance) == 0x000AE8, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingDuringUrgentMovementMinTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingDuringUrgentMovementMaxTriggerChance) == 0x000B10, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingDuringUrgentMovementMaxTriggerChance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingSlopeMinAngle) == 0x000B38, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingSlopeMinAngle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, MinSlidingDuration) == 0x000B60, "Member 'UFortAthenaAIBotMovementSkillSet::MinSlidingDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingCooldownMinTime) == 0x000B88, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingCooldownMinTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingCooldownMaxTime) == 0x000BB0, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingCooldownMaxTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingStopMinDelay) == 0x000BD8, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingStopMinDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, SlidingStopMaxDelay) == 0x000C00, "Member 'UFortAthenaAIBotMovementSkillSet::SlidingStopMaxDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, ZiplineOctreeBoxExtent) == 0x000C28, "Member 'UFortAthenaAIBotMovementSkillSet::ZiplineOctreeBoxExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, ThresholdDistanceToRescanForZiplines) == 0x000C40, "Member 'UFortAthenaAIBotMovementSkillSet::ThresholdDistanceToRescanForZiplines' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, CooldownBetweenZiplineUsages) == 0x000C68, "Member 'UFortAthenaAIBotMovementSkillSet::CooldownBetweenZiplineUsages' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, DistanceToAddToZiplineStartPosition) == 0x000C90, "Member 'UFortAthenaAIBotMovementSkillSet::DistanceToAddToZiplineStartPosition' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, RadiusFromZiplineEnterPointToLookAtExit) == 0x000CB8, "Member 'UFortAthenaAIBotMovementSkillSet::RadiusFromZiplineEnterPointToLookAtExit' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, ZiplineUsageEnabled) == 0x000CE0, "Member 'UFortAthenaAIBotMovementSkillSet::ZiplineUsageEnabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotMovementSkillSet, KnockbackSettings) == 0x000D08, "Member 'UFortAthenaAIBotMovementSkillSet::KnockbackSettings' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_BotWait
// 0x0028 (0x00A0 - 0x0078)
class UFortAthenaBTTask_BotWait final : public UBTTask_Wait
{
public:
	struct FBlackboardKeySelector                 WaitCompleteKeySelector;                           // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_BotWait">();
	}
	static class UFortAthenaBTTask_BotWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_BotWait>();
	}
};
static_assert(alignof(UFortAthenaBTTask_BotWait) == 0x000008, "Wrong alignment on UFortAthenaBTTask_BotWait");
static_assert(sizeof(UFortAthenaBTTask_BotWait) == 0x0000A0, "Wrong size on UFortAthenaBTTask_BotWait");
static_assert(offsetof(UFortAthenaBTTask_BotWait, WaitCompleteKeySelector) == 0x000078, "Member 'UFortAthenaBTTask_BotWait::WaitCompleteKeySelector' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotNameDataAsset
// 0x0060 (0x0090 - 0x0030)
class UFortAthenaAIBotNameDataAsset final : public UDataAsset
{
public:
	TSoftObjectPtr<class UDataTable>              DefaultNameDataTable;                              // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              ChinaNameDataTable;                                // 0x0058(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFortAthenaAIBotNameRegionData> RegionData;                                        // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotNameDataAsset">();
	}
	static class UFortAthenaAIBotNameDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotNameDataAsset>();
	}
};
static_assert(alignof(UFortAthenaAIBotNameDataAsset) == 0x000008, "Wrong alignment on UFortAthenaAIBotNameDataAsset");
static_assert(sizeof(UFortAthenaAIBotNameDataAsset) == 0x000090, "Wrong size on UFortAthenaAIBotNameDataAsset");
static_assert(offsetof(UFortAthenaAIBotNameDataAsset, DefaultNameDataTable) == 0x000030, "Member 'UFortAthenaAIBotNameDataAsset::DefaultNameDataTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotNameDataAsset, ChinaNameDataTable) == 0x000058, "Member 'UFortAthenaAIBotNameDataAsset::ChinaNameDataTable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotNameDataAsset, RegionData) == 0x000080, "Member 'UFortAthenaAIBotNameDataAsset::RegionData' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotPathFollowingComponent
// 0x0230 (0x0558 - 0x0328)
class UFortAthenaAIBotPathFollowingComponent final : public UFortPathFollowingComponentBase
{
public:
	class AFortAthenaAIBotController*             BotController;                                     // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingActor*                         HitBuilding;                                       // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotUnstuckDigestedSkillSet* CachedUnstuckSkillSet;                             // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotMovementDigestedSkillSet* CachedMovementSkillSet;                            // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAIBotVehicleDigestedSkillSet* CachedVehicleSkillSet;                             // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x208];                                    // 0x0350(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePawnTeleported(class AFortPawn* TeleportedPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotPathFollowingComponent">();
	}
	static class UFortAthenaAIBotPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotPathFollowingComponent>();
	}
};
static_assert(alignof(UFortAthenaAIBotPathFollowingComponent) == 0x000008, "Wrong alignment on UFortAthenaAIBotPathFollowingComponent");
static_assert(sizeof(UFortAthenaAIBotPathFollowingComponent) == 0x000558, "Wrong size on UFortAthenaAIBotPathFollowingComponent");
static_assert(offsetof(UFortAthenaAIBotPathFollowingComponent, BotController) == 0x000328, "Member 'UFortAthenaAIBotPathFollowingComponent::BotController' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPathFollowingComponent, HitBuilding) == 0x000330, "Member 'UFortAthenaAIBotPathFollowingComponent::HitBuilding' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPathFollowingComponent, CachedUnstuckSkillSet) == 0x000338, "Member 'UFortAthenaAIBotPathFollowingComponent::CachedUnstuckSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPathFollowingComponent, CachedMovementSkillSet) == 0x000340, "Member 'UFortAthenaAIBotPathFollowingComponent::CachedMovementSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPathFollowingComponent, CachedVehicleSkillSet) == 0x000348, "Member 'UFortAthenaAIBotPathFollowingComponent::CachedVehicleSkillSet' has a wrong offset!");

// Class FortniteAI.FortNavLinkDefinition
// 0x0030 (0x0080 - 0x0050)
class UFortNavLinkDefinition : public UNavLinkDefinition
{
public:
	struct FFortNavLinkPattern                    Pattern;                                           // 0x0050(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FFortNavLinkPattern>            AdditionalPatterns;                                // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EBuildingStairsRailing>                StairsRailing;                                     // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBuildingFloorRailing                         FloorRailing;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortNavLinkPattern                           PatternType;                                       // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavLinkDefinition">();
	}
	static class UFortNavLinkDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavLinkDefinition>();
	}
};
static_assert(alignof(UFortNavLinkDefinition) == 0x000008, "Wrong alignment on UFortNavLinkDefinition");
static_assert(sizeof(UFortNavLinkDefinition) == 0x000080, "Wrong size on UFortNavLinkDefinition");
static_assert(offsetof(UFortNavLinkDefinition, Pattern) == 0x000050, "Member 'UFortNavLinkDefinition::Pattern' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, AdditionalPatterns) == 0x000058, "Member 'UFortNavLinkDefinition::AdditionalPatterns' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, StairsRailing) == 0x000068, "Member 'UFortNavLinkDefinition::StairsRailing' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, FloorRailing) == 0x000078, "Member 'UFortNavLinkDefinition::FloorRailing' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, PatternType) == 0x000079, "Member 'UFortNavLinkDefinition::PatternType' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotPerceptionDigestedSkillSet
// 0x0318 (0x0348 - 0x0030)
class UFortAthenaAIBotPerceptionDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         SightReactionTime;                                 // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SightRandomDeviation;                              // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDigestedSightReactionSpecialization> SightReactionSpecializations;                      // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         LoseSightTime;                                     // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoseSightRandomDeviation;                          // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SightSuspicionTime;                                // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SightSuspicionRandomDeviation;                     // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyMarkedReactionTime;                           // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyMarkedReactionRandomDeviation;                // 0x0084(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChancesToHelpOnMarkedEnemy;                        // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageReactionTime;                                // 0x008C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRandomDeviation;                             // 0x0090(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HearingReactionTime;                               // 0x0094(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HearingRandomDeviation;                            // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHearingLocationError;                           // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleDistanceOverrideTargetingSq;               // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleForgetDistanceSq;                          // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleMinimumBlockingTime;                       // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAthenaAIBotDigestedTargetHeuristicSettings DefaultTargetHeuristicSettings;                    // 0x00B0(0x0188)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAthenaAIBotDigestedTargetHeuristicSettingsSpecialization> TargetHeuristicsSettingsSpecializations;           // 0x0238(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FSoundPerceptionDigestedSetting        SoundSettings[0x7];                                // 0x0248(0x000C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AlertedAccumulatedLoudnessLimit;                   // 0x029C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LKPAccumulatedLoudnessLimit;                       // 0x02A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyMarkingDelay;                                 // 0x02A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyMarkingDelayRandomDeviation;                  // 0x02A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalMarkedEnemyLKPForgetTime;                // 0x02AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalMarkedEnemyLKPForgetDistance;            // 0x02B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlertLevelInfo                        AlertLevelInfos[0x4];                              // 0x02B8(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         ProjectileThreatForgetTime;                        // 0x02F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTrapPerceptionSettings                TrapPerceptionSettings;                            // 0x02FC(0x0014)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bStealthMeterEnable;                               // 0x0310(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StealthMeterThreshold;                             // 0x0314(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealthMeterIncreaseSpeed;                         // 0x0318(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         StealthMeterDecreaseSpeed;                         // 0x0340(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStealthMeterAllowSharedTarget;                    // 0x0344(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStealthMeterForceLKPWhenDamagedAndThreatened;     // 0x0345(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_346[0x2];                                      // 0x0346(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotPerceptionDigestedSkillSet">();
	}
	static class UFortAthenaAIBotPerceptionDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotPerceptionDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotPerceptionDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotPerceptionDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotPerceptionDigestedSkillSet) == 0x000348, "Wrong size on UFortAthenaAIBotPerceptionDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, SightReactionTime) == 0x000030, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::SightReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, SightRandomDeviation) == 0x000034, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::SightRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, SightReactionSpecializations) == 0x000060, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::SightReactionSpecializations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, LoseSightTime) == 0x000070, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::LoseSightTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, LoseSightRandomDeviation) == 0x000074, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::LoseSightRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, SightSuspicionTime) == 0x000078, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::SightSuspicionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, SightSuspicionRandomDeviation) == 0x00007C, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::SightSuspicionRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, EnemyMarkedReactionTime) == 0x000080, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::EnemyMarkedReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, EnemyMarkedReactionRandomDeviation) == 0x000084, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::EnemyMarkedReactionRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, ChancesToHelpOnMarkedEnemy) == 0x000088, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::ChancesToHelpOnMarkedEnemy' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, DamageReactionTime) == 0x00008C, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::DamageReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, DamageRandomDeviation) == 0x000090, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::DamageRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, HearingReactionTime) == 0x000094, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::HearingReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, HearingRandomDeviation) == 0x000098, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::HearingRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, MaxHearingLocationError) == 0x00009C, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::MaxHearingLocationError' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, ObstacleDistanceOverrideTargetingSq) == 0x0000A0, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::ObstacleDistanceOverrideTargetingSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, ObstacleForgetDistanceSq) == 0x0000A4, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::ObstacleForgetDistanceSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, ObstacleMinimumBlockingTime) == 0x0000A8, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::ObstacleMinimumBlockingTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, DefaultTargetHeuristicSettings) == 0x0000B0, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::DefaultTargetHeuristicSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, TargetHeuristicsSettingsSpecializations) == 0x000238, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::TargetHeuristicsSettingsSpecializations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, SoundSettings) == 0x000248, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::SoundSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, AlertedAccumulatedLoudnessLimit) == 0x00029C, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::AlertedAccumulatedLoudnessLimit' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, LKPAccumulatedLoudnessLimit) == 0x0002A0, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::LKPAccumulatedLoudnessLimit' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, EnemyMarkingDelay) == 0x0002A4, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::EnemyMarkingDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, EnemyMarkingDelayRandomDeviation) == 0x0002A8, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::EnemyMarkingDelayRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, AdditionalMarkedEnemyLKPForgetTime) == 0x0002AC, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::AdditionalMarkedEnemyLKPForgetTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, AdditionalMarkedEnemyLKPForgetDistance) == 0x0002B0, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::AdditionalMarkedEnemyLKPForgetDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, AlertLevelInfos) == 0x0002B8, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::AlertLevelInfos' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, ProjectileThreatForgetTime) == 0x0002F8, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::ProjectileThreatForgetTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, TrapPerceptionSettings) == 0x0002FC, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::TrapPerceptionSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, bStealthMeterEnable) == 0x000310, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::bStealthMeterEnable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, StealthMeterThreshold) == 0x000314, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::StealthMeterThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, StealthMeterIncreaseSpeed) == 0x000318, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::StealthMeterIncreaseSpeed' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, StealthMeterDecreaseSpeed) == 0x000340, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::StealthMeterDecreaseSpeed' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, bStealthMeterAllowSharedTarget) == 0x000344, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::bStealthMeterAllowSharedTarget' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionDigestedSkillSet, bStealthMeterForceLKPWhenDamagedAndThreatened) == 0x000345, "Member 'UFortAthenaAIBotPerceptionDigestedSkillSet::bStealthMeterForceLKPWhenDamagedAndThreatened' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_ReverseVehicle
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_ReverseVehicle final : public UBTTaskNode
{
public:
	bool                                          bReverseVehicle;                                   // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_ReverseVehicle">();
	}
	static class UFortAthenaBTTask_ReverseVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_ReverseVehicle>();
	}
};
static_assert(alignof(UFortAthenaBTTask_ReverseVehicle) == 0x000008, "Wrong alignment on UFortAthenaBTTask_ReverseVehicle");
static_assert(sizeof(UFortAthenaBTTask_ReverseVehicle) == 0x000078, "Wrong size on UFortAthenaBTTask_ReverseVehicle");
static_assert(offsetof(UFortAthenaBTTask_ReverseVehicle, bReverseVehicle) == 0x000070, "Member 'UFortAthenaBTTask_ReverseVehicle::bReverseVehicle' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotPerceptionSkillSet
// 0x0C60 (0x0C90 - 0x0030)
class UFortAthenaAIBotPerceptionSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         SightReactionTime;                                 // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SightRandomDeviation;                              // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SightRandomAddition;                               // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSightReactionSpecialization>   SightReactionSpecializations;                      // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LoseSightTime;                                     // 0x00B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LoseSightRandomDeviation;                          // 0x00E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SightSuspicionTime;                                // 0x0108(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SightSuspicionRandomDeviation;                     // 0x0130(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         EnemyMarkedReactionTime;                           // 0x0158(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         EnemyMarkedReactionRandomDeviation;                // 0x0180(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ChancesToHelpOnMarkedEnemy;                        // 0x01A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DamageReactionTime;                                // 0x01D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DamageRandomDeviation;                             // 0x01F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HearingReactionTime;                               // 0x0220(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HearingRandomDeviation;                            // 0x0248(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxHearingLocationError;                           // 0x0270(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFortAthenaAIBotTargetHeuristicSettings DefaultTargetHeuristicSettings;                    // 0x0298(0x0320)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAthenaAIBotTargetHeuristicSettingsSpecialization> TargetHeuristicSettingsSpecializations;            // 0x05B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ObstacleDistanceOverrideTargeting;                 // 0x05C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ObstacleForgetDistance;                            // 0x05F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ObstacleMinimumBlockingTime;                       // 0x0618(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSoundPerceptionSetting                SoundSettings[0x7];                                // 0x0640(0x0078)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AlertedAccumulatedLoudnessLimit;                   // 0x0988(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         LKPAccumulatedLoudnessLimit;                       // 0x09B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         EnemyMarkingDelay;                                 // 0x09D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         EnemyMarkingDelayRandomDeviation;                  // 0x0A00(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AdditionalMarkedEnemyLKPForgetTime;                // 0x0A28(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AdditionalMarkedEnemyLKPForgetDistance;            // 0x0A50(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAthenaAIBotAlertLevelConfig*> AlertLevelConfigs;                                 // 0x0A78(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ProjectileThreatForgetTime;                        // 0x0A88(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrapDetectionDistanceMax;                          // 0x0AB0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrapDetectionDistanceMaxDeviation;                 // 0x0AD8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrapDetectionChanceWhenPerpendicular;              // 0x0B00(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrapDetectionChanceWhenParallel;                   // 0x0B28(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrapDetectionEvaluationAngleThreshold;             // 0x0B50(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TrapDetectionAutomaticIfWithinCreationTime;        // 0x0B78(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealthMeterEnable;                                // 0x0BA0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealthMeterThreshold;                             // 0x0BC8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealthMeterIncreaseSpeed;                         // 0x0BF0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealthMeterDecreaseSpeed;                         // 0x0C18(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StealthMeterAllowSharedTarget;                     // 0x0C40(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         bStealthMeterForceLKPWhenDamagedAndThreatened;     // 0x0C68(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotPerceptionSkillSet">();
	}
	static class UFortAthenaAIBotPerceptionSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotPerceptionSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotPerceptionSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotPerceptionSkillSet");
static_assert(sizeof(UFortAthenaAIBotPerceptionSkillSet) == 0x000C90, "Wrong size on UFortAthenaAIBotPerceptionSkillSet");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, SightReactionTime) == 0x000030, "Member 'UFortAthenaAIBotPerceptionSkillSet::SightReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, SightRandomDeviation) == 0x000058, "Member 'UFortAthenaAIBotPerceptionSkillSet::SightRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, SightRandomAddition) == 0x000080, "Member 'UFortAthenaAIBotPerceptionSkillSet::SightRandomAddition' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, SightReactionSpecializations) == 0x0000A8, "Member 'UFortAthenaAIBotPerceptionSkillSet::SightReactionSpecializations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, LoseSightTime) == 0x0000B8, "Member 'UFortAthenaAIBotPerceptionSkillSet::LoseSightTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, LoseSightRandomDeviation) == 0x0000E0, "Member 'UFortAthenaAIBotPerceptionSkillSet::LoseSightRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, SightSuspicionTime) == 0x000108, "Member 'UFortAthenaAIBotPerceptionSkillSet::SightSuspicionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, SightSuspicionRandomDeviation) == 0x000130, "Member 'UFortAthenaAIBotPerceptionSkillSet::SightSuspicionRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, EnemyMarkedReactionTime) == 0x000158, "Member 'UFortAthenaAIBotPerceptionSkillSet::EnemyMarkedReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, EnemyMarkedReactionRandomDeviation) == 0x000180, "Member 'UFortAthenaAIBotPerceptionSkillSet::EnemyMarkedReactionRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, ChancesToHelpOnMarkedEnemy) == 0x0001A8, "Member 'UFortAthenaAIBotPerceptionSkillSet::ChancesToHelpOnMarkedEnemy' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, DamageReactionTime) == 0x0001D0, "Member 'UFortAthenaAIBotPerceptionSkillSet::DamageReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, DamageRandomDeviation) == 0x0001F8, "Member 'UFortAthenaAIBotPerceptionSkillSet::DamageRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, HearingReactionTime) == 0x000220, "Member 'UFortAthenaAIBotPerceptionSkillSet::HearingReactionTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, HearingRandomDeviation) == 0x000248, "Member 'UFortAthenaAIBotPerceptionSkillSet::HearingRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, MaxHearingLocationError) == 0x000270, "Member 'UFortAthenaAIBotPerceptionSkillSet::MaxHearingLocationError' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, DefaultTargetHeuristicSettings) == 0x000298, "Member 'UFortAthenaAIBotPerceptionSkillSet::DefaultTargetHeuristicSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, TargetHeuristicSettingsSpecializations) == 0x0005B8, "Member 'UFortAthenaAIBotPerceptionSkillSet::TargetHeuristicSettingsSpecializations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, ObstacleDistanceOverrideTargeting) == 0x0005C8, "Member 'UFortAthenaAIBotPerceptionSkillSet::ObstacleDistanceOverrideTargeting' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, ObstacleForgetDistance) == 0x0005F0, "Member 'UFortAthenaAIBotPerceptionSkillSet::ObstacleForgetDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, ObstacleMinimumBlockingTime) == 0x000618, "Member 'UFortAthenaAIBotPerceptionSkillSet::ObstacleMinimumBlockingTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, SoundSettings) == 0x000640, "Member 'UFortAthenaAIBotPerceptionSkillSet::SoundSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, AlertedAccumulatedLoudnessLimit) == 0x000988, "Member 'UFortAthenaAIBotPerceptionSkillSet::AlertedAccumulatedLoudnessLimit' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, LKPAccumulatedLoudnessLimit) == 0x0009B0, "Member 'UFortAthenaAIBotPerceptionSkillSet::LKPAccumulatedLoudnessLimit' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, EnemyMarkingDelay) == 0x0009D8, "Member 'UFortAthenaAIBotPerceptionSkillSet::EnemyMarkingDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, EnemyMarkingDelayRandomDeviation) == 0x000A00, "Member 'UFortAthenaAIBotPerceptionSkillSet::EnemyMarkingDelayRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, AdditionalMarkedEnemyLKPForgetTime) == 0x000A28, "Member 'UFortAthenaAIBotPerceptionSkillSet::AdditionalMarkedEnemyLKPForgetTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, AdditionalMarkedEnemyLKPForgetDistance) == 0x000A50, "Member 'UFortAthenaAIBotPerceptionSkillSet::AdditionalMarkedEnemyLKPForgetDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, AlertLevelConfigs) == 0x000A78, "Member 'UFortAthenaAIBotPerceptionSkillSet::AlertLevelConfigs' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, ProjectileThreatForgetTime) == 0x000A88, "Member 'UFortAthenaAIBotPerceptionSkillSet::ProjectileThreatForgetTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, TrapDetectionDistanceMax) == 0x000AB0, "Member 'UFortAthenaAIBotPerceptionSkillSet::TrapDetectionDistanceMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, TrapDetectionDistanceMaxDeviation) == 0x000AD8, "Member 'UFortAthenaAIBotPerceptionSkillSet::TrapDetectionDistanceMaxDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, TrapDetectionChanceWhenPerpendicular) == 0x000B00, "Member 'UFortAthenaAIBotPerceptionSkillSet::TrapDetectionChanceWhenPerpendicular' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, TrapDetectionChanceWhenParallel) == 0x000B28, "Member 'UFortAthenaAIBotPerceptionSkillSet::TrapDetectionChanceWhenParallel' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, TrapDetectionEvaluationAngleThreshold) == 0x000B50, "Member 'UFortAthenaAIBotPerceptionSkillSet::TrapDetectionEvaluationAngleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, TrapDetectionAutomaticIfWithinCreationTime) == 0x000B78, "Member 'UFortAthenaAIBotPerceptionSkillSet::TrapDetectionAutomaticIfWithinCreationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, StealthMeterEnable) == 0x000BA0, "Member 'UFortAthenaAIBotPerceptionSkillSet::StealthMeterEnable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, StealthMeterThreshold) == 0x000BC8, "Member 'UFortAthenaAIBotPerceptionSkillSet::StealthMeterThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, StealthMeterIncreaseSpeed) == 0x000BF0, "Member 'UFortAthenaAIBotPerceptionSkillSet::StealthMeterIncreaseSpeed' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, StealthMeterDecreaseSpeed) == 0x000C18, "Member 'UFortAthenaAIBotPerceptionSkillSet::StealthMeterDecreaseSpeed' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, StealthMeterAllowSharedTarget) == 0x000C40, "Member 'UFortAthenaAIBotPerceptionSkillSet::StealthMeterAllowSharedTarget' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPerceptionSkillSet, bStealthMeterForceLKPWhenDamagedAndThreatened) == 0x000C68, "Member 'UFortAthenaAIBotPerceptionSkillSet::bStealthMeterForceLKPWhenDamagedAndThreatened' has a wrong offset!");

// Class FortniteAI.FortNavigationMetaFilter
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationMetaFilter : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationMetaFilter">();
	}
	static class UFortNavigationMetaFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationMetaFilter>();
	}
};
static_assert(alignof(UFortNavigationMetaFilter) == 0x000008, "Wrong alignment on UFortNavigationMetaFilter");
static_assert(sizeof(UFortNavigationMetaFilter) == 0x000048, "Wrong size on UFortNavigationMetaFilter");

// Class FortniteAI.FortQueryTest_MissionGameplayTagMatch
// 0x0068 (0x0260 - 0x01F8)
class UFortQueryTest_MissionGameplayTagMatch final : public UEnvQueryTest
{
public:
	struct FGameplayTagQuery                      MissionPlacementActorTagQuery;                     // 0x01F8(0x0048)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  GameplayTagsToMatch;                               // 0x0240(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_MissionGameplayTagMatch">();
	}
	static class UFortQueryTest_MissionGameplayTagMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_MissionGameplayTagMatch>();
	}
};
static_assert(alignof(UFortQueryTest_MissionGameplayTagMatch) == 0x000008, "Wrong alignment on UFortQueryTest_MissionGameplayTagMatch");
static_assert(sizeof(UFortQueryTest_MissionGameplayTagMatch) == 0x000260, "Wrong size on UFortQueryTest_MissionGameplayTagMatch");
static_assert(offsetof(UFortQueryTest_MissionGameplayTagMatch, MissionPlacementActorTagQuery) == 0x0001F8, "Member 'UFortQueryTest_MissionGameplayTagMatch::MissionPlacementActorTagQuery' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_MissionGameplayTagMatch, GameplayTagsToMatch) == 0x000240, "Member 'UFortQueryTest_MissionGameplayTagMatch::GameplayTagsToMatch' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotPlayStyleDigestedSkillSet
// 0x0068 (0x0098 - 0x0030)
class UFortAthenaAIBotPlayStyleDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	struct FScalableFloat                         AggressiveTowardsThreatWeight;                     // 0x0030(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DefensiveTowardsThreatWeight;                      // 0x0058(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	EDBNOPlayStyle                                DBNOPlayStyle;                                     // 0x0080(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlaystyleSwitchToAggressiveDataDigested> ChangeToAggressiveData;                            // 0x0088(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotPlayStyleDigestedSkillSet">();
	}
	static class UFortAthenaAIBotPlayStyleDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotPlayStyleDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotPlayStyleDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotPlayStyleDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotPlayStyleDigestedSkillSet) == 0x000098, "Wrong size on UFortAthenaAIBotPlayStyleDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotPlayStyleDigestedSkillSet, AggressiveTowardsThreatWeight) == 0x000030, "Member 'UFortAthenaAIBotPlayStyleDigestedSkillSet::AggressiveTowardsThreatWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPlayStyleDigestedSkillSet, DefensiveTowardsThreatWeight) == 0x000058, "Member 'UFortAthenaAIBotPlayStyleDigestedSkillSet::DefensiveTowardsThreatWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPlayStyleDigestedSkillSet, DBNOPlayStyle) == 0x000080, "Member 'UFortAthenaAIBotPlayStyleDigestedSkillSet::DBNOPlayStyle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPlayStyleDigestedSkillSet, ChangeToAggressiveData) == 0x000088, "Member 'UFortAthenaAIBotPlayStyleDigestedSkillSet::ChangeToAggressiveData' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotPlayStyleSkillSet
// 0x00D8 (0x0108 - 0x0030)
class UFortAthenaAIBotPlayStyleSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         AggressiveTowardsThreatWeight;                     // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DefensiveTowardsThreatWeight;                      // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PassiveDBNOPlayStyle;                              // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ThirstyDBNOPlayStyle;                              // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PassiveOnHumansDBNOPlayStyle;                      // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPlaystyleSwitchToAggressiveData> ChangeToAggressiveData;                            // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotPlayStyleSkillSet">();
	}
	static class UFortAthenaAIBotPlayStyleSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotPlayStyleSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotPlayStyleSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotPlayStyleSkillSet");
static_assert(sizeof(UFortAthenaAIBotPlayStyleSkillSet) == 0x000108, "Wrong size on UFortAthenaAIBotPlayStyleSkillSet");
static_assert(offsetof(UFortAthenaAIBotPlayStyleSkillSet, AggressiveTowardsThreatWeight) == 0x000030, "Member 'UFortAthenaAIBotPlayStyleSkillSet::AggressiveTowardsThreatWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPlayStyleSkillSet, DefensiveTowardsThreatWeight) == 0x000058, "Member 'UFortAthenaAIBotPlayStyleSkillSet::DefensiveTowardsThreatWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPlayStyleSkillSet, PassiveDBNOPlayStyle) == 0x000080, "Member 'UFortAthenaAIBotPlayStyleSkillSet::PassiveDBNOPlayStyle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPlayStyleSkillSet, ThirstyDBNOPlayStyle) == 0x0000A8, "Member 'UFortAthenaAIBotPlayStyleSkillSet::ThirstyDBNOPlayStyle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPlayStyleSkillSet, PassiveOnHumansDBNOPlayStyle) == 0x0000D0, "Member 'UFortAthenaAIBotPlayStyleSkillSet::PassiveOnHumansDBNOPlayStyle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPlayStyleSkillSet, ChangeToAggressiveData) == 0x0000F8, "Member 'UFortAthenaAIBotPlayStyleSkillSet::ChangeToAggressiveData' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_Conversation
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_Conversation final : public UBTTaskNode
{
public:
	class FName                                   ConversationStatusKeyName;                         // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_Conversation">();
	}
	static class UFortAthenaBTTask_Conversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_Conversation>();
	}
};
static_assert(alignof(UFortAthenaBTTask_Conversation) == 0x000008, "Wrong alignment on UFortAthenaBTTask_Conversation");
static_assert(sizeof(UFortAthenaBTTask_Conversation) == 0x000078, "Wrong size on UFortAthenaBTTask_Conversation");
static_assert(offsetof(UFortAthenaBTTask_Conversation, ConversationStatusKeyName) == 0x000070, "Member 'UFortAthenaBTTask_Conversation::ConversationStatusKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotPropagateAwarenessDigestedSkillSet
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAIBotPropagateAwarenessDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         PropagationMaxDistanceSQ;                          // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CosineFOV;                                         // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotPropagateAwarenessDigestedSkillSet">();
	}
	static class UFortAthenaAIBotPropagateAwarenessDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotPropagateAwarenessDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotPropagateAwarenessDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotPropagateAwarenessDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotPropagateAwarenessDigestedSkillSet) == 0x000038, "Wrong size on UFortAthenaAIBotPropagateAwarenessDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotPropagateAwarenessDigestedSkillSet, PropagationMaxDistanceSQ) == 0x000030, "Member 'UFortAthenaAIBotPropagateAwarenessDigestedSkillSet::PropagationMaxDistanceSQ' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPropagateAwarenessDigestedSkillSet, CosineFOV) == 0x000034, "Member 'UFortAthenaAIBotPropagateAwarenessDigestedSkillSet::CosineFOV' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotPropagateAwarenessSkillSet
// 0x0050 (0x0080 - 0x0030)
class UFortAthenaAIBotPropagateAwarenessSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         PropagationMaxDistance;                            // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         FOV;                                               // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotPropagateAwarenessSkillSet">();
	}
	static class UFortAthenaAIBotPropagateAwarenessSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotPropagateAwarenessSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotPropagateAwarenessSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotPropagateAwarenessSkillSet");
static_assert(sizeof(UFortAthenaAIBotPropagateAwarenessSkillSet) == 0x000080, "Wrong size on UFortAthenaAIBotPropagateAwarenessSkillSet");
static_assert(offsetof(UFortAthenaAIBotPropagateAwarenessSkillSet, PropagationMaxDistance) == 0x000030, "Member 'UFortAthenaAIBotPropagateAwarenessSkillSet::PropagationMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotPropagateAwarenessSkillSet, FOV) == 0x000058, "Member 'UFortAthenaAIBotPropagateAwarenessSkillSet::FOV' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_BotUnstuckTeleport
// 0x0080 (0x00F0 - 0x0070)
class UFortAthenaBTTask_BotUnstuckTeleport final : public UBTTaskNode
{
public:
	struct FEQSParametrizedQueryExecutionRequest  EQSRequest;                                        // 0x0070(0x0048)(Edit, NativeAccessSpecifierPrivate)
	class FName                                   CanReachDestinationKeyName;                        // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TeleportExecutionStatusKeyName;                    // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LastPartialPathTimeKeyName;                        // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LastPartialPathCountKeyName;                       // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIBotUnstuckDigestedSkillSet* UnstuckSkillSet;                                   // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_BotUnstuckTeleport">();
	}
	static class UFortAthenaBTTask_BotUnstuckTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_BotUnstuckTeleport>();
	}
};
static_assert(alignof(UFortAthenaBTTask_BotUnstuckTeleport) == 0x000008, "Wrong alignment on UFortAthenaBTTask_BotUnstuckTeleport");
static_assert(sizeof(UFortAthenaBTTask_BotUnstuckTeleport) == 0x0000F0, "Wrong size on UFortAthenaBTTask_BotUnstuckTeleport");
static_assert(offsetof(UFortAthenaBTTask_BotUnstuckTeleport, EQSRequest) == 0x000070, "Member 'UFortAthenaBTTask_BotUnstuckTeleport::EQSRequest' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotUnstuckTeleport, CanReachDestinationKeyName) == 0x0000B8, "Member 'UFortAthenaBTTask_BotUnstuckTeleport::CanReachDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotUnstuckTeleport, TeleportExecutionStatusKeyName) == 0x0000BC, "Member 'UFortAthenaBTTask_BotUnstuckTeleport::TeleportExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotUnstuckTeleport, LastPartialPathTimeKeyName) == 0x0000C0, "Member 'UFortAthenaBTTask_BotUnstuckTeleport::LastPartialPathTimeKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotUnstuckTeleport, LastPartialPathCountKeyName) == 0x0000C4, "Member 'UFortAthenaBTTask_BotUnstuckTeleport::LastPartialPathCountKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotUnstuckTeleport, UnstuckSkillSet) == 0x0000E8, "Member 'UFortAthenaBTTask_BotUnstuckTeleport::UnstuckSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotRangeAttackDigestedSkillSet
// 0x00A0 (0x00D0 - 0x0030)
class UFortAthenaAIBotRangeAttackDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	class AFortWeapon*                            CachedWeaponUsedToCalculateSkillSet;               // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDigestedRangedWeaponSkillCategory> RangedWeaponCategorySkills;                        // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         ChangeWeaponDelay;                                 // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeWeaponDelayDeviation;                        // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwapInsteadOfReloadOdds;                           // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwapInsteadOfReloadRangeMax;                       // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SwapInsteadOfReloadIgnoredWeaponTags;              // 0x0060(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         InterruptReloadToShootOdds;                        // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReloadPartiallyEmptyWeaponsOdds;                   // 0x0084(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UseCoverOdds;                                      // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverDistanceMin;                                  // 0x008C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CoverDistanceMaxCurve;                             // 0x0090(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         CoverDistanceToTargetMin;                          // 0x00B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverSearchCooldown;                               // 0x00BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostCoverCooldownMin;                              // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostCoverCooldownMax;                              // 0x00C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanFindShootingPositionAround;                    // 0x00C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotRangeAttackDigestedSkillSet">();
	}
	static class UFortAthenaAIBotRangeAttackDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotRangeAttackDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotRangeAttackDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotRangeAttackDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotRangeAttackDigestedSkillSet) == 0x0000D0, "Wrong size on UFortAthenaAIBotRangeAttackDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, CachedWeaponUsedToCalculateSkillSet) == 0x000030, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::CachedWeaponUsedToCalculateSkillSet' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, RangedWeaponCategorySkills) == 0x000040, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::RangedWeaponCategorySkills' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, ChangeWeaponDelay) == 0x000050, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::ChangeWeaponDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, ChangeWeaponDelayDeviation) == 0x000054, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::ChangeWeaponDelayDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, SwapInsteadOfReloadOdds) == 0x000058, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::SwapInsteadOfReloadOdds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, SwapInsteadOfReloadRangeMax) == 0x00005C, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::SwapInsteadOfReloadRangeMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, SwapInsteadOfReloadIgnoredWeaponTags) == 0x000060, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::SwapInsteadOfReloadIgnoredWeaponTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, InterruptReloadToShootOdds) == 0x000080, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::InterruptReloadToShootOdds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, ReloadPartiallyEmptyWeaponsOdds) == 0x000084, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::ReloadPartiallyEmptyWeaponsOdds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, UseCoverOdds) == 0x000088, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::UseCoverOdds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, CoverDistanceMin) == 0x00008C, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::CoverDistanceMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, CoverDistanceMaxCurve) == 0x000090, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::CoverDistanceMaxCurve' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, CoverDistanceToTargetMin) == 0x0000B8, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::CoverDistanceToTargetMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, CoverSearchCooldown) == 0x0000BC, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::CoverSearchCooldown' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, PostCoverCooldownMin) == 0x0000C0, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::PostCoverCooldownMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, PostCoverCooldownMax) == 0x0000C4, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::PostCoverCooldownMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackDigestedSkillSet, bCanFindShootingPositionAround) == 0x0000C8, "Member 'UFortAthenaAIBotRangeAttackDigestedSkillSet::bCanFindShootingPositionAround' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotRangeAttackSkillSet
// 0x0260 (0x0290 - 0x0030)
class UFortAthenaAIBotRangeAttackSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	TArray<struct FRangedWeaponSkillCategory>     RangedWeaponSkills;                                // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ChangeWeaponDelay;                                 // 0x0040(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ChangeWeaponDelayDeviation;                        // 0x0068(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SwapInsteadOfReloadOdds;                           // 0x0090(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SwapInsteadOfReloadRangeMax;                       // 0x00B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SwapInsteadOfReloadIgnoredWeaponTags;              // 0x00E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         InterruptReloadToShootOdds;                        // 0x0100(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ReloadPartiallyEmptyWeaponsOdds;                   // 0x0128(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         UseCoverOdds;                                      // 0x0150(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CoverDistanceMin;                                  // 0x0178(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CoverDistanceMaxCurve;                             // 0x01A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CoverDistanceToTargetMin;                          // 0x01C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CoverSearchCooldown;                               // 0x01F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PostCoverCooldownMin;                              // 0x0218(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PostCoverCooldownMax;                              // 0x0240(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CanFindShootingPositionAround;                     // 0x0268(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotRangeAttackSkillSet">();
	}
	static class UFortAthenaAIBotRangeAttackSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotRangeAttackSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotRangeAttackSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotRangeAttackSkillSet");
static_assert(sizeof(UFortAthenaAIBotRangeAttackSkillSet) == 0x000290, "Wrong size on UFortAthenaAIBotRangeAttackSkillSet");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, RangedWeaponSkills) == 0x000030, "Member 'UFortAthenaAIBotRangeAttackSkillSet::RangedWeaponSkills' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, ChangeWeaponDelay) == 0x000040, "Member 'UFortAthenaAIBotRangeAttackSkillSet::ChangeWeaponDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, ChangeWeaponDelayDeviation) == 0x000068, "Member 'UFortAthenaAIBotRangeAttackSkillSet::ChangeWeaponDelayDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, SwapInsteadOfReloadOdds) == 0x000090, "Member 'UFortAthenaAIBotRangeAttackSkillSet::SwapInsteadOfReloadOdds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, SwapInsteadOfReloadRangeMax) == 0x0000B8, "Member 'UFortAthenaAIBotRangeAttackSkillSet::SwapInsteadOfReloadRangeMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, SwapInsteadOfReloadIgnoredWeaponTags) == 0x0000E0, "Member 'UFortAthenaAIBotRangeAttackSkillSet::SwapInsteadOfReloadIgnoredWeaponTags' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, InterruptReloadToShootOdds) == 0x000100, "Member 'UFortAthenaAIBotRangeAttackSkillSet::InterruptReloadToShootOdds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, ReloadPartiallyEmptyWeaponsOdds) == 0x000128, "Member 'UFortAthenaAIBotRangeAttackSkillSet::ReloadPartiallyEmptyWeaponsOdds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, UseCoverOdds) == 0x000150, "Member 'UFortAthenaAIBotRangeAttackSkillSet::UseCoverOdds' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, CoverDistanceMin) == 0x000178, "Member 'UFortAthenaAIBotRangeAttackSkillSet::CoverDistanceMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, CoverDistanceMaxCurve) == 0x0001A0, "Member 'UFortAthenaAIBotRangeAttackSkillSet::CoverDistanceMaxCurve' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, CoverDistanceToTargetMin) == 0x0001C8, "Member 'UFortAthenaAIBotRangeAttackSkillSet::CoverDistanceToTargetMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, CoverSearchCooldown) == 0x0001F0, "Member 'UFortAthenaAIBotRangeAttackSkillSet::CoverSearchCooldown' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, PostCoverCooldownMin) == 0x000218, "Member 'UFortAthenaAIBotRangeAttackSkillSet::PostCoverCooldownMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, PostCoverCooldownMax) == 0x000240, "Member 'UFortAthenaAIBotRangeAttackSkillSet::PostCoverCooldownMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotRangeAttackSkillSet, CanFindShootingPositionAround) == 0x000268, "Member 'UFortAthenaAIBotRangeAttackSkillSet::CanFindShootingPositionAround' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotReviveDigestedSkillSet
// 0x0010 (0x0040 - 0x0030)
class UFortAthenaAIBotReviveDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         AllyEvaluationTime;                                // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AllyEvaluationTimeDeviation;                       // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CooldownOnCancel;                                  // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotReviveDigestedSkillSet">();
	}
	static class UFortAthenaAIBotReviveDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotReviveDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotReviveDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotReviveDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotReviveDigestedSkillSet) == 0x000040, "Wrong size on UFortAthenaAIBotReviveDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotReviveDigestedSkillSet, AllyEvaluationTime) == 0x000030, "Member 'UFortAthenaAIBotReviveDigestedSkillSet::AllyEvaluationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotReviveDigestedSkillSet, AllyEvaluationTimeDeviation) == 0x000034, "Member 'UFortAthenaAIBotReviveDigestedSkillSet::AllyEvaluationTimeDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotReviveDigestedSkillSet, CooldownOnCancel) == 0x000038, "Member 'UFortAthenaAIBotReviveDigestedSkillSet::CooldownOnCancel' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotReviveSkillSet
// 0x0078 (0x00A8 - 0x0030)
class UFortAthenaAIBotReviveSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         AllyEvaluationTime;                                // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AllyEvaluationTimeDeviation;                       // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CooldownOnCancel;                                  // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotReviveSkillSet">();
	}
	static class UFortAthenaAIBotReviveSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotReviveSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotReviveSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotReviveSkillSet");
static_assert(sizeof(UFortAthenaAIBotReviveSkillSet) == 0x0000A8, "Wrong size on UFortAthenaAIBotReviveSkillSet");
static_assert(offsetof(UFortAthenaAIBotReviveSkillSet, AllyEvaluationTime) == 0x000030, "Member 'UFortAthenaAIBotReviveSkillSet::AllyEvaluationTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotReviveSkillSet, AllyEvaluationTimeDeviation) == 0x000058, "Member 'UFortAthenaAIBotReviveSkillSet::AllyEvaluationTimeDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotReviveSkillSet, CooldownOnCancel) == 0x000080, "Member 'UFortAthenaAIBotReviveSkillSet::CooldownOnCancel' has a wrong offset!");

// Class FortniteAI.FortNavigationFilter_Hunting
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_Hunting final : public UFortNavigationMetaFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_Hunting">();
	}
	static class UFortNavigationFilter_Hunting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_Hunting>();
	}
};
static_assert(alignof(UFortNavigationFilter_Hunting) == 0x000008, "Wrong alignment on UFortNavigationFilter_Hunting");
static_assert(sizeof(UFortNavigationFilter_Hunting) == 0x000048, "Wrong size on UFortNavigationFilter_Hunting");

// Class FortniteAI.FortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags">();
	}
	static class UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags");

// Class FortniteAI.FortAthenaAIBotUnstuckDigestedSkillSet
// 0x0050 (0x0080 - 0x0030)
class UFortAthenaAIBotUnstuckDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	bool                                          bCanTeleportWhenStuck;                             // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanTeleportWhenStuckWithPlayerAround;             // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceSqToPlayerToTeleport;                   // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerToPhoebeAngleVisibilityConeToTeleport;       // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBetweenPartialPathToConsiderPathStuck;         // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ConsecutivePartialPathCountToConsiderPathStuck;    // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceSqBetweenBlockedPathToConsiderPathStuck;   // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceBetweenSampleToConsiderPathStuckInWater;   // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBetweenSampleToConsiderPathStuckInWater;       // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceBetweenSampleToConsiderPathStuckOnGround;  // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBetweenSampleToConsiderPathStuckOnGround;      // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ConsecutiveBlockedPathCountToConsiderPathStuck;    // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSafeZoneIndexToAllowTeleport;                   // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToBreakBlockingDoor;                           // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToCloseBlockingDoor;                           // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RiverbedObstacleCollisionNormalThreshold;          // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanUseSteeringWhenStuckOnIsolatedIsland;          // 0x006C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSteeringDirectionAttempts;                      // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SteeringAttemptDuration;                           // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EvaluateIsolatedIslandSteeringTime;                // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotUnstuckDigestedSkillSet">();
	}
	static class UFortAthenaAIBotUnstuckDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotUnstuckDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotUnstuckDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotUnstuckDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotUnstuckDigestedSkillSet) == 0x000080, "Wrong size on UFortAthenaAIBotUnstuckDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, bCanTeleportWhenStuck) == 0x000030, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::bCanTeleportWhenStuck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, bCanTeleportWhenStuckWithPlayerAround) == 0x000031, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::bCanTeleportWhenStuckWithPlayerAround' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, MaxDistanceSqToPlayerToTeleport) == 0x000034, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::MaxDistanceSqToPlayerToTeleport' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, PlayerToPhoebeAngleVisibilityConeToTeleport) == 0x000038, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::PlayerToPhoebeAngleVisibilityConeToTeleport' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, TimeBetweenPartialPathToConsiderPathStuck) == 0x00003C, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::TimeBetweenPartialPathToConsiderPathStuck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, ConsecutivePartialPathCountToConsiderPathStuck) == 0x000040, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::ConsecutivePartialPathCountToConsiderPathStuck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, DistanceSqBetweenBlockedPathToConsiderPathStuck) == 0x000044, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::DistanceSqBetweenBlockedPathToConsiderPathStuck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, DistanceBetweenSampleToConsiderPathStuckInWater) == 0x000048, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::DistanceBetweenSampleToConsiderPathStuckInWater' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, TimeBetweenSampleToConsiderPathStuckInWater) == 0x00004C, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::TimeBetweenSampleToConsiderPathStuckInWater' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, DistanceBetweenSampleToConsiderPathStuckOnGround) == 0x000050, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::DistanceBetweenSampleToConsiderPathStuckOnGround' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, TimeBetweenSampleToConsiderPathStuckOnGround) == 0x000054, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::TimeBetweenSampleToConsiderPathStuckOnGround' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, ConsecutiveBlockedPathCountToConsiderPathStuck) == 0x000058, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::ConsecutiveBlockedPathCountToConsiderPathStuck' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, MaxSafeZoneIndexToAllowTeleport) == 0x00005C, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::MaxSafeZoneIndexToAllowTeleport' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, TimeToBreakBlockingDoor) == 0x000060, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::TimeToBreakBlockingDoor' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, TimeToCloseBlockingDoor) == 0x000064, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::TimeToCloseBlockingDoor' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, RiverbedObstacleCollisionNormalThreshold) == 0x000068, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::RiverbedObstacleCollisionNormalThreshold' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, bCanUseSteeringWhenStuckOnIsolatedIsland) == 0x00006C, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::bCanUseSteeringWhenStuckOnIsolatedIsland' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, MaxSteeringDirectionAttempts) == 0x000070, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::MaxSteeringDirectionAttempts' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, SteeringAttemptDuration) == 0x000074, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::SteeringAttemptDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotUnstuckDigestedSkillSet, EvaluateIsolatedIslandSteeringTime) == 0x000078, "Member 'UFortAthenaAIBotUnstuckDigestedSkillSet::EvaluateIsolatedIslandSteeringTime' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_PauseVehicle
// 0x0000 (0x0070 - 0x0070)
class UFortAthenaBTService_PauseVehicle final : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_PauseVehicle">();
	}
	static class UFortAthenaBTService_PauseVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_PauseVehicle>();
	}
};
static_assert(alignof(UFortAthenaBTService_PauseVehicle) == 0x000008, "Wrong alignment on UFortAthenaBTService_PauseVehicle");
static_assert(sizeof(UFortAthenaBTService_PauseVehicle) == 0x000070, "Wrong size on UFortAthenaBTService_PauseVehicle");

// Class FortniteAI.FortQueryTest_HasNearbyEncounterGoals
// 0x0040 (0x0238 - 0x01F8)
class UFortQueryTest_HasNearbyEncounterGoals final : public UEnvQueryTest
{
public:
	uint8                                         bOnlyActiveEncounters : 1;                         // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              TestDistance;                                      // 0x0200(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_HasNearbyEncounterGoals">();
	}
	static class UFortQueryTest_HasNearbyEncounterGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_HasNearbyEncounterGoals>();
	}
};
static_assert(alignof(UFortQueryTest_HasNearbyEncounterGoals) == 0x000008, "Wrong alignment on UFortQueryTest_HasNearbyEncounterGoals");
static_assert(sizeof(UFortQueryTest_HasNearbyEncounterGoals) == 0x000238, "Wrong size on UFortQueryTest_HasNearbyEncounterGoals");
static_assert(offsetof(UFortQueryTest_HasNearbyEncounterGoals, TestDistance) == 0x000200, "Member 'UFortQueryTest_HasNearbyEncounterGoals::TestDistance' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotVehicleDigestedSkillSet
// 0x00A8 (0x00D8 - 0x0030)
class UFortAthenaAIBotVehicleDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	struct FDigestedVehicleDriving                NoMatchingVehicleDriving;                          // 0x0030(0x0098)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDigestedVehicleDrivingCategory> VehicleDrivingArray;                               // 0x00C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotVehicleDigestedSkillSet">();
	}
	static class UFortAthenaAIBotVehicleDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotVehicleDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotVehicleDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotVehicleDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotVehicleDigestedSkillSet) == 0x0000D8, "Wrong size on UFortAthenaAIBotVehicleDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotVehicleDigestedSkillSet, NoMatchingVehicleDriving) == 0x000030, "Member 'UFortAthenaAIBotVehicleDigestedSkillSet::NoMatchingVehicleDriving' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotVehicleDigestedSkillSet, VehicleDrivingArray) == 0x0000C8, "Member 'UFortAthenaAIBotVehicleDigestedSkillSet::VehicleDrivingArray' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_DebugBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_DebugBase : public UFortAthenaAISpawnerDataComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_DebugBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_DebugBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_DebugBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_DebugBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_DebugBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_DebugBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_DebugBase");

// Class FortniteAI.FortAthenaAIBotVehicleSkillSet
// 0x02F0 (0x0320 - 0x0030)
class UFortAthenaAIBotVehicleSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FVehicleDriving                        NoMatchingVehicleDriving;                          // 0x0030(0x02E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FVehicleDrivingCategory>        VehicleDrivingArray;                               // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotVehicleSkillSet">();
	}
	static class UFortAthenaAIBotVehicleSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotVehicleSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotVehicleSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotVehicleSkillSet");
static_assert(sizeof(UFortAthenaAIBotVehicleSkillSet) == 0x000320, "Wrong size on UFortAthenaAIBotVehicleSkillSet");
static_assert(offsetof(UFortAthenaAIBotVehicleSkillSet, NoMatchingVehicleDriving) == 0x000030, "Member 'UFortAthenaAIBotVehicleSkillSet::NoMatchingVehicleDriving' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotVehicleSkillSet, VehicleDrivingArray) == 0x000310, "Member 'UFortAthenaAIBotVehicleSkillSet::VehicleDrivingArray' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotWarmupDigestedSkillSet
// 0x0010 (0x0040 - 0x0030)
class UFortAthenaAIBotWarmupDigestedSkillSet final : public UFortAthenaAIBotDigestedSkillSet
{
public:
	float                                         WarmupPlayEmoteBehaviorWeight;                     // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WarmupLootAndShootBehaviorWeight;                  // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WarmupIdleBehaviorWeight;                          // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotWarmupDigestedSkillSet">();
	}
	static class UFortAthenaAIBotWarmupDigestedSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotWarmupDigestedSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotWarmupDigestedSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotWarmupDigestedSkillSet");
static_assert(sizeof(UFortAthenaAIBotWarmupDigestedSkillSet) == 0x000040, "Wrong size on UFortAthenaAIBotWarmupDigestedSkillSet");
static_assert(offsetof(UFortAthenaAIBotWarmupDigestedSkillSet, WarmupPlayEmoteBehaviorWeight) == 0x000030, "Member 'UFortAthenaAIBotWarmupDigestedSkillSet::WarmupPlayEmoteBehaviorWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotWarmupDigestedSkillSet, WarmupLootAndShootBehaviorWeight) == 0x000034, "Member 'UFortAthenaAIBotWarmupDigestedSkillSet::WarmupLootAndShootBehaviorWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotWarmupDigestedSkillSet, WarmupIdleBehaviorWeight) == 0x000038, "Member 'UFortAthenaAIBotWarmupDigestedSkillSet::WarmupIdleBehaviorWeight' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_GameplayBase
// 0x0260 (0x0290 - 0x0030)
class UFortAthenaAISpawnerDataComponent_GameplayBase : public UFortAthenaAISpawnerDataComponent
{
public:
	bool                                          bOverrideGlobalSpeedMultiplier;                    // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         GlobalSpeedMultiplier;                             // 0x0038(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CanBeConverted;                                    // 0x0060(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CanBeConvertedFromDBNO;                            // 0x0088(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ForceKillWhenUnconverted;                          // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CopyConverterSpecificRelations;                    // 0x00D8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RemoveFromAllFactions;                             // 0x0100(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ReleaseDistance;                                   // 0x0128(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CheckReleaseConditionsTimeInterval;                // 0x0150(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  AddToFactions;                                     // 0x0178(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  RemoveFromFactions;                                // 0x0198(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         PawnCullDistance;                                  // 0x01B8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TArray<class UFortAbilitySet*>                AbilitySetsForConverted;                           // 0x01E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTeleportSettings                      TeleportSettings;                                  // 0x01F0(0x0038)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bApplyTaggedNavFilters;                            // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAITaggedNavFilterData             NavFilterData;                                     // 0x0230(0x0060)(Edit, NativeAccessSpecifierPrivate)

public:
	void SetCanBeConverted(const bool bInCanBeConverted);
	void SetCopyConverterSpecificRelations(const bool bInCopyConverterSpecificRelations);

	float GetGlobalSpeedMultiplier() const;
	void PostOnSpawnedBP(class APawn* PawnAI) const;
	bool ShouldOverrideGlobalSpeedMultiplier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_GameplayBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_GameplayBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_GameplayBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_GameplayBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_GameplayBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_GameplayBase) == 0x000290, "Wrong size on UFortAthenaAISpawnerDataComponent_GameplayBase");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, bOverrideGlobalSpeedMultiplier) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::bOverrideGlobalSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, GlobalSpeedMultiplier) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::GlobalSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, CanBeConverted) == 0x000060, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::CanBeConverted' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, CanBeConvertedFromDBNO) == 0x000088, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::CanBeConvertedFromDBNO' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, ForceKillWhenUnconverted) == 0x0000B0, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::ForceKillWhenUnconverted' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, CopyConverterSpecificRelations) == 0x0000D8, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::CopyConverterSpecificRelations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, RemoveFromAllFactions) == 0x000100, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::RemoveFromAllFactions' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, ReleaseDistance) == 0x000128, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::ReleaseDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, CheckReleaseConditionsTimeInterval) == 0x000150, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::CheckReleaseConditionsTimeInterval' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, AddToFactions) == 0x000178, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::AddToFactions' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, RemoveFromFactions) == 0x000198, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::RemoveFromFactions' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, PawnCullDistance) == 0x0001B8, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::PawnCullDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, AbilitySetsForConverted) == 0x0001E0, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::AbilitySetsForConverted' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, TeleportSettings) == 0x0001F0, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::TeleportSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, bApplyTaggedNavFilters) == 0x000228, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::bApplyTaggedNavFilters' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_GameplayBase, NavFilterData) == 0x000230, "Member 'UFortAthenaAISpawnerDataComponent_GameplayBase::NavFilterData' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotGameplay
// 0x02E8 (0x0578 - 0x0290)
class UFortAthenaAISpawnerDataComponent_AIBotGameplay final : public UFortAthenaAISpawnerDataComponent_GameplayBase
{
public:
	class UFortBotNameSettings*                   NameSettings;                                      // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bRequiresUniqueNetId : 1;                          // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         CanRespawnOnDeath;                                 // 0x02A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RespawnOnDeathLocation;                            // 0x02C8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RespawnTime;                                       // 0x02F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         PawnCullDistanceAfterPlayerAggroMode;              // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EReachLocationValidationMode                  ReachLocationValidationMode;                       // 0x031C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeashLocation;                                     // 0x0320(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeashInnerRadius;                                  // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeashOuterRadius;                                  // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELeashReturnLocationMode                      LeashReturnLocationMode;                           // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAthenaPatrolPath*                  AssociatedPatrolPath;                              // 0x0348(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanInvestigateWithMeleeWeapon;                    // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyMutatorsHealthAndShieldModifiers;            // 0x0351(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSupportsTethering;                                // 0x0352(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableRenderCustomDepth;                          // 0x0353(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableGiveWeaponCheat;                           // 0x0354(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableGiveMaterialsCheat;                        // 0x0355(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_356[0x2];                                      // 0x0356(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         InnerLeashRadius;                                  // 0x0358(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         OuterLeashRadius;                                  // 0x0380(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldLeashFollowConverter;                        // 0x03A8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         LeashFollowActorUpdateRate;                        // 0x03D0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FVector                                LeashFollowActorLocalOffset;                       // 0x03F8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         SkillLevelOverride;                                // 0x0410(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldScanAroundWhenWaiting;                       // 0x0438(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldMoveTowardsConverter;                        // 0x0460(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldTeleportTowardsConverter;                    // 0x0488(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MoveTowardsConverterInnerRadius;                   // 0x04B0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MoveTowardsConverterOuterRadius;                   // 0x04D8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CanDanceWithConverter;                             // 0x0500(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         TeleportTowardsConverterDistance;                  // 0x0528(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MinDistanceFromConverterWhenTeleported;            // 0x0550(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	void SetAssociatedPatrolPath(class AFortAthenaPatrolPath* InAssociatedPatrolPath);
	void SetLeashInnerRadius(const float InLeashInnerRadius);
	void SetLeashLocation(const struct FVector& InLeashLocation);
	void SetLeashOuterRadius(const float InLeashOuterRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotGameplay">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotGameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotGameplay>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotGameplay) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotGameplay");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotGameplay) == 0x000578, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotGameplay");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, NameSettings) == 0x000290, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::NameSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, CanRespawnOnDeath) == 0x0002A0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::CanRespawnOnDeath' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, RespawnOnDeathLocation) == 0x0002C8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::RespawnOnDeathLocation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, RespawnTime) == 0x0002F0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::RespawnTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, PawnCullDistanceAfterPlayerAggroMode) == 0x000318, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::PawnCullDistanceAfterPlayerAggroMode' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, ReachLocationValidationMode) == 0x00031C, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::ReachLocationValidationMode' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, LeashLocation) == 0x000320, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::LeashLocation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, LeashInnerRadius) == 0x000338, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::LeashInnerRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, LeashOuterRadius) == 0x00033C, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::LeashOuterRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, LeashReturnLocationMode) == 0x000340, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::LeashReturnLocationMode' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, AssociatedPatrolPath) == 0x000348, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::AssociatedPatrolPath' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, bCanInvestigateWithMeleeWeapon) == 0x000350, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::bCanInvestigateWithMeleeWeapon' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, bApplyMutatorsHealthAndShieldModifiers) == 0x000351, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::bApplyMutatorsHealthAndShieldModifiers' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, bSupportsTethering) == 0x000352, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::bSupportsTethering' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, bEnableRenderCustomDepth) == 0x000353, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::bEnableRenderCustomDepth' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, bDisableGiveWeaponCheat) == 0x000354, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::bDisableGiveWeaponCheat' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, bDisableGiveMaterialsCheat) == 0x000355, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::bDisableGiveMaterialsCheat' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, InnerLeashRadius) == 0x000358, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::InnerLeashRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, OuterLeashRadius) == 0x000380, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::OuterLeashRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, ShouldLeashFollowConverter) == 0x0003A8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::ShouldLeashFollowConverter' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, LeashFollowActorUpdateRate) == 0x0003D0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::LeashFollowActorUpdateRate' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, LeashFollowActorLocalOffset) == 0x0003F8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::LeashFollowActorLocalOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, SkillLevelOverride) == 0x000410, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::SkillLevelOverride' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, ShouldScanAroundWhenWaiting) == 0x000438, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::ShouldScanAroundWhenWaiting' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, ShouldMoveTowardsConverter) == 0x000460, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::ShouldMoveTowardsConverter' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, ShouldTeleportTowardsConverter) == 0x000488, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::ShouldTeleportTowardsConverter' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, MoveTowardsConverterInnerRadius) == 0x0004B0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::MoveTowardsConverterInnerRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, MoveTowardsConverterOuterRadius) == 0x0004D8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::MoveTowardsConverterOuterRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, CanDanceWithConverter) == 0x000500, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::CanDanceWithConverter' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, TeleportTowardsConverterDistance) == 0x000528, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::TeleportTowardsConverterDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotGameplay, MinDistanceFromConverterWhenTeleported) == 0x000550, "Member 'UFortAthenaAISpawnerDataComponent_AIBotGameplay::MinDistanceFromConverterWhenTeleported' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_GoalTrackableAIObjects
// 0x0080 (0x00D0 - 0x0050)
class UFortQueryGenerator_GoalTrackableAIObjects final : public UEnvQueryGenerator
{
public:
	struct FFortAIAssignmentIdentifier            AssignmentIdentifier;                              // 0x0050(0x0030)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     SearchedActorClass;                                // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RequiredTag;                                       // 0x0088(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_GoalTrackableAIObjects">();
	}
	static class UFortQueryGenerator_GoalTrackableAIObjects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_GoalTrackableAIObjects>();
	}
};
static_assert(alignof(UFortQueryGenerator_GoalTrackableAIObjects) == 0x000008, "Wrong alignment on UFortQueryGenerator_GoalTrackableAIObjects");
static_assert(sizeof(UFortQueryGenerator_GoalTrackableAIObjects) == 0x0000D0, "Wrong size on UFortQueryGenerator_GoalTrackableAIObjects");
static_assert(offsetof(UFortQueryGenerator_GoalTrackableAIObjects, AssignmentIdentifier) == 0x000050, "Member 'UFortQueryGenerator_GoalTrackableAIObjects::AssignmentIdentifier' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_GoalTrackableAIObjects, SearchedActorClass) == 0x000080, "Member 'UFortQueryGenerator_GoalTrackableAIObjects::SearchedActorClass' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_GoalTrackableAIObjects, RequiredTag) == 0x000088, "Member 'UFortQueryGenerator_GoalTrackableAIObjects::RequiredTag' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_GoalTrackableAIObjects, SearchRadius) == 0x000090, "Member 'UFortQueryGenerator_GoalTrackableAIObjects::SearchRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_GoalTrackableAIObjects, SearchCenter) == 0x0000C8, "Member 'UFortQueryGenerator_GoalTrackableAIObjects::SearchCenter' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBotWarmupSkillSet
// 0x0078 (0x00A8 - 0x0030)
class UFortAthenaAIBotWarmupSkillSet final : public UFortAthenaAIBotSkillSet
{
public:
	struct FScalableFloat                         WarmupPlayEmoteBehaviorWeight;                     // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WarmupLootAndShootBehaviorWeight;                  // 0x0058(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WarmupIdleBehaviorWeight;                          // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBotWarmupSkillSet">();
	}
	static class UFortAthenaAIBotWarmupSkillSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBotWarmupSkillSet>();
	}
};
static_assert(alignof(UFortAthenaAIBotWarmupSkillSet) == 0x000008, "Wrong alignment on UFortAthenaAIBotWarmupSkillSet");
static_assert(sizeof(UFortAthenaAIBotWarmupSkillSet) == 0x0000A8, "Wrong size on UFortAthenaAIBotWarmupSkillSet");
static_assert(offsetof(UFortAthenaAIBotWarmupSkillSet, WarmupPlayEmoteBehaviorWeight) == 0x000030, "Member 'UFortAthenaAIBotWarmupSkillSet::WarmupPlayEmoteBehaviorWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotWarmupSkillSet, WarmupLootAndShootBehaviorWeight) == 0x000058, "Member 'UFortAthenaAIBotWarmupSkillSet::WarmupLootAndShootBehaviorWeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIBotWarmupSkillSet, WarmupIdleBehaviorWeight) == 0x000080, "Member 'UFortAthenaAIBotWarmupSkillSet::WarmupIdleBehaviorWeight' has a wrong offset!");

// Class FortniteAI.FortAthenaAIBot_EQSQueryContext_CurrentTarget
// 0x0000 (0x0028 - 0x0028)
class UFortAthenaAIBot_EQSQueryContext_CurrentTarget final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIBot_EQSQueryContext_CurrentTarget">();
	}
	static class UFortAthenaAIBot_EQSQueryContext_CurrentTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIBot_EQSQueryContext_CurrentTarget>();
	}
};
static_assert(alignof(UFortAthenaAIBot_EQSQueryContext_CurrentTarget) == 0x000008, "Wrong alignment on UFortAthenaAIBot_EQSQueryContext_CurrentTarget");
static_assert(sizeof(UFortAthenaAIBot_EQSQueryContext_CurrentTarget) == 0x000028, "Wrong size on UFortAthenaAIBot_EQSQueryContext_CurrentTarget");

// Class FortniteAI.FortAthenaAIControllerInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAthenaAIControllerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIControllerInterface">();
	}
	static class IFortAthenaAIControllerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAthenaAIControllerInterface>();
	}
};
static_assert(alignof(IFortAthenaAIControllerInterface) == 0x000008, "Wrong alignment on IFortAthenaAIControllerInterface");
static_assert(sizeof(IFortAthenaAIControllerInterface) == 0x000028, "Wrong size on IFortAthenaAIControllerInterface");

// Class FortniteAI.FortAthenaAICoverComponent
// 0x0038 (0x00D8 - 0x00A0)
class UFortAthenaAICoverComponent final : public UControllerComponent
{
public:
	TSubclassOf<class UNavigationQueryFilter>     CoverPositionFilterClass;                          // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CoverBoxExtent;                                    // 0x00A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverOffset;                                       // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          CachedController;                                  // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ABuildingActor>          LastBuildingActorUsedForCover;                     // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAICoverComponent">();
	}
	static class UFortAthenaAICoverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAICoverComponent>();
	}
};
static_assert(alignof(UFortAthenaAICoverComponent) == 0x000008, "Wrong alignment on UFortAthenaAICoverComponent");
static_assert(sizeof(UFortAthenaAICoverComponent) == 0x0000D8, "Wrong size on UFortAthenaAICoverComponent");
static_assert(offsetof(UFortAthenaAICoverComponent, CoverPositionFilterClass) == 0x0000A0, "Member 'UFortAthenaAICoverComponent::CoverPositionFilterClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAICoverComponent, CoverBoxExtent) == 0x0000A8, "Member 'UFortAthenaAICoverComponent::CoverBoxExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAICoverComponent, CoverOffset) == 0x0000C0, "Member 'UFortAthenaAICoverComponent::CoverOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAICoverComponent, CachedController) == 0x0000C8, "Member 'UFortAthenaAICoverComponent::CachedController' has a wrong offset!");
static_assert(offsetof(UFortAthenaAICoverComponent, LastBuildingActorUsedForCover) == 0x0000D0, "Member 'UFortAthenaAICoverComponent::LastBuildingActorUsedForCover' has a wrong offset!");

// Class FortniteAI.BlackboardKeyAccessValidator
// 0x0000 (0x0028 - 0x0028)
class UBlackboardKeyAccessValidator final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackboardKeyAccessValidator">();
	}
	static class UBlackboardKeyAccessValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackboardKeyAccessValidator>();
	}
};
static_assert(alignof(UBlackboardKeyAccessValidator) == 0x000008, "Wrong alignment on UBlackboardKeyAccessValidator");
static_assert(sizeof(UBlackboardKeyAccessValidator) == 0x000028, "Wrong size on UBlackboardKeyAccessValidator");

// Class FortniteAI.FortAthenaBTService_Escape
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTService_Escape final : public UBTService
{
public:
	class FName                                   EscapeKeyName;                                     // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Escape">();
	}
	static class UFortAthenaBTService_Escape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Escape>();
	}
};
static_assert(alignof(UFortAthenaBTService_Escape) == 0x000008, "Wrong alignment on UFortAthenaBTService_Escape");
static_assert(sizeof(UFortAthenaBTService_Escape) == 0x000078, "Wrong size on UFortAthenaBTService_Escape");
static_assert(offsetof(UFortAthenaBTService_Escape, EscapeKeyName) == 0x000070, "Member 'UFortAthenaBTService_Escape::EscapeKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIEvaluatorComponent
// 0x0020 (0x00C0 - 0x00A0)
class UFortAthenaAIEvaluatorComponent final : public UActorComponent
{
public:
	TArray<struct FMovementEvaluatorInfo>         MovementEvaluatorInfo;                             // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UFortAthenaAIEvaluator*>         AIEvaluators;                                      // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIEvaluatorComponent">();
	}
	static class UFortAthenaAIEvaluatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIEvaluatorComponent>();
	}
};
static_assert(alignof(UFortAthenaAIEvaluatorComponent) == 0x000008, "Wrong alignment on UFortAthenaAIEvaluatorComponent");
static_assert(sizeof(UFortAthenaAIEvaluatorComponent) == 0x0000C0, "Wrong size on UFortAthenaAIEvaluatorComponent");
static_assert(offsetof(UFortAthenaAIEvaluatorComponent, MovementEvaluatorInfo) == 0x0000A0, "Member 'UFortAthenaAIEvaluatorComponent::MovementEvaluatorInfo' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluatorComponent, AIEvaluators) == 0x0000B0, "Member 'UFortAthenaAIEvaluatorComponent::AIEvaluators' has a wrong offset!");

// Class FortniteAI.FortNavArea_Danger
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_Danger final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_Danger">();
	}
	static class UFortNavArea_Danger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_Danger>();
	}
};
static_assert(alignof(UFortNavArea_Danger) == 0x000008, "Wrong alignment on UFortNavArea_Danger");
static_assert(sizeof(UFortNavArea_Danger) == 0x000050, "Wrong size on UFortNavArea_Danger");

// Class FortniteAI.FortAthenaAIEvaluator_DormantUntilPhase
// 0x0090 (0x00E8 - 0x0058)
class UFortAthenaAIEvaluator_DormantUntilPhase final : public UFortAthenaAIEvaluator
{
public:
	struct FScalableFloat                         bIsEnabled;                                        // 0x0058(0x0028)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bDisabledInCreative;                               // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAthenaGamePhaseStep                          RequiredGamePhaseStep;                             // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         DelayAfterPhase;                                   // 0x0088(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RandomDeviationAfterPhase;                         // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleGamePhaseStepChanged(const TScriptInterface<class IFortSafeZoneInterface>& SafeZoneInterface, const EAthenaGamePhaseStep GamePhaseStep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIEvaluator_DormantUntilPhase">();
	}
	static class UFortAthenaAIEvaluator_DormantUntilPhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIEvaluator_DormantUntilPhase>();
	}
};
static_assert(alignof(UFortAthenaAIEvaluator_DormantUntilPhase) == 0x000008, "Wrong alignment on UFortAthenaAIEvaluator_DormantUntilPhase");
static_assert(sizeof(UFortAthenaAIEvaluator_DormantUntilPhase) == 0x0000E8, "Wrong size on UFortAthenaAIEvaluator_DormantUntilPhase");
static_assert(offsetof(UFortAthenaAIEvaluator_DormantUntilPhase, bIsEnabled) == 0x000058, "Member 'UFortAthenaAIEvaluator_DormantUntilPhase::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_DormantUntilPhase, bDisabledInCreative) == 0x000080, "Member 'UFortAthenaAIEvaluator_DormantUntilPhase::bDisabledInCreative' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_DormantUntilPhase, RequiredGamePhaseStep) == 0x000081, "Member 'UFortAthenaAIEvaluator_DormantUntilPhase::RequiredGamePhaseStep' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_DormantUntilPhase, DelayAfterPhase) == 0x000088, "Member 'UFortAthenaAIEvaluator_DormantUntilPhase::DelayAfterPhase' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_DormantUntilPhase, RandomDeviationAfterPhase) == 0x0000B0, "Member 'UFortAthenaAIEvaluator_DormantUntilPhase::RandomDeviationAfterPhase' has a wrong offset!");

// Class FortniteAI.FortAthenaAIEvaluator_FollowGroupLeader
// 0x0028 (0x0240 - 0x0218)
class UFortAthenaAIEvaluator_FollowGroupLeader final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   FollowGroupLeaderStatusKeyName;                    // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FollowGroupLeaderMovementStateKeyName;             // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FollowGroupLeaderDestinationKeyName;               // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TooFarFromLeaderKeyName;                           // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          CachedAIController;                                // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortPawnComponent_AIGroup*             CachedAIGroupComponent;                            // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIEvaluator_FollowGroupLeader">();
	}
	static class UFortAthenaAIEvaluator_FollowGroupLeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIEvaluator_FollowGroupLeader>();
	}
};
static_assert(alignof(UFortAthenaAIEvaluator_FollowGroupLeader) == 0x000008, "Wrong alignment on UFortAthenaAIEvaluator_FollowGroupLeader");
static_assert(sizeof(UFortAthenaAIEvaluator_FollowGroupLeader) == 0x000240, "Wrong size on UFortAthenaAIEvaluator_FollowGroupLeader");
static_assert(offsetof(UFortAthenaAIEvaluator_FollowGroupLeader, FollowGroupLeaderStatusKeyName) == 0x000218, "Member 'UFortAthenaAIEvaluator_FollowGroupLeader::FollowGroupLeaderStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_FollowGroupLeader, FollowGroupLeaderMovementStateKeyName) == 0x00021C, "Member 'UFortAthenaAIEvaluator_FollowGroupLeader::FollowGroupLeaderMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_FollowGroupLeader, FollowGroupLeaderDestinationKeyName) == 0x000220, "Member 'UFortAthenaAIEvaluator_FollowGroupLeader::FollowGroupLeaderDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_FollowGroupLeader, TooFarFromLeaderKeyName) == 0x000224, "Member 'UFortAthenaAIEvaluator_FollowGroupLeader::TooFarFromLeaderKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_FollowGroupLeader, CachedAIController) == 0x000230, "Member 'UFortAthenaAIEvaluator_FollowGroupLeader::CachedAIController' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_FollowGroupLeader, CachedAIGroupComponent) == 0x000238, "Member 'UFortAthenaAIEvaluator_FollowGroupLeader::CachedAIGroupComponent' has a wrong offset!");

// Class FortniteAI.FortNavArea_PlayerBuiltSmashable
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_PlayerBuiltSmashable final : public UFortNavArea_DefaultSmashable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_PlayerBuiltSmashable">();
	}
	static class UFortNavArea_PlayerBuiltSmashable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_PlayerBuiltSmashable>();
	}
};
static_assert(alignof(UFortNavArea_PlayerBuiltSmashable) == 0x000008, "Wrong alignment on UFortNavArea_PlayerBuiltSmashable");
static_assert(sizeof(UFortNavArea_PlayerBuiltSmashable) == 0x000050, "Wrong size on UFortNavArea_PlayerBuiltSmashable");

// Class FortniteAI.FortAthenaBTService_Revive
// 0x0028 (0x0098 - 0x0070)
class UFortAthenaBTService_Revive final : public UBTService
{
public:
	class FName                                   ReviveTargetKeyName;                               // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExecutionStatusName;                               // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MoveToPathMovementStateName;                       // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InteractionExecutionStatusName;                    // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InteractionContextInfoName;                        // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Revive">();
	}
	static class UFortAthenaBTService_Revive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Revive>();
	}
};
static_assert(alignof(UFortAthenaBTService_Revive) == 0x000008, "Wrong alignment on UFortAthenaBTService_Revive");
static_assert(sizeof(UFortAthenaBTService_Revive) == 0x000098, "Wrong size on UFortAthenaBTService_Revive");
static_assert(offsetof(UFortAthenaBTService_Revive, ReviveTargetKeyName) == 0x000070, "Member 'UFortAthenaBTService_Revive::ReviveTargetKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Revive, ExecutionStatusName) == 0x000078, "Member 'UFortAthenaBTService_Revive::ExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Revive, MoveToPathMovementStateName) == 0x000080, "Member 'UFortAthenaBTService_Revive::MoveToPathMovementStateName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Revive, InteractionExecutionStatusName) == 0x000088, "Member 'UFortAthenaBTService_Revive::InteractionExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Revive, InteractionContextInfoName) == 0x000090, "Member 'UFortAthenaBTService_Revive::InteractionContextInfoName' has a wrong offset!");

// Class FortniteAI.FortAthenaAIEvaluator_Leash
// 0x0028 (0x00B0 - 0x0088)
class UFortAthenaAIEvaluator_Leash final : public UFortAthenaAIBotEvaluator
{
public:
	class FName                                   GoalIsInsideLeashKeyName;                          // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AIIsInsideLeashKeyName;                            // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          CachedAIController;                                // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaLeashComponent*              CachedLeashComponent;                              // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIGoalComponent*                   CachedAIGoalComponent;                             // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIEvaluator_Leash">();
	}
	static class UFortAthenaAIEvaluator_Leash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIEvaluator_Leash>();
	}
};
static_assert(alignof(UFortAthenaAIEvaluator_Leash) == 0x000008, "Wrong alignment on UFortAthenaAIEvaluator_Leash");
static_assert(sizeof(UFortAthenaAIEvaluator_Leash) == 0x0000B0, "Wrong size on UFortAthenaAIEvaluator_Leash");
static_assert(offsetof(UFortAthenaAIEvaluator_Leash, GoalIsInsideLeashKeyName) == 0x000088, "Member 'UFortAthenaAIEvaluator_Leash::GoalIsInsideLeashKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_Leash, AIIsInsideLeashKeyName) == 0x000090, "Member 'UFortAthenaAIEvaluator_Leash::AIIsInsideLeashKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_Leash, CachedAIController) == 0x000098, "Member 'UFortAthenaAIEvaluator_Leash::CachedAIController' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_Leash, CachedLeashComponent) == 0x0000A0, "Member 'UFortAthenaAIEvaluator_Leash::CachedLeashComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_Leash, CachedAIGoalComponent) == 0x0000A8, "Member 'UFortAthenaAIEvaluator_Leash::CachedAIGoalComponent' has a wrong offset!");

// Class FortniteAI.FortNavArea_CheapObstacle
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_CheapObstacle : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_CheapObstacle">();
	}
	static class UFortNavArea_CheapObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_CheapObstacle>();
	}
};
static_assert(alignof(UFortNavArea_CheapObstacle) == 0x000008, "Wrong alignment on UFortNavArea_CheapObstacle");
static_assert(sizeof(UFortNavArea_CheapObstacle) == 0x000050, "Wrong size on UFortNavArea_CheapObstacle");

// Class FortniteAI.FortQueryTest_GoalDistanceRanges
// 0x0028 (0x0248 - 0x0220)
class UFortQueryTest_GoalDistanceRanges final : public UFortQueryTest_GoalBase
{
public:
	EDistanceMode                                 DistanceMode;                                      // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvTestDistance                              ScreeningTestMode;                                 // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvTestDistance                              TestMode;                                          // 0x0231(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_232[0x6];                                      // 0x0232(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGoalDistanceData>              GoalDistanceDataRanges;                            // 0x0238(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalDistanceRanges">();
	}
	static class UFortQueryTest_GoalDistanceRanges* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalDistanceRanges>();
	}
};
static_assert(alignof(UFortQueryTest_GoalDistanceRanges) == 0x000008, "Wrong alignment on UFortQueryTest_GoalDistanceRanges");
static_assert(sizeof(UFortQueryTest_GoalDistanceRanges) == 0x000248, "Wrong size on UFortQueryTest_GoalDistanceRanges");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, DistanceMode) == 0x000220, "Member 'UFortQueryTest_GoalDistanceRanges::DistanceMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, DistanceTo) == 0x000228, "Member 'UFortQueryTest_GoalDistanceRanges::DistanceTo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, ScreeningTestMode) == 0x000230, "Member 'UFortQueryTest_GoalDistanceRanges::ScreeningTestMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, TestMode) == 0x000231, "Member 'UFortQueryTest_GoalDistanceRanges::TestMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, GoalDistanceDataRanges) == 0x000238, "Member 'UFortQueryTest_GoalDistanceRanges::GoalDistanceDataRanges' has a wrong offset!");

// Class FortniteAI.FortAthenaAIEvaluator_NearbyActorsPerception
// 0x01B8 (0x0210 - 0x0058)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAthenaAIEvaluator_NearbyActorsPerception : public UFortAthenaAIEvaluator
{
public:
	class FName                                   FoundNearbyActorKeyName;                           // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         MinimumUpdateInterval;                             // 0x0060(0x0028)(Edit, NativeAccessSpecifierPrivate)
	int32                                         RequiredTypes;                                     // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         MinimumDistanceToActors;                           // 0x0090(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TArray<ETeamAttitude>                         RequiredAttitudes;                                 // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bRequireLOS;                                       // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      RequiredTagsQuery;                                 // 0x00D0(0x0048)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0xF0];                                     // 0x0118(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIEvaluator_NearbyActorsPerception">();
	}
	static class UFortAthenaAIEvaluator_NearbyActorsPerception* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIEvaluator_NearbyActorsPerception>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAthenaAIEvaluator_NearbyActorsPerception) == 0x000010, "Wrong alignment on UFortAthenaAIEvaluator_NearbyActorsPerception");
static_assert(sizeof(UFortAthenaAIEvaluator_NearbyActorsPerception) == 0x000210, "Wrong size on UFortAthenaAIEvaluator_NearbyActorsPerception");
static_assert(offsetof(UFortAthenaAIEvaluator_NearbyActorsPerception, FoundNearbyActorKeyName) == 0x000058, "Member 'UFortAthenaAIEvaluator_NearbyActorsPerception::FoundNearbyActorKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_NearbyActorsPerception, MinimumUpdateInterval) == 0x000060, "Member 'UFortAthenaAIEvaluator_NearbyActorsPerception::MinimumUpdateInterval' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_NearbyActorsPerception, RequiredTypes) == 0x000088, "Member 'UFortAthenaAIEvaluator_NearbyActorsPerception::RequiredTypes' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_NearbyActorsPerception, MinimumDistanceToActors) == 0x000090, "Member 'UFortAthenaAIEvaluator_NearbyActorsPerception::MinimumDistanceToActors' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_NearbyActorsPerception, RequiredAttitudes) == 0x0000B8, "Member 'UFortAthenaAIEvaluator_NearbyActorsPerception::RequiredAttitudes' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_NearbyActorsPerception, bRequireLOS) == 0x0000C8, "Member 'UFortAthenaAIEvaluator_NearbyActorsPerception::bRequireLOS' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIEvaluator_NearbyActorsPerception, RequiredTagsQuery) == 0x0000D0, "Member 'UFortAthenaAIEvaluator_NearbyActorsPerception::RequiredTagsQuery' has a wrong offset!");

// Class FortniteAI.FortAthenaAIEvaluator_SpeechBubble
// 0x0000 (0x0210 - 0x0210)
class UFortAthenaAIEvaluator_SpeechBubble final : public UFortAthenaAIEvaluator_NearbyActorsPerception
{
public:
	class UFortPawnComponent_SpeechBubble*        CachedSpeechBubbleComponent;                       // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIEvaluator_SpeechBubble">();
	}
	static class UFortAthenaAIEvaluator_SpeechBubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIEvaluator_SpeechBubble>();
	}
};
static_assert(alignof(UFortAthenaAIEvaluator_SpeechBubble) == 0x000010, "Wrong alignment on UFortAthenaAIEvaluator_SpeechBubble");
static_assert(sizeof(UFortAthenaAIEvaluator_SpeechBubble) == 0x000210, "Wrong size on UFortAthenaAIEvaluator_SpeechBubble");
static_assert(offsetof(UFortAthenaAIEvaluator_SpeechBubble, CachedSpeechBubbleComponent) == 0x000208, "Member 'UFortAthenaAIEvaluator_SpeechBubble::CachedSpeechBubbleComponent' has a wrong offset!");

// Class FortniteAI.FortAthenaAILeashVolume
// 0x0020 (0x02C8 - 0x02A8)
class AFortAthenaAILeashVolume final : public AVolume
{
public:
	struct FVector                                ProjectExtent;                                     // 0x02A8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IsInsideTolerance;                                 // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAILeashVolume">();
	}
	static class AFortAthenaAILeashVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaAILeashVolume>();
	}
};
static_assert(alignof(AFortAthenaAILeashVolume) == 0x000008, "Wrong alignment on AFortAthenaAILeashVolume");
static_assert(sizeof(AFortAthenaAILeashVolume) == 0x0002C8, "Wrong size on AFortAthenaAILeashVolume");
static_assert(offsetof(AFortAthenaAILeashVolume, ProjectExtent) == 0x0002A8, "Member 'AFortAthenaAILeashVolume::ProjectExtent' has a wrong offset!");
static_assert(offsetof(AFortAthenaAILeashVolume, IsInsideTolerance) == 0x0002C0, "Member 'AFortAthenaAILeashVolume::IsInsideTolerance' has a wrong offset!");

// Class FortniteAI.FortAthenaAILODSettingsContainer
// 0x00A0 (0x00C8 - 0x0028)
class UFortAthenaAILODSettingsContainer final : public UObject
{
public:
	TMap<class UClass*, TScriptInterface<class IFortAthenaAILODSettings>> ClassToSettings;                                   // 0x0028(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UFortAthenaAILODSettings_AIEvaluator>> LODSettings_AIEvaluators;                          // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UFortAthenaAILODSettings_CharacterMovement>> LODSettings_CharacterMovement;                     // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UFortAthenaAILODSettings_FortWeaponRanged>> LODSettings_FortWeaponRanged;                      // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UFortAthenaAILODSettings_GenericTickingObject>> LODSettings_GenericTickingObject;                  // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortAIDirectorLODAIConfig> FortAIDirectorLODConfig;                           // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAIDirectorLODAIConfig*             FortAIDirectorObjectLODConfig;                     // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAILODSettingsContainer">();
	}
	static class UFortAthenaAILODSettingsContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAILODSettingsContainer>();
	}
};
static_assert(alignof(UFortAthenaAILODSettingsContainer) == 0x000008, "Wrong alignment on UFortAthenaAILODSettingsContainer");
static_assert(sizeof(UFortAthenaAILODSettingsContainer) == 0x0000C8, "Wrong size on UFortAthenaAILODSettingsContainer");
static_assert(offsetof(UFortAthenaAILODSettingsContainer, ClassToSettings) == 0x000028, "Member 'UFortAthenaAILODSettingsContainer::ClassToSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettingsContainer, LODSettings_AIEvaluators) == 0x000078, "Member 'UFortAthenaAILODSettingsContainer::LODSettings_AIEvaluators' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettingsContainer, LODSettings_CharacterMovement) == 0x000088, "Member 'UFortAthenaAILODSettingsContainer::LODSettings_CharacterMovement' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettingsContainer, LODSettings_FortWeaponRanged) == 0x000098, "Member 'UFortAthenaAILODSettingsContainer::LODSettings_FortWeaponRanged' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettingsContainer, LODSettings_GenericTickingObject) == 0x0000A8, "Member 'UFortAthenaAILODSettingsContainer::LODSettings_GenericTickingObject' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettingsContainer, FortAIDirectorLODConfig) == 0x0000B8, "Member 'UFortAthenaAILODSettingsContainer::FortAIDirectorLODConfig' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettingsContainer, FortAIDirectorObjectLODConfig) == 0x0000C0, "Member 'UFortAthenaAILODSettingsContainer::FortAIDirectorObjectLODConfig' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_Crouch
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTService_Crouch final : public UBTService
{
public:
	class FName                                   CrouchExecutionStatusName;                         // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Crouch">();
	}
	static class UFortAthenaBTService_Crouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Crouch>();
	}
};
static_assert(alignof(UFortAthenaBTService_Crouch) == 0x000008, "Wrong alignment on UFortAthenaBTService_Crouch");
static_assert(sizeof(UFortAthenaBTService_Crouch) == 0x000078, "Wrong size on UFortAthenaBTService_Crouch");
static_assert(offsetof(UFortAthenaBTService_Crouch, CrouchExecutionStatusName) == 0x000070, "Member 'UFortAthenaBTService_Crouch::CrouchExecutionStatusName' has a wrong offset!");

// Class FortniteAI.FortAthenaAILODComponent
// 0x0048 (0x00E8 - 0x00A0)
class UFortAthenaAILODComponent final : public UActorComponent
{
public:
	EFortAILODLevel                               CurrentFortAILODLevel;                             // 0x00A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x2];                                       // 0x00A1(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_A3_0 : 1;                                   // 0x00A3(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bCouldBeVisibleToPlayers : 1;                      // 0x00A3(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPawn*                              CachedFortPawn;                                    // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAILODSettingsContainer*      AILODSettingsContainer;                            // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentFortAILODLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAILODComponent">();
	}
	static class UFortAthenaAILODComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAILODComponent>();
	}
};
static_assert(alignof(UFortAthenaAILODComponent) == 0x000008, "Wrong alignment on UFortAthenaAILODComponent");
static_assert(sizeof(UFortAthenaAILODComponent) == 0x0000E8, "Wrong size on UFortAthenaAILODComponent");
static_assert(offsetof(UFortAthenaAILODComponent, CurrentFortAILODLevel) == 0x0000A0, "Member 'UFortAthenaAILODComponent::CurrentFortAILODLevel' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODComponent, CachedFortPawn) == 0x0000A8, "Member 'UFortAthenaAILODComponent::CachedFortPawn' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODComponent, AILODSettingsContainer) == 0x0000B0, "Member 'UFortAthenaAILODComponent::AILODSettingsContainer' has a wrong offset!");

// Class FortniteAI.FortAthenaAILODSettings
// 0x0000 (0x0028 - 0x0028)
class IFortAthenaAILODSettings final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAILODSettings">();
	}
	static class IFortAthenaAILODSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAthenaAILODSettings>();
	}
};
static_assert(alignof(IFortAthenaAILODSettings) == 0x000008, "Wrong alignment on IFortAthenaAILODSettings");
static_assert(sizeof(IFortAthenaAILODSettings) == 0x000028, "Wrong size on IFortAthenaAILODSettings");

// Class FortniteAI.FortAthenaAILODSettings_AIEvaluator
// 0x0288 (0x02B0 - 0x0028)
class UFortAthenaAILODSettings_AIEvaluator final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UFortAthenaAIEvaluator>> SystemClasses;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_AIEvaluator          BelowLowerLODSettings;                             // 0x0040(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_AIEvaluator          LowerLODSettings;                                  // 0x00A8(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_AIEvaluator          AboveLowerLODSettings;                             // 0x0110(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_AIEvaluator          BelowNormalLODSettings;                            // 0x0178(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_AIEvaluator          NormalLODSettings;                                 // 0x01E0(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_AIEvaluator          AboveNormalLODSettings;                            // 0x0248(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAILODSettings_AIEvaluator">();
	}
	static class UFortAthenaAILODSettings_AIEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAILODSettings_AIEvaluator>();
	}
};
static_assert(alignof(UFortAthenaAILODSettings_AIEvaluator) == 0x000008, "Wrong alignment on UFortAthenaAILODSettings_AIEvaluator");
static_assert(sizeof(UFortAthenaAILODSettings_AIEvaluator) == 0x0002B0, "Wrong size on UFortAthenaAILODSettings_AIEvaluator");
static_assert(offsetof(UFortAthenaAILODSettings_AIEvaluator, SystemClasses) == 0x000030, "Member 'UFortAthenaAILODSettings_AIEvaluator::SystemClasses' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_AIEvaluator, BelowLowerLODSettings) == 0x000040, "Member 'UFortAthenaAILODSettings_AIEvaluator::BelowLowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_AIEvaluator, LowerLODSettings) == 0x0000A8, "Member 'UFortAthenaAILODSettings_AIEvaluator::LowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_AIEvaluator, AboveLowerLODSettings) == 0x000110, "Member 'UFortAthenaAILODSettings_AIEvaluator::AboveLowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_AIEvaluator, BelowNormalLODSettings) == 0x000178, "Member 'UFortAthenaAILODSettings_AIEvaluator::BelowNormalLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_AIEvaluator, NormalLODSettings) == 0x0001E0, "Member 'UFortAthenaAILODSettings_AIEvaluator::NormalLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_AIEvaluator, AboveNormalLODSettings) == 0x000248, "Member 'UFortAthenaAILODSettings_AIEvaluator::AboveNormalLODSettings' has a wrong offset!");

// Class FortniteAI.FortAthenaAILODSettings_CharacterMovement
// 0x0948 (0x0970 - 0x0028)
class UFortAthenaAILODSettings_CharacterMovement final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UFortMovementComp_Character>> SystemClasses;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_CharacterMovement    BelowLowerLODSettings;                             // 0x0040(0x0188)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_CharacterMovement    LowerLODSettings;                                  // 0x01C8(0x0188)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_CharacterMovement    AboveLowerLODSettings;                             // 0x0350(0x0188)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_CharacterMovement    BelowNormalLODSettings;                            // 0x04D8(0x0188)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_CharacterMovement    NormalLODSettings;                                 // 0x0660(0x0188)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_CharacterMovement    AboveNormalLODSettings;                            // 0x07E8(0x0188)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAILODSettings_CharacterMovement">();
	}
	static class UFortAthenaAILODSettings_CharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAILODSettings_CharacterMovement>();
	}
};
static_assert(alignof(UFortAthenaAILODSettings_CharacterMovement) == 0x000008, "Wrong alignment on UFortAthenaAILODSettings_CharacterMovement");
static_assert(sizeof(UFortAthenaAILODSettings_CharacterMovement) == 0x000970, "Wrong size on UFortAthenaAILODSettings_CharacterMovement");
static_assert(offsetof(UFortAthenaAILODSettings_CharacterMovement, SystemClasses) == 0x000030, "Member 'UFortAthenaAILODSettings_CharacterMovement::SystemClasses' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_CharacterMovement, BelowLowerLODSettings) == 0x000040, "Member 'UFortAthenaAILODSettings_CharacterMovement::BelowLowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_CharacterMovement, LowerLODSettings) == 0x0001C8, "Member 'UFortAthenaAILODSettings_CharacterMovement::LowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_CharacterMovement, AboveLowerLODSettings) == 0x000350, "Member 'UFortAthenaAILODSettings_CharacterMovement::AboveLowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_CharacterMovement, BelowNormalLODSettings) == 0x0004D8, "Member 'UFortAthenaAILODSettings_CharacterMovement::BelowNormalLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_CharacterMovement, NormalLODSettings) == 0x000660, "Member 'UFortAthenaAILODSettings_CharacterMovement::NormalLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_CharacterMovement, AboveNormalLODSettings) == 0x0007E8, "Member 'UFortAthenaAILODSettings_CharacterMovement::AboveNormalLODSettings' has a wrong offset!");

// Class FortniteAI.FortNavArea_Clamber
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_Clamber final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_Clamber">();
	}
	static class UFortNavArea_Clamber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_Clamber>();
	}
};
static_assert(alignof(UFortNavArea_Clamber) == 0x000008, "Wrong alignment on UFortNavArea_Clamber");
static_assert(sizeof(UFortNavArea_Clamber) == 0x000050, "Wrong size on UFortNavArea_Clamber");

// Class FortniteAI.FortAthenaAILODSettings_FortWeaponRanged
// 0x0288 (0x02B0 - 0x0028)
class UFortAthenaAILODSettings_FortWeaponRanged final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AFortWeaponRanged>>  SystemClasses;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_FortWeaponRanged     BelowLowerLODSettings;                             // 0x0040(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_FortWeaponRanged     LowerLODSettings;                                  // 0x00A8(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_FortWeaponRanged     AboveLowerLODSettings;                             // 0x0110(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_FortWeaponRanged     BelowNormalLODSettings;                            // 0x0178(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_FortWeaponRanged     NormalLODSettings;                                 // 0x01E0(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_FortWeaponRanged     AboveNormalLODSettings;                            // 0x0248(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAILODSettings_FortWeaponRanged">();
	}
	static class UFortAthenaAILODSettings_FortWeaponRanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAILODSettings_FortWeaponRanged>();
	}
};
static_assert(alignof(UFortAthenaAILODSettings_FortWeaponRanged) == 0x000008, "Wrong alignment on UFortAthenaAILODSettings_FortWeaponRanged");
static_assert(sizeof(UFortAthenaAILODSettings_FortWeaponRanged) == 0x0002B0, "Wrong size on UFortAthenaAILODSettings_FortWeaponRanged");
static_assert(offsetof(UFortAthenaAILODSettings_FortWeaponRanged, SystemClasses) == 0x000030, "Member 'UFortAthenaAILODSettings_FortWeaponRanged::SystemClasses' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_FortWeaponRanged, BelowLowerLODSettings) == 0x000040, "Member 'UFortAthenaAILODSettings_FortWeaponRanged::BelowLowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_FortWeaponRanged, LowerLODSettings) == 0x0000A8, "Member 'UFortAthenaAILODSettings_FortWeaponRanged::LowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_FortWeaponRanged, AboveLowerLODSettings) == 0x000110, "Member 'UFortAthenaAILODSettings_FortWeaponRanged::AboveLowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_FortWeaponRanged, BelowNormalLODSettings) == 0x000178, "Member 'UFortAthenaAILODSettings_FortWeaponRanged::BelowNormalLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_FortWeaponRanged, NormalLODSettings) == 0x0001E0, "Member 'UFortAthenaAILODSettings_FortWeaponRanged::NormalLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_FortWeaponRanged, AboveNormalLODSettings) == 0x000248, "Member 'UFortAthenaAILODSettings_FortWeaponRanged::AboveNormalLODSettings' has a wrong offset!");

// Class FortniteAI.FortInfluenceMap
// 0x00D0 (0x00F8 - 0x0028)
class UFortInfluenceMap final : public UObject
{
public:
	uint8                                         Pad_28[0xB8];                                      // 0x0028(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortNavigationGraph*                   GraphData;                                         // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void K2_AddInfluenceSource(class UObject* WorldContext, const struct FVector& Position, const class FString& SourceName, float Strength);
	static void K2_GetInfluenceSourcePositions(class UObject* WorldContext, TArray<struct FVector>* InfluenceSourcePositions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInfluenceMap">();
	}
	static class UFortInfluenceMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortInfluenceMap>();
	}
};
static_assert(alignof(UFortInfluenceMap) == 0x000008, "Wrong alignment on UFortInfluenceMap");
static_assert(sizeof(UFortInfluenceMap) == 0x0000F8, "Wrong size on UFortInfluenceMap");
static_assert(offsetof(UFortInfluenceMap, GraphData) == 0x0000E0, "Member 'UFortInfluenceMap::GraphData' has a wrong offset!");

// Class FortniteAI.FortAthenaAILODSettings_GenericTickingObject
// 0x0168 (0x0190 - 0x0028)
class UFortAthenaAILODSettings_GenericTickingObject final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UObject>>            SystemClasses;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_GenericTickingObject BelowLowerLODSettings;                             // 0x0040(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_GenericTickingObject LowerLODSettings;                                  // 0x0078(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_GenericTickingObject AboveLowerLODSettings;                             // 0x00B0(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_GenericTickingObject BelowNormalLODSettings;                            // 0x00E8(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_GenericTickingObject NormalLODSettings;                                 // 0x0120(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortAILODSetting_GenericTickingObject AboveNormalLODSettings;                            // 0x0158(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAILODSettings_GenericTickingObject">();
	}
	static class UFortAthenaAILODSettings_GenericTickingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAILODSettings_GenericTickingObject>();
	}
};
static_assert(alignof(UFortAthenaAILODSettings_GenericTickingObject) == 0x000008, "Wrong alignment on UFortAthenaAILODSettings_GenericTickingObject");
static_assert(sizeof(UFortAthenaAILODSettings_GenericTickingObject) == 0x000190, "Wrong size on UFortAthenaAILODSettings_GenericTickingObject");
static_assert(offsetof(UFortAthenaAILODSettings_GenericTickingObject, SystemClasses) == 0x000030, "Member 'UFortAthenaAILODSettings_GenericTickingObject::SystemClasses' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_GenericTickingObject, BelowLowerLODSettings) == 0x000040, "Member 'UFortAthenaAILODSettings_GenericTickingObject::BelowLowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_GenericTickingObject, LowerLODSettings) == 0x000078, "Member 'UFortAthenaAILODSettings_GenericTickingObject::LowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_GenericTickingObject, AboveLowerLODSettings) == 0x0000B0, "Member 'UFortAthenaAILODSettings_GenericTickingObject::AboveLowerLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_GenericTickingObject, BelowNormalLODSettings) == 0x0000E8, "Member 'UFortAthenaAILODSettings_GenericTickingObject::BelowNormalLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_GenericTickingObject, NormalLODSettings) == 0x000120, "Member 'UFortAthenaAILODSettings_GenericTickingObject::NormalLODSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAILODSettings_GenericTickingObject, AboveNormalLODSettings) == 0x000158, "Member 'UFortAthenaAILODSettings_GenericTickingObject::AboveNormalLODSettings' has a wrong offset!");

// Class FortniteAI.FortAthenaAIObjectTracker
// 0x0078 (0x00A8 - 0x0030)
class UFortAthenaAIObjectTracker final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FAITrackedObjectsSet> TrackedObjects;                                    // 0x0058(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIObjectTracker">();
	}
	static class UFortAthenaAIObjectTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIObjectTracker>();
	}
};
static_assert(alignof(UFortAthenaAIObjectTracker) == 0x000008, "Wrong alignment on UFortAthenaAIObjectTracker");
static_assert(sizeof(UFortAthenaAIObjectTracker) == 0x0000A8, "Wrong size on UFortAthenaAIObjectTracker");
static_assert(offsetof(UFortAthenaAIObjectTracker, TrackedObjects) == 0x000058, "Member 'UFortAthenaAIObjectTracker::TrackedObjects' has a wrong offset!");

// Class FortniteAI.FortDoorLinkComponent
// 0x0000 (0x01D0 - 0x01D0)
class UFortDoorLinkComponent final : public UNavLinkCustomComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDoorLinkComponent">();
	}
	static class UFortDoorLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDoorLinkComponent>();
	}
};
static_assert(alignof(UFortDoorLinkComponent) == 0x000008, "Wrong alignment on UFortDoorLinkComponent");
static_assert(sizeof(UFortDoorLinkComponent) == 0x0001D0, "Wrong size on UFortDoorLinkComponent");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_SpawnParamsBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_SpawnParamsBase : public UFortAthenaAISpawnerDataComponent
{
public:
	TSubclassOf<class AAIController> GetAIControllerClass() const;
	float GetInAirSpawnTraceEndHeight() const;
	float GetInAirSpawnTraceSphereRadius() const;
	float GetInAirSpawnTraceStartHeight() const;
	TSubclassOf<class APawn> GetPawnClass() const;
	struct FDataTableRowHandle GetPawnStatHandle() const;
	TArray<TSubclassOf<class UFortAthenaAISpawnerData>> GetSpawnerDataSpawnedAsChildren() const;
	float GetSpawnTracePadding() const;
	bool ShouldCheckForOverlaps() const;
	bool ShouldSpawnInAir() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_SpawnParamsBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_SpawnParamsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_SpawnParamsBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_SpawnParamsBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_SpawnParamsBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_SpawnParamsBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_SpawnParamsBase");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_SpawnParams
// 0x0048 (0x0078 - 0x0030)
class UFortAthenaAISpawnerDataComponent_SpawnParams final : public UFortAthenaAISpawnerDataComponent_SpawnParamsBase
{
public:
	TSubclassOf<class APawn>                      PawnClass;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAIController>              AIControllerClass;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    PawnStatHandle;                                    // 0x0040(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UFortAthenaAISpawnerData>> SpawnerDataSpawnedAsChildren;                      // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         bSpawnInAir : 1;                                   // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bSetSkyDivingFromBus : 1;                          // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InAirSpawnTraceStartHeight;                        // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InAirSpawnTraceEndHeight;                          // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InAirSpawnTraceSphereRadius;                       // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpawnTracePadding;                                 // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bCheckForOverlaps : 1;                             // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bAddPOILocationTagsOnSpawn : 1;                    // 0x0074(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_SpawnParams">();
	}
	static class UFortAthenaAISpawnerDataComponent_SpawnParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_SpawnParams>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_SpawnParams) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_SpawnParams");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_SpawnParams) == 0x000078, "Wrong size on UFortAthenaAISpawnerDataComponent_SpawnParams");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SpawnParams, PawnClass) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_SpawnParams::PawnClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SpawnParams, AIControllerClass) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_SpawnParams::AIControllerClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SpawnParams, PawnStatHandle) == 0x000040, "Member 'UFortAthenaAISpawnerDataComponent_SpawnParams::PawnStatHandle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SpawnParams, SpawnerDataSpawnedAsChildren) == 0x000050, "Member 'UFortAthenaAISpawnerDataComponent_SpawnParams::SpawnerDataSpawnedAsChildren' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SpawnParams, InAirSpawnTraceStartHeight) == 0x000064, "Member 'UFortAthenaAISpawnerDataComponent_SpawnParams::InAirSpawnTraceStartHeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SpawnParams, InAirSpawnTraceEndHeight) == 0x000068, "Member 'UFortAthenaAISpawnerDataComponent_SpawnParams::InAirSpawnTraceEndHeight' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SpawnParams, InAirSpawnTraceSphereRadius) == 0x00006C, "Member 'UFortAthenaAISpawnerDataComponent_SpawnParams::InAirSpawnTraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SpawnParams, SpawnTracePadding) == 0x000070, "Member 'UFortAthenaAISpawnerDataComponent_SpawnParams::SpawnTracePadding' has a wrong offset!");

// Class FortniteAI.FortAthenaAIPerk_Ambush
// 0x0000 (0x0168 - 0x0168)
class UFortAthenaAIPerk_Ambush final : public UFortAIPerkBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIPerk_Ambush">();
	}
	static class UFortAthenaAIPerk_Ambush* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIPerk_Ambush>();
	}
};
static_assert(alignof(UFortAthenaAIPerk_Ambush) == 0x000008, "Wrong alignment on UFortAthenaAIPerk_Ambush");
static_assert(sizeof(UFortAthenaAIPerk_Ambush) == 0x000168, "Wrong size on UFortAthenaAIPerk_Ambush");

// Class FortniteAI.FortAthenaAIPerk_Bunker
// 0x0140 (0x02A8 - 0x0168)
class UFortAthenaAIPerk_Bunker final : public UFortAIPerkBase
{
public:
	struct FScalableFloat                         OddsToBeUsedAgainstUnknownThreat;                  // 0x0168(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         OddsToUseRoofBuilding;                             // 0x0190(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         OddsToBuildForwardRamp;                            // 0x01B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         InitialBuildDelay;                                 // 0x01E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SamePieceBuildDelay;                               // 0x0208(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SamePieceBuildDelayRandomDeviation;                // 0x0230(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DifferentPieceBuildDelay;                          // 0x0258(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DifferentPieceBuildDelayRandomDeviation;           // 0x0280(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIPerk_Bunker">();
	}
	static class UFortAthenaAIPerk_Bunker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIPerk_Bunker>();
	}
};
static_assert(alignof(UFortAthenaAIPerk_Bunker) == 0x000008, "Wrong alignment on UFortAthenaAIPerk_Bunker");
static_assert(sizeof(UFortAthenaAIPerk_Bunker) == 0x0002A8, "Wrong size on UFortAthenaAIPerk_Bunker");
static_assert(offsetof(UFortAthenaAIPerk_Bunker, OddsToBeUsedAgainstUnknownThreat) == 0x000168, "Member 'UFortAthenaAIPerk_Bunker::OddsToBeUsedAgainstUnknownThreat' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_Bunker, OddsToUseRoofBuilding) == 0x000190, "Member 'UFortAthenaAIPerk_Bunker::OddsToUseRoofBuilding' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_Bunker, OddsToBuildForwardRamp) == 0x0001B8, "Member 'UFortAthenaAIPerk_Bunker::OddsToBuildForwardRamp' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_Bunker, InitialBuildDelay) == 0x0001E0, "Member 'UFortAthenaAIPerk_Bunker::InitialBuildDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_Bunker, SamePieceBuildDelay) == 0x000208, "Member 'UFortAthenaAIPerk_Bunker::SamePieceBuildDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_Bunker, SamePieceBuildDelayRandomDeviation) == 0x000230, "Member 'UFortAthenaAIPerk_Bunker::SamePieceBuildDelayRandomDeviation' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_Bunker, DifferentPieceBuildDelay) == 0x000258, "Member 'UFortAthenaAIPerk_Bunker::DifferentPieceBuildDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_Bunker, DifferentPieceBuildDelayRandomDeviation) == 0x000280, "Member 'UFortAthenaAIPerk_Bunker::DifferentPieceBuildDelayRandomDeviation' has a wrong offset!");

// Class FortniteAI.FortAthenaBeaconComponent
// 0x0030 (0x00D0 - 0x00A0)
class UFortAthenaBeaconComponent final : public UActorComponent
{
public:
	int32                                         MaxAttractedBots;                                  // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttractionRadius;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         RegisteredActors;                                  // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnConsumeEvent;                                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	bool                                          bIsConsumed;                                       // 0x00C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBeaconComponent">();
	}
	static class UFortAthenaBeaconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBeaconComponent>();
	}
};
static_assert(alignof(UFortAthenaBeaconComponent) == 0x000008, "Wrong alignment on UFortAthenaBeaconComponent");
static_assert(sizeof(UFortAthenaBeaconComponent) == 0x0000D0, "Wrong size on UFortAthenaBeaconComponent");
static_assert(offsetof(UFortAthenaBeaconComponent, MaxAttractedBots) == 0x0000A0, "Member 'UFortAthenaBeaconComponent::MaxAttractedBots' has a wrong offset!");
static_assert(offsetof(UFortAthenaBeaconComponent, AttractionRadius) == 0x0000A4, "Member 'UFortAthenaBeaconComponent::AttractionRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaBeaconComponent, RegisteredActors) == 0x0000A8, "Member 'UFortAthenaBeaconComponent::RegisteredActors' has a wrong offset!");
static_assert(offsetof(UFortAthenaBeaconComponent, OnConsumeEvent) == 0x0000B8, "Member 'UFortAthenaBeaconComponent::OnConsumeEvent' has a wrong offset!");
static_assert(offsetof(UFortAthenaBeaconComponent, bIsConsumed) == 0x0000C8, "Member 'UFortAthenaBeaconComponent::bIsConsumed' has a wrong offset!");

// Class FortniteAI.FortAthenaAIPerk_EvasiveManeuvers
// 0x02F0 (0x0458 - 0x0168)
class UFortAthenaAIPerk_EvasiveManeuvers final : public UFortAIPerkBase
{
public:
	struct FEvasiveManeuverSkillSettings          EvasiveManeuverSkillSettings;                      // 0x0168(0x0258)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DistanceMin;                                       // 0x03C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DistanceMax;                                       // 0x03E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      WeaponTagQuery;                                    // 0x0410(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIPerk_EvasiveManeuvers">();
	}
	static class UFortAthenaAIPerk_EvasiveManeuvers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIPerk_EvasiveManeuvers>();
	}
};
static_assert(alignof(UFortAthenaAIPerk_EvasiveManeuvers) == 0x000008, "Wrong alignment on UFortAthenaAIPerk_EvasiveManeuvers");
static_assert(sizeof(UFortAthenaAIPerk_EvasiveManeuvers) == 0x000458, "Wrong size on UFortAthenaAIPerk_EvasiveManeuvers");
static_assert(offsetof(UFortAthenaAIPerk_EvasiveManeuvers, EvasiveManeuverSkillSettings) == 0x000168, "Member 'UFortAthenaAIPerk_EvasiveManeuvers::EvasiveManeuverSkillSettings' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_EvasiveManeuvers, DistanceMin) == 0x0003C0, "Member 'UFortAthenaAIPerk_EvasiveManeuvers::DistanceMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_EvasiveManeuvers, DistanceMax) == 0x0003E8, "Member 'UFortAthenaAIPerk_EvasiveManeuvers::DistanceMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIPerk_EvasiveManeuvers, WeaponTagQuery) == 0x000410, "Member 'UFortAthenaAIPerk_EvasiveManeuvers::WeaponTagQuery' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParametersProvider
// 0x0000 (0x0028 - 0x0028)
class IFortAthenaAIRuntimeParametersProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParametersProvider">();
	}
	static class IFortAthenaAIRuntimeParametersProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAthenaAIRuntimeParametersProvider>();
	}
};
static_assert(alignof(IFortAthenaAIRuntimeParametersProvider) == 0x000008, "Wrong alignment on IFortAthenaAIRuntimeParametersProvider");
static_assert(sizeof(IFortAthenaAIRuntimeParametersProvider) == 0x000028, "Wrong size on IFortAthenaAIRuntimeParametersProvider");

// Class FortniteAI.FortAthenaBTService_Clamber
// 0x0040 (0x00B0 - 0x0070)
class UFortAthenaBTService_Clamber final : public UBTService
{
public:
	class FName                                   ClamberExecutionStatusName;                        // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ClamberOriginLocationName;                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ClamberDestinationLocationName;                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ClamberAbilityStatusName;                          // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   JumpExecutionStatusName;                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CrouchExecutionStatusName;                         // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        FirstJumpRetryMaxCount;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FirstJumpRetryDelay;                               // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FirstJumpClamberMaxStartDelay;                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Clamber">();
	}
	static class UFortAthenaBTService_Clamber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Clamber>();
	}
};
static_assert(alignof(UFortAthenaBTService_Clamber) == 0x000008, "Wrong alignment on UFortAthenaBTService_Clamber");
static_assert(sizeof(UFortAthenaBTService_Clamber) == 0x0000B0, "Wrong size on UFortAthenaBTService_Clamber");
static_assert(offsetof(UFortAthenaBTService_Clamber, ClamberExecutionStatusName) == 0x000070, "Member 'UFortAthenaBTService_Clamber::ClamberExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Clamber, ClamberOriginLocationName) == 0x000078, "Member 'UFortAthenaBTService_Clamber::ClamberOriginLocationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Clamber, ClamberDestinationLocationName) == 0x000080, "Member 'UFortAthenaBTService_Clamber::ClamberDestinationLocationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Clamber, ClamberAbilityStatusName) == 0x000088, "Member 'UFortAthenaBTService_Clamber::ClamberAbilityStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Clamber, JumpExecutionStatusName) == 0x000090, "Member 'UFortAthenaBTService_Clamber::JumpExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Clamber, CrouchExecutionStatusName) == 0x000098, "Member 'UFortAthenaBTService_Clamber::CrouchExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Clamber, FirstJumpRetryMaxCount) == 0x0000A0, "Member 'UFortAthenaBTService_Clamber::FirstJumpRetryMaxCount' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Clamber, FirstJumpRetryDelay) == 0x0000A4, "Member 'UFortAthenaBTService_Clamber::FirstJumpRetryDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Clamber, FirstJumpClamberMaxStartDelay) == 0x0000A8, "Member 'UFortAthenaBTService_Clamber::FirstJumpClamberMaxStartDelay' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalProject
// 0x0038 (0x0258 - 0x0220)
class UFortQueryTest_GoalProject final : public UFortQueryTest_GoalBase
{
public:
	struct FEnvTraceData                          ProjectionData;                                    // 0x0220(0x0038)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalProject">();
	}
	static class UFortQueryTest_GoalProject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalProject>();
	}
};
static_assert(alignof(UFortQueryTest_GoalProject) == 0x000008, "Wrong alignment on UFortQueryTest_GoalProject");
static_assert(sizeof(UFortQueryTest_GoalProject) == 0x000258, "Wrong size on UFortQueryTest_GoalProject");
static_assert(offsetof(UFortQueryTest_GoalProject, ProjectionData) == 0x000220, "Member 'UFortQueryTest_GoalProject::ProjectionData' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParametersComponent
// 0x00A0 (0x0140 - 0x00A0)
class UFortAthenaAIRuntimeParametersComponent final : public UActorComponent
{
public:
	TMap<TSubclassOf<class UFortAthenaAIRuntimeParameters>, TScriptInterface<class IFortAthenaAIRuntimeParametersProvider>> RegisteredParametersProviders;                     // 0x00A0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class UClass*, class UFortAthenaAIRuntimeParameters*> ExtractedRuntimeParameters;                        // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParametersComponent">();
	}
	static class UFortAthenaAIRuntimeParametersComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParametersComponent>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParametersComponent) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParametersComponent");
static_assert(sizeof(UFortAthenaAIRuntimeParametersComponent) == 0x000140, "Wrong size on UFortAthenaAIRuntimeParametersComponent");
static_assert(offsetof(UFortAthenaAIRuntimeParametersComponent, RegisteredParametersProviders) == 0x0000A0, "Member 'UFortAthenaAIRuntimeParametersComponent::RegisteredParametersProviders' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParametersComponent, ExtractedRuntimeParameters) == 0x0000F0, "Member 'UFortAthenaAIRuntimeParametersComponent::ExtractedRuntimeParameters' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_SmartObjectBase
// 0x0070 (0x00A0 - 0x0030)
class UFortAthenaAIRuntimeParameters_SmartObjectBase final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bChooseClosestSmartObject : 1;                     // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelectedSmartObjectExpirationDelay;                // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GlobalSmartObjectCooldownOnFinished;               // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GlobalSmartObjectCooldownOnInterrupted;            // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAIRuntimeParametersSmartObjectActivity> SmartObjectActivities;                             // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FSmartObjectRecentlyUsed>       SmartObjectsMostRecentlyUsed;                      // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         SelectedActivityID;                                // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSmartObjectRequestResult              SelectedResult;                                    // 0x0064(0x000C)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         LastSelectedSmartObjectTimestamp;                  // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSmartObjectClaimHandle                ClaimedHandle;                                     // 0x0074(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayBehaviorConfig*                BehaviorConfig;                                    // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayBehavior*                      GameplayBehavior;                                  // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GlobalSmartObjectLastUseTimestamp;                 // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GlobalSmartObjectCooldown;                         // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_SmartObjectBase">();
	}
	static class UFortAthenaAIRuntimeParameters_SmartObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_SmartObjectBase>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_SmartObjectBase) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_SmartObjectBase");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_SmartObjectBase) == 0x0000A0, "Wrong size on UFortAthenaAIRuntimeParameters_SmartObjectBase");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, SelectedSmartObjectExpirationDelay) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::SelectedSmartObjectExpirationDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, GlobalSmartObjectCooldownOnFinished) == 0x000038, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::GlobalSmartObjectCooldownOnFinished' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, GlobalSmartObjectCooldownOnInterrupted) == 0x00003C, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::GlobalSmartObjectCooldownOnInterrupted' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, SmartObjectActivities) == 0x000040, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::SmartObjectActivities' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, SmartObjectsMostRecentlyUsed) == 0x000050, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::SmartObjectsMostRecentlyUsed' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, SelectedActivityID) == 0x000060, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::SelectedActivityID' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, SelectedResult) == 0x000064, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::SelectedResult' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, LastSelectedSmartObjectTimestamp) == 0x000070, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::LastSelectedSmartObjectTimestamp' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, ClaimedHandle) == 0x000074, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::ClaimedHandle' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, BehaviorConfig) == 0x000088, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::BehaviorConfig' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, GameplayBehavior) == 0x000090, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::GameplayBehavior' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, GlobalSmartObjectLastUseTimestamp) == 0x000098, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::GlobalSmartObjectLastUseTimestamp' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_SmartObjectBase, GlobalSmartObjectCooldown) == 0x00009C, "Member 'UFortAthenaAIRuntimeParameters_SmartObjectBase::GlobalSmartObjectCooldown' has a wrong offset!");

// Class FortniteAI.FortAthenaAISmartObjectActivity
// 0x0130 (0x0158 - 0x0028)
class UFortAthenaAISmartObjectActivity final : public UObject
{
public:
	struct FScalableFloat                         Enabled;                                           // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortAthenaAISmartObjectActivityCondition SmartObjectActivityCondition;                      // 0x0050(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortAthenaAISmartObjectActivityConfig SmartObjectActivityConfig;                         // 0x0098(0x00C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISmartObjectActivity">();
	}
	static class UFortAthenaAISmartObjectActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISmartObjectActivity>();
	}
};
static_assert(alignof(UFortAthenaAISmartObjectActivity) == 0x000008, "Wrong alignment on UFortAthenaAISmartObjectActivity");
static_assert(sizeof(UFortAthenaAISmartObjectActivity) == 0x000158, "Wrong size on UFortAthenaAISmartObjectActivity");
static_assert(offsetof(UFortAthenaAISmartObjectActivity, Enabled) == 0x000028, "Member 'UFortAthenaAISmartObjectActivity::Enabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISmartObjectActivity, SmartObjectActivityCondition) == 0x000050, "Member 'UFortAthenaAISmartObjectActivity::SmartObjectActivityCondition' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISmartObjectActivity, SmartObjectActivityConfig) == 0x000098, "Member 'UFortAthenaAISmartObjectActivity::SmartObjectActivityConfig' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_Marker
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAIRuntimeParameters_Marker final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bSupportsMarkerWithFaction : 1;                    // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MarkerPropagationMaxDistanceSQ;                    // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_Marker">();
	}
	static class UFortAthenaAIRuntimeParameters_Marker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_Marker>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_Marker) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_Marker");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_Marker) == 0x000038, "Wrong size on UFortAthenaAIRuntimeParameters_Marker");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Marker, MarkerPropagationMaxDistanceSQ) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_Marker::MarkerPropagationMaxDistanceSQ' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_AIBotDisguise
// 0x00A0 (0x00D0 - 0x0030)
class UFortAthenaAIRuntimeParameters_AIBotDisguise final : public UFortAthenaAIRuntimeParameters
{
public:
	bool                                          bShouldApplyDisguise;                              // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRevealDisguiseOnDamage;                           // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRevealOnDamageExcludeAIPawnDamage;                // 0x0032(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRevealDisguiseOnPlayerProximity;                  // 0x0033(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RevealPlayerProximityDistanceSqr;                  // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RevealPlayerProximityMinDuration;                  // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RevealPlayerProximityMaxDuration;                  // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortBotNameSettings*                   NameSettingsAfterReveal;                           // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  DisguisedFactionsBeforeReveal;                     // 0x0048(0x0020)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  DisguisedFactionsAfterReveal;                      // 0x0068(0x0020)(Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UGameplayEffect>>    DisguiseGameplayEffectBeforeReveal;                // 0x0088(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UGameplayEffect>>    DisguiseGameplayEffectAfterReveal;                 // 0x0098(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FItemAndCount>                  DisguiseInventory;                                 // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    DisguiseLootInfo;                                  // 0x00B8(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortNPCConversationParticipantComponent> DisguiseConversationComponentOverride;             // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_AIBotDisguise">();
	}
	static class UFortAthenaAIRuntimeParameters_AIBotDisguise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_AIBotDisguise>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_AIBotDisguise) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_AIBotDisguise");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_AIBotDisguise) == 0x0000D0, "Wrong size on UFortAthenaAIRuntimeParameters_AIBotDisguise");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, bShouldApplyDisguise) == 0x000030, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::bShouldApplyDisguise' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, bRevealDisguiseOnDamage) == 0x000031, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::bRevealDisguiseOnDamage' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, bRevealOnDamageExcludeAIPawnDamage) == 0x000032, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::bRevealOnDamageExcludeAIPawnDamage' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, bRevealDisguiseOnPlayerProximity) == 0x000033, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::bRevealDisguiseOnPlayerProximity' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, RevealPlayerProximityDistanceSqr) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::RevealPlayerProximityDistanceSqr' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, RevealPlayerProximityMinDuration) == 0x000038, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::RevealPlayerProximityMinDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, RevealPlayerProximityMaxDuration) == 0x00003C, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::RevealPlayerProximityMaxDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, NameSettingsAfterReveal) == 0x000040, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::NameSettingsAfterReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, DisguisedFactionsBeforeReveal) == 0x000048, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::DisguisedFactionsBeforeReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, DisguisedFactionsAfterReveal) == 0x000068, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::DisguisedFactionsAfterReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, DisguiseGameplayEffectBeforeReveal) == 0x000088, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::DisguiseGameplayEffectBeforeReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, DisguiseGameplayEffectAfterReveal) == 0x000098, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::DisguiseGameplayEffectAfterReveal' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, DisguiseInventory) == 0x0000A8, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::DisguiseInventory' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, DisguiseLootInfo) == 0x0000B8, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::DisguiseLootInfo' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotDisguise, DisguiseConversationComponentOverride) == 0x0000C8, "Member 'UFortAthenaAIRuntimeParameters_AIBotDisguise::DisguiseConversationComponentOverride' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_Collection
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAIRuntimeParameters_Collection final : public UFortAthenaAIRuntimeParameters
{
public:
	bool                                          bForceAddToCollectionOnDamage;                     // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_Collection">();
	}
	static class UFortAthenaAIRuntimeParameters_Collection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_Collection>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_Collection) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_Collection");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_Collection) == 0x000038, "Wrong size on UFortAthenaAIRuntimeParameters_Collection");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_Collection, bForceAddToCollectionOnDamage) == 0x000030, "Member 'UFortAthenaAIRuntimeParameters_Collection::bForceAddToCollectionOnDamage' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotAnalytic
// 0x0018 (0x0078 - 0x0060)
class UFortAthenaAISpawnerDataComponent_AIBotAnalytic final : public UFortAthenaAISpawnerDataComponent_AnalyticBase
{
public:
	uint8                                         bUseDescriptorTagSuffix : 1;                       // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BotIDSuffix;                                       // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotAnalytic">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotAnalytic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotAnalytic>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotAnalytic) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotAnalytic");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotAnalytic) == 0x000078, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotAnalytic");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotAnalytic, BotIDSuffix) == 0x000068, "Member 'UFortAthenaAISpawnerDataComponent_AIBotAnalytic::BotIDSuffix' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_BehaviorTreeControl
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAIRuntimeParameters_BehaviorTreeControl final : public UFortAthenaAIRuntimeParameters
{
public:
	uint32                                        BehaviorTreeControls;                              // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableBehaviorTreeBranch(const EBehaviorTreeBranches Behavior);
	void EnableBehaviorTreeBranch(const EBehaviorTreeBranches Behavior);

	bool IsBehaviorTreeBranchActive(const EBehaviorTreeBranches Behavior) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_BehaviorTreeControl">();
	}
	static class UFortAthenaAIRuntimeParameters_BehaviorTreeControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_BehaviorTreeControl>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_BehaviorTreeControl) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_BehaviorTreeControl");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_BehaviorTreeControl) == 0x000038, "Wrong size on UFortAthenaAIRuntimeParameters_BehaviorTreeControl");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_BehaviorTreeControl, BehaviorTreeControls) == 0x000030, "Member 'UFortAthenaAIRuntimeParameters_BehaviorTreeControl::BehaviorTreeControls' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_DBNOBehavior
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAIRuntimeParameters_DBNOBehavior final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bDieWhenAllAlliesAreDBNO : 1;                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AliveAlliesMaxRangeSqr;                            // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_DBNOBehavior">();
	}
	static class UFortAthenaAIRuntimeParameters_DBNOBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_DBNOBehavior>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_DBNOBehavior) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_DBNOBehavior");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_DBNOBehavior) == 0x000038, "Wrong size on UFortAthenaAIRuntimeParameters_DBNOBehavior");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_DBNOBehavior, AliveAlliesMaxRangeSqr) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_DBNOBehavior::AliveAlliesMaxRangeSqr' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotChanceEncounter
// 0x0030 (0x0060 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter final : public UFortAthenaAISpawnerDataComponent_ChanceEncounterBase
{
public:
	struct FScalableFloat                         PassiveHealerEnable;                               // 0x0030(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortPawnComponent_PassiveHealer> PassiveHealerComponentClass;                       // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotChanceEncounter">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter) == 0x000060, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter, PassiveHealerEnable) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter::PassiveHealerEnable' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter, PassiveHealerComponentClass) == 0x000058, "Member 'UFortAthenaAISpawnerDataComponent_AIBotChanceEncounter::PassiveHealerComponentClass' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotConstruction
// 0x0090 (0x00C0 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIBotConstruction final : public UFortAthenaAISpawnerDataComponent_ConstructionBase
{
public:
	struct FConstructionBuildingList              ConstructionBuildingInfoList;                      // 0x0030(0x0090)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotConstruction">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotConstruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotConstruction>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotConstruction) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotConstruction");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotConstruction) == 0x0000C0, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotConstruction");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConstruction, ConstructionBuildingInfoList) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConstruction::ConstructionBuildingInfoList' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_AIBotLoopSettings
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAIRuntimeParameters_AIBotLoopSettings final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bSpawnOutsideTheLoop : 1;                          // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bRespawnOustideTheLoop : 1;                        // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bRemoveInvulnerabilityOutsideSafeZone : 1;         // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDisableSpecialActorComponentUntilRespawn : 1;     // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_AIBotLoopSettings">();
	}
	static class UFortAthenaAIRuntimeParameters_AIBotLoopSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_AIBotLoopSettings>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_AIBotLoopSettings) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_AIBotLoopSettings");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_AIBotLoopSettings) == 0x000038, "Wrong size on UFortAthenaAIRuntimeParameters_AIBotLoopSettings");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_ConversationBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_ConversationBase : public UFortAthenaAISpawnerDataComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_ConversationBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_ConversationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_ConversationBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_ConversationBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_ConversationBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_ConversationBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_ConversationBase");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotConversation
// 0x01D0 (0x0200 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIBotConversation final : public UFortAthenaAISpawnerDataComponent_ConversationBase
{
public:
	TSubclassOf<class UFortNPCConversationParticipantComponent> ConversationComponentClass;                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           ConversationEntryTag;                              // 0x0038(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           InteractorParticipantTag;                          // 0x003C(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           SelfParticipantTag;                                // 0x0040(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         EnterBTTaskConversationIfPlayerAround;             // 0x0048(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EnterBTTaskConversationIfPlayerAroundDist;         // 0x0070(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UAthenaDanceItemDefinition*>     GreetingEmotes;                                    // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         GreetingEmoteMaxDuration;                          // 0x00A8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class UFortTandemCharacterData*               CharacterData;                                     // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ConversationInteractionCollisionProfile;           // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ConversationInteractionBoxExtent;                  // 0x00E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                ConversationInteractionBoxOffset;                  // 0x00F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         SpawnOutOfTheLoop;                                 // 0x0110(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RespawnOutsideTheLoop;                             // 0x0138(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         RemoveInvulnerabilityOutsideSafeZone;              // 0x0160(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortAthenaNPCLoopStateComponent> NPCLoopStateComponentClass;                        // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         UseSpecialActorComponent;                          // 0x0190(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAthenaSpecialActorComponent> SpecialActorComponentClass;                        // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         BlockSpecialActorUntilOutsideTheLoop;              // 0x01C0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   OverridenConversationParticipantName;              // 0x01E8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void SetOverridenConversationParticipantName(const class FText& SpeakerName);

	const class FText GetOverridenConversationParticipantName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotConversation">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotConversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotConversation>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotConversation) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotConversation");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotConversation) == 0x000200, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotConversation");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, ConversationComponentClass) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::ConversationComponentClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, ConversationEntryTag) == 0x000038, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::ConversationEntryTag' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, InteractorParticipantTag) == 0x00003C, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::InteractorParticipantTag' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, SelfParticipantTag) == 0x000040, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::SelfParticipantTag' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, EnterBTTaskConversationIfPlayerAround) == 0x000048, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::EnterBTTaskConversationIfPlayerAround' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, EnterBTTaskConversationIfPlayerAroundDist) == 0x000070, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::EnterBTTaskConversationIfPlayerAroundDist' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, GreetingEmotes) == 0x000098, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::GreetingEmotes' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, GreetingEmoteMaxDuration) == 0x0000A8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::GreetingEmoteMaxDuration' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, CharacterData) == 0x0000D0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::CharacterData' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, ConversationInteractionCollisionProfile) == 0x0000D8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::ConversationInteractionCollisionProfile' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, ConversationInteractionBoxExtent) == 0x0000E0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::ConversationInteractionBoxExtent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, ConversationInteractionBoxOffset) == 0x0000F8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::ConversationInteractionBoxOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, SpawnOutOfTheLoop) == 0x000110, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::SpawnOutOfTheLoop' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, RespawnOutsideTheLoop) == 0x000138, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::RespawnOutsideTheLoop' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, RemoveInvulnerabilityOutsideSafeZone) == 0x000160, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::RemoveInvulnerabilityOutsideSafeZone' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, NPCLoopStateComponentClass) == 0x000188, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::NPCLoopStateComponentClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, UseSpecialActorComponent) == 0x000190, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::UseSpecialActorComponent' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, SpecialActorComponentClass) == 0x0001B8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::SpecialActorComponentClass' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, BlockSpecialActorUntilOutsideTheLoop) == 0x0001C0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::BlockSpecialActorUntilOutsideTheLoop' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotConversation, OverridenConversationParticipantName) == 0x0001E8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotConversation::OverridenConversationParticipantName' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotDebug
// 0x01B0 (0x01E0 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIBotDebug final : public UFortAthenaAISpawnerDataComponent_DebugBase
{
public:
	struct FDebugMinimapData                      DebugMinimapData;                                  // 0x0030(0x01B0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotDebug">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotDebug>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotDebug) == 0x000010, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotDebug");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotDebug) == 0x0001E0, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotDebug");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotDebug, DebugMinimapData) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_AIBotDebug::DebugMinimapData' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_AIConvert
// 0x00C0 (0x00F0 - 0x0030)
class UFortAthenaAIRuntimeParameters_AIConvert : public UFortAthenaAIRuntimeParameters
{
public:
	bool                                          bCanBeConverted;                                   // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeConvertedFromDBNO;                           // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceKillWhenUnconverted;                         // 0x0032(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCopyConverterSpecificRelations;                   // 0x0033(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRemoveFromAllFactions;                            // 0x0034(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReleaseDistanceSq;                                 // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CheckReleaseConditionsTimeInterval;                // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  AddToFactions;                                     // 0x0040(0x0020)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  RemoveFromFactions;                                // 0x0060(0x0020)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         PreConversionTeamIndex;                            // 0x0080(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PreConversionFactions;                             // 0x0088(0x0020)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UFortAbilitySet*>                AbilitySetsForConverted;                           // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FTeleportSettings                      TeleportSettings;                                  // 0x00B8(0x0038)(Transient, NativeAccessSpecifierPrivate)

public:
	void SetCanBeConverted(const bool bInCanBeConverted);
	void SetCanBeConvertedFromDBNO(const bool bInCanBeConvertedFromDBNO);
	void SetForceKillWhenUnconverted(const bool bInForceKillWhenUnconverted);

	bool GetCanBeConverted() const;
	bool GetCanBeConvertedFromDBNO() const;
	bool GetForceKillWhenUnconverted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_AIConvert">();
	}
	static class UFortAthenaAIRuntimeParameters_AIConvert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_AIConvert>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_AIConvert) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_AIConvert");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_AIConvert) == 0x0000F0, "Wrong size on UFortAthenaAIRuntimeParameters_AIConvert");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, bCanBeConverted) == 0x000030, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::bCanBeConverted' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, bCanBeConvertedFromDBNO) == 0x000031, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::bCanBeConvertedFromDBNO' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, bForceKillWhenUnconverted) == 0x000032, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::bForceKillWhenUnconverted' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, bCopyConverterSpecificRelations) == 0x000033, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::bCopyConverterSpecificRelations' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, bRemoveFromAllFactions) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::bRemoveFromAllFactions' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, ReleaseDistanceSq) == 0x000038, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::ReleaseDistanceSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, CheckReleaseConditionsTimeInterval) == 0x00003C, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::CheckReleaseConditionsTimeInterval' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, AddToFactions) == 0x000040, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::AddToFactions' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, RemoveFromFactions) == 0x000060, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::RemoveFromFactions' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, PreConversionTeamIndex) == 0x000080, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::PreConversionTeamIndex' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, PreConversionFactions) == 0x000088, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::PreConversionFactions' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, AbilitySetsForConverted) == 0x0000A8, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::AbilitySetsForConverted' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIConvert, TeleportSettings) == 0x0000B8, "Member 'UFortAthenaAIRuntimeParameters_AIConvert::TeleportSettings' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_AIBotConvert
// 0x0040 (0x0130 - 0x00F0)
class UFortAthenaAIRuntimeParameters_AIBotConvert final : public UFortAthenaAIRuntimeParameters_AIConvert
{
public:
	uint8                                         bShouldLeashFollowConverter : 1;                   // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldScanAroundWhenWaiting : 1;                  // 0x00F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldMoveTowardsConverter : 1;                   // 0x00F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShouldTeleportTowardsConverter : 1;               // 0x00F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCanDanceWithConverter : 1;                        // 0x00F0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillLevelOverride;                                // 0x00F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InnerLeashRadius;                                  // 0x00F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OuterLeashRadius;                                  // 0x00FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeashFollowActorUpdateRate;                        // 0x0100(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeashFollowActorLocalOffset;                       // 0x0108(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveTowardsConverterInnerDistanceSq;               // 0x0120(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveTowardsConverterOuterDistanceSq;               // 0x0124(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TeleportTowardsConverterDistanceSq;                // 0x0128(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDistanceFromConverterWhenTeleported;            // 0x012C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_AIBotConvert">();
	}
	static class UFortAthenaAIRuntimeParameters_AIBotConvert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_AIBotConvert>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_AIBotConvert) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_AIBotConvert");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_AIBotConvert) == 0x000130, "Wrong size on UFortAthenaAIRuntimeParameters_AIBotConvert");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotConvert, SkillLevelOverride) == 0x0000F4, "Member 'UFortAthenaAIRuntimeParameters_AIBotConvert::SkillLevelOverride' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotConvert, InnerLeashRadius) == 0x0000F8, "Member 'UFortAthenaAIRuntimeParameters_AIBotConvert::InnerLeashRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotConvert, OuterLeashRadius) == 0x0000FC, "Member 'UFortAthenaAIRuntimeParameters_AIBotConvert::OuterLeashRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotConvert, LeashFollowActorUpdateRate) == 0x000100, "Member 'UFortAthenaAIRuntimeParameters_AIBotConvert::LeashFollowActorUpdateRate' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotConvert, LeashFollowActorLocalOffset) == 0x000108, "Member 'UFortAthenaAIRuntimeParameters_AIBotConvert::LeashFollowActorLocalOffset' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotConvert, MoveTowardsConverterInnerDistanceSq) == 0x000120, "Member 'UFortAthenaAIRuntimeParameters_AIBotConvert::MoveTowardsConverterInnerDistanceSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotConvert, MoveTowardsConverterOuterDistanceSq) == 0x000124, "Member 'UFortAthenaAIRuntimeParameters_AIBotConvert::MoveTowardsConverterOuterDistanceSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotConvert, TeleportTowardsConverterDistanceSq) == 0x000128, "Member 'UFortAthenaAIRuntimeParameters_AIBotConvert::TeleportTowardsConverterDistanceSq' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotConvert, MinDistanceFromConverterWhenTeleported) == 0x00012C, "Member 'UFortAthenaAIRuntimeParameters_AIBotConvert::MinDistanceFromConverterWhenTeleported' has a wrong offset!");

// Class FortniteAI.FortAthenaAIRuntimeParameters_AIBotRespawn
// 0x0010 (0x0040 - 0x0030)
class UFortAthenaAIRuntimeParameters_AIBotRespawn final : public UFortAthenaAIRuntimeParameters
{
public:
	uint8                                         bCanRespawnOnDeath : 1;                            // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bRespawnOnDeathLocation : 1;                       // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnTime;                                       // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAthenaAISpawnerDataComponentList*  AISpawnerDataComponentList;                        // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAIRuntimeParameters_AIBotRespawn">();
	}
	static class UFortAthenaAIRuntimeParameters_AIBotRespawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAIRuntimeParameters_AIBotRespawn>();
	}
};
static_assert(alignof(UFortAthenaAIRuntimeParameters_AIBotRespawn) == 0x000008, "Wrong alignment on UFortAthenaAIRuntimeParameters_AIBotRespawn");
static_assert(sizeof(UFortAthenaAIRuntimeParameters_AIBotRespawn) == 0x000040, "Wrong size on UFortAthenaAIRuntimeParameters_AIBotRespawn");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotRespawn, RespawnTime) == 0x000034, "Member 'UFortAthenaAIRuntimeParameters_AIBotRespawn::RespawnTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaAIRuntimeParameters_AIBotRespawn, AISpawnerDataComponentList) == 0x000038, "Member 'UFortAthenaAIRuntimeParameters_AIBotRespawn::AISpawnerDataComponentList' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIBotInventory
// 0x0028 (0x00C8 - 0x00A0)
class UFortAthenaAISpawnerDataComponent_AIBotInventory final : public UFortAthenaAISpawnerDataComponent_InventoryBase
{
public:
	TArray<struct FItemAndCount>                  Items;                                             // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         bItemsToGiveInEditorWhenCustomizationIsEnabled : 1; // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemAndCount>                  EditorOnlyItems;                                   // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void SetInventoryItems(const TArray<struct FItemAndCount>& InItems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIBotInventory">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIBotInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIBotInventory>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIBotInventory) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIBotInventory");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIBotInventory) == 0x0000C8, "Wrong size on UFortAthenaAISpawnerDataComponent_AIBotInventory");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotInventory, Items) == 0x0000A0, "Member 'UFortAthenaAISpawnerDataComponent_AIBotInventory::Items' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIBotInventory, EditorOnlyItems) == 0x0000B8, "Member 'UFortAthenaAISpawnerDataComponent_AIBotInventory::EditorOnlyItems' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIGameplay
// 0x0040 (0x02D0 - 0x0290)
class UFortAthenaAISpawnerDataComponent_AIGameplay final : public UFortAthenaAISpawnerDataComponent_GameplayBase
{
public:
	float                                         MoveSoundStimulusBroadcastInterval;                // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxMoveSoundRange;                                 // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bGenerateSoundInAllMovementModes : 1;              // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         DefaultLifespanAfterDeath;                         // 0x02A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	EFortAthenaAISpawnerDataComponentTriBool      IsAlwaysGameplayRelevantOverride;                  // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIGameplay">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIGameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIGameplay>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIGameplay) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIGameplay");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIGameplay) == 0x0002D0, "Wrong size on UFortAthenaAISpawnerDataComponent_AIGameplay");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIGameplay, MoveSoundStimulusBroadcastInterval) == 0x000290, "Member 'UFortAthenaAISpawnerDataComponent_AIGameplay::MoveSoundStimulusBroadcastInterval' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIGameplay, MaxMoveSoundRange) == 0x000294, "Member 'UFortAthenaAISpawnerDataComponent_AIGameplay::MaxMoveSoundRange' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIGameplay, DefaultLifespanAfterDeath) == 0x0002A0, "Member 'UFortAthenaAISpawnerDataComponent_AIGameplay::DefaultLifespanAfterDeath' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_AIGameplay, IsAlwaysGameplayRelevantOverride) == 0x0002C8, "Member 'UFortAthenaAISpawnerDataComponent_AIGameplay::IsAlwaysGameplayRelevantOverride' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_OptimBase
// 0x0000 (0x0030 - 0x0030)
class UFortAthenaAISpawnerDataComponent_OptimBase : public UFortAthenaAISpawnerDataComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_OptimBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_OptimBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_OptimBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_OptimBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_OptimBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_OptimBase) == 0x000030, "Wrong size on UFortAthenaAISpawnerDataComponent_OptimBase");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_AIPawnOptim
// 0x0008 (0x0038 - 0x0030)
class UFortAthenaAISpawnerDataComponent_AIPawnOptim final : public UFortAthenaAISpawnerDataComponent_OptimBase
{
public:
	uint8                                         bRegisterToAIDropper : 1;                          // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_AIPawnOptim">();
	}
	static class UFortAthenaAISpawnerDataComponent_AIPawnOptim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_AIPawnOptim>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_AIPawnOptim) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_AIPawnOptim");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_AIPawnOptim) == 0x000038, "Wrong size on UFortAthenaAISpawnerDataComponent_AIPawnOptim");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_PerksBase
// 0x0010 (0x0040 - 0x0030)
class UFortAthenaAISpawnerDataComponent_PerksBase final : public UFortAthenaAISpawnerDataComponent
{
public:
	TArray<struct FPerkAvailabilityContainer>     PerksContainers;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_PerksBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_PerksBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_PerksBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_PerksBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_PerksBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_PerksBase) == 0x000040, "Wrong size on UFortAthenaAISpawnerDataComponent_PerksBase");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_PerksBase, PerksContainers) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_PerksBase::PerksContainers' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_PlayerBotSkillset
// 0x0008 (0x0100 - 0x00F8)
class UFortAthenaAISpawnerDataComponent_PlayerBotSkillset final : public UFortAthenaAISpawnerDataComponent_AIBotSkillset
{
public:
	TSubclassOf<class UFortAthenaAIBotWarmupSkillSet> WarmUpSkillSet;                                    // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_PlayerBotSkillset">();
	}
	static class UFortAthenaAISpawnerDataComponent_PlayerBotSkillset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_PlayerBotSkillset>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_PlayerBotSkillset) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_PlayerBotSkillset");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_PlayerBotSkillset) == 0x000100, "Wrong size on UFortAthenaAISpawnerDataComponent_PlayerBotSkillset");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_PlayerBotSkillset, WarmUpSkillSet) == 0x0000F8, "Member 'UFortAthenaAISpawnerDataComponent_PlayerBotSkillset::WarmUpSkillSet' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_RandomInventory
// 0x0010 (0x00B0 - 0x00A0)
class UFortAthenaAISpawnerDataComponent_RandomInventory final : public UFortAthenaAISpawnerDataComponent_InventoryBase
{
public:
	TArray<struct FWeightedAIInventoryLoadout>    Loadouts;                                          // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_RandomInventory">();
	}
	static class UFortAthenaAISpawnerDataComponent_RandomInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_RandomInventory>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_RandomInventory) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_RandomInventory");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_RandomInventory) == 0x0000B0, "Wrong size on UFortAthenaAISpawnerDataComponent_RandomInventory");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_RandomInventory, Loadouts) == 0x0000A0, "Member 'UFortAthenaAISpawnerDataComponent_RandomInventory::Loadouts' has a wrong offset!");

// Class FortniteAI.FortAthenaAISpawnerDataComponent_SmartObjectBase
// 0x00F8 (0x0128 - 0x0030)
class UFortAthenaAISpawnerDataComponent_SmartObjectBase final : public UFortAthenaAISpawnerDataComponent
{
public:
	struct FScalableFloat                         Enabled;                                           // 0x0030(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ChooseClosestSmartObject;                          // 0x0058(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         SelectedSmartObjectExpirationDelay;                // 0x0080(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         GlobalSmartObjectCooldownOnFinished;               // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         GlobalSmartObjectCooldownOnInterrupted;            // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UFortAthenaAISmartObjectActivity>> SmartObjectActivitiesCombined;                     // 0x00F8(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UFortAthenaAISmartObjectActivity>> SmartObjectActivitiesToAdd;                        // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UFortAthenaAISmartObjectActivity>> SmartObjectActivitiesToRemove;                     // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAISpawnerDataComponent_SmartObjectBase">();
	}
	static class UFortAthenaAISpawnerDataComponent_SmartObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAISpawnerDataComponent_SmartObjectBase>();
	}
};
static_assert(alignof(UFortAthenaAISpawnerDataComponent_SmartObjectBase) == 0x000008, "Wrong alignment on UFortAthenaAISpawnerDataComponent_SmartObjectBase");
static_assert(sizeof(UFortAthenaAISpawnerDataComponent_SmartObjectBase) == 0x000128, "Wrong size on UFortAthenaAISpawnerDataComponent_SmartObjectBase");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SmartObjectBase, Enabled) == 0x000030, "Member 'UFortAthenaAISpawnerDataComponent_SmartObjectBase::Enabled' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SmartObjectBase, ChooseClosestSmartObject) == 0x000058, "Member 'UFortAthenaAISpawnerDataComponent_SmartObjectBase::ChooseClosestSmartObject' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SmartObjectBase, SelectedSmartObjectExpirationDelay) == 0x000080, "Member 'UFortAthenaAISpawnerDataComponent_SmartObjectBase::SelectedSmartObjectExpirationDelay' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SmartObjectBase, GlobalSmartObjectCooldownOnFinished) == 0x0000A8, "Member 'UFortAthenaAISpawnerDataComponent_SmartObjectBase::GlobalSmartObjectCooldownOnFinished' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SmartObjectBase, GlobalSmartObjectCooldownOnInterrupted) == 0x0000D0, "Member 'UFortAthenaAISpawnerDataComponent_SmartObjectBase::GlobalSmartObjectCooldownOnInterrupted' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SmartObjectBase, SmartObjectActivitiesCombined) == 0x0000F8, "Member 'UFortAthenaAISpawnerDataComponent_SmartObjectBase::SmartObjectActivitiesCombined' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SmartObjectBase, SmartObjectActivitiesToAdd) == 0x000108, "Member 'UFortAthenaAISpawnerDataComponent_SmartObjectBase::SmartObjectActivitiesToAdd' has a wrong offset!");
static_assert(offsetof(UFortAthenaAISpawnerDataComponent_SmartObjectBase, SmartObjectActivitiesToRemove) == 0x000118, "Member 'UFortAthenaAISpawnerDataComponent_SmartObjectBase::SmartObjectActivitiesToRemove' has a wrong offset!");

// Class FortniteAI.FortAthenaAlertStateComponent
// 0x0008 (0x00A8 - 0x00A0)
class UFortAthenaAlertStateComponent final : public UActorComponent
{
public:
	float                                         StealthMeterTarget;                                // 0x00A0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StealthMeterTargetTime;                            // 0x00A4(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnStealthMeterChanged(class AFortAthenaAIBotController* BotController, float StealthMeterTarget_0, float StealthMeterTargetTime_0);
	void SetStealthMeterTarget(const float InStealthMeterTarget);
	void SetStealthMeterTargetTime(const float InStealthMeterTargetTime);

	float GetStealthMeterTarget() const;
	float GetStealthMeterTargetTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAlertStateComponent">();
	}
	static class UFortAthenaAlertStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaAlertStateComponent>();
	}
};
static_assert(alignof(UFortAthenaAlertStateComponent) == 0x000008, "Wrong alignment on UFortAthenaAlertStateComponent");
static_assert(sizeof(UFortAthenaAlertStateComponent) == 0x0000A8, "Wrong size on UFortAthenaAlertStateComponent");
static_assert(offsetof(UFortAthenaAlertStateComponent, StealthMeterTarget) == 0x0000A0, "Member 'UFortAthenaAlertStateComponent::StealthMeterTarget' has a wrong offset!");
static_assert(offsetof(UFortAthenaAlertStateComponent, StealthMeterTargetTime) == 0x0000A4, "Member 'UFortAthenaAlertStateComponent::StealthMeterTargetTime' has a wrong offset!");

// Class FortniteAI.FortAthenaBTContext_SuppressAutomaticAttackCheck
// 0x0000 (0x0070 - 0x0070)
class UFortAthenaBTContext_SuppressAutomaticAttackCheck final : public UFortBTService_ContextOverride
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTContext_SuppressAutomaticAttackCheck">();
	}
	static class UFortAthenaBTContext_SuppressAutomaticAttackCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTContext_SuppressAutomaticAttackCheck>();
	}
};
static_assert(alignof(UFortAthenaBTContext_SuppressAutomaticAttackCheck) == 0x000008, "Wrong alignment on UFortAthenaBTContext_SuppressAutomaticAttackCheck");
static_assert(sizeof(UFortAthenaBTContext_SuppressAutomaticAttackCheck) == 0x000070, "Wrong size on UFortAthenaBTContext_SuppressAutomaticAttackCheck");

// Class FortniteAI.FortAthenaBTDecorator_BehaviorControls
// 0x0008 (0x0070 - 0x0068)
class UFortAthenaBTDecorator_BehaviorControls final : public UBTDecorator
{
public:
	EBehaviorTreeBranches                         BehaviorTreeBranch;                                // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTDecorator_BehaviorControls">();
	}
	static class UFortAthenaBTDecorator_BehaviorControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTDecorator_BehaviorControls>();
	}
};
static_assert(alignof(UFortAthenaBTDecorator_BehaviorControls) == 0x000008, "Wrong alignment on UFortAthenaBTDecorator_BehaviorControls");
static_assert(sizeof(UFortAthenaBTDecorator_BehaviorControls) == 0x000070, "Wrong size on UFortAthenaBTDecorator_BehaviorControls");
static_assert(offsetof(UFortAthenaBTDecorator_BehaviorControls, BehaviorTreeBranch) == 0x000068, "Member 'UFortAthenaBTDecorator_BehaviorControls::BehaviorTreeBranch' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_ApplyGameplayTags
// 0x0020 (0x0090 - 0x0070)
class UFortAthenaBTService_ApplyGameplayTags final : public UBTService
{
public:
	struct FGameplayTagContainer                  GameplayTagsToApply;                               // 0x0070(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_ApplyGameplayTags">();
	}
	static class UFortAthenaBTService_ApplyGameplayTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_ApplyGameplayTags>();
	}
};
static_assert(alignof(UFortAthenaBTService_ApplyGameplayTags) == 0x000008, "Wrong alignment on UFortAthenaBTService_ApplyGameplayTags");
static_assert(sizeof(UFortAthenaBTService_ApplyGameplayTags) == 0x000090, "Wrong size on UFortAthenaBTService_ApplyGameplayTags");
static_assert(offsetof(UFortAthenaBTService_ApplyGameplayTags, GameplayTagsToApply) == 0x000070, "Member 'UFortAthenaBTService_ApplyGameplayTags::GameplayTagsToApply' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_BuildConstruction
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTService_BuildConstruction final : public UBTService
{
public:
	class FName                                   StealWallBuildName;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StealWallBuildTypeName;                            // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StealWallBuildGridCoordName;                       // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_BuildConstruction">();
	}
	static class UFortAthenaBTService_BuildConstruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_BuildConstruction>();
	}
};
static_assert(alignof(UFortAthenaBTService_BuildConstruction) == 0x000008, "Wrong alignment on UFortAthenaBTService_BuildConstruction");
static_assert(sizeof(UFortAthenaBTService_BuildConstruction) == 0x000080, "Wrong size on UFortAthenaBTService_BuildConstruction");
static_assert(offsetof(UFortAthenaBTService_BuildConstruction, StealWallBuildName) == 0x000070, "Member 'UFortAthenaBTService_BuildConstruction::StealWallBuildName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_BuildConstruction, StealWallBuildTypeName) == 0x000074, "Member 'UFortAthenaBTService_BuildConstruction::StealWallBuildTypeName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_BuildConstruction, StealWallBuildGridCoordName) == 0x000078, "Member 'UFortAthenaBTService_BuildConstruction::StealWallBuildGridCoordName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_CopyBlackboardVariable
// 0x0058 (0x00C8 - 0x0070)
class UFortAthenaBTService_CopyBlackboardVariable final : public UBTService
{
public:
	struct FBlackboardKeySelector                 SourceBlackboardKey;                               // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 DestinationBlackboardKey;                          // 0x0098(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         bCopyOnBecomeRelevant : 1;                         // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCopyOnCeaseRelevant : 1;                          // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCopyWhenSourceValueChange : 1;                    // 0x00C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_CopyBlackboardVariable">();
	}
	static class UFortAthenaBTService_CopyBlackboardVariable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_CopyBlackboardVariable>();
	}
};
static_assert(alignof(UFortAthenaBTService_CopyBlackboardVariable) == 0x000008, "Wrong alignment on UFortAthenaBTService_CopyBlackboardVariable");
static_assert(sizeof(UFortAthenaBTService_CopyBlackboardVariable) == 0x0000C8, "Wrong size on UFortAthenaBTService_CopyBlackboardVariable");
static_assert(offsetof(UFortAthenaBTService_CopyBlackboardVariable, SourceBlackboardKey) == 0x000070, "Member 'UFortAthenaBTService_CopyBlackboardVariable::SourceBlackboardKey' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_CopyBlackboardVariable, DestinationBlackboardKey) == 0x000098, "Member 'UFortAthenaBTService_CopyBlackboardVariable::DestinationBlackboardKey' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_Interact
// 0x00D0 (0x0140 - 0x0070)
class UFortAthenaBTService_Interact final : public UBTService
{
public:
	struct FBlackboardKeySelector                 InteractExecutionStatusKeySelector;                // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 InteractContextInfoKeySelector;                    // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 InteractObjectKeySelector;                         // 0x00C0(0x0028)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 ExecutionStatusKeySelector;                        // 0x00E8(0x0028)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 MovementStateKeySelector;                          // 0x0110(0x0028)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	EInteractionBeingAttempted                    InteractionBeingAttempted;                         // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireDistanceCheck;                             // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireBlockedCheck;                              // 0x013A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13B[0x5];                                      // 0x013B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Interact">();
	}
	static class UFortAthenaBTService_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Interact>();
	}
};
static_assert(alignof(UFortAthenaBTService_Interact) == 0x000008, "Wrong alignment on UFortAthenaBTService_Interact");
static_assert(sizeof(UFortAthenaBTService_Interact) == 0x000140, "Wrong size on UFortAthenaBTService_Interact");
static_assert(offsetof(UFortAthenaBTService_Interact, InteractExecutionStatusKeySelector) == 0x000070, "Member 'UFortAthenaBTService_Interact::InteractExecutionStatusKeySelector' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Interact, InteractContextInfoKeySelector) == 0x000098, "Member 'UFortAthenaBTService_Interact::InteractContextInfoKeySelector' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Interact, InteractObjectKeySelector) == 0x0000C0, "Member 'UFortAthenaBTService_Interact::InteractObjectKeySelector' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Interact, ExecutionStatusKeySelector) == 0x0000E8, "Member 'UFortAthenaBTService_Interact::ExecutionStatusKeySelector' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Interact, MovementStateKeySelector) == 0x000110, "Member 'UFortAthenaBTService_Interact::MovementStateKeySelector' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Interact, InteractionBeingAttempted) == 0x000138, "Member 'UFortAthenaBTService_Interact::InteractionBeingAttempted' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Interact, bRequireDistanceCheck) == 0x000139, "Member 'UFortAthenaBTService_Interact::bRequireDistanceCheck' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Interact, bRequireBlockedCheck) == 0x00013A, "Member 'UFortAthenaBTService_Interact::bRequireBlockedCheck' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_ModulateVehicleSpeedUsingDistBetween
// 0x0070 (0x00E0 - 0x0070)
class UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween final : public UBTService
{
public:
	struct FBlackboardKeySelector                 BlackboardKeyA;                                    // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BlackboardKeyB;                                    // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MinDistance;                                       // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceSpeed;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceSpeed;                                  // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCalculateAs2D;                                    // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0xF];                                       // 0x00D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_ModulateVehicleSpeedUsingDistBetween">();
	}
	static class UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween>();
	}
};
static_assert(alignof(UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween) == 0x000008, "Wrong alignment on UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween");
static_assert(sizeof(UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween) == 0x0000E0, "Wrong size on UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween");
static_assert(offsetof(UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween, BlackboardKeyA) == 0x000070, "Member 'UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween::BlackboardKeyA' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween, BlackboardKeyB) == 0x000098, "Member 'UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween::BlackboardKeyB' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween, MinDistance) == 0x0000C0, "Member 'UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween::MinDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween, MaxDistance) == 0x0000C4, "Member 'UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween::MaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween, MinDistanceSpeed) == 0x0000C8, "Member 'UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween::MinDistanceSpeed' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween, MaxDistanceSpeed) == 0x0000CC, "Member 'UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween::MaxDistanceSpeed' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween, bCalculateAs2D) == 0x0000D0, "Member 'UFortAthenaBTService_ModulateVehicleSpeedUsingDistBetween::bCalculateAs2D' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_Patrolling
// 0x0020 (0x0090 - 0x0070)
class UFortAthenaBTService_Patrolling final : public UBTService
{
public:
	class FName                                   PatrollingAppendDestinationKeyName;                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AcceptableRadius;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllowPartialPath : 1;                             // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProjectGoalLocation : 1;                          // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Patrolling">();
	}
	static class UFortAthenaBTService_Patrolling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Patrolling>();
	}
};
static_assert(alignof(UFortAthenaBTService_Patrolling) == 0x000008, "Wrong alignment on UFortAthenaBTService_Patrolling");
static_assert(sizeof(UFortAthenaBTService_Patrolling) == 0x000090, "Wrong size on UFortAthenaBTService_Patrolling");
static_assert(offsetof(UFortAthenaBTService_Patrolling, PatrollingAppendDestinationKeyName) == 0x000070, "Member 'UFortAthenaBTService_Patrolling::PatrollingAppendDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Patrolling, AcceptableRadius) == 0x000078, "Member 'UFortAthenaBTService_Patrolling::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Patrolling, FilterClass) == 0x000080, "Member 'UFortAthenaBTService_Patrolling::FilterClass' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_PickUpLoot
// 0x0020 (0x0090 - 0x0070)
class UFortAthenaBTService_PickUpLoot final : public UBTService
{
public:
	class FName                                   LootObjectKeyName;                                 // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ExecutionStatusName;                               // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   InteractionExecutionStatusName;                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   InteractionContextInfoName;                        // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MovementStateKeyName;                              // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_PickUpLoot">();
	}
	static class UFortAthenaBTService_PickUpLoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_PickUpLoot>();
	}
};
static_assert(alignof(UFortAthenaBTService_PickUpLoot) == 0x000008, "Wrong alignment on UFortAthenaBTService_PickUpLoot");
static_assert(sizeof(UFortAthenaBTService_PickUpLoot) == 0x000090, "Wrong size on UFortAthenaBTService_PickUpLoot");
static_assert(offsetof(UFortAthenaBTService_PickUpLoot, LootObjectKeyName) == 0x000070, "Member 'UFortAthenaBTService_PickUpLoot::LootObjectKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_PickUpLoot, ExecutionStatusName) == 0x000074, "Member 'UFortAthenaBTService_PickUpLoot::ExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_PickUpLoot, InteractionExecutionStatusName) == 0x000078, "Member 'UFortAthenaBTService_PickUpLoot::InteractionExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_PickUpLoot, InteractionContextInfoName) == 0x00007C, "Member 'UFortAthenaBTService_PickUpLoot::InteractionContextInfoName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_PickUpLoot, MovementStateKeyName) == 0x000080, "Member 'UFortAthenaBTService_PickUpLoot::MovementStateKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_PropagatePatrolProgressToPassengers
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTService_PropagatePatrolProgressToPassengers final : public UBTService
{
public:
	class FName                                   PatrollingAppendDestinationKeyName;                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_PropagatePatrolProgressToPassengers">();
	}
	static class UFortAthenaBTService_PropagatePatrolProgressToPassengers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_PropagatePatrolProgressToPassengers>();
	}
};
static_assert(alignof(UFortAthenaBTService_PropagatePatrolProgressToPassengers) == 0x000008, "Wrong alignment on UFortAthenaBTService_PropagatePatrolProgressToPassengers");
static_assert(sizeof(UFortAthenaBTService_PropagatePatrolProgressToPassengers) == 0x000078, "Wrong size on UFortAthenaBTService_PropagatePatrolProgressToPassengers");
static_assert(offsetof(UFortAthenaBTService_PropagatePatrolProgressToPassengers, PatrollingAppendDestinationKeyName) == 0x000070, "Member 'UFortAthenaBTService_PropagatePatrolProgressToPassengers::PatrollingAppendDestinationKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_Slide
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTService_Slide final : public UBTService
{
public:
	class FName                                   SlideExecutionStatusName;                          // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Slide">();
	}
	static class UFortAthenaBTService_Slide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Slide>();
	}
};
static_assert(alignof(UFortAthenaBTService_Slide) == 0x000008, "Wrong alignment on UFortAthenaBTService_Slide");
static_assert(sizeof(UFortAthenaBTService_Slide) == 0x000078, "Wrong size on UFortAthenaBTService_Slide");
static_assert(offsetof(UFortAthenaBTService_Slide, SlideExecutionStatusName) == 0x000070, "Member 'UFortAthenaBTService_Slide::SlideExecutionStatusName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_Sprinting
// 0x0050 (0x00C0 - 0x0070)
class UFortAthenaBTService_Sprinting final : public UBTService
{
public:
	uint8                                         Pad_70[0x40];                                      // 0x0070(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SprintExecutionStatusName;                         // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TacticalSprintExecutionStatusName;                 // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Sprinting">();
	}
	static class UFortAthenaBTService_Sprinting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Sprinting>();
	}
};
static_assert(alignof(UFortAthenaBTService_Sprinting) == 0x000008, "Wrong alignment on UFortAthenaBTService_Sprinting");
static_assert(sizeof(UFortAthenaBTService_Sprinting) == 0x0000C0, "Wrong size on UFortAthenaBTService_Sprinting");
static_assert(offsetof(UFortAthenaBTService_Sprinting, SprintExecutionStatusName) == 0x0000B0, "Member 'UFortAthenaBTService_Sprinting::SprintExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Sprinting, TacticalSprintExecutionStatusName) == 0x0000B4, "Member 'UFortAthenaBTService_Sprinting::TacticalSprintExecutionStatusName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTService_UpdateTarget
// 0x0000 (0x0070 - 0x0070)
class UFortAthenaBTService_UpdateTarget final : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_UpdateTarget">();
	}
	static class UFortAthenaBTService_UpdateTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_UpdateTarget>();
	}
};
static_assert(alignof(UFortAthenaBTService_UpdateTarget) == 0x000008, "Wrong alignment on UFortAthenaBTService_UpdateTarget");
static_assert(sizeof(UFortAthenaBTService_UpdateTarget) == 0x000070, "Wrong size on UFortAthenaBTService_UpdateTarget");

// Class FortniteAI.FortAthenaBTService_Zipline
// 0x0048 (0x00B8 - 0x0070)
class UFortAthenaBTService_Zipline final : public UBTService
{
public:
	class FName                                   ZiplineTargetName;                                 // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LastZiplineUsedName;                               // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   InteractionExecutionStatusName;                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   InteractionContextInfoName;                        // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   UsageExecutionStatusName;                          // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ZiplineEntryLocationName;                          // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ZiplineExitLocationKeyName;                        // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MoveToPathMovementStateName;                       // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MoveExecutionStatusName;                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FocalPointName;                                    // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LastUsageTimeName;                                 // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x1C];                                      // 0x009C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTService_Zipline">();
	}
	static class UFortAthenaBTService_Zipline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTService_Zipline>();
	}
};
static_assert(alignof(UFortAthenaBTService_Zipline) == 0x000008, "Wrong alignment on UFortAthenaBTService_Zipline");
static_assert(sizeof(UFortAthenaBTService_Zipline) == 0x0000B8, "Wrong size on UFortAthenaBTService_Zipline");
static_assert(offsetof(UFortAthenaBTService_Zipline, ZiplineTargetName) == 0x000070, "Member 'UFortAthenaBTService_Zipline::ZiplineTargetName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, LastZiplineUsedName) == 0x000074, "Member 'UFortAthenaBTService_Zipline::LastZiplineUsedName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, InteractionExecutionStatusName) == 0x000078, "Member 'UFortAthenaBTService_Zipline::InteractionExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, InteractionContextInfoName) == 0x00007C, "Member 'UFortAthenaBTService_Zipline::InteractionContextInfoName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, UsageExecutionStatusName) == 0x000080, "Member 'UFortAthenaBTService_Zipline::UsageExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, ZiplineEntryLocationName) == 0x000084, "Member 'UFortAthenaBTService_Zipline::ZiplineEntryLocationName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, ZiplineExitLocationKeyName) == 0x000088, "Member 'UFortAthenaBTService_Zipline::ZiplineExitLocationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, MoveToPathMovementStateName) == 0x00008C, "Member 'UFortAthenaBTService_Zipline::MoveToPathMovementStateName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, MoveExecutionStatusName) == 0x000090, "Member 'UFortAthenaBTService_Zipline::MoveExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, FocalPointName) == 0x000094, "Member 'UFortAthenaBTService_Zipline::FocalPointName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTService_Zipline, LastUsageTimeName) == 0x000098, "Member 'UFortAthenaBTService_Zipline::LastUsageTimeName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_ActivateVehicleBoost
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTTask_ActivateVehicleBoost final : public UBTTaskNode
{
public:
	bool                                          bActivateBoost;                                    // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoostLength;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreMinimumDistanceLeft;                        // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_ActivateVehicleBoost">();
	}
	static class UFortAthenaBTTask_ActivateVehicleBoost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_ActivateVehicleBoost>();
	}
};
static_assert(alignof(UFortAthenaBTTask_ActivateVehicleBoost) == 0x000008, "Wrong alignment on UFortAthenaBTTask_ActivateVehicleBoost");
static_assert(sizeof(UFortAthenaBTTask_ActivateVehicleBoost) == 0x000080, "Wrong size on UFortAthenaBTTask_ActivateVehicleBoost");
static_assert(offsetof(UFortAthenaBTTask_ActivateVehicleBoost, bActivateBoost) == 0x000070, "Member 'UFortAthenaBTTask_ActivateVehicleBoost::bActivateBoost' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_ActivateVehicleBoost, BoostLength) == 0x000074, "Member 'UFortAthenaBTTask_ActivateVehicleBoost::BoostLength' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_ActivateVehicleBoost, bIgnoreMinimumDistanceLeft) == 0x000078, "Member 'UFortAthenaBTTask_ActivateVehicleBoost::bIgnoreMinimumDistanceLeft' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_BotAmbushPlayer
// 0x0090 (0x0108 - 0x0078)
class UFortAthenaBTTask_BotAmbushPlayer final : public UBTTask_Wait
{
public:
	float                                         FacingPrecision;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponCooldown;                                    // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClearBlackboardOnFinished;                        // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 TargetedPlayerKeySelector;                         // 0x0088(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 MaxLocationErrorKeySelector;                       // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 MinLocationErrorKeySelector;                       // 0x00D8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_BotAmbushPlayer">();
	}
	static class UFortAthenaBTTask_BotAmbushPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_BotAmbushPlayer>();
	}
};
static_assert(alignof(UFortAthenaBTTask_BotAmbushPlayer) == 0x000008, "Wrong alignment on UFortAthenaBTTask_BotAmbushPlayer");
static_assert(sizeof(UFortAthenaBTTask_BotAmbushPlayer) == 0x000108, "Wrong size on UFortAthenaBTTask_BotAmbushPlayer");
static_assert(offsetof(UFortAthenaBTTask_BotAmbushPlayer, FacingPrecision) == 0x000078, "Member 'UFortAthenaBTTask_BotAmbushPlayer::FacingPrecision' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotAmbushPlayer, WeaponCooldown) == 0x00007C, "Member 'UFortAthenaBTTask_BotAmbushPlayer::WeaponCooldown' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotAmbushPlayer, bClearBlackboardOnFinished) == 0x000080, "Member 'UFortAthenaBTTask_BotAmbushPlayer::bClearBlackboardOnFinished' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotAmbushPlayer, TargetedPlayerKeySelector) == 0x000088, "Member 'UFortAthenaBTTask_BotAmbushPlayer::TargetedPlayerKeySelector' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotAmbushPlayer, MaxLocationErrorKeySelector) == 0x0000B0, "Member 'UFortAthenaBTTask_BotAmbushPlayer::MaxLocationErrorKeySelector' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotAmbushPlayer, MinLocationErrorKeySelector) == 0x0000D8, "Member 'UFortAthenaBTTask_BotAmbushPlayer::MinLocationErrorKeySelector' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_BotMoveTo
// 0x0010 (0x00C0 - 0x00B0)
class UFortAthenaBTTask_BotMoveTo final : public UBTTask_MoveTo
{
public:
	class FName                                   MovementResultKeyName;                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ExecutionStatusKeyName;                            // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x2];                                       // 0x00B8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllowRandomWobble : 1;                            // 0x00BA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsUrgentMovement : 1;                             // 0x00BA(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_BotMoveTo">();
	}
	static class UFortAthenaBTTask_BotMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_BotMoveTo>();
	}
};
static_assert(alignof(UFortAthenaBTTask_BotMoveTo) == 0x000008, "Wrong alignment on UFortAthenaBTTask_BotMoveTo");
static_assert(sizeof(UFortAthenaBTTask_BotMoveTo) == 0x0000C0, "Wrong size on UFortAthenaBTTask_BotMoveTo");
static_assert(offsetof(UFortAthenaBTTask_BotMoveTo, MovementResultKeyName) == 0x0000B0, "Member 'UFortAthenaBTTask_BotMoveTo::MovementResultKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_BotMoveTo, ExecutionStatusKeyName) == 0x0000B4, "Member 'UFortAthenaBTTask_BotMoveTo::ExecutionStatusKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_Build
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTTask_Build final : public UBTTaskNode
{
public:
	class FName                                   ExecutionStatusKeyName;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FocalPointName;                                    // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BlockWeaponActionsKeyName;                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_Build">();
	}
	static class UFortAthenaBTTask_Build* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_Build>();
	}
};
static_assert(alignof(UFortAthenaBTTask_Build) == 0x000008, "Wrong alignment on UFortAthenaBTTask_Build");
static_assert(sizeof(UFortAthenaBTTask_Build) == 0x000080, "Wrong size on UFortAthenaBTTask_Build");
static_assert(offsetof(UFortAthenaBTTask_Build, ExecutionStatusKeyName) == 0x000070, "Member 'UFortAthenaBTTask_Build::ExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Build, FocalPointName) == 0x000074, "Member 'UFortAthenaBTTask_Build::FocalPointName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Build, BlockWeaponActionsKeyName) == 0x000078, "Member 'UFortAthenaBTTask_Build::BlockWeaponActionsKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_EnterVehicle
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_EnterVehicle final : public UBTTaskNode
{
public:
	class FName                                   SelectedVehicleKeyName;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_EnterVehicle">();
	}
	static class UFortAthenaBTTask_EnterVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_EnterVehicle>();
	}
};
static_assert(alignof(UFortAthenaBTTask_EnterVehicle) == 0x000008, "Wrong alignment on UFortAthenaBTTask_EnterVehicle");
static_assert(sizeof(UFortAthenaBTTask_EnterVehicle) == 0x000078, "Wrong size on UFortAthenaBTTask_EnterVehicle");
static_assert(offsetof(UFortAthenaBTTask_EnterVehicle, SelectedVehicleKeyName) == 0x000070, "Member 'UFortAthenaBTTask_EnterVehicle::SelectedVehicleKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_Interact
// 0x0068 (0x00D8 - 0x0070)
class UFortAthenaBTTask_Interact final : public UBTTaskNode
{
public:
	bool                                          bShouldFocusOnInteraction;                         // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 InteractExecutionStatusKeySelector;                // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 InteractContextInfoKeySelector;                    // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class FName                                   FocalPointName;                                    // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   JumpExecutionStatusName;                           // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponTriggerMeleeName;                            // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_Interact">();
	}
	static class UFortAthenaBTTask_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_Interact>();
	}
};
static_assert(alignof(UFortAthenaBTTask_Interact) == 0x000008, "Wrong alignment on UFortAthenaBTTask_Interact");
static_assert(sizeof(UFortAthenaBTTask_Interact) == 0x0000D8, "Wrong size on UFortAthenaBTTask_Interact");
static_assert(offsetof(UFortAthenaBTTask_Interact, bShouldFocusOnInteraction) == 0x000070, "Member 'UFortAthenaBTTask_Interact::bShouldFocusOnInteraction' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Interact, InteractExecutionStatusKeySelector) == 0x000078, "Member 'UFortAthenaBTTask_Interact::InteractExecutionStatusKeySelector' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Interact, InteractContextInfoKeySelector) == 0x0000A0, "Member 'UFortAthenaBTTask_Interact::InteractContextInfoKeySelector' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Interact, FocalPointName) == 0x0000C8, "Member 'UFortAthenaBTTask_Interact::FocalPointName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Interact, JumpExecutionStatusName) == 0x0000CC, "Member 'UFortAthenaBTTask_Interact::JumpExecutionStatusName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_Interact, WeaponTriggerMeleeName) == 0x0000D0, "Member 'UFortAthenaBTTask_Interact::WeaponTriggerMeleeName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_LeaveVehicle
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_LeaveVehicle final : public UBTTaskNode
{
public:
	bool                                          bWaitVehicleStop;                                  // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_LeaveVehicle">();
	}
	static class UFortAthenaBTTask_LeaveVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_LeaveVehicle>();
	}
};
static_assert(alignof(UFortAthenaBTTask_LeaveVehicle) == 0x000008, "Wrong alignment on UFortAthenaBTTask_LeaveVehicle");
static_assert(sizeof(UFortAthenaBTTask_LeaveVehicle) == 0x000078, "Wrong size on UFortAthenaBTTask_LeaveVehicle");
static_assert(offsetof(UFortAthenaBTTask_LeaveVehicle, bWaitVehicleStop) == 0x000070, "Member 'UFortAthenaBTTask_LeaveVehicle::bWaitVehicleStop' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_PauseVehicle
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_PauseVehicle final : public UBTTaskNode
{
public:
	bool                                          bPausePathFollow;                                  // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_PauseVehicle">();
	}
	static class UFortAthenaBTTask_PauseVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_PauseVehicle>();
	}
};
static_assert(alignof(UFortAthenaBTTask_PauseVehicle) == 0x000008, "Wrong alignment on UFortAthenaBTTask_PauseVehicle");
static_assert(sizeof(UFortAthenaBTTask_PauseVehicle) == 0x000078, "Wrong size on UFortAthenaBTTask_PauseVehicle");
static_assert(offsetof(UFortAthenaBTTask_PauseVehicle, bPausePathFollow) == 0x000070, "Member 'UFortAthenaBTTask_PauseVehicle::bPausePathFollow' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_PlayEmote
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_PlayEmote final : public UBTTaskNode
{
public:
	class FName                                   PlayEmoteExecutionStatusKeyName;                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_PlayEmote">();
	}
	static class UFortAthenaBTTask_PlayEmote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_PlayEmote>();
	}
};
static_assert(alignof(UFortAthenaBTTask_PlayEmote) == 0x000008, "Wrong alignment on UFortAthenaBTTask_PlayEmote");
static_assert(sizeof(UFortAthenaBTTask_PlayEmote) == 0x000078, "Wrong size on UFortAthenaBTTask_PlayEmote");
static_assert(offsetof(UFortAthenaBTTask_PlayEmote, PlayEmoteExecutionStatusKeyName) == 0x000070, "Member 'UFortAthenaBTTask_PlayEmote::PlayEmoteExecutionStatusKeyName' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_UseItem
// 0x0018 (0x0088 - 0x0070)
class UFortAthenaBTTask_UseItem final : public UBTTaskNode
{
public:
	class FName                                   ActionObjectKeyName;                               // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ExecutionStatusKeyName;                            // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinWaitTimeBetweenUses;                            // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWaitTimeBetweenUses;                            // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_UseItem">();
	}
	static class UFortAthenaBTTask_UseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_UseItem>();
	}
};
static_assert(alignof(UFortAthenaBTTask_UseItem) == 0x000008, "Wrong alignment on UFortAthenaBTTask_UseItem");
static_assert(sizeof(UFortAthenaBTTask_UseItem) == 0x000088, "Wrong size on UFortAthenaBTTask_UseItem");
static_assert(offsetof(UFortAthenaBTTask_UseItem, ActionObjectKeyName) == 0x000070, "Member 'UFortAthenaBTTask_UseItem::ActionObjectKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_UseItem, ExecutionStatusKeyName) == 0x000074, "Member 'UFortAthenaBTTask_UseItem::ExecutionStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_UseItem, MinWaitTimeBetweenUses) == 0x000078, "Member 'UFortAthenaBTTask_UseItem::MinWaitTimeBetweenUses' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_UseItem, MaxWaitTimeBetweenUses) == 0x00007C, "Member 'UFortAthenaBTTask_UseItem::MaxWaitTimeBetweenUses' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_VehicleHonk
// 0x0010 (0x0080 - 0x0070)
class UFortAthenaBTTask_VehicleHonk final : public UBTTaskNode
{
public:
	float                                         MaxHonkTime;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinHonkTime;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFlickerTime;                                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinFlickerTime;                                    // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_VehicleHonk">();
	}
	static class UFortAthenaBTTask_VehicleHonk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_VehicleHonk>();
	}
};
static_assert(alignof(UFortAthenaBTTask_VehicleHonk) == 0x000008, "Wrong alignment on UFortAthenaBTTask_VehicleHonk");
static_assert(sizeof(UFortAthenaBTTask_VehicleHonk) == 0x000080, "Wrong size on UFortAthenaBTTask_VehicleHonk");
static_assert(offsetof(UFortAthenaBTTask_VehicleHonk, MaxHonkTime) == 0x000070, "Member 'UFortAthenaBTTask_VehicleHonk::MaxHonkTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_VehicleHonk, MinHonkTime) == 0x000074, "Member 'UFortAthenaBTTask_VehicleHonk::MinHonkTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_VehicleHonk, MaxFlickerTime) == 0x000078, "Member 'UFortAthenaBTTask_VehicleHonk::MaxFlickerTime' has a wrong offset!");
static_assert(offsetof(UFortAthenaBTTask_VehicleHonk, MinFlickerTime) == 0x00007C, "Member 'UFortAthenaBTTask_VehicleHonk::MinFlickerTime' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_VehicleSwitchSeat
// 0x0008 (0x0078 - 0x0070)
class UFortAthenaBTTask_VehicleSwitchSeat final : public UBTTaskNode
{
public:
	ESwitchSeatType                               SwitchSeatType;                                    // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_VehicleSwitchSeat">();
	}
	static class UFortAthenaBTTask_VehicleSwitchSeat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_VehicleSwitchSeat>();
	}
};
static_assert(alignof(UFortAthenaBTTask_VehicleSwitchSeat) == 0x000008, "Wrong alignment on UFortAthenaBTTask_VehicleSwitchSeat");
static_assert(sizeof(UFortAthenaBTTask_VehicleSwitchSeat) == 0x000078, "Wrong size on UFortAthenaBTTask_VehicleSwitchSeat");
static_assert(offsetof(UFortAthenaBTTask_VehicleSwitchSeat, SwitchSeatType) == 0x000070, "Member 'UFortAthenaBTTask_VehicleSwitchSeat::SwitchSeatType' has a wrong offset!");

// Class FortniteAI.FortAthenaBTTask_VehicleTurnTo
// 0x0008 (0x00A0 - 0x0098)
class UFortAthenaBTTask_VehicleTurnTo final : public UBTTask_BlackboardBase
{
public:
	float                                         Precision;                                         // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaBTTask_VehicleTurnTo">();
	}
	static class UFortAthenaBTTask_VehicleTurnTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaBTTask_VehicleTurnTo>();
	}
};
static_assert(alignof(UFortAthenaBTTask_VehicleTurnTo) == 0x000008, "Wrong alignment on UFortAthenaBTTask_VehicleTurnTo");
static_assert(sizeof(UFortAthenaBTTask_VehicleTurnTo) == 0x0000A0, "Wrong size on UFortAthenaBTTask_VehicleTurnTo");
static_assert(offsetof(UFortAthenaBTTask_VehicleTurnTo, Precision) == 0x000098, "Member 'UFortAthenaBTTask_VehicleTurnTo::Precision' has a wrong offset!");

// Class FortniteAI.FortAthenaLeashComponent
// 0x0048 (0x00E8 - 0x00A0)
class UFortAthenaLeashComponent final : public UActorComponent
{
public:
	struct FScalableFloat                         LeashRadius;                                       // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FVector                                LeashCenter;                                       // 0x00C8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeashRadiusSqr;                                    // 0x00E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FVector GetLeashCenter() const;
	float GetLeashRadius() const;
	bool IsInsideLeash(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaLeashComponent">();
	}
	static class UFortAthenaLeashComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaLeashComponent>();
	}
};
static_assert(alignof(UFortAthenaLeashComponent) == 0x000008, "Wrong alignment on UFortAthenaLeashComponent");
static_assert(sizeof(UFortAthenaLeashComponent) == 0x0000E8, "Wrong size on UFortAthenaLeashComponent");
static_assert(offsetof(UFortAthenaLeashComponent, LeashRadius) == 0x0000A0, "Member 'UFortAthenaLeashComponent::LeashRadius' has a wrong offset!");
static_assert(offsetof(UFortAthenaLeashComponent, LeashCenter) == 0x0000C8, "Member 'UFortAthenaLeashComponent::LeashCenter' has a wrong offset!");
static_assert(offsetof(UFortAthenaLeashComponent, LeashRadiusSqr) == 0x0000E0, "Member 'UFortAthenaLeashComponent::LeashRadiusSqr' has a wrong offset!");

// Class FortniteAI.FortAthenaLocalGameplayBehavior
// 0x0010 (0x0280 - 0x0270)
class AFortAthenaLocalGameplayBehavior final : public AActor
{
public:
	bool                                          bNeedToAwakeDuringExecution;                       // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaBTTask_DynamicBlueprint*     CachedTask;                                        // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FinishExecute();
	void OnAbort();
	void OnExecute(class AActor* Activator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaLocalGameplayBehavior">();
	}
	static class AFortAthenaLocalGameplayBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaLocalGameplayBehavior>();
	}
};
static_assert(alignof(AFortAthenaLocalGameplayBehavior) == 0x000008, "Wrong alignment on AFortAthenaLocalGameplayBehavior");
static_assert(sizeof(AFortAthenaLocalGameplayBehavior) == 0x000280, "Wrong size on AFortAthenaLocalGameplayBehavior");
static_assert(offsetof(AFortAthenaLocalGameplayBehavior, bNeedToAwakeDuringExecution) == 0x000270, "Member 'AFortAthenaLocalGameplayBehavior::bNeedToAwakeDuringExecution' has a wrong offset!");
static_assert(offsetof(AFortAthenaLocalGameplayBehavior, CachedTask) == 0x000278, "Member 'AFortAthenaLocalGameplayBehavior::CachedTask' has a wrong offset!");

// Class FortniteAI.FortAthenaNavArea_Water
// 0x0000 (0x0050 - 0x0050)
class UFortAthenaNavArea_Water final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNavArea_Water">();
	}
	static class UFortAthenaNavArea_Water* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNavArea_Water>();
	}
};
static_assert(alignof(UFortAthenaNavArea_Water) == 0x000008, "Wrong alignment on UFortAthenaNavArea_Water");
static_assert(sizeof(UFortAthenaNavArea_Water) == 0x000050, "Wrong size on UFortAthenaNavArea_Water");

// Class FortniteAI.FortAthenaNpcEvaluator_Encampment
// 0x02A8 (0x04C0 - 0x0218)
class UFortAthenaNpcEvaluator_Encampment final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	struct FScalableFloat                         EncampmentEnable;                                  // 0x0218(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EncampmentTentativeDelayMin;                       // 0x0240(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EncampmentTentativeDelayMax;                       // 0x0268(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EncampmentDurationMin;                             // 0x0290(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EncampmentDurationMax;                             // 0x02B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         BuilderPercentage;                                 // 0x02E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         BuilderMinDistance;                                // 0x0308(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         BuilderMaxDistance;                                // 0x0330(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         GuardMinDistance;                                  // 0x0358(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         GuardMaxDistance;                                  // 0x0380(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         AllowInSwimming;                                   // 0x03A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         AllowInFalling;                                    // 0x03D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         MinSquadMembersCountToBuild;                       // 0x03F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   EncampmentStatusKeyName;                           // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EncampmentMovementStateKeyName;                    // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EncampmentCenterLocationKeyName;                   // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EncampmentDestinationKeyName;                      // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EncampmentAroundCampFireLocationKeyName;           // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EncampmentRoleKeyName;                             // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefensiveBuildName;                                // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_454[0x6C];                                     // 0x0454(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNpcEvaluator_Encampment">();
	}
	static class UFortAthenaNpcEvaluator_Encampment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNpcEvaluator_Encampment>();
	}
};
static_assert(alignof(UFortAthenaNpcEvaluator_Encampment) == 0x000008, "Wrong alignment on UFortAthenaNpcEvaluator_Encampment");
static_assert(sizeof(UFortAthenaNpcEvaluator_Encampment) == 0x0004C0, "Wrong size on UFortAthenaNpcEvaluator_Encampment");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentEnable) == 0x000218, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentEnable' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentTentativeDelayMin) == 0x000240, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentTentativeDelayMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentTentativeDelayMax) == 0x000268, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentTentativeDelayMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentDurationMin) == 0x000290, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentDurationMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentDurationMax) == 0x0002B8, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentDurationMax' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, BuilderPercentage) == 0x0002E0, "Member 'UFortAthenaNpcEvaluator_Encampment::BuilderPercentage' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, BuilderMinDistance) == 0x000308, "Member 'UFortAthenaNpcEvaluator_Encampment::BuilderMinDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, BuilderMaxDistance) == 0x000330, "Member 'UFortAthenaNpcEvaluator_Encampment::BuilderMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, GuardMinDistance) == 0x000358, "Member 'UFortAthenaNpcEvaluator_Encampment::GuardMinDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, GuardMaxDistance) == 0x000380, "Member 'UFortAthenaNpcEvaluator_Encampment::GuardMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, AllowInSwimming) == 0x0003A8, "Member 'UFortAthenaNpcEvaluator_Encampment::AllowInSwimming' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, AllowInFalling) == 0x0003D0, "Member 'UFortAthenaNpcEvaluator_Encampment::AllowInFalling' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, MinSquadMembersCountToBuild) == 0x0003F8, "Member 'UFortAthenaNpcEvaluator_Encampment::MinSquadMembersCountToBuild' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentStatusKeyName) == 0x000420, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentStatusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentMovementStateKeyName) == 0x000428, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentCenterLocationKeyName) == 0x000430, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentCenterLocationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentDestinationKeyName) == 0x000438, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentAroundCampFireLocationKeyName) == 0x000440, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentAroundCampFireLocationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, EncampmentRoleKeyName) == 0x000448, "Member 'UFortAthenaNpcEvaluator_Encampment::EncampmentRoleKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Encampment, DefensiveBuildName) == 0x000450, "Member 'UFortAthenaNpcEvaluator_Encampment::DefensiveBuildName' has a wrong offset!");

// Class FortniteAI.FortAthenaNpcEvaluator_FollowPatrolPath
// 0x0030 (0x0248 - 0x0218)
class UFortAthenaNpcEvaluator_FollowPatrolPath final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   FollowPatrolPathKeyName;                           // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FollowPatrolPathMovementStateKeyName;              // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FollowPatrolPathDestinationKeyName;                // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToTakeABreak;                                // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BreakDurationMin;                                  // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BreakDurationMax;                                  // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_234[0x14];                                     // 0x0234(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNpcEvaluator_FollowPatrolPath">();
	}
	static class UFortAthenaNpcEvaluator_FollowPatrolPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNpcEvaluator_FollowPatrolPath>();
	}
};
static_assert(alignof(UFortAthenaNpcEvaluator_FollowPatrolPath) == 0x000008, "Wrong alignment on UFortAthenaNpcEvaluator_FollowPatrolPath");
static_assert(sizeof(UFortAthenaNpcEvaluator_FollowPatrolPath) == 0x000248, "Wrong size on UFortAthenaNpcEvaluator_FollowPatrolPath");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowPatrolPath, FollowPatrolPathKeyName) == 0x000218, "Member 'UFortAthenaNpcEvaluator_FollowPatrolPath::FollowPatrolPathKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowPatrolPath, FollowPatrolPathMovementStateKeyName) == 0x00021C, "Member 'UFortAthenaNpcEvaluator_FollowPatrolPath::FollowPatrolPathMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowPatrolPath, FollowPatrolPathDestinationKeyName) == 0x000220, "Member 'UFortAthenaNpcEvaluator_FollowPatrolPath::FollowPatrolPathDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowPatrolPath, ChanceToTakeABreak) == 0x000228, "Member 'UFortAthenaNpcEvaluator_FollowPatrolPath::ChanceToTakeABreak' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowPatrolPath, BreakDurationMin) == 0x00022C, "Member 'UFortAthenaNpcEvaluator_FollowPatrolPath::BreakDurationMin' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_FollowPatrolPath, BreakDurationMax) == 0x000230, "Member 'UFortAthenaNpcEvaluator_FollowPatrolPath::BreakDurationMax' has a wrong offset!");

// Class FortniteAI.FortAthenaNpcEvaluator_Leash
// 0x0028 (0x0240 - 0x0218)
class UFortAthenaNpcEvaluator_Leash final : public UFortAthenaAIBotEvaluator_Movement
{
public:
	class FName                                   LeashKeyName;                                      // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LeashMovementStateKeyName;                         // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LeashDestinationKeyName;                           // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LeashLocationKeyName;                              // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LeashOuterRadiusKeyName;                           // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22C[0xC];                                      // 0x022C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIRuntimeParameters_Leash*   LeashRuntimeParameters;                            // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNpcEvaluator_Leash">();
	}
	static class UFortAthenaNpcEvaluator_Leash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNpcEvaluator_Leash>();
	}
};
static_assert(alignof(UFortAthenaNpcEvaluator_Leash) == 0x000008, "Wrong alignment on UFortAthenaNpcEvaluator_Leash");
static_assert(sizeof(UFortAthenaNpcEvaluator_Leash) == 0x000240, "Wrong size on UFortAthenaNpcEvaluator_Leash");
static_assert(offsetof(UFortAthenaNpcEvaluator_Leash, LeashKeyName) == 0x000218, "Member 'UFortAthenaNpcEvaluator_Leash::LeashKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Leash, LeashMovementStateKeyName) == 0x00021C, "Member 'UFortAthenaNpcEvaluator_Leash::LeashMovementStateKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Leash, LeashDestinationKeyName) == 0x000220, "Member 'UFortAthenaNpcEvaluator_Leash::LeashDestinationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Leash, LeashLocationKeyName) == 0x000224, "Member 'UFortAthenaNpcEvaluator_Leash::LeashLocationKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Leash, LeashOuterRadiusKeyName) == 0x000228, "Member 'UFortAthenaNpcEvaluator_Leash::LeashOuterRadiusKeyName' has a wrong offset!");
static_assert(offsetof(UFortAthenaNpcEvaluator_Leash, LeashRuntimeParameters) == 0x000238, "Member 'UFortAthenaNpcEvaluator_Leash::LeashRuntimeParameters' has a wrong offset!");

// Class FortniteAI.FortAthenaNPCLoopStateComponent
// 0x0010 (0x00B0 - 0x00A0)
class UFortAthenaNPCLoopStateComponent final : public UActorComponent
{
public:
	uint8                                         bSpawnOutsideTheLoop : 1;                          // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAthenaAIRuntimeParameters_AIBotLoopSettings* RuntimeLoopSettings;                               // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitLoopState(class AFortPawn* PawnOwner);
	void OnOwnerPawnDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaNPCLoopStateComponent">();
	}
	static class UFortAthenaNPCLoopStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaNPCLoopStateComponent>();
	}
};
static_assert(alignof(UFortAthenaNPCLoopStateComponent) == 0x000008, "Wrong alignment on UFortAthenaNPCLoopStateComponent");
static_assert(sizeof(UFortAthenaNPCLoopStateComponent) == 0x0000B0, "Wrong size on UFortAthenaNPCLoopStateComponent");
static_assert(offsetof(UFortAthenaNPCLoopStateComponent, RuntimeLoopSettings) == 0x0000A8, "Member 'UFortAthenaNPCLoopStateComponent::RuntimeLoopSettings' has a wrong offset!");

// Class FortniteAI.PatrolPathRenderingComponent
// 0x0000 (0x0530 - 0x0530)
class UPatrolPathRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatrolPathRenderingComponent">();
	}
	static class UPatrolPathRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatrolPathRenderingComponent>();
	}
};
static_assert(alignof(UPatrolPathRenderingComponent) == 0x000010, "Wrong alignment on UPatrolPathRenderingComponent");
static_assert(sizeof(UPatrolPathRenderingComponent) == 0x000530, "Wrong size on UPatrolPathRenderingComponent");

// Class FortniteAI.FortAthenaPatrolPath
// 0x0170 (0x03E0 - 0x0270)
class AFortAthenaPatrolPath : public AActor
{
public:
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EPatrollingMode                               Mode;                                              // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortAthenaPatrolPoint*>         PatrolPoints;                                      // 0x0288(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseRandomStartupPatrolPoint;                      // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRandomStartupDirection;                        // 0x0299(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A[0x6];                                      // 0x029A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x02A0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 RadialLeashLocationActorOverride;                  // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadialLeashInnerRadiusOverride;                    // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadialLeashOuterRadiusOverride;                    // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPatrolPathLeash>               PathLeashArray;                                    // 0x02D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WaterLevelIndexMax;                                // 0x02E0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         WaterLevelIndexMin;                                // 0x0308(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MaxConcurrentUsage;                                // 0x0330(0x0028)(Edit, NativeAccessSpecifierPrivate)
	int32                                         CurrentConcurrentUsage;                            // 0x0358(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         MaxLifetimeUsage;                                  // 0x0360(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         DebugLinkWidthSelected;                            // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugLinkWidthNotSelected;                         // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DebugNotSelectedColor;                             // 0x0390(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         BitPad_3A0_0 : 1;                                  // 0x03A0(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsPatrolPathEnabled : 1;                          // 0x03A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_3A1[0x3F];                                     // 0x03A1(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCurrentPlaylistLoaded(class FName PlaylistName, const struct FGameplayTagContainer& PlaylistContextTags);
	void SetPatrolPathEnabled(const bool bIsEnabled);

	bool CanBeUsed() const;
	void GetPatrolPoints(TArray<class AFortAthenaPatrolPoint*>* OutPatrolPoints) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaPatrolPath">();
	}
	static class AFortAthenaPatrolPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaPatrolPath>();
	}
};
static_assert(alignof(AFortAthenaPatrolPath) == 0x000008, "Wrong alignment on AFortAthenaPatrolPath");
static_assert(sizeof(AFortAthenaPatrolPath) == 0x0003E0, "Wrong size on AFortAthenaPatrolPath");
static_assert(offsetof(AFortAthenaPatrolPath, Mode) == 0x000280, "Member 'AFortAthenaPatrolPath::Mode' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, PatrolPoints) == 0x000288, "Member 'AFortAthenaPatrolPath::PatrolPoints' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, bUseRandomStartupPatrolPoint) == 0x000298, "Member 'AFortAthenaPatrolPath::bUseRandomStartupPatrolPoint' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, bUseRandomStartupDirection) == 0x000299, "Member 'AFortAthenaPatrolPath::bUseRandomStartupDirection' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, GameplayTags) == 0x0002A0, "Member 'AFortAthenaPatrolPath::GameplayTags' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, RadialLeashLocationActorOverride) == 0x0002C0, "Member 'AFortAthenaPatrolPath::RadialLeashLocationActorOverride' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, RadialLeashInnerRadiusOverride) == 0x0002C8, "Member 'AFortAthenaPatrolPath::RadialLeashInnerRadiusOverride' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, RadialLeashOuterRadiusOverride) == 0x0002CC, "Member 'AFortAthenaPatrolPath::RadialLeashOuterRadiusOverride' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, PathLeashArray) == 0x0002D0, "Member 'AFortAthenaPatrolPath::PathLeashArray' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, WaterLevelIndexMax) == 0x0002E0, "Member 'AFortAthenaPatrolPath::WaterLevelIndexMax' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, WaterLevelIndexMin) == 0x000308, "Member 'AFortAthenaPatrolPath::WaterLevelIndexMin' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, MaxConcurrentUsage) == 0x000330, "Member 'AFortAthenaPatrolPath::MaxConcurrentUsage' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, CurrentConcurrentUsage) == 0x000358, "Member 'AFortAthenaPatrolPath::CurrentConcurrentUsage' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, MaxLifetimeUsage) == 0x000360, "Member 'AFortAthenaPatrolPath::MaxLifetimeUsage' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, DebugLinkWidthSelected) == 0x000388, "Member 'AFortAthenaPatrolPath::DebugLinkWidthSelected' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, DebugLinkWidthNotSelected) == 0x00038C, "Member 'AFortAthenaPatrolPath::DebugLinkWidthNotSelected' has a wrong offset!");
static_assert(offsetof(AFortAthenaPatrolPath, DebugNotSelectedColor) == 0x000390, "Member 'AFortAthenaPatrolPath::DebugNotSelectedColor' has a wrong offset!");

// Class FortniteAI.PatrolPointRenderingComponent
// 0x0000 (0x0530 - 0x0530)
class UPatrolPointRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatrolPointRenderingComponent">();
	}
	static class UPatrolPointRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatrolPointRenderingComponent>();
	}
};
static_assert(alignof(UPatrolPointRenderingComponent) == 0x000010, "Wrong alignment on UPatrolPointRenderingComponent");
static_assert(sizeof(UPatrolPointRenderingComponent) == 0x000530, "Wrong size on UPatrolPointRenderingComponent");

// Class FortniteAI.FortAthenaPatrolPoint
// 0x0008 (0x0278 - 0x0270)
class AFortAthenaPatrolPoint final : public AActor
{
public:
	class AFortAthenaLocalGameplayBehavior*       LocalGameplayBehavior;                             // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaPatrolPoint">();
	}
	static class AFortAthenaPatrolPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaPatrolPoint>();
	}
};
static_assert(alignof(AFortAthenaPatrolPoint) == 0x000008, "Wrong alignment on AFortAthenaPatrolPoint");
static_assert(sizeof(AFortAthenaPatrolPoint) == 0x000278, "Wrong size on AFortAthenaPatrolPoint");
static_assert(offsetof(AFortAthenaPatrolPoint, LocalGameplayBehavior) == 0x000270, "Member 'AFortAthenaPatrolPoint::LocalGameplayBehavior' has a wrong offset!");

// Class FortniteAI.FortAthenaPlayerBotSpawnerData
// 0x0000 (0x0110 - 0x0110)
class UFortAthenaPlayerBotSpawnerData final : public UFortAthenaAIBotSpawnerData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaPlayerBotSpawnerData">();
	}
	static class UFortAthenaPlayerBotSpawnerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaPlayerBotSpawnerData>();
	}
};
static_assert(alignof(UFortAthenaPlayerBotSpawnerData) == 0x000008, "Wrong alignment on UFortAthenaPlayerBotSpawnerData");
static_assert(sizeof(UFortAthenaPlayerBotSpawnerData) == 0x000110, "Wrong size on UFortAthenaPlayerBotSpawnerData");

// Class FortniteAI.FortAthenaTrackableAIObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAthenaTrackableAIObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaTrackableAIObjectInterface">();
	}
	static class IFortAthenaTrackableAIObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAthenaTrackableAIObjectInterface>();
	}
};
static_assert(alignof(IFortAthenaTrackableAIObjectInterface) == 0x000008, "Wrong alignment on IFortAthenaTrackableAIObjectInterface");
static_assert(sizeof(IFortAthenaTrackableAIObjectInterface) == 0x000028, "Wrong size on IFortAthenaTrackableAIObjectInterface");

// Class FortniteAI.FortBTContext_MoveUrgency
// 0x0008 (0x0078 - 0x0070)
class UFortBTContext_MoveUrgency final : public UFortBTService_ContextOverride
{
public:
	EFortMovementUrgency                          MoveUrgency;                                       // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTContext_MoveUrgency">();
	}
	static class UFortBTContext_MoveUrgency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTContext_MoveUrgency>();
	}
};
static_assert(alignof(UFortBTContext_MoveUrgency) == 0x000008, "Wrong alignment on UFortBTContext_MoveUrgency");
static_assert(sizeof(UFortBTContext_MoveUrgency) == 0x000078, "Wrong size on UFortBTContext_MoveUrgency");
static_assert(offsetof(UFortBTContext_MoveUrgency, MoveUrgency) == 0x000070, "Member 'UFortBTContext_MoveUrgency::MoveUrgency' has a wrong offset!");

// Class FortniteAI.FortBTContext_SkipNotPerceivedGoals
// 0x0000 (0x0070 - 0x0070)
class UFortBTContext_SkipNotPerceivedGoals final : public UFortBTService_ContextOverride
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTContext_SkipNotPerceivedGoals">();
	}
	static class UFortBTContext_SkipNotPerceivedGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTContext_SkipNotPerceivedGoals>();
	}
};
static_assert(alignof(UFortBTContext_SkipNotPerceivedGoals) == 0x000008, "Wrong alignment on UFortBTContext_SkipNotPerceivedGoals");
static_assert(sizeof(UFortBTContext_SkipNotPerceivedGoals) == 0x000070, "Wrong size on UFortBTContext_SkipNotPerceivedGoals");

// Class FortniteAI.FortBTDecorator_AIBotVehicleSeatStatus
// 0x0008 (0x0070 - 0x0068)
class UFortBTDecorator_AIBotVehicleSeatStatus final : public UBTDecorator
{
public:
	ESeatStatusType                               SeatType;                                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_AIBotVehicleSeatStatus">();
	}
	static class UFortBTDecorator_AIBotVehicleSeatStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_AIBotVehicleSeatStatus>();
	}
};
static_assert(alignof(UFortBTDecorator_AIBotVehicleSeatStatus) == 0x000008, "Wrong alignment on UFortBTDecorator_AIBotVehicleSeatStatus");
static_assert(sizeof(UFortBTDecorator_AIBotVehicleSeatStatus) == 0x000070, "Wrong size on UFortBTDecorator_AIBotVehicleSeatStatus");
static_assert(offsetof(UFortBTDecorator_AIBotVehicleSeatStatus, SeatType) == 0x000068, "Member 'UFortBTDecorator_AIBotVehicleSeatStatus::SeatType' has a wrong offset!");

// Class FortniteAI.FortBTDecorator_CanBeConsideredAirborne
// 0x0000 (0x0090 - 0x0090)
class UFortBTDecorator_CanBeConsideredAirborne final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_CanBeConsideredAirborne">();
	}
	static class UFortBTDecorator_CanBeConsideredAirborne* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_CanBeConsideredAirborne>();
	}
};
static_assert(alignof(UFortBTDecorator_CanBeConsideredAirborne) == 0x000008, "Wrong alignment on UFortBTDecorator_CanBeConsideredAirborne");
static_assert(sizeof(UFortBTDecorator_CanBeConsideredAirborne) == 0x000090, "Wrong size on UFortBTDecorator_CanBeConsideredAirborne");

// Class FortniteAI.FortBTDecorator_GameplayAbility_CompareDistance
// 0x0010 (0x00E8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_CompareDistance final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	TArray<struct FDistanceToTargetComparison>    DistanceComparisons;                               // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_CompareDistance">();
	}
	static class UFortBTDecorator_GameplayAbility_CompareDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_CompareDistance>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_CompareDistance) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_CompareDistance");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_CompareDistance) == 0x0000E8, "Wrong size on UFortBTDecorator_GameplayAbility_CompareDistance");
static_assert(offsetof(UFortBTDecorator_GameplayAbility_CompareDistance, DistanceComparisons) == 0x0000D8, "Member 'UFortBTDecorator_GameplayAbility_CompareDistance::DistanceComparisons' has a wrong offset!");

// Class FortniteAI.FortBTDecorator_GameplayAbility_HasGameplayAbility
// 0x0020 (0x0088 - 0x0068)
class UFortBTDecorator_GameplayAbility_HasGameplayAbility final : public UBTDecorator
{
public:
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_HasGameplayAbility">();
	}
	static class UFortBTDecorator_GameplayAbility_HasGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_HasGameplayAbility>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_HasGameplayAbility) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_HasGameplayAbility");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_HasGameplayAbility) == 0x000088, "Wrong size on UFortBTDecorator_GameplayAbility_HasGameplayAbility");
static_assert(offsetof(UFortBTDecorator_GameplayAbility_HasGameplayAbility, GameplayAbilityTag) == 0x000068, "Member 'UFortBTDecorator_GameplayAbility_HasGameplayAbility::GameplayAbilityTag' has a wrong offset!");

// Class FortniteAI.FortBTDecorator_GameplayAbility_IsOnCooldown
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_IsOnCooldown final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_IsOnCooldown">();
	}
	static class UFortBTDecorator_GameplayAbility_IsOnCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_IsOnCooldown>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_IsOnCooldown) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_IsOnCooldown");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_IsOnCooldown) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_IsOnCooldown");

// Class FortniteAI.FortBTDecorator_GameplayAbility_IsRotatedToAttackTarget
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_IsRotatedToAttackTarget">();
	}
	static class UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget");

// Class FortniteAI.FortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange">();
	}
	static class UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange");

// Class FortniteAI.FortBTDecorator_IsGoalPawn
// 0x0000 (0x0090 - 0x0090)
class UFortBTDecorator_IsGoalPawn final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_IsGoalPawn">();
	}
	static class UFortBTDecorator_IsGoalPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_IsGoalPawn>();
	}
};
static_assert(alignof(UFortBTDecorator_IsGoalPawn) == 0x000008, "Wrong alignment on UFortBTDecorator_IsGoalPawn");
static_assert(sizeof(UFortBTDecorator_IsGoalPawn) == 0x000090, "Wrong size on UFortBTDecorator_IsGoalPawn");

// Class FortniteAI.FortBTDecorator_IsInBotEndGame
// 0x0000 (0x0068 - 0x0068)
class UFortBTDecorator_IsInBotEndGame final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_IsInBotEndGame">();
	}
	static class UFortBTDecorator_IsInBotEndGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_IsInBotEndGame>();
	}
};
static_assert(alignof(UFortBTDecorator_IsInBotEndGame) == 0x000008, "Wrong alignment on UFortBTDecorator_IsInBotEndGame");
static_assert(sizeof(UFortBTDecorator_IsInBotEndGame) == 0x000068, "Wrong size on UFortBTDecorator_IsInBotEndGame");

// Class FortniteAI.FortBTDecorator_IsTakerAirborne
// 0x0000 (0x0068 - 0x0068)
class UFortBTDecorator_IsTakerAirborne final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_IsTakerAirborne">();
	}
	static class UFortBTDecorator_IsTakerAirborne* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_IsTakerAirborne>();
	}
};
static_assert(alignof(UFortBTDecorator_IsTakerAirborne) == 0x000008, "Wrong alignment on UFortBTDecorator_IsTakerAirborne");
static_assert(sizeof(UFortBTDecorator_IsTakerAirborne) == 0x000068, "Wrong size on UFortBTDecorator_IsTakerAirborne");

// Class FortniteAI.FortBTTask_BotMissionInteract
// 0x0000 (0x0098 - 0x0098)
class UFortBTTask_BotMissionInteract final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_BotMissionInteract">();
	}
	static class UFortBTTask_BotMissionInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_BotMissionInteract>();
	}
};
static_assert(alignof(UFortBTTask_BotMissionInteract) == 0x000008, "Wrong alignment on UFortBTTask_BotMissionInteract");
static_assert(sizeof(UFortBTTask_BotMissionInteract) == 0x000098, "Wrong size on UFortBTTask_BotMissionInteract");

// Class FortniteAI.FortBTTask_ExecuteGameplayAbility
// 0x0020 (0x0098 - 0x0078)
class UFortBTTask_ExecuteGameplayAbility final : public UBTTask_GameplayTaskBase
{
public:
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0078(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_ExecuteGameplayAbility">();
	}
	static class UFortBTTask_ExecuteGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_ExecuteGameplayAbility>();
	}
};
static_assert(alignof(UFortBTTask_ExecuteGameplayAbility) == 0x000008, "Wrong alignment on UFortBTTask_ExecuteGameplayAbility");
static_assert(sizeof(UFortBTTask_ExecuteGameplayAbility) == 0x000098, "Wrong size on UFortBTTask_ExecuteGameplayAbility");
static_assert(offsetof(UFortBTTask_ExecuteGameplayAbility, GameplayAbilityTag) == 0x000078, "Member 'UFortBTTask_ExecuteGameplayAbility::GameplayAbilityTag' has a wrong offset!");

// Class FortniteAI.FortBTTask_GameMoveDirectlyToward
// 0x0000 (0x00F0 - 0x00F0)
class UFortBTTask_GameMoveDirectlyToward final : public UFortBTTask_GameMoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_GameMoveDirectlyToward">();
	}
	static class UFortBTTask_GameMoveDirectlyToward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_GameMoveDirectlyToward>();
	}
};
static_assert(alignof(UFortBTTask_GameMoveDirectlyToward) == 0x000008, "Wrong alignment on UFortBTTask_GameMoveDirectlyToward");
static_assert(sizeof(UFortBTTask_GameMoveDirectlyToward) == 0x0000F0, "Wrong size on UFortBTTask_GameMoveDirectlyToward");

// Class FortniteAI.FortBTTask_RequestUndermining
// 0x0000 (0x0070 - 0x0070)
class UFortBTTask_RequestUndermining final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_RequestUndermining">();
	}
	static class UFortBTTask_RequestUndermining* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_RequestUndermining>();
	}
};
static_assert(alignof(UFortBTTask_RequestUndermining) == 0x000008, "Wrong alignment on UFortBTTask_RequestUndermining");
static_assert(sizeof(UFortBTTask_RequestUndermining) == 0x000070, "Wrong size on UFortBTTask_RequestUndermining");

// Class FortniteAI.FortBTTask_SetFrustrationDiscouragement
// 0x0008 (0x0078 - 0x0070)
class UFortBTTask_SetFrustrationDiscouragement final : public UBTTaskNode
{
public:
	float                                         DiscouragementDuration;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_SetFrustrationDiscouragement">();
	}
	static class UFortBTTask_SetFrustrationDiscouragement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_SetFrustrationDiscouragement>();
	}
};
static_assert(alignof(UFortBTTask_SetFrustrationDiscouragement) == 0x000008, "Wrong alignment on UFortBTTask_SetFrustrationDiscouragement");
static_assert(sizeof(UFortBTTask_SetFrustrationDiscouragement) == 0x000078, "Wrong size on UFortBTTask_SetFrustrationDiscouragement");
static_assert(offsetof(UFortBTTask_SetFrustrationDiscouragement, DiscouragementDuration) == 0x000070, "Member 'UFortBTTask_SetFrustrationDiscouragement::DiscouragementDuration' has a wrong offset!");

// Class FortniteAI.FortCollisionResponseSwapperComponent
// 0x0080 (0x0120 - 0x00A0)
class UFortCollisionResponseSwapperComponent final : public UActorComponent
{
public:
	class UPrimitiveComponent*                    CollisionPrimitiveComponent;                       // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    OverlapPrimitiveComponent;                         // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPawn*>                      PawnsListenedTo;                                   // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         VisibilityModifiedTime;                            // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	ECollisionResponse                            NewCollisionResponse;                              // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandleEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void RegisterCallbacksForOverlap(class UPrimitiveComponent* InCollisionPrimitiveComponent, class UPrimitiveComponent* InOverlapPrimitiveComponent);
	void RestoreCollisionResponses();
	void UnregisterCallbacksForOverlap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCollisionResponseSwapperComponent">();
	}
	static class UFortCollisionResponseSwapperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCollisionResponseSwapperComponent>();
	}
};
static_assert(alignof(UFortCollisionResponseSwapperComponent) == 0x000008, "Wrong alignment on UFortCollisionResponseSwapperComponent");
static_assert(sizeof(UFortCollisionResponseSwapperComponent) == 0x000120, "Wrong size on UFortCollisionResponseSwapperComponent");
static_assert(offsetof(UFortCollisionResponseSwapperComponent, CollisionPrimitiveComponent) == 0x0000A0, "Member 'UFortCollisionResponseSwapperComponent::CollisionPrimitiveComponent' has a wrong offset!");
static_assert(offsetof(UFortCollisionResponseSwapperComponent, OverlapPrimitiveComponent) == 0x0000A8, "Member 'UFortCollisionResponseSwapperComponent::OverlapPrimitiveComponent' has a wrong offset!");
static_assert(offsetof(UFortCollisionResponseSwapperComponent, PawnsListenedTo) == 0x0000D8, "Member 'UFortCollisionResponseSwapperComponent::PawnsListenedTo' has a wrong offset!");
static_assert(offsetof(UFortCollisionResponseSwapperComponent, VisibilityModifiedTime) == 0x0000F0, "Member 'UFortCollisionResponseSwapperComponent::VisibilityModifiedTime' has a wrong offset!");
static_assert(offsetof(UFortCollisionResponseSwapperComponent, NewCollisionResponse) == 0x000118, "Member 'UFortCollisionResponseSwapperComponent::NewCollisionResponse' has a wrong offset!");

// Class FortniteAI.FortCreativePatrolPath
// 0x0008 (0x03E8 - 0x03E0)
class AFortCreativePatrolPath final : public AFortAthenaPatrolPath
{
public:
	EFortCreativePatrolPathGroup                  PatrolPathGroup;                                   // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCreativePatrolPath">();
	}
	static class AFortCreativePatrolPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCreativePatrolPath>();
	}
};
static_assert(alignof(AFortCreativePatrolPath) == 0x000008, "Wrong alignment on AFortCreativePatrolPath");
static_assert(sizeof(AFortCreativePatrolPath) == 0x0003E8, "Wrong size on AFortCreativePatrolPath");
static_assert(offsetof(AFortCreativePatrolPath, PatrolPathGroup) == 0x0003E0, "Member 'AFortCreativePatrolPath::PatrolPathGroup' has a wrong offset!");

// Class FortniteAI.FortEnemySpawn
// 0x0008 (0x0718 - 0x0710)
class AFortEnemySpawn final : public TObjectBasedCycleFixup<class ABuildingActor, 0x06E8, 0x08>
{
public:
	float                                         ClusterRadius;                                     // 0x0710(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_714[0x4];                                      // 0x0714(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnemySpawn">();
	}
	static class AFortEnemySpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortEnemySpawn>();
	}
};
static_assert(alignof(AFortEnemySpawn) == 0x000008, "Wrong alignment on AFortEnemySpawn");
static_assert(sizeof(AFortEnemySpawn) == 0x000718, "Wrong size on AFortEnemySpawn");
static_assert(offsetof(AFortEnemySpawn, ClusterRadius) == 0x000710, "Member 'AFortEnemySpawn::ClusterRadius' has a wrong offset!");

// Class FortniteAI.FortEQSPrevisActor
// 0x0010 (0x0280 - 0x0270)
class AFortEQSPrevisActor final : public AActor
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneRoot;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PrepForPrevis();
	void SetQueryTemplate(class UEnvQuery* InPrevisQueryTemplate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEQSPrevisActor">();
	}
	static class AFortEQSPrevisActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortEQSPrevisActor>();
	}
};
static_assert(alignof(AFortEQSPrevisActor) == 0x000008, "Wrong alignment on AFortEQSPrevisActor");
static_assert(sizeof(AFortEQSPrevisActor) == 0x000280, "Wrong size on AFortEQSPrevisActor");
static_assert(offsetof(AFortEQSPrevisActor, SceneRoot) == 0x000278, "Member 'AFortEQSPrevisActor::SceneRoot' has a wrong offset!");

// Class FortniteAI.FortInescapableZoneTracker
// 0x0068 (0x0090 - 0x0028)
class UFortInescapableZoneTracker final : public UObject
{
public:
	class AFortNavigationGraph*                   NavGraph;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInescapableZoneTracker">();
	}
	static class UFortInescapableZoneTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortInescapableZoneTracker>();
	}
};
static_assert(alignof(UFortInescapableZoneTracker) == 0x000008, "Wrong alignment on UFortInescapableZoneTracker");
static_assert(sizeof(UFortInescapableZoneTracker) == 0x000090, "Wrong size on UFortInescapableZoneTracker");
static_assert(offsetof(UFortInescapableZoneTracker, NavGraph) == 0x000028, "Member 'UFortInescapableZoneTracker::NavGraph' has a wrong offset!");

// Class FortniteAI.FortIntensityCurveSequenceProgression
// 0x0010 (0x0040 - 0x0030)
class UFortIntensityCurveSequenceProgression final : public UDataAsset
{
public:
	TArray<struct FFortInstensityCurveSequenceProgression> IntensityCurveSequences;                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIntensityCurveSequenceProgression">();
	}
	static class UFortIntensityCurveSequenceProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIntensityCurveSequenceProgression>();
	}
};
static_assert(alignof(UFortIntensityCurveSequenceProgression) == 0x000008, "Wrong alignment on UFortIntensityCurveSequenceProgression");
static_assert(sizeof(UFortIntensityCurveSequenceProgression) == 0x000040, "Wrong size on UFortIntensityCurveSequenceProgression");
static_assert(offsetof(UFortIntensityCurveSequenceProgression, IntensityCurveSequences) == 0x000030, "Member 'UFortIntensityCurveSequenceProgression::IntensityCurveSequences' has a wrong offset!");

// Class FortniteAI.FortJumpDownLink
// 0x0000 (0x02C0 - 0x02C0)
class AFortJumpDownLink final : public ANavLinkProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortJumpDownLink">();
	}
	static class AFortJumpDownLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortJumpDownLink>();
	}
};
static_assert(alignof(AFortJumpDownLink) == 0x000008, "Wrong alignment on AFortJumpDownLink");
static_assert(sizeof(AFortJumpDownLink) == 0x0002C0, "Wrong size on AFortJumpDownLink");

// Class FortniteAI.FortMetaNavArea
// 0x0010 (0x0058 - 0x0048)
class UFortMetaNavArea : public UNavAreaMeta
{
public:
	TArray<struct FNavAgentData>                  AgentData;                                         // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetaNavArea">();
	}
	static class UFortMetaNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetaNavArea>();
	}
};
static_assert(alignof(UFortMetaNavArea) == 0x000008, "Wrong alignment on UFortMetaNavArea");
static_assert(sizeof(UFortMetaNavArea) == 0x000058, "Wrong size on UFortMetaNavArea");
static_assert(offsetof(UFortMetaNavArea, AgentData) == 0x000048, "Member 'UFortMetaNavArea::AgentData' has a wrong offset!");

// Class FortniteAI.FortMetaNavArea_Obstacles
// 0x0008 (0x0050 - 0x0048)
class UFortMetaNavArea_Obstacles final : public UNavAreaMeta
{
public:
	int32                                         HealthThreshold;                                   // 0x0048(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetaNavArea_Obstacles">();
	}
	static class UFortMetaNavArea_Obstacles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetaNavArea_Obstacles>();
	}
};
static_assert(alignof(UFortMetaNavArea_Obstacles) == 0x000008, "Wrong alignment on UFortMetaNavArea_Obstacles");
static_assert(sizeof(UFortMetaNavArea_Obstacles) == 0x000050, "Wrong size on UFortMetaNavArea_Obstacles");
static_assert(offsetof(UFortMetaNavArea_Obstacles, HealthThreshold) == 0x000048, "Member 'UFortMetaNavArea_Obstacles::HealthThreshold' has a wrong offset!");

// Class FortniteAI.FortMetaNavArea_Wall
// 0x0000 (0x0058 - 0x0058)
class UFortMetaNavArea_Wall : public UFortMetaNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetaNavArea_Wall">();
	}
	static class UFortMetaNavArea_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetaNavArea_Wall>();
	}
};
static_assert(alignof(UFortMetaNavArea_Wall) == 0x000008, "Wrong alignment on UFortMetaNavArea_Wall");
static_assert(sizeof(UFortMetaNavArea_Wall) == 0x000058, "Wrong size on UFortMetaNavArea_Wall");

// Class FortniteAI.FortNavArea_BigMovingPawn
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_BigMovingPawn final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_BigMovingPawn">();
	}
	static class UFortNavArea_BigMovingPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_BigMovingPawn>();
	}
};
static_assert(alignof(UFortNavArea_BigMovingPawn) == 0x000008, "Wrong alignment on UFortNavArea_BigMovingPawn");
static_assert(sizeof(UFortNavArea_BigMovingPawn) == 0x000050, "Wrong size on UFortNavArea_BigMovingPawn");

// Class FortniteAI.FortNavArea_DefenderNull
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_DefenderNull final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_DefenderNull">();
	}
	static class UFortNavArea_DefenderNull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_DefenderNull>();
	}
};
static_assert(alignof(UFortNavArea_DefenderNull) == 0x000008, "Wrong alignment on UFortNavArea_DefenderNull");
static_assert(sizeof(UFortNavArea_DefenderNull) == 0x000050, "Wrong size on UFortNavArea_DefenderNull");

// Class FortniteAI.FortNavArea_HuskNull
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_HuskNull final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_HuskNull">();
	}
	static class UFortNavArea_HuskNull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_HuskNull>();
	}
};
static_assert(alignof(UFortNavArea_HuskNull) == 0x000008, "Wrong alignment on UFortNavArea_HuskNull");
static_assert(sizeof(UFortNavArea_HuskNull) == 0x000050, "Wrong size on UFortNavArea_HuskNull");

// Class FortniteAI.FortNavArea_LowSmashable
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_LowSmashable final : public UFortNavArea_DefaultSmashable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_LowSmashable">();
	}
	static class UFortNavArea_LowSmashable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_LowSmashable>();
	}
};
static_assert(alignof(UFortNavArea_LowSmashable) == 0x000008, "Wrong alignment on UFortNavArea_LowSmashable");
static_assert(sizeof(UFortNavArea_LowSmashable) == 0x000050, "Wrong size on UFortNavArea_LowSmashable");

// Class FortniteAI.FortNavArea_Obstacle
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_Obstacle : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_Obstacle">();
	}
	static class UFortNavArea_Obstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_Obstacle>();
	}
};
static_assert(alignof(UFortNavArea_Obstacle) == 0x000008, "Wrong alignment on UFortNavArea_Obstacle");
static_assert(sizeof(UFortNavArea_Obstacle) == 0x000050, "Wrong size on UFortNavArea_Obstacle");

// Class FortniteAI.FortNavArea_PortalOrSmash
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_PortalOrSmash final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_PortalOrSmash">();
	}
	static class UFortNavArea_PortalOrSmash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_PortalOrSmash>();
	}
};
static_assert(alignof(UFortNavArea_PortalOrSmash) == 0x000008, "Wrong alignment on UFortNavArea_PortalOrSmash");
static_assert(sizeof(UFortNavArea_PortalOrSmash) == 0x000050, "Wrong size on UFortNavArea_PortalOrSmash");

// Class FortniteAI.FortNavArea_StarlightCheapObstacle
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_StarlightCheapObstacle final : public UFortNavArea_CheapObstacle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_StarlightCheapObstacle">();
	}
	static class UFortNavArea_StarlightCheapObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_StarlightCheapObstacle>();
	}
};
static_assert(alignof(UFortNavArea_StarlightCheapObstacle) == 0x000008, "Wrong alignment on UFortNavArea_StarlightCheapObstacle");
static_assert(sizeof(UFortNavArea_StarlightCheapObstacle) == 0x000050, "Wrong size on UFortNavArea_StarlightCheapObstacle");

// Class FortniteAI.FortNavArea_StarlightObstacle
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_StarlightObstacle final : public UFortNavArea_Obstacle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_StarlightObstacle">();
	}
	static class UFortNavArea_StarlightObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_StarlightObstacle>();
	}
};
static_assert(alignof(UFortNavArea_StarlightObstacle) == 0x000008, "Wrong alignment on UFortNavArea_StarlightObstacle");
static_assert(sizeof(UFortNavArea_StarlightObstacle) == 0x000050, "Wrong size on UFortNavArea_StarlightObstacle");

// Class FortniteAI.FortNavArea_TraceSmashable
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_TraceSmashable final : public UFortNavArea_DefaultSmashable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_TraceSmashable">();
	}
	static class UFortNavArea_TraceSmashable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_TraceSmashable>();
	}
};
static_assert(alignof(UFortNavArea_TraceSmashable) == 0x000008, "Wrong alignment on UFortNavArea_TraceSmashable");
static_assert(sizeof(UFortNavArea_TraceSmashable) == 0x000050, "Wrong size on UFortNavArea_TraceSmashable");

// Class FortniteAI.FortNavArea_Unwalkable
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_Unwalkable final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_Unwalkable">();
	}
	static class UFortNavArea_Unwalkable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_Unwalkable>();
	}
};
static_assert(alignof(UFortNavArea_Unwalkable) == 0x000008, "Wrong alignment on UFortNavArea_Unwalkable");
static_assert(sizeof(UFortNavArea_Unwalkable) == 0x000050, "Wrong size on UFortNavArea_Unwalkable");

// Class FortniteAI.FortNavArea_WalkOverWall
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_WalkOverWall final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_WalkOverWall">();
	}
	static class UFortNavArea_WalkOverWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_WalkOverWall>();
	}
};
static_assert(alignof(UFortNavArea_WalkOverWall) == 0x000008, "Wrong alignment on UFortNavArea_WalkOverWall");
static_assert(sizeof(UFortNavArea_WalkOverWall) == 0x000050, "Wrong size on UFortNavArea_WalkOverWall");

// Class FortniteAI.FortNavArea_WallCorner
// 0x0000 (0x0050 - 0x0050)
class UFortNavArea_WallCorner final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_WallCorner">();
	}
	static class UFortNavArea_WallCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_WallCorner>();
	}
};
static_assert(alignof(UFortNavArea_WallCorner) == 0x000008, "Wrong alignment on UFortNavArea_WallCorner");
static_assert(sizeof(UFortNavArea_WallCorner) == 0x000050, "Wrong size on UFortNavArea_WallCorner");

// Class FortniteAI.FortNavGraphGoal
// 0x0010 (0x0280 - 0x0270)
class AFortNavGraphGoal final : public AActor
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GraphRadius;                                       // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavGraphGoal">();
	}
	static class AFortNavGraphGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavGraphGoal>();
	}
};
static_assert(alignof(AFortNavGraphGoal) == 0x000008, "Wrong alignment on AFortNavGraphGoal");
static_assert(sizeof(AFortNavGraphGoal) == 0x000280, "Wrong size on AFortNavGraphGoal");
static_assert(offsetof(AFortNavGraphGoal, GraphRadius) == 0x000278, "Member 'AFortNavGraphGoal::GraphRadius' has a wrong offset!");

// Class FortniteAI.FortNavigationFilter_Leash
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_Leash : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_Leash">();
	}
	static class UFortNavigationFilter_Leash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_Leash>();
	}
};
static_assert(alignof(UFortNavigationFilter_Leash) == 0x000008, "Wrong alignment on UFortNavigationFilter_Leash");
static_assert(sizeof(UFortNavigationFilter_Leash) == 0x000048, "Wrong size on UFortNavigationFilter_Leash");

// Class FortniteAI.FortNavigationFilter_NoSmashingIncludeLow
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_NoSmashingIncludeLow final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_NoSmashingIncludeLow">();
	}
	static class UFortNavigationFilter_NoSmashingIncludeLow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_NoSmashingIncludeLow>();
	}
};
static_assert(alignof(UFortNavigationFilter_NoSmashingIncludeLow) == 0x000008, "Wrong alignment on UFortNavigationFilter_NoSmashingIncludeLow");
static_assert(sizeof(UFortNavigationFilter_NoSmashingIncludeLow) == 0x000048, "Wrong size on UFortNavigationFilter_NoSmashingIncludeLow");

// Class FortniteAI.FortNavigationFilter_TetherZone
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_TetherZone final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_TetherZone">();
	}
	static class UFortNavigationFilter_TetherZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_TetherZone>();
	}
};
static_assert(alignof(UFortNavigationFilter_TetherZone) == 0x000008, "Wrong alignment on UFortNavigationFilter_TetherZone");
static_assert(sizeof(UFortNavigationFilter_TetherZone) == 0x000048, "Wrong size on UFortNavigationFilter_TetherZone");

// Class FortniteAI.FortNavigationGraph
// 0x0158 (0x05D8 - 0x0480)
class AFortNavigationGraph final : public ANavigationData
{
public:
	uint8                                         Pad_480[0x158];                                    // 0x0480(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationGraph">();
	}
	static class AFortNavigationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavigationGraph>();
	}
};
static_assert(alignof(AFortNavigationGraph) == 0x000008, "Wrong alignment on AFortNavigationGraph");
static_assert(sizeof(AFortNavigationGraph) == 0x0005D8, "Wrong size on AFortNavigationGraph");

// Class FortniteAI.FortNavLinkBlockerComponent
// 0x0000 (0x0570 - 0x0570)
class UFortNavLinkBlockerComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavLinkBlockerComponent">();
	}
	static class UFortNavLinkBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavLinkBlockerComponent>();
	}
};
static_assert(alignof(UFortNavLinkBlockerComponent) == 0x000010, "Wrong alignment on UFortNavLinkBlockerComponent");
static_assert(sizeof(UFortNavLinkBlockerComponent) == 0x000570, "Wrong size on UFortNavLinkBlockerComponent");

// Class FortniteAI.FortNavLinkContainer
// 0x0000 (0x0270 - 0x0270)
class AFortNavLinkContainer final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavLinkContainer">();
	}
	static class AFortNavLinkContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavLinkContainer>();
	}
};
static_assert(alignof(AFortNavLinkContainer) == 0x000008, "Wrong alignment on AFortNavLinkContainer");
static_assert(sizeof(AFortNavLinkContainer) == 0x000270, "Wrong size on AFortNavLinkContainer");

// Class FortniteAI.FortNavModifierVolume
// 0x0010 (0x02D0 - 0x02C0)
class AFortNavModifierVolume final : public ANavModifierVolume
{
public:
	TArray<TSubclassOf<class ANavigationData>>    EnableOnlyForNavmeshClasses;                       // 0x02C0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavModifierVolume">();
	}
	static class AFortNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavModifierVolume>();
	}
};
static_assert(alignof(AFortNavModifierVolume) == 0x000008, "Wrong alignment on AFortNavModifierVolume");
static_assert(sizeof(AFortNavModifierVolume) == 0x0002D0, "Wrong size on AFortNavModifierVolume");
static_assert(offsetof(AFortNavModifierVolume, EnableOnlyForNavmeshClasses) == 0x0002C0, "Member 'AFortNavModifierVolume::EnableOnlyForNavmeshClasses' has a wrong offset!");

// Class FortniteAI.FortNavObstacleComponent
// 0x0008 (0x00F8 - 0x00F0)
class UFortNavObstacleComponent final : public UNavRelevantComponent
{
public:
	TSubclassOf<class UNavArea>                   ObstacleAreaClass;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavObstacleComponent">();
	}
	static class UFortNavObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavObstacleComponent>();
	}
};
static_assert(alignof(UFortNavObstacleComponent) == 0x000008, "Wrong alignment on UFortNavObstacleComponent");
static_assert(sizeof(UFortNavObstacleComponent) == 0x0000F8, "Wrong size on UFortNavObstacleComponent");
static_assert(offsetof(UFortNavObstacleComponent, ObstacleAreaClass) == 0x0000F0, "Member 'UFortNavObstacleComponent::ObstacleAreaClass' has a wrong offset!");

// Class FortniteAI.FortPatrolWardInterface
// 0x0000 (0x0028 - 0x0028)
class IFortPatrolWardInterface final : public IInterface
{
public:
	float GetAffectingDistance() const;
	EWardAffectType GetAffectingType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPatrolWardInterface">();
	}
	static class IFortPatrolWardInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortPatrolWardInterface>();
	}
};
static_assert(alignof(IFortPatrolWardInterface) == 0x000008, "Wrong alignment on IFortPatrolWardInterface");
static_assert(sizeof(IFortPatrolWardInterface) == 0x000028, "Wrong size on IFortPatrolWardInterface");

// Class FortniteAI.FortPawnComponent_AIFormation
// 0x0030 (0x00D0 - 0x00A0)
class UFortPawnComponent_AIFormation final : public TObjectBasedCycleFixup<class UFortPawnComponent, 0x0078, 0x08>
{
public:
	TArray<struct FVector>                        Slots;                                             // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MaxDistanceFromSlotToSprint;                       // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAthenaAIFormationSlotRuntime> RuntimeSlots;                                      // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         MaxDistanceFromSlotToSprintSqr;                    // 0x00C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUserDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawnComponent_AIFormation">();
	}
	static class UFortPawnComponent_AIFormation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPawnComponent_AIFormation>();
	}
};
static_assert(alignof(UFortPawnComponent_AIFormation) == 0x000008, "Wrong alignment on UFortPawnComponent_AIFormation");
static_assert(sizeof(UFortPawnComponent_AIFormation) == 0x0000D0, "Wrong size on UFortPawnComponent_AIFormation");
static_assert(offsetof(UFortPawnComponent_AIFormation, Slots) == 0x0000A0, "Member 'UFortPawnComponent_AIFormation::Slots' has a wrong offset!");
static_assert(offsetof(UFortPawnComponent_AIFormation, MaxDistanceFromSlotToSprint) == 0x0000B0, "Member 'UFortPawnComponent_AIFormation::MaxDistanceFromSlotToSprint' has a wrong offset!");
static_assert(offsetof(UFortPawnComponent_AIFormation, RuntimeSlots) == 0x0000B8, "Member 'UFortPawnComponent_AIFormation::RuntimeSlots' has a wrong offset!");
static_assert(offsetof(UFortPawnComponent_AIFormation, MaxDistanceFromSlotToSprintSqr) == 0x0000C8, "Member 'UFortPawnComponent_AIFormation::MaxDistanceFromSlotToSprintSqr' has a wrong offset!");

// Class FortniteAI.FortPawnComponent_AIGroup
// 0x0008 (0x00A8 - 0x00A0)
class UFortPawnComponent_AIGroup final : public TObjectBasedCycleFixup<class UFortPawnComponent, 0x0078, 0x08>
{
public:
	bool                                          bCanBeGroupLeader;                                 // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupId;                                           // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnGroupMemberDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawnComponent_AIGroup">();
	}
	static class UFortPawnComponent_AIGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPawnComponent_AIGroup>();
	}
};
static_assert(alignof(UFortPawnComponent_AIGroup) == 0x000008, "Wrong alignment on UFortPawnComponent_AIGroup");
static_assert(sizeof(UFortPawnComponent_AIGroup) == 0x0000A8, "Wrong size on UFortPawnComponent_AIGroup");
static_assert(offsetof(UFortPawnComponent_AIGroup, bCanBeGroupLeader) == 0x0000A0, "Member 'UFortPawnComponent_AIGroup::bCanBeGroupLeader' has a wrong offset!");
static_assert(offsetof(UFortPawnComponent_AIGroup, GroupId) == 0x0000A4, "Member 'UFortPawnComponent_AIGroup::GroupId' has a wrong offset!");

// Class FortniteAI.FortQueryContext_AIPawnSpawnLocation
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_AIPawnSpawnLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AIPawnSpawnLocation">();
	}
	static class UFortQueryContext_AIPawnSpawnLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AIPawnSpawnLocation>();
	}
};
static_assert(alignof(UFortQueryContext_AIPawnSpawnLocation) == 0x000008, "Wrong alignment on UFortQueryContext_AIPawnSpawnLocation");
static_assert(sizeof(UFortQueryContext_AIPawnSpawnLocation) == 0x000028, "Wrong size on UFortQueryContext_AIPawnSpawnLocation");

// Class FortniteAI.FortQueryContext_AllBots
// 0x0050 (0x0078 - 0x0028)
class UFortQueryContext_AllBots final : public UEnvQueryContext
{
public:
	bool                                          bIncludeOnlyAthenaGameParticipantBots;             // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      BotTagQuery;                                       // 0x0030(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllBots">();
	}
	static class UFortQueryContext_AllBots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllBots>();
	}
};
static_assert(alignof(UFortQueryContext_AllBots) == 0x000008, "Wrong alignment on UFortQueryContext_AllBots");
static_assert(sizeof(UFortQueryContext_AllBots) == 0x000078, "Wrong size on UFortQueryContext_AllBots");
static_assert(offsetof(UFortQueryContext_AllBots, bIncludeOnlyAthenaGameParticipantBots) == 0x000028, "Member 'UFortQueryContext_AllBots::bIncludeOnlyAthenaGameParticipantBots' has a wrong offset!");
static_assert(offsetof(UFortQueryContext_AllBots, BotTagQuery) == 0x000030, "Member 'UFortQueryContext_AllBots::BotTagQuery' has a wrong offset!");

// Class FortniteAI.FortQueryContext_AllEnemies
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_AllEnemies final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllEnemies">();
	}
	static class UFortQueryContext_AllEnemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllEnemies>();
	}
};
static_assert(alignof(UFortQueryContext_AllEnemies) == 0x000008, "Wrong alignment on UFortQueryContext_AllEnemies");
static_assert(sizeof(UFortQueryContext_AllEnemies) == 0x000028, "Wrong size on UFortQueryContext_AllEnemies");

// Class FortniteAI.FortQueryContext_AllPlayers
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_AllPlayers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllPlayers">();
	}
	static class UFortQueryContext_AllPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllPlayers>();
	}
};
static_assert(alignof(UFortQueryContext_AllPlayers) == 0x000008, "Wrong alignment on UFortQueryContext_AllPlayers");
static_assert(sizeof(UFortQueryContext_AllPlayers) == 0x000028, "Wrong size on UFortQueryContext_AllPlayers");

// Class FortniteAI.FortQueryContext_AllPOIVolumes
// 0x0048 (0x0070 - 0x0028)
class UFortQueryContext_AllPOIVolumes final : public UEnvQueryContext
{
public:
	struct FGameplayTagQuery                      VolumeLocationTagQuery;                            // 0x0028(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllPOIVolumes">();
	}
	static class UFortQueryContext_AllPOIVolumes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllPOIVolumes>();
	}
};
static_assert(alignof(UFortQueryContext_AllPOIVolumes) == 0x000008, "Wrong alignment on UFortQueryContext_AllPOIVolumes");
static_assert(sizeof(UFortQueryContext_AllPOIVolumes) == 0x000070, "Wrong size on UFortQueryContext_AllPOIVolumes");
static_assert(offsetof(UFortQueryContext_AllPOIVolumes, VolumeLocationTagQuery) == 0x000028, "Member 'UFortQueryContext_AllPOIVolumes::VolumeLocationTagQuery' has a wrong offset!");

// Class FortniteAI.FortQueryContext_AthenaCurrentSafeZoneCenter
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_AthenaCurrentSafeZoneCenter final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AthenaCurrentSafeZoneCenter">();
	}
	static class UFortQueryContext_AthenaCurrentSafeZoneCenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AthenaCurrentSafeZoneCenter>();
	}
};
static_assert(alignof(UFortQueryContext_AthenaCurrentSafeZoneCenter) == 0x000008, "Wrong alignment on UFortQueryContext_AthenaCurrentSafeZoneCenter");
static_assert(sizeof(UFortQueryContext_AthenaCurrentSafeZoneCenter) == 0x000028, "Wrong size on UFortQueryContext_AthenaCurrentSafeZoneCenter");

// Class FortniteAI.FortQueryContext_AthenaCurrentSafeZoneIndicatorCenter
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_AthenaCurrentSafeZoneIndicatorCenter final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AthenaCurrentSafeZoneIndicatorCenter">();
	}
	static class UFortQueryContext_AthenaCurrentSafeZoneIndicatorCenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AthenaCurrentSafeZoneIndicatorCenter>();
	}
};
static_assert(alignof(UFortQueryContext_AthenaCurrentSafeZoneIndicatorCenter) == 0x000008, "Wrong alignment on UFortQueryContext_AthenaCurrentSafeZoneIndicatorCenter");
static_assert(sizeof(UFortQueryContext_AthenaCurrentSafeZoneIndicatorCenter) == 0x000028, "Wrong size on UFortQueryContext_AthenaCurrentSafeZoneIndicatorCenter");

// Class FortniteAI.FortQueryContext_BlackboardKeyLeader
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_BlackboardKeyLeader final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_BlackboardKeyLeader">();
	}
	static class UFortQueryContext_BlackboardKeyLeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_BlackboardKeyLeader>();
	}
};
static_assert(alignof(UFortQueryContext_BlackboardKeyLeader) == 0x000008, "Wrong alignment on UFortQueryContext_BlackboardKeyLeader");
static_assert(sizeof(UFortQueryContext_BlackboardKeyLeader) == 0x000028, "Wrong size on UFortQueryContext_BlackboardKeyLeader");

// Class FortniteAI.FortQueryContext_ConverterPawn
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_ConverterPawn final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_ConverterPawn">();
	}
	static class UFortQueryContext_ConverterPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_ConverterPawn>();
	}
};
static_assert(alignof(UFortQueryContext_ConverterPawn) == 0x000008, "Wrong alignment on UFortQueryContext_ConverterPawn");
static_assert(sizeof(UFortQueryContext_ConverterPawn) == 0x000028, "Wrong size on UFortQueryContext_ConverterPawn");

// Class FortniteAI.FortQueryContext_EncounterFallbackTarget
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterFallbackTarget final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterFallbackTarget">();
	}
	static class UFortQueryContext_EncounterFallbackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterFallbackTarget>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterFallbackTarget) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterFallbackTarget");
static_assert(sizeof(UFortQueryContext_EncounterFallbackTarget) == 0x000028, "Wrong size on UFortQueryContext_EncounterFallbackTarget");

// Class FortniteAI.FortQueryContext_EncounterGoalsCenterLocation
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterGoalsCenterLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterGoalsCenterLocation">();
	}
	static class UFortQueryContext_EncounterGoalsCenterLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterGoalsCenterLocation>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterGoalsCenterLocation) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterGoalsCenterLocation");
static_assert(sizeof(UFortQueryContext_EncounterGoalsCenterLocation) == 0x000028, "Wrong size on UFortQueryContext_EncounterGoalsCenterLocation");

// Class FortniteAI.FortQueryContext_EncounterGoalsOnGround
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterGoalsOnGround final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterGoalsOnGround">();
	}
	static class UFortQueryContext_EncounterGoalsOnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterGoalsOnGround>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterGoalsOnGround) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterGoalsOnGround");
static_assert(sizeof(UFortQueryContext_EncounterGoalsOnGround) == 0x000028, "Wrong size on UFortQueryContext_EncounterGoalsOnGround");

// Class FortniteAI.FortQueryContext_EncounterProvidedQueryLocations
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterProvidedQueryLocations final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterProvidedQueryLocations">();
	}
	static class UFortQueryContext_EncounterProvidedQueryLocations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterProvidedQueryLocations>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterProvidedQueryLocations) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterProvidedQueryLocations");
static_assert(sizeof(UFortQueryContext_EncounterProvidedQueryLocations) == 0x000028, "Wrong size on UFortQueryContext_EncounterProvidedQueryLocations");

// Class FortniteAI.FortQueryContext_EncounterQueryActor
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterQueryActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterQueryActor">();
	}
	static class UFortQueryContext_EncounterQueryActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterQueryActor>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterQueryActor) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterQueryActor");
static_assert(sizeof(UFortQueryContext_EncounterQueryActor) == 0x000028, "Wrong size on UFortQueryContext_EncounterQueryActor");

// Class FortniteAI.FortQueryContext_EncounterRandomDirection
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterRandomDirection final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterRandomDirection">();
	}
	static class UFortQueryContext_EncounterRandomDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterRandomDirection>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterRandomDirection) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterRandomDirection");
static_assert(sizeof(UFortQueryContext_EncounterRandomDirection) == 0x000028, "Wrong size on UFortQueryContext_EncounterRandomDirection");

// Class FortniteAI.FortQueryContext_EncounterTargetObjective
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterTargetObjective final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterTargetObjective">();
	}
	static class UFortQueryContext_EncounterTargetObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterTargetObjective>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterTargetObjective) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterTargetObjective");
static_assert(sizeof(UFortQueryContext_EncounterTargetObjective) == 0x000028, "Wrong size on UFortQueryContext_EncounterTargetObjective");

// Class FortniteAI.FortQueryContext_Goal
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_Goal final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_Goal">();
	}
	static class UFortQueryContext_Goal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_Goal>();
	}
};
static_assert(alignof(UFortQueryContext_Goal) == 0x000008, "Wrong alignment on UFortQueryContext_Goal");
static_assert(sizeof(UFortQueryContext_Goal) == 0x000028, "Wrong size on UFortQueryContext_Goal");

// Class FortniteAI.FortQueryContext_GoalProviderRootAssignmentGoals
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_GoalProviderRootAssignmentGoals final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_GoalProviderRootAssignmentGoals">();
	}
	static class UFortQueryContext_GoalProviderRootAssignmentGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_GoalProviderRootAssignmentGoals>();
	}
};
static_assert(alignof(UFortQueryContext_GoalProviderRootAssignmentGoals) == 0x000008, "Wrong alignment on UFortQueryContext_GoalProviderRootAssignmentGoals");
static_assert(sizeof(UFortQueryContext_GoalProviderRootAssignmentGoals) == 0x000028, "Wrong size on UFortQueryContext_GoalProviderRootAssignmentGoals");

// Class FortniteAI.FortQueryContext_NearbyAIPawns
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_NearbyAIPawns final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_NearbyAIPawns">();
	}
	static class UFortQueryContext_NearbyAIPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_NearbyAIPawns>();
	}
};
static_assert(alignof(UFortQueryContext_NearbyAIPawns) == 0x000008, "Wrong alignment on UFortQueryContext_NearbyAIPawns");
static_assert(sizeof(UFortQueryContext_NearbyAIPawns) == 0x000028, "Wrong size on UFortQueryContext_NearbyAIPawns");

// Class FortniteAI.FortQueryContext_NearbyFriendlyAIPawns
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_NearbyFriendlyAIPawns final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_NearbyFriendlyAIPawns">();
	}
	static class UFortQueryContext_NearbyFriendlyAIPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_NearbyFriendlyAIPawns>();
	}
};
static_assert(alignof(UFortQueryContext_NearbyFriendlyAIPawns) == 0x000008, "Wrong alignment on UFortQueryContext_NearbyFriendlyAIPawns");
static_assert(sizeof(UFortQueryContext_NearbyFriendlyAIPawns) == 0x000028, "Wrong size on UFortQueryContext_NearbyFriendlyAIPawns");

// Class FortniteAI.FortQueryContext_NearbyFriendlyAIPawnsAndPlayerPawns
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_NearbyFriendlyAIPawnsAndPlayerPawns final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_NearbyFriendlyAIPawnsAndPlayerPawns">();
	}
	static class UFortQueryContext_NearbyFriendlyAIPawnsAndPlayerPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_NearbyFriendlyAIPawnsAndPlayerPawns>();
	}
};
static_assert(alignof(UFortQueryContext_NearbyFriendlyAIPawnsAndPlayerPawns) == 0x000008, "Wrong alignment on UFortQueryContext_NearbyFriendlyAIPawnsAndPlayerPawns");
static_assert(sizeof(UFortQueryContext_NearbyFriendlyAIPawnsAndPlayerPawns) == 0x000028, "Wrong size on UFortQueryContext_NearbyFriendlyAIPawnsAndPlayerPawns");

// Class FortniteAI.FortQueryContext_RandomDirectionXY
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_RandomDirectionXY final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_RandomDirectionXY">();
	}
	static class UFortQueryContext_RandomDirectionXY* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_RandomDirectionXY>();
	}
};
static_assert(alignof(UFortQueryContext_RandomDirectionXY) == 0x000008, "Wrong alignment on UFortQueryContext_RandomDirectionXY");
static_assert(sizeof(UFortQueryContext_RandomDirectionXY) == 0x000028, "Wrong size on UFortQueryContext_RandomDirectionXY");

// Class FortniteAI.FortQueryContext_SpawnSpotActorLocationOrAIPawnSpawnLocation
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_SpawnSpotActorLocationOrAIPawnSpawnLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_SpawnSpotActorLocationOrAIPawnSpawnLocation">();
	}
	static class UFortQueryContext_SpawnSpotActorLocationOrAIPawnSpawnLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_SpawnSpotActorLocationOrAIPawnSpawnLocation>();
	}
};
static_assert(alignof(UFortQueryContext_SpawnSpotActorLocationOrAIPawnSpawnLocation) == 0x000008, "Wrong alignment on UFortQueryContext_SpawnSpotActorLocationOrAIPawnSpawnLocation");
static_assert(sizeof(UFortQueryContext_SpawnSpotActorLocationOrAIPawnSpawnLocation) == 0x000028, "Wrong size on UFortQueryContext_SpawnSpotActorLocationOrAIPawnSpawnLocation");

// Class FortniteAI.FortQueryContext_StWStormShield
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_StWStormShield final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_StWStormShield">();
	}
	static class UFortQueryContext_StWStormShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_StWStormShield>();
	}
};
static_assert(alignof(UFortQueryContext_StWStormShield) == 0x000008, "Wrong alignment on UFortQueryContext_StWStormShield");
static_assert(sizeof(UFortQueryContext_StWStormShield) == 0x000028, "Wrong size on UFortQueryContext_StWStormShield");

// Class FortniteAI.FortQueryContext_TwoPointSolverRotationA
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_TwoPointSolverRotationA final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_TwoPointSolverRotationA">();
	}
	static class UFortQueryContext_TwoPointSolverRotationA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_TwoPointSolverRotationA>();
	}
};
static_assert(alignof(UFortQueryContext_TwoPointSolverRotationA) == 0x000008, "Wrong alignment on UFortQueryContext_TwoPointSolverRotationA");
static_assert(sizeof(UFortQueryContext_TwoPointSolverRotationA) == 0x000028, "Wrong size on UFortQueryContext_TwoPointSolverRotationA");

// Class FortniteAI.FortQueryGenerator_ActorsAround
// 0x0000 (0x00D0 - 0x00D0)
class UFortQueryGenerator_ActorsAround final : public UEnvQueryGenerator_ActorsOfClass
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_ActorsAround">();
	}
	static class UFortQueryGenerator_ActorsAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_ActorsAround>();
	}
};
static_assert(alignof(UFortQueryGenerator_ActorsAround) == 0x000008, "Wrong alignment on UFortQueryGenerator_ActorsAround");
static_assert(sizeof(UFortQueryGenerator_ActorsAround) == 0x0000D0, "Wrong size on UFortQueryGenerator_ActorsAround");

// Class FortniteAI.FortQueryGenerator_Allies
// 0x0000 (0x0050 - 0x0050)
class UFortQueryGenerator_Allies final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_Allies">();
	}
	static class UFortQueryGenerator_Allies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_Allies>();
	}
};
static_assert(alignof(UFortQueryGenerator_Allies) == 0x000008, "Wrong alignment on UFortQueryGenerator_Allies");
static_assert(sizeof(UFortQueryGenerator_Allies) == 0x000050, "Wrong size on UFortQueryGenerator_Allies");

// Class FortniteAI.FortQueryGenerator_AssignmentGoal
// 0x0000 (0x0050 - 0x0050)
class UFortQueryGenerator_AssignmentGoal final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_AssignmentGoal">();
	}
	static class UFortQueryGenerator_AssignmentGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_AssignmentGoal>();
	}
};
static_assert(alignof(UFortQueryGenerator_AssignmentGoal) == 0x000008, "Wrong alignment on UFortQueryGenerator_AssignmentGoal");
static_assert(sizeof(UFortQueryGenerator_AssignmentGoal) == 0x000050, "Wrong size on UFortQueryGenerator_AssignmentGoal");

// Class FortniteAI.FortQueryGenerator_BuildingRifts
// 0x0000 (0x0050 - 0x0050)
class UFortQueryGenerator_BuildingRifts final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_BuildingRifts">();
	}
	static class UFortQueryGenerator_BuildingRifts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_BuildingRifts>();
	}
};
static_assert(alignof(UFortQueryGenerator_BuildingRifts) == 0x000008, "Wrong alignment on UFortQueryGenerator_BuildingRifts");
static_assert(sizeof(UFortQueryGenerator_BuildingRifts) == 0x000050, "Wrong size on UFortQueryGenerator_BuildingRifts");

// Class FortniteAI.FortQueryGenerator_BuildingsOnCachedPath
// 0x00B0 (0x0100 - 0x0050)
class UFortQueryGenerator_BuildingsOnCachedPath final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           CachedPathSource;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeWalls;                                     // 0x0058(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeFloors;                                    // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeCenterCell;                                // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_BuildingsOnCachedPath">();
	}
	static class UFortQueryGenerator_BuildingsOnCachedPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_BuildingsOnCachedPath>();
	}
};
static_assert(alignof(UFortQueryGenerator_BuildingsOnCachedPath) == 0x000008, "Wrong alignment on UFortQueryGenerator_BuildingsOnCachedPath");
static_assert(sizeof(UFortQueryGenerator_BuildingsOnCachedPath) == 0x000100, "Wrong size on UFortQueryGenerator_BuildingsOnCachedPath");
static_assert(offsetof(UFortQueryGenerator_BuildingsOnCachedPath, CachedPathSource) == 0x000050, "Member 'UFortQueryGenerator_BuildingsOnCachedPath::CachedPathSource' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_BuildingsOnCachedPath, bIncludeWalls) == 0x000058, "Member 'UFortQueryGenerator_BuildingsOnCachedPath::bIncludeWalls' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_BuildingsOnCachedPath, bIncludeFloors) == 0x000090, "Member 'UFortQueryGenerator_BuildingsOnCachedPath::bIncludeFloors' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_BuildingsOnCachedPath, bIncludeCenterCell) == 0x0000C8, "Member 'UFortQueryGenerator_BuildingsOnCachedPath::bIncludeCenterCell' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_EncounterTargets
// 0x0000 (0x0050 - 0x0050)
class UFortQueryGenerator_EncounterTargets final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_EncounterTargets">();
	}
	static class UFortQueryGenerator_EncounterTargets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_EncounterTargets>();
	}
};
static_assert(alignof(UFortQueryGenerator_EncounterTargets) == 0x000008, "Wrong alignment on UFortQueryGenerator_EncounterTargets");
static_assert(sizeof(UFortQueryGenerator_EncounterTargets) == 0x000050, "Wrong size on UFortQueryGenerator_EncounterTargets");

// Class FortniteAI.FortQueryGenerator_Enemies
// 0x0080 (0x00D0 - 0x0050)
class UFortQueryGenerator_Enemies final : public UEnvQueryGenerator
{
public:
	bool                                          bPerceivedEnemiesOnly;                             // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSleepCapableAIUsePerceivedEnemiesOnly;            // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreDBNOPawns;                                  // 0x0052(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreSleepingAIs;                                // 0x0053(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAddEnemiesFromAbilityRange;                       // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0058(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  DistanceTags;                                      // 0x0078(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxTimeSincePerceived;                             // 0x0098(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_Enemies">();
	}
	static class UFortQueryGenerator_Enemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_Enemies>();
	}
};
static_assert(alignof(UFortQueryGenerator_Enemies) == 0x000008, "Wrong alignment on UFortQueryGenerator_Enemies");
static_assert(sizeof(UFortQueryGenerator_Enemies) == 0x0000D0, "Wrong size on UFortQueryGenerator_Enemies");
static_assert(offsetof(UFortQueryGenerator_Enemies, bPerceivedEnemiesOnly) == 0x000050, "Member 'UFortQueryGenerator_Enemies::bPerceivedEnemiesOnly' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, bSleepCapableAIUsePerceivedEnemiesOnly) == 0x000051, "Member 'UFortQueryGenerator_Enemies::bSleepCapableAIUsePerceivedEnemiesOnly' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, bIgnoreDBNOPawns) == 0x000052, "Member 'UFortQueryGenerator_Enemies::bIgnoreDBNOPawns' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, bIgnoreSleepingAIs) == 0x000053, "Member 'UFortQueryGenerator_Enemies::bIgnoreSleepingAIs' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, bAddEnemiesFromAbilityRange) == 0x000054, "Member 'UFortQueryGenerator_Enemies::bAddEnemiesFromAbilityRange' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, AbilityTags) == 0x000058, "Member 'UFortQueryGenerator_Enemies::AbilityTags' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, DistanceTags) == 0x000078, "Member 'UFortQueryGenerator_Enemies::DistanceTags' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, MaxTimeSincePerceived) == 0x000098, "Member 'UFortQueryGenerator_Enemies::MaxTimeSincePerceived' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_GoalActorsOfClass
// 0x0048 (0x0098 - 0x0050)
class UFortQueryGenerator_GoalActorsOfClass final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class AActor>                     SearchedActorClass;                                // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0058(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_GoalActorsOfClass">();
	}
	static class UFortQueryGenerator_GoalActorsOfClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_GoalActorsOfClass>();
	}
};
static_assert(alignof(UFortQueryGenerator_GoalActorsOfClass) == 0x000008, "Wrong alignment on UFortQueryGenerator_GoalActorsOfClass");
static_assert(sizeof(UFortQueryGenerator_GoalActorsOfClass) == 0x000098, "Wrong size on UFortQueryGenerator_GoalActorsOfClass");
static_assert(offsetof(UFortQueryGenerator_GoalActorsOfClass, SearchedActorClass) == 0x000050, "Member 'UFortQueryGenerator_GoalActorsOfClass::SearchedActorClass' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_GoalActorsOfClass, SearchRadius) == 0x000058, "Member 'UFortQueryGenerator_GoalActorsOfClass::SearchRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_GoalActorsOfClass, SearchCenter) == 0x000090, "Member 'UFortQueryGenerator_GoalActorsOfClass::SearchCenter' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_GoalOnCircle
// 0x0040 (0x0260 - 0x0220)
class UFortQueryGenerator_GoalOnCircle final : public UEnvQueryGenerator_OnCircle
{
public:
	bool                                          bIncludeCenterActorInGeneratedGoals;               // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIAssignmentSettings*              OptionalAssignmentSettings;                        // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortAIAssignmentIdentifier            OptionalAssignmentIdentifier;                      // 0x0230(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_GoalOnCircle">();
	}
	static class UFortQueryGenerator_GoalOnCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_GoalOnCircle>();
	}
};
static_assert(alignof(UFortQueryGenerator_GoalOnCircle) == 0x000008, "Wrong alignment on UFortQueryGenerator_GoalOnCircle");
static_assert(sizeof(UFortQueryGenerator_GoalOnCircle) == 0x000260, "Wrong size on UFortQueryGenerator_GoalOnCircle");
static_assert(offsetof(UFortQueryGenerator_GoalOnCircle, bIncludeCenterActorInGeneratedGoals) == 0x000220, "Member 'UFortQueryGenerator_GoalOnCircle::bIncludeCenterActorInGeneratedGoals' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_GoalOnCircle, OptionalAssignmentSettings) == 0x000228, "Member 'UFortQueryGenerator_GoalOnCircle::OptionalAssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_GoalOnCircle, OptionalAssignmentIdentifier) == 0x000230, "Member 'UFortQueryGenerator_GoalOnCircle::OptionalAssignmentIdentifier' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_GoalPlayerPawns
// 0x0008 (0x0058 - 0x0050)
class UFortQueryGenerator_GoalPlayerPawns final : public UEnvQueryGenerator
{
public:
	bool                                          bOnlyAthenaGameParticipants;                       // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_GoalPlayerPawns">();
	}
	static class UFortQueryGenerator_GoalPlayerPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_GoalPlayerPawns>();
	}
};
static_assert(alignof(UFortQueryGenerator_GoalPlayerPawns) == 0x000008, "Wrong alignment on UFortQueryGenerator_GoalPlayerPawns");
static_assert(sizeof(UFortQueryGenerator_GoalPlayerPawns) == 0x000058, "Wrong size on UFortQueryGenerator_GoalPlayerPawns");
static_assert(offsetof(UFortQueryGenerator_GoalPlayerPawns, bOnlyAthenaGameParticipants) == 0x000050, "Member 'UFortQueryGenerator_GoalPlayerPawns::bOnlyAthenaGameParticipants' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_HotspotSlots
// 0x0050 (0x00A0 - 0x0050)
class UFortQueryGenerator_HotspotSlots final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              Radius;                                            // 0x0058(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseTetherZone : 1;                                // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortAIHotSpot>             HotspotClass;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_HotspotSlots">();
	}
	static class UFortQueryGenerator_HotspotSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_HotspotSlots>();
	}
};
static_assert(alignof(UFortQueryGenerator_HotspotSlots) == 0x000008, "Wrong alignment on UFortQueryGenerator_HotspotSlots");
static_assert(sizeof(UFortQueryGenerator_HotspotSlots) == 0x0000A0, "Wrong size on UFortQueryGenerator_HotspotSlots");
static_assert(offsetof(UFortQueryGenerator_HotspotSlots, GenerateAround) == 0x000050, "Member 'UFortQueryGenerator_HotspotSlots::GenerateAround' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_HotspotSlots, Radius) == 0x000058, "Member 'UFortQueryGenerator_HotspotSlots::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_HotspotSlots, HotspotClass) == 0x000098, "Member 'UFortQueryGenerator_HotspotSlots::HotspotClass' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_LootGoalsAthena
// 0x00D8 (0x0128 - 0x0050)
class UFortQueryGenerator_LootGoalsAthena final : public UEnvQueryGenerator
{
public:
	struct FFortAIAssignmentIdentifier            AssignmentIdentifier;                              // 0x0050(0x0030)(Edit, NativeAccessSpecifierPublic)
	class UFortAIAssignmentSettings*              AssignmentSettings;                                // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              HorizontalHalfExtents;                             // 0x0088(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              VerticalHalfExtents;                               // 0x00C0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAvailableLootOnly : 1;                            // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlacklistAILootGameplayTags;                       // 0x0108(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_LootGoalsAthena">();
	}
	static class UFortQueryGenerator_LootGoalsAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_LootGoalsAthena>();
	}
};
static_assert(alignof(UFortQueryGenerator_LootGoalsAthena) == 0x000008, "Wrong alignment on UFortQueryGenerator_LootGoalsAthena");
static_assert(sizeof(UFortQueryGenerator_LootGoalsAthena) == 0x000128, "Wrong size on UFortQueryGenerator_LootGoalsAthena");
static_assert(offsetof(UFortQueryGenerator_LootGoalsAthena, AssignmentIdentifier) == 0x000050, "Member 'UFortQueryGenerator_LootGoalsAthena::AssignmentIdentifier' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_LootGoalsAthena, AssignmentSettings) == 0x000080, "Member 'UFortQueryGenerator_LootGoalsAthena::AssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_LootGoalsAthena, HorizontalHalfExtents) == 0x000088, "Member 'UFortQueryGenerator_LootGoalsAthena::HorizontalHalfExtents' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_LootGoalsAthena, VerticalHalfExtents) == 0x0000C0, "Member 'UFortQueryGenerator_LootGoalsAthena::VerticalHalfExtents' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_LootGoalsAthena, SearchCenter) == 0x0000F8, "Member 'UFortQueryGenerator_LootGoalsAthena::SearchCenter' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_LootGoalsAthena, BlacklistAILootGameplayTags) == 0x000108, "Member 'UFortQueryGenerator_LootGoalsAthena::BlacklistAILootGameplayTags' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_MissionPlacementActors
// 0x0048 (0x0098 - 0x0050)
class UFortQueryGenerator_MissionPlacementActors final : public UEnvQueryGenerator
{
public:
	struct FGameplayTagQuery                      MissionPlacementActorTagQuery;                     // 0x0050(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_MissionPlacementActors">();
	}
	static class UFortQueryGenerator_MissionPlacementActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_MissionPlacementActors>();
	}
};
static_assert(alignof(UFortQueryGenerator_MissionPlacementActors) == 0x000008, "Wrong alignment on UFortQueryGenerator_MissionPlacementActors");
static_assert(sizeof(UFortQueryGenerator_MissionPlacementActors) == 0x000098, "Wrong size on UFortQueryGenerator_MissionPlacementActors");
static_assert(offsetof(UFortQueryGenerator_MissionPlacementActors, MissionPlacementActorTagQuery) == 0x000050, "Member 'UFortQueryGenerator_MissionPlacementActors::MissionPlacementActorTagQuery' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_MutatorBaseQueryResults
// 0x0000 (0x0050 - 0x0050)
class UFortQueryGenerator_MutatorBaseQueryResults final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_MutatorBaseQueryResults">();
	}
	static class UFortQueryGenerator_MutatorBaseQueryResults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_MutatorBaseQueryResults>();
	}
};
static_assert(alignof(UFortQueryGenerator_MutatorBaseQueryResults) == 0x000008, "Wrong alignment on UFortQueryGenerator_MutatorBaseQueryResults");
static_assert(sizeof(UFortQueryGenerator_MutatorBaseQueryResults) == 0x000050, "Wrong size on UFortQueryGenerator_MutatorBaseQueryResults");

// Class FortniteAI.FortQueryGenerator_PointsAroundLine
// 0x00A0 (0x0128 - 0x0088)
class UFortQueryGenerator_PointsAroundLine final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDataProviderIntValue                MaxPointsPerClusterLocation;                       // 0x0090(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ClusterRadius;                                     // 0x00C8(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortQueryData_CurvesAroundLine> CurvesAroundLineAsset;                             // 0x0100(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsAroundLine">();
	}
	static class UFortQueryGenerator_PointsAroundLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsAroundLine>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsAroundLine) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsAroundLine");
static_assert(sizeof(UFortQueryGenerator_PointsAroundLine) == 0x000128, "Wrong size on UFortQueryGenerator_PointsAroundLine");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, GenerateAround) == 0x000088, "Member 'UFortQueryGenerator_PointsAroundLine::GenerateAround' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, MaxPointsPerClusterLocation) == 0x000090, "Member 'UFortQueryGenerator_PointsAroundLine::MaxPointsPerClusterLocation' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, ClusterRadius) == 0x0000C8, "Member 'UFortQueryGenerator_PointsAroundLine::ClusterRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, CurvesAroundLineAsset) == 0x000100, "Member 'UFortQueryGenerator_PointsAroundLine::CurvesAroundLineAsset' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_PointsFromNavGraph
// 0x0150 (0x01D8 - 0x0088)
class UFortQueryGenerator_PointsFromNavGraph final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              MinPathDistance;                                   // 0x0088(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxPathDistance;                                   // 0x00C0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                Density;                                           // 0x00F8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ExploreDirectionYaw;                               // 0x0130(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FEnvDirection                          ExploreDirection;                                  // 0x0168(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExploreAngleDot;                                   // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              ExploreInnerRadius;                                // 0x0190(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bLimitExplorationDirection : 1;                    // 0x01C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyFlatSurface : 1;                              // 0x01C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseParameterizedDirection : 1;                    // 0x01C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseHeightCheck : 1;                               // 0x01C8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowTerrain : 1;                           // 0x01C8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowBuildings : 1;                         // 0x01C8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowDropdown : 1;                          // 0x01C8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowClimbup : 1;                           // 0x01C8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowSmash : 1;                             // 0x01C9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1CA[0x2];                                      // 0x01CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EFortPointsFromNavGraphGoalPathDistanceFilterOperator PathDistanceFilterOperator;                        // 0x01CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsFromNavGraph">();
	}
	static class UFortQueryGenerator_PointsFromNavGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsFromNavGraph>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsFromNavGraph) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsFromNavGraph");
static_assert(sizeof(UFortQueryGenerator_PointsFromNavGraph) == 0x0001D8, "Wrong size on UFortQueryGenerator_PointsFromNavGraph");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, MinPathDistance) == 0x000088, "Member 'UFortQueryGenerator_PointsFromNavGraph::MinPathDistance' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, MaxPathDistance) == 0x0000C0, "Member 'UFortQueryGenerator_PointsFromNavGraph::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, Density) == 0x0000F8, "Member 'UFortQueryGenerator_PointsFromNavGraph::Density' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, ExploreDirectionYaw) == 0x000130, "Member 'UFortQueryGenerator_PointsFromNavGraph::ExploreDirectionYaw' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, ExploreDirection) == 0x000168, "Member 'UFortQueryGenerator_PointsFromNavGraph::ExploreDirection' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, ExploreAngleDot) == 0x000188, "Member 'UFortQueryGenerator_PointsFromNavGraph::ExploreAngleDot' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, ExploreInnerRadius) == 0x000190, "Member 'UFortQueryGenerator_PointsFromNavGraph::ExploreInnerRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, PathDistanceFilterOperator) == 0x0001CC, "Member 'UFortQueryGenerator_PointsFromNavGraph::PathDistanceFilterOperator' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, GenerateAround) == 0x0001D0, "Member 'UFortQueryGenerator_PointsFromNavGraph::GenerateAround' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_PointsOnBuildingActors
// 0x01C8 (0x0250 - 0x0088)
class UFortQueryGenerator_PointsOnBuildingActors final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              BoundingBoxExtentXY;                               // 0x0088(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              BoundingBoxExtentZ;                                // 0x00C0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              PointDensity;                                      // 0x00F8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                MaxGeneratedPoints;                                // 0x0130(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FFortTaggedActorOctreeFilter           ActorLookupFilter;                                 // 0x0168(0x00A8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              RandomChanceToSkip;                                // 0x0210(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsOnBuildingActors">();
	}
	static class UFortQueryGenerator_PointsOnBuildingActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsOnBuildingActors>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsOnBuildingActors) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsOnBuildingActors");
static_assert(sizeof(UFortQueryGenerator_PointsOnBuildingActors) == 0x000250, "Wrong size on UFortQueryGenerator_PointsOnBuildingActors");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingActors, BoundingBoxExtentXY) == 0x000088, "Member 'UFortQueryGenerator_PointsOnBuildingActors::BoundingBoxExtentXY' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingActors, BoundingBoxExtentZ) == 0x0000C0, "Member 'UFortQueryGenerator_PointsOnBuildingActors::BoundingBoxExtentZ' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingActors, PointDensity) == 0x0000F8, "Member 'UFortQueryGenerator_PointsOnBuildingActors::PointDensity' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingActors, MaxGeneratedPoints) == 0x000130, "Member 'UFortQueryGenerator_PointsOnBuildingActors::MaxGeneratedPoints' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingActors, ActorLookupFilter) == 0x000168, "Member 'UFortQueryGenerator_PointsOnBuildingActors::ActorLookupFilter' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingActors, RandomChanceToSkip) == 0x000210, "Member 'UFortQueryGenerator_PointsOnBuildingActors::RandomChanceToSkip' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingActors, GenerateAround) == 0x000248, "Member 'UFortQueryGenerator_PointsOnBuildingActors::GenerateAround' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_PointsOnBuildingGrid
// 0x0080 (0x0108 - 0x0088)
class UFortQueryGenerator_PointsOnBuildingGrid final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderIntValue                HorizontalGridSize;                                // 0x0088(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                VerticalGridSize;                                  // 0x00C0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bStartGridFromBottom;                              // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePointInVerticalCenterOfCell;                   // 0x00F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsOnBuildingGrid">();
	}
	static class UFortQueryGenerator_PointsOnBuildingGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsOnBuildingGrid>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsOnBuildingGrid) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsOnBuildingGrid");
static_assert(sizeof(UFortQueryGenerator_PointsOnBuildingGrid) == 0x000108, "Wrong size on UFortQueryGenerator_PointsOnBuildingGrid");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, HorizontalGridSize) == 0x000088, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::HorizontalGridSize' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, VerticalGridSize) == 0x0000C0, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::VerticalGridSize' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, bStartGridFromBottom) == 0x0000F8, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::bStartGridFromBottom' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, bUsePointInVerticalCenterOfCell) == 0x0000F9, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::bUsePointInVerticalCenterOfCell' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, GenerateAround) == 0x000100, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::GenerateAround' has a wrong offset!");

// Class FortniteAI.FortQueryGenerator_RandomPointsInBoundingVolume
// 0x0040 (0x00C8 - 0x0088)
class UFortQueryGenerator_RandomPointsInBoundingVolume final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	TSubclassOf<class UEnvQueryContext>           GenerateIn;                                        // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              RandomPointsCount;                                 // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_RandomPointsInBoundingVolume">();
	}
	static class UFortQueryGenerator_RandomPointsInBoundingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_RandomPointsInBoundingVolume>();
	}
};
static_assert(alignof(UFortQueryGenerator_RandomPointsInBoundingVolume) == 0x000008, "Wrong alignment on UFortQueryGenerator_RandomPointsInBoundingVolume");
static_assert(sizeof(UFortQueryGenerator_RandomPointsInBoundingVolume) == 0x0000C8, "Wrong size on UFortQueryGenerator_RandomPointsInBoundingVolume");
static_assert(offsetof(UFortQueryGenerator_RandomPointsInBoundingVolume, GenerateIn) == 0x000088, "Member 'UFortQueryGenerator_RandomPointsInBoundingVolume::GenerateIn' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_RandomPointsInBoundingVolume, RandomPointsCount) == 0x000090, "Member 'UFortQueryGenerator_RandomPointsInBoundingVolume::RandomPointsCount' has a wrong offset!");

// Class FortniteAI.FortQueryItemType_Goal
// 0x0000 (0x0030 - 0x0030)
class UFortQueryItemType_Goal final : public UEnvQueryItemType_ActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryItemType_Goal">();
	}
	static class UFortQueryItemType_Goal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryItemType_Goal>();
	}
};
static_assert(alignof(UFortQueryItemType_Goal) == 0x000008, "Wrong alignment on UFortQueryItemType_Goal");
static_assert(sizeof(UFortQueryItemType_Goal) == 0x000030, "Wrong size on UFortQueryItemType_Goal");

// Class FortniteAI.FortQueryItemType_PointOrSlot
// 0x0000 (0x0030 - 0x0030)
class UFortQueryItemType_PointOrSlot final : public UEnvQueryItemType_Point
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryItemType_PointOrSlot">();
	}
	static class UFortQueryItemType_PointOrSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryItemType_PointOrSlot>();
	}
};
static_assert(alignof(UFortQueryItemType_PointOrSlot) == 0x000008, "Wrong alignment on UFortQueryItemType_PointOrSlot");
static_assert(sizeof(UFortQueryItemType_PointOrSlot) == 0x000030, "Wrong size on UFortQueryItemType_PointOrSlot");

// Class FortniteAI.FortQueryTest_AssignmentTypeInterest
// 0x01C0 (0x03E0 - 0x0220)
class UFortQueryTest_AssignmentTypeInterest final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              InvalidTypeStartInterest;                          // 0x0220(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InvalidTypeEndInterest;                            // 0x0258(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InvalidTypeTimeBeforeLerp;                         // 0x0290(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InvalidTypeLerpDuration;                           // 0x02C8(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeStartInterest;                            // 0x0300(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeEndInterest;                              // 0x0338(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeTimeBeforeLerp;                           // 0x0370(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeLerpDuration;                             // 0x03A8(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_AssignmentTypeInterest">();
	}
	static class UFortQueryTest_AssignmentTypeInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_AssignmentTypeInterest>();
	}
};
static_assert(alignof(UFortQueryTest_AssignmentTypeInterest) == 0x000008, "Wrong alignment on UFortQueryTest_AssignmentTypeInterest");
static_assert(sizeof(UFortQueryTest_AssignmentTypeInterest) == 0x0003E0, "Wrong size on UFortQueryTest_AssignmentTypeInterest");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeStartInterest) == 0x000220, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeStartInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeEndInterest) == 0x000258, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeEndInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeTimeBeforeLerp) == 0x000290, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeTimeBeforeLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeLerpDuration) == 0x0002C8, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeLerpDuration' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeStartInterest) == 0x000300, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeStartInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeEndInterest) == 0x000338, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeEndInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeTimeBeforeLerp) == 0x000370, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeTimeBeforeLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeLerpDuration) == 0x0003A8, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeLerpDuration' has a wrong offset!");

// Class FortniteAI.FortQueryTest_BuildingCriteria
// 0x0378 (0x0598 - 0x0220)
class UFortQueryTest_BuildingCriteria final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              ScoreForGroundSupportedFloor;                      // 0x0220(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForBeingGroundSupported;                      // 0x0258(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForTraps;                                     // 0x0290(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForWalls;                                     // 0x02C8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForNavigableOpening;                          // 0x0300(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FFortAIAssignmentIdentifier            RootAssignmentID;                                  // 0x0338(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bPreferCloserToRootAssignment;                     // 0x0368(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForDistanceFromClosestRootAssignmentGoal;     // 0x03A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MinDistanceForDistanceScoring;                     // 0x03D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxDistanceForDistanceScoring;                     // 0x0410(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxHealthScore;                                    // 0x0448(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bPreferHigherHealth;                               // 0x0480(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ClampMaxHealthValue;                               // 0x04B8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ClampMinHealthValue;                               // 0x04F0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bPreferHigherHealthPercentage;                     // 0x0528(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxHealthPercentageScore;                          // 0x0560(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_BuildingCriteria">();
	}
	static class UFortQueryTest_BuildingCriteria* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_BuildingCriteria>();
	}
};
static_assert(alignof(UFortQueryTest_BuildingCriteria) == 0x000008, "Wrong alignment on UFortQueryTest_BuildingCriteria");
static_assert(sizeof(UFortQueryTest_BuildingCriteria) == 0x000598, "Wrong size on UFortQueryTest_BuildingCriteria");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForGroundSupportedFloor) == 0x000220, "Member 'UFortQueryTest_BuildingCriteria::ScoreForGroundSupportedFloor' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForBeingGroundSupported) == 0x000258, "Member 'UFortQueryTest_BuildingCriteria::ScoreForBeingGroundSupported' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForTraps) == 0x000290, "Member 'UFortQueryTest_BuildingCriteria::ScoreForTraps' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForWalls) == 0x0002C8, "Member 'UFortQueryTest_BuildingCriteria::ScoreForWalls' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForNavigableOpening) == 0x000300, "Member 'UFortQueryTest_BuildingCriteria::ScoreForNavigableOpening' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, RootAssignmentID) == 0x000338, "Member 'UFortQueryTest_BuildingCriteria::RootAssignmentID' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, bPreferCloserToRootAssignment) == 0x000368, "Member 'UFortQueryTest_BuildingCriteria::bPreferCloserToRootAssignment' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForDistanceFromClosestRootAssignmentGoal) == 0x0003A0, "Member 'UFortQueryTest_BuildingCriteria::ScoreForDistanceFromClosestRootAssignmentGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MinDistanceForDistanceScoring) == 0x0003D8, "Member 'UFortQueryTest_BuildingCriteria::MinDistanceForDistanceScoring' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MaxDistanceForDistanceScoring) == 0x000410, "Member 'UFortQueryTest_BuildingCriteria::MaxDistanceForDistanceScoring' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MaxHealthScore) == 0x000448, "Member 'UFortQueryTest_BuildingCriteria::MaxHealthScore' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, bPreferHigherHealth) == 0x000480, "Member 'UFortQueryTest_BuildingCriteria::bPreferHigherHealth' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ClampMaxHealthValue) == 0x0004B8, "Member 'UFortQueryTest_BuildingCriteria::ClampMaxHealthValue' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ClampMinHealthValue) == 0x0004F0, "Member 'UFortQueryTest_BuildingCriteria::ClampMinHealthValue' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, bPreferHigherHealthPercentage) == 0x000528, "Member 'UFortQueryTest_BuildingCriteria::bPreferHigherHealthPercentage' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MaxHealthPercentageScore) == 0x000560, "Member 'UFortQueryTest_BuildingCriteria::MaxHealthPercentageScore' has a wrong offset!");

// Class FortniteAI.FortQueryTest_CanBeDamaged
// 0x0000 (0x0220 - 0x0220)
class UFortQueryTest_CanBeDamaged final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CanBeDamaged">();
	}
	static class UFortQueryTest_CanBeDamaged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CanBeDamaged>();
	}
};
static_assert(alignof(UFortQueryTest_CanBeDamaged) == 0x000008, "Wrong alignment on UFortQueryTest_CanBeDamaged");
static_assert(sizeof(UFortQueryTest_CanBeDamaged) == 0x000220, "Wrong size on UFortQueryTest_CanBeDamaged");

// Class FortniteAI.FortQueryTest_CanHitWithGameplayAbility
// 0x0030 (0x0228 - 0x01F8)
class UFortQueryTest_CanHitWithGameplayAbility final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           AIsUsingAbility;                                   // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           AbilityTargets;                                    // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0208(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CanHitWithGameplayAbility">();
	}
	static class UFortQueryTest_CanHitWithGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CanHitWithGameplayAbility>();
	}
};
static_assert(alignof(UFortQueryTest_CanHitWithGameplayAbility) == 0x000008, "Wrong alignment on UFortQueryTest_CanHitWithGameplayAbility");
static_assert(sizeof(UFortQueryTest_CanHitWithGameplayAbility) == 0x000228, "Wrong size on UFortQueryTest_CanHitWithGameplayAbility");
static_assert(offsetof(UFortQueryTest_CanHitWithGameplayAbility, AIsUsingAbility) == 0x0001F8, "Member 'UFortQueryTest_CanHitWithGameplayAbility::AIsUsingAbility' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_CanHitWithGameplayAbility, AbilityTargets) == 0x000200, "Member 'UFortQueryTest_CanHitWithGameplayAbility::AbilityTargets' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_CanHitWithGameplayAbility, GameplayAbilityTag) == 0x000208, "Member 'UFortQueryTest_CanHitWithGameplayAbility::GameplayAbilityTag' has a wrong offset!");

// Class FortniteAI.FortQueryTest_CurieState
// 0x0048 (0x0240 - 0x01F8)
class UFortQueryTest_CurieState final : public UEnvQueryTest
{
public:
	struct FGameplayTagQuery                      CurieStateQuery;                                   // 0x01F8(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CurieState">();
	}
	static class UFortQueryTest_CurieState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CurieState>();
	}
};
static_assert(alignof(UFortQueryTest_CurieState) == 0x000008, "Wrong alignment on UFortQueryTest_CurieState");
static_assert(sizeof(UFortQueryTest_CurieState) == 0x000240, "Wrong size on UFortQueryTest_CurieState");
static_assert(offsetof(UFortQueryTest_CurieState, CurieStateQuery) == 0x0001F8, "Member 'UFortQueryTest_CurieState::CurieStateQuery' has a wrong offset!");

// Class FortniteAI.FortQueryTest_DecoyDistance
// 0x0008 (0x0200 - 0x01F8)
class UFortQueryTest_DecoyDistance final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_DecoyDistance">();
	}
	static class UFortQueryTest_DecoyDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_DecoyDistance>();
	}
};
static_assert(alignof(UFortQueryTest_DecoyDistance) == 0x000008, "Wrong alignment on UFortQueryTest_DecoyDistance");
static_assert(sizeof(UFortQueryTest_DecoyDistance) == 0x000200, "Wrong size on UFortQueryTest_DecoyDistance");
static_assert(offsetof(UFortQueryTest_DecoyDistance, DistanceTo) == 0x0001F8, "Member 'UFortQueryTest_DecoyDistance::DistanceTo' has a wrong offset!");

// Class FortniteAI.FortQueryTest_DistanceToActorBound
// 0x0008 (0x0200 - 0x01F8)
class UFortQueryTest_DistanceToActorBound final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_DistanceToActorBound">();
	}
	static class UFortQueryTest_DistanceToActorBound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_DistanceToActorBound>();
	}
};
static_assert(alignof(UFortQueryTest_DistanceToActorBound) == 0x000008, "Wrong alignment on UFortQueryTest_DistanceToActorBound");
static_assert(sizeof(UFortQueryTest_DistanceToActorBound) == 0x000200, "Wrong size on UFortQueryTest_DistanceToActorBound");
static_assert(offsetof(UFortQueryTest_DistanceToActorBound, DistanceTo) == 0x0001F8, "Member 'UFortQueryTest_DistanceToActorBound::DistanceTo' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalActorDot
// 0x0018 (0x0238 - 0x0220)
class UFortQueryTest_GoalActorDot final : public UFortQueryTest_GoalBase
{
public:
	TSubclassOf<class UEnvQueryContext>           LineATo;                                           // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           LineBTo;                                           // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTestGoalActorDot                         TestMode;                                          // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteValue;                                    // 0x0231(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_232[0x6];                                      // 0x0232(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalActorDot">();
	}
	static class UFortQueryTest_GoalActorDot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalActorDot>();
	}
};
static_assert(alignof(UFortQueryTest_GoalActorDot) == 0x000008, "Wrong alignment on UFortQueryTest_GoalActorDot");
static_assert(sizeof(UFortQueryTest_GoalActorDot) == 0x000238, "Wrong size on UFortQueryTest_GoalActorDot");
static_assert(offsetof(UFortQueryTest_GoalActorDot, LineATo) == 0x000220, "Member 'UFortQueryTest_GoalActorDot::LineATo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalActorDot, LineBTo) == 0x000228, "Member 'UFortQueryTest_GoalActorDot::LineBTo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalActorDot, TestMode) == 0x000230, "Member 'UFortQueryTest_GoalActorDot::TestMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalActorDot, bAbsoluteValue) == 0x000231, "Member 'UFortQueryTest_GoalActorDot::bAbsoluteValue' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalActorTimeSinceSpawn
// 0x0000 (0x0220 - 0x0220)
class UFortQueryTest_GoalActorTimeSinceSpawn final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalActorTimeSinceSpawn">();
	}
	static class UFortQueryTest_GoalActorTimeSinceSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalActorTimeSinceSpawn>();
	}
};
static_assert(alignof(UFortQueryTest_GoalActorTimeSinceSpawn) == 0x000008, "Wrong alignment on UFortQueryTest_GoalActorTimeSinceSpawn");
static_assert(sizeof(UFortQueryTest_GoalActorTimeSinceSpawn) == 0x000220, "Wrong size on UFortQueryTest_GoalActorTimeSinceSpawn");

// Class FortniteAI.FortQueryTest_GoalDiscouragement
// 0x0038 (0x0258 - 0x0220)
class UFortQueryTest_GoalDiscouragement final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderBoolValue               DisableDiscouragementWhenUndermining;              // 0x0220(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalDiscouragement">();
	}
	static class UFortQueryTest_GoalDiscouragement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalDiscouragement>();
	}
};
static_assert(alignof(UFortQueryTest_GoalDiscouragement) == 0x000008, "Wrong alignment on UFortQueryTest_GoalDiscouragement");
static_assert(sizeof(UFortQueryTest_GoalDiscouragement) == 0x000258, "Wrong size on UFortQueryTest_GoalDiscouragement");
static_assert(offsetof(UFortQueryTest_GoalDiscouragement, DisableDiscouragementWhenUndermining) == 0x000220, "Member 'UFortQueryTest_GoalDiscouragement::DisableDiscouragementWhenUndermining' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalDistance
// 0x0018 (0x0238 - 0x0220)
class UFortQueryTest_GoalDistance final : public UFortQueryTest_GoalBase
{
public:
	EDistanceMode                                 DistanceMode;                                      // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvTestDistance                              TestMode;                                          // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalDistance">();
	}
	static class UFortQueryTest_GoalDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalDistance>();
	}
};
static_assert(alignof(UFortQueryTest_GoalDistance) == 0x000008, "Wrong alignment on UFortQueryTest_GoalDistance");
static_assert(sizeof(UFortQueryTest_GoalDistance) == 0x000238, "Wrong size on UFortQueryTest_GoalDistance");
static_assert(offsetof(UFortQueryTest_GoalDistance, DistanceMode) == 0x000220, "Member 'UFortQueryTest_GoalDistance::DistanceMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistance, DistanceTo) == 0x000228, "Member 'UFortQueryTest_GoalDistance::DistanceTo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistance, TestMode) == 0x000230, "Member 'UFortQueryTest_GoalDistance::TestMode' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalGameplayTags
// 0x0058 (0x0278 - 0x0220)
class UFortQueryTest_GoalGameplayTags final : public UFortQueryTest_GoalBase
{
public:
	bool                                          bShouldLookupQueryByTag;                           // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      TagQueryToMatch;                                   // 0x0228(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           QueryLookupTag;                                    // 0x0270(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldPassWhenQueryNotFound;                      // 0x0274(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireAllProvidedTagQueriesPass;                 // 0x0275(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_276[0x2];                                      // 0x0276(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalGameplayTags">();
	}
	static class UFortQueryTest_GoalGameplayTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalGameplayTags>();
	}
};
static_assert(alignof(UFortQueryTest_GoalGameplayTags) == 0x000008, "Wrong alignment on UFortQueryTest_GoalGameplayTags");
static_assert(sizeof(UFortQueryTest_GoalGameplayTags) == 0x000278, "Wrong size on UFortQueryTest_GoalGameplayTags");
static_assert(offsetof(UFortQueryTest_GoalGameplayTags, bShouldLookupQueryByTag) == 0x000220, "Member 'UFortQueryTest_GoalGameplayTags::bShouldLookupQueryByTag' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalGameplayTags, TagQueryToMatch) == 0x000228, "Member 'UFortQueryTest_GoalGameplayTags::TagQueryToMatch' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalGameplayTags, QueryLookupTag) == 0x000270, "Member 'UFortQueryTest_GoalGameplayTags::QueryLookupTag' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalGameplayTags, bShouldPassWhenQueryNotFound) == 0x000274, "Member 'UFortQueryTest_GoalGameplayTags::bShouldPassWhenQueryNotFound' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalGameplayTags, bRequireAllProvidedTagQueriesPass) == 0x000275, "Member 'UFortQueryTest_GoalGameplayTags::bRequireAllProvidedTagQueriesPass' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalMarkedByPlayer
// 0x0080 (0x02A0 - 0x0220)
class UFortQueryTest_GoalMarkedByPlayer final : public UFortQueryTest_GoalBase
{
public:
	struct FGameplayTagQuery                      OwnerTagQuery;                                     // 0x0220(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderBoolValue               OnlyConverterMarkedTargets;                        // 0x0268(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalMarkedByPlayer">();
	}
	static class UFortQueryTest_GoalMarkedByPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalMarkedByPlayer>();
	}
};
static_assert(alignof(UFortQueryTest_GoalMarkedByPlayer) == 0x000008, "Wrong alignment on UFortQueryTest_GoalMarkedByPlayer");
static_assert(sizeof(UFortQueryTest_GoalMarkedByPlayer) == 0x0002A0, "Wrong size on UFortQueryTest_GoalMarkedByPlayer");
static_assert(offsetof(UFortQueryTest_GoalMarkedByPlayer, OwnerTagQuery) == 0x000220, "Member 'UFortQueryTest_GoalMarkedByPlayer::OwnerTagQuery' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalMarkedByPlayer, OnlyConverterMarkedTargets) == 0x000268, "Member 'UFortQueryTest_GoalMarkedByPlayer::OnlyConverterMarkedTargets' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalNumberOfAIAssigned
// 0x0008 (0x0228 - 0x0220)
class UFortQueryTest_GoalNumberOfAIAssigned final : public UFortQueryTest_GoalBase
{
public:
	ECountAIAssignedToType                        TypeOfMatchToCount;                                // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalNumberOfAIAssigned">();
	}
	static class UFortQueryTest_GoalNumberOfAIAssigned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalNumberOfAIAssigned>();
	}
};
static_assert(alignof(UFortQueryTest_GoalNumberOfAIAssigned) == 0x000008, "Wrong alignment on UFortQueryTest_GoalNumberOfAIAssigned");
static_assert(sizeof(UFortQueryTest_GoalNumberOfAIAssigned) == 0x000228, "Wrong size on UFortQueryTest_GoalNumberOfAIAssigned");
static_assert(offsetof(UFortQueryTest_GoalNumberOfAIAssigned, TypeOfMatchToCount) == 0x000220, "Member 'UFortQueryTest_GoalNumberOfAIAssigned::TypeOfMatchToCount' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalOverallDamageCaused
// 0x0000 (0x0220 - 0x0220)
class UFortQueryTest_GoalOverallDamageCaused final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalOverallDamageCaused">();
	}
	static class UFortQueryTest_GoalOverallDamageCaused* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalOverallDamageCaused>();
	}
};
static_assert(alignof(UFortQueryTest_GoalOverallDamageCaused) == 0x000008, "Wrong alignment on UFortQueryTest_GoalOverallDamageCaused");
static_assert(sizeof(UFortQueryTest_GoalOverallDamageCaused) == 0x000220, "Wrong size on UFortQueryTest_GoalOverallDamageCaused");

// Class FortniteAI.FortQueryTest_GoalPickupFilter
// 0x0008 (0x0228 - 0x0220)
class UFortQueryTest_GoalPickupFilter final : public UFortQueryTest_GoalBase
{
public:
	float                                         MaxLifetime;                                       // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortPickupSpawnSource                        RequiredPickupSpawnSource;                         // 0x0224(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalPickupFilter">();
	}
	static class UFortQueryTest_GoalPickupFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalPickupFilter>();
	}
};
static_assert(alignof(UFortQueryTest_GoalPickupFilter) == 0x000008, "Wrong alignment on UFortQueryTest_GoalPickupFilter");
static_assert(sizeof(UFortQueryTest_GoalPickupFilter) == 0x000228, "Wrong size on UFortQueryTest_GoalPickupFilter");
static_assert(offsetof(UFortQueryTest_GoalPickupFilter, MaxLifetime) == 0x000220, "Member 'UFortQueryTest_GoalPickupFilter::MaxLifetime' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalPickupFilter, RequiredPickupSpawnSource) == 0x000224, "Member 'UFortQueryTest_GoalPickupFilter::RequiredPickupSpawnSource' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalStickiness
// 0x0118 (0x0338 - 0x0220)
class UFortQueryTest_GoalStickiness final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              StartValueForGoal;                                 // 0x0220(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              EndValueForGoal;                                   // 0x0258(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              TimeBeforeValueLerp;                               // 0x0290(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValueLerpDuration;                                 // 0x02C8(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderBoolValue               ApplyStickinessToAllGoalsWithSameActor;            // 0x0300(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalStickiness">();
	}
	static class UFortQueryTest_GoalStickiness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalStickiness>();
	}
};
static_assert(alignof(UFortQueryTest_GoalStickiness) == 0x000008, "Wrong alignment on UFortQueryTest_GoalStickiness");
static_assert(sizeof(UFortQueryTest_GoalStickiness) == 0x000338, "Wrong size on UFortQueryTest_GoalStickiness");
static_assert(offsetof(UFortQueryTest_GoalStickiness, StartValueForGoal) == 0x000220, "Member 'UFortQueryTest_GoalStickiness::StartValueForGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, EndValueForGoal) == 0x000258, "Member 'UFortQueryTest_GoalStickiness::EndValueForGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, TimeBeforeValueLerp) == 0x000290, "Member 'UFortQueryTest_GoalStickiness::TimeBeforeValueLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, ValueLerpDuration) == 0x0002C8, "Member 'UFortQueryTest_GoalStickiness::ValueLerpDuration' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, ApplyStickinessToAllGoalsWithSameActor) == 0x000300, "Member 'UFortQueryTest_GoalStickiness::ApplyStickinessToAllGoalsWithSameActor' has a wrong offset!");

// Class FortniteAI.FortQueryTest_GoalWithinTetheredBounds
// 0x0000 (0x0220 - 0x0220)
class UFortQueryTest_GoalWithinTetheredBounds final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalWithinTetheredBounds">();
	}
	static class UFortQueryTest_GoalWithinTetheredBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalWithinTetheredBounds>();
	}
};
static_assert(alignof(UFortQueryTest_GoalWithinTetheredBounds) == 0x000008, "Wrong alignment on UFortQueryTest_GoalWithinTetheredBounds");
static_assert(sizeof(UFortQueryTest_GoalWithinTetheredBounds) == 0x000220, "Wrong size on UFortQueryTest_GoalWithinTetheredBounds");

// Class FortniteAI.FortQueryTest_HasNearbyBuildings
// 0x0010 (0x0208 - 0x01F8)
class UFortQueryTest_HasNearbyBuildings final : public UEnvQueryTest
{
public:
	uint8                                         bIncludeCenter : 1;                                // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeFloors : 1;                                // 0x01F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeFloorsAbove : 1;                           // 0x01F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeWalls : 1;                                 // 0x01F8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExtentXY;                                          // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtentZ;                                           // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_HasNearbyBuildings">();
	}
	static class UFortQueryTest_HasNearbyBuildings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_HasNearbyBuildings>();
	}
};
static_assert(alignof(UFortQueryTest_HasNearbyBuildings) == 0x000008, "Wrong alignment on UFortQueryTest_HasNearbyBuildings");
static_assert(sizeof(UFortQueryTest_HasNearbyBuildings) == 0x000208, "Wrong size on UFortQueryTest_HasNearbyBuildings");
static_assert(offsetof(UFortQueryTest_HasNearbyBuildings, ExtentXY) == 0x0001FC, "Member 'UFortQueryTest_HasNearbyBuildings::ExtentXY' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_HasNearbyBuildings, ExtentZ) == 0x000200, "Member 'UFortQueryTest_HasNearbyBuildings::ExtentZ' has a wrong offset!");

// Class FortniteAI.FortQueryTest_HotspotSlotOrientation
// 0x0040 (0x0238 - 0x01F8)
class UFortQueryTest_HotspotSlotOrientation final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           FaceToward;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              DotThreshold;                                      // 0x0200(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_HotspotSlotOrientation">();
	}
	static class UFortQueryTest_HotspotSlotOrientation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_HotspotSlotOrientation>();
	}
};
static_assert(alignof(UFortQueryTest_HotspotSlotOrientation) == 0x000008, "Wrong alignment on UFortQueryTest_HotspotSlotOrientation");
static_assert(sizeof(UFortQueryTest_HotspotSlotOrientation) == 0x000238, "Wrong size on UFortQueryTest_HotspotSlotOrientation");
static_assert(offsetof(UFortQueryTest_HotspotSlotOrientation, FaceToward) == 0x0001F8, "Member 'UFortQueryTest_HotspotSlotOrientation::FaceToward' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_HotspotSlotOrientation, DotThreshold) == 0x000200, "Member 'UFortQueryTest_HotspotSlotOrientation::DotThreshold' has a wrong offset!");

// Class FortniteAI.FortQueryTest_HotspotSlotState
// 0x0008 (0x0200 - 0x01F8)
class UFortQueryTest_HotspotSlotState final : public UEnvQueryTest
{
public:
	EAIHotSpotSlot                                SlotState;                                         // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_HotspotSlotState">();
	}
	static class UFortQueryTest_HotspotSlotState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_HotspotSlotState>();
	}
};
static_assert(alignof(UFortQueryTest_HotspotSlotState) == 0x000008, "Wrong alignment on UFortQueryTest_HotspotSlotState");
static_assert(sizeof(UFortQueryTest_HotspotSlotState) == 0x000200, "Wrong size on UFortQueryTest_HotspotSlotState");
static_assert(offsetof(UFortQueryTest_HotspotSlotState, SlotState) == 0x0001F8, "Member 'UFortQueryTest_HotspotSlotState::SlotState' has a wrong offset!");

// Class FortniteAI.FortQueryTest_InfluenceScore
// 0x0000 (0x01F8 - 0x01F8)
class UFortQueryTest_InfluenceScore final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_InfluenceScore">();
	}
	static class UFortQueryTest_InfluenceScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_InfluenceScore>();
	}
};
static_assert(alignof(UFortQueryTest_InfluenceScore) == 0x000008, "Wrong alignment on UFortQueryTest_InfluenceScore");
static_assert(sizeof(UFortQueryTest_InfluenceScore) == 0x0001F8, "Wrong size on UFortQueryTest_InfluenceScore");

// Class FortniteAI.FortQueryTest_InsideAthenaSafeZone
// 0x0048 (0x0240 - 0x01F8)
class UFortQueryTest_InsideAthenaSafeZone final : public UEnvQueryTest
{
public:
	bool                                          bUseCurrentSafeZoneIndicatorRadius;                // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderIntValue                SafeZoneIndex;                                     // 0x0200(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bNextSafeZone;                                     // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_InsideAthenaSafeZone">();
	}
	static class UFortQueryTest_InsideAthenaSafeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_InsideAthenaSafeZone>();
	}
};
static_assert(alignof(UFortQueryTest_InsideAthenaSafeZone) == 0x000008, "Wrong alignment on UFortQueryTest_InsideAthenaSafeZone");
static_assert(sizeof(UFortQueryTest_InsideAthenaSafeZone) == 0x000240, "Wrong size on UFortQueryTest_InsideAthenaSafeZone");
static_assert(offsetof(UFortQueryTest_InsideAthenaSafeZone, bUseCurrentSafeZoneIndicatorRadius) == 0x0001F8, "Member 'UFortQueryTest_InsideAthenaSafeZone::bUseCurrentSafeZoneIndicatorRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_InsideAthenaSafeZone, SafeZoneIndex) == 0x000200, "Member 'UFortQueryTest_InsideAthenaSafeZone::SafeZoneIndex' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_InsideAthenaSafeZone, bNextSafeZone) == 0x000238, "Member 'UFortQueryTest_InsideAthenaSafeZone::bNextSafeZone' has a wrong offset!");

// Class FortniteAI.FortQueryTest_IsCloseToHotspotSlot
// 0x0048 (0x0240 - 0x01F8)
class UFortQueryTest_IsCloseToHotspotSlot final : public UEnvQueryTest
{
public:
	TSubclassOf<class AFortAIHotSpot>             HotspotClass;                                      // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              Radius;                                            // 0x0200(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreItemsWithSlotData;                          // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_IsCloseToHotspotSlot">();
	}
	static class UFortQueryTest_IsCloseToHotspotSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_IsCloseToHotspotSlot>();
	}
};
static_assert(alignof(UFortQueryTest_IsCloseToHotspotSlot) == 0x000008, "Wrong alignment on UFortQueryTest_IsCloseToHotspotSlot");
static_assert(sizeof(UFortQueryTest_IsCloseToHotspotSlot) == 0x000240, "Wrong size on UFortQueryTest_IsCloseToHotspotSlot");
static_assert(offsetof(UFortQueryTest_IsCloseToHotspotSlot, HotspotClass) == 0x0001F8, "Member 'UFortQueryTest_IsCloseToHotspotSlot::HotspotClass' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_IsCloseToHotspotSlot, Radius) == 0x000200, "Member 'UFortQueryTest_IsCloseToHotspotSlot::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_IsCloseToHotspotSlot, bIgnoreItemsWithSlotData) == 0x000238, "Member 'UFortQueryTest_IsCloseToHotspotSlot::bIgnoreItemsWithSlotData' has a wrong offset!");

// Class FortniteAI.FortQueryTest_IsGoalForAssignment
// 0x0038 (0x0230 - 0x01F8)
class UFortQueryTest_IsGoalForAssignment final : public UEnvQueryTest
{
public:
	bool                                          bRetrieveRootAssignmentFromOwner;                  // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAIAssignmentIdentifier            RootAssignmentID;                                  // 0x0200(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_IsGoalForAssignment">();
	}
	static class UFortQueryTest_IsGoalForAssignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_IsGoalForAssignment>();
	}
};
static_assert(alignof(UFortQueryTest_IsGoalForAssignment) == 0x000008, "Wrong alignment on UFortQueryTest_IsGoalForAssignment");
static_assert(sizeof(UFortQueryTest_IsGoalForAssignment) == 0x000230, "Wrong size on UFortQueryTest_IsGoalForAssignment");
static_assert(offsetof(UFortQueryTest_IsGoalForAssignment, bRetrieveRootAssignmentFromOwner) == 0x0001F8, "Member 'UFortQueryTest_IsGoalForAssignment::bRetrieveRootAssignmentFromOwner' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_IsGoalForAssignment, RootAssignmentID) == 0x000200, "Member 'UFortQueryTest_IsGoalForAssignment::RootAssignmentID' has a wrong offset!");

// Class FortniteAI.FortQueryTest_MissionSameMap
// 0x0048 (0x0240 - 0x01F8)
class UFortQueryTest_MissionSameMap final : public UEnvQueryTest
{
public:
	struct FGameplayTagQuery                      MissionPlacementActorTagQuery;                     // 0x01F8(0x0048)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_MissionSameMap">();
	}
	static class UFortQueryTest_MissionSameMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_MissionSameMap>();
	}
};
static_assert(alignof(UFortQueryTest_MissionSameMap) == 0x000008, "Wrong alignment on UFortQueryTest_MissionSameMap");
static_assert(sizeof(UFortQueryTest_MissionSameMap) == 0x000240, "Wrong size on UFortQueryTest_MissionSameMap");
static_assert(offsetof(UFortQueryTest_MissionSameMap, MissionPlacementActorTagQuery) == 0x0001F8, "Member 'UFortQueryTest_MissionSameMap::MissionPlacementActorTagQuery' has a wrong offset!");

// Class FortniteAI.FortQueryTest_NavGraphDistance
// 0x0008 (0x0200 - 0x01F8)
class UFortQueryTest_NavGraphDistance final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_NavGraphDistance">();
	}
	static class UFortQueryTest_NavGraphDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_NavGraphDistance>();
	}
};
static_assert(alignof(UFortQueryTest_NavGraphDistance) == 0x000008, "Wrong alignment on UFortQueryTest_NavGraphDistance");
static_assert(sizeof(UFortQueryTest_NavGraphDistance) == 0x000200, "Wrong size on UFortQueryTest_NavGraphDistance");
static_assert(offsetof(UFortQueryTest_NavGraphDistance, DistanceTo) == 0x0001F8, "Member 'UFortQueryTest_NavGraphDistance::DistanceTo' has a wrong offset!");

// Class FortniteAI.FortQueryTest_OnFlatSurface
// 0x0010 (0x0208 - 0x01F8)
class UFortQueryTest_OnFlatSurface final : public UEnvQueryTest
{
public:
	float                                         Radius;                                            // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToleranceZ;                                        // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffsetUp;                                     // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffsetDown;                                   // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_OnFlatSurface">();
	}
	static class UFortQueryTest_OnFlatSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_OnFlatSurface>();
	}
};
static_assert(alignof(UFortQueryTest_OnFlatSurface) == 0x000008, "Wrong alignment on UFortQueryTest_OnFlatSurface");
static_assert(sizeof(UFortQueryTest_OnFlatSurface) == 0x000208, "Wrong size on UFortQueryTest_OnFlatSurface");
static_assert(offsetof(UFortQueryTest_OnFlatSurface, Radius) == 0x0001F8, "Member 'UFortQueryTest_OnFlatSurface::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurface, ToleranceZ) == 0x0001FC, "Member 'UFortQueryTest_OnFlatSurface::ToleranceZ' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurface, TraceOffsetUp) == 0x000200, "Member 'UFortQueryTest_OnFlatSurface::TraceOffsetUp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurface, TraceOffsetDown) == 0x000204, "Member 'UFortQueryTest_OnFlatSurface::TraceOffsetDown' has a wrong offset!");

// Class FortniteAI.FortQueryTest_OnFlatSurfaceNoNavMesh
// 0x0020 (0x0218 - 0x01F8)
class UFortQueryTest_OnFlatSurfaceNoNavMesh final : public UEnvQueryTest
{
public:
	float                                         Radius;                                            // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZTolerance;                                        // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalTolerance;                                   // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffset;                                       // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             ActorClassesToIgnoreInTrace;                       // 0x0208(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_OnFlatSurfaceNoNavMesh">();
	}
	static class UFortQueryTest_OnFlatSurfaceNoNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_OnFlatSurfaceNoNavMesh>();
	}
};
static_assert(alignof(UFortQueryTest_OnFlatSurfaceNoNavMesh) == 0x000008, "Wrong alignment on UFortQueryTest_OnFlatSurfaceNoNavMesh");
static_assert(sizeof(UFortQueryTest_OnFlatSurfaceNoNavMesh) == 0x000218, "Wrong size on UFortQueryTest_OnFlatSurfaceNoNavMesh");
static_assert(offsetof(UFortQueryTest_OnFlatSurfaceNoNavMesh, Radius) == 0x0001F8, "Member 'UFortQueryTest_OnFlatSurfaceNoNavMesh::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurfaceNoNavMesh, ZTolerance) == 0x0001FC, "Member 'UFortQueryTest_OnFlatSurfaceNoNavMesh::ZTolerance' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurfaceNoNavMesh, NormalTolerance) == 0x000200, "Member 'UFortQueryTest_OnFlatSurfaceNoNavMesh::NormalTolerance' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurfaceNoNavMesh, TraceOffset) == 0x000204, "Member 'UFortQueryTest_OnFlatSurfaceNoNavMesh::TraceOffset' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurfaceNoNavMesh, ActorClassesToIgnoreInTrace) == 0x000208, "Member 'UFortQueryTest_OnFlatSurfaceNoNavMesh::ActorClassesToIgnoreInTrace' has a wrong offset!");

// Class FortniteAI.FortQueryTest_PathfindingBatch
// 0x0008 (0x02C0 - 0x02B8)
class UFortQueryTest_PathfindingBatch final : public UEnvQueryTest_PathfindingBatch
{
public:
	struct FGameplayTag                           NavFilterTag;                                      // 0x02B8(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PathfindingBatch">();
	}
	static class UFortQueryTest_PathfindingBatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PathfindingBatch>();
	}
};
static_assert(alignof(UFortQueryTest_PathfindingBatch) == 0x000008, "Wrong alignment on UFortQueryTest_PathfindingBatch");
static_assert(sizeof(UFortQueryTest_PathfindingBatch) == 0x0002C0, "Wrong size on UFortQueryTest_PathfindingBatch");
static_assert(offsetof(UFortQueryTest_PathfindingBatch, NavFilterTag) == 0x0002B8, "Member 'UFortQueryTest_PathfindingBatch::NavFilterTag' has a wrong offset!");

// Class FortniteAI.FortQueryTest_PawnHealth
// 0x0008 (0x0228 - 0x0220)
class UFortQueryTest_PawnHealth final : public UFortQueryTest_GoalBase
{
public:
	bool                                          bUsePercentHealth;                                 // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PawnHealth">();
	}
	static class UFortQueryTest_PawnHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PawnHealth>();
	}
};
static_assert(alignof(UFortQueryTest_PawnHealth) == 0x000008, "Wrong alignment on UFortQueryTest_PawnHealth");
static_assert(sizeof(UFortQueryTest_PawnHealth) == 0x000228, "Wrong size on UFortQueryTest_PawnHealth");
static_assert(offsetof(UFortQueryTest_PawnHealth, bUsePercentHealth) == 0x000220, "Member 'UFortQueryTest_PawnHealth::bUsePercentHealth' has a wrong offset!");

// Class FortniteAI.FortQueryTest_PerceptionAge
// 0x0010 (0x0208 - 0x01F8)
class UFortQueryTest_PerceptionAge final : public UEnvQueryTest
{
public:
	ECorePerceptionTypes                          Sense;                                             // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAISense>                   SenseClass;                                        // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PerceptionAge">();
	}
	static class UFortQueryTest_PerceptionAge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PerceptionAge>();
	}
};
static_assert(alignof(UFortQueryTest_PerceptionAge) == 0x000008, "Wrong alignment on UFortQueryTest_PerceptionAge");
static_assert(sizeof(UFortQueryTest_PerceptionAge) == 0x000208, "Wrong size on UFortQueryTest_PerceptionAge");
static_assert(offsetof(UFortQueryTest_PerceptionAge, Sense) == 0x0001F8, "Member 'UFortQueryTest_PerceptionAge::Sense' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAge, SenseClass) == 0x000200, "Member 'UFortQueryTest_PerceptionAge::SenseClass' has a wrong offset!");

// Class FortniteAI.FortQueryTest_PerceptionAll
// 0x0210 (0x0430 - 0x0220)
class UFortQueryTest_PerceptionAll final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              SenseScores[0x6];                                  // 0x0220(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UAISense>, struct FAIDataProviderFloatValue> AdditionalSenseScores;                             // 0x0370(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MinSenseAge;                                       // 0x03C0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxSenseAge;                                       // 0x03F8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PerceptionAll">();
	}
	static class UFortQueryTest_PerceptionAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PerceptionAll>();
	}
};
static_assert(alignof(UFortQueryTest_PerceptionAll) == 0x000008, "Wrong alignment on UFortQueryTest_PerceptionAll");
static_assert(sizeof(UFortQueryTest_PerceptionAll) == 0x000430, "Wrong size on UFortQueryTest_PerceptionAll");
static_assert(offsetof(UFortQueryTest_PerceptionAll, SenseScores) == 0x000220, "Member 'UFortQueryTest_PerceptionAll::SenseScores' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, AdditionalSenseScores) == 0x000370, "Member 'UFortQueryTest_PerceptionAll::AdditionalSenseScores' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, MinSenseAge) == 0x0003C0, "Member 'UFortQueryTest_PerceptionAll::MinSenseAge' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, MaxSenseAge) == 0x0003F8, "Member 'UFortQueryTest_PerceptionAll::MaxSenseAge' has a wrong offset!");

// Class FortniteAI.FortQueryTest_PickupDropper
// 0x0118 (0x0338 - 0x0220)
class UFortQueryTest_PickupDropper final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              ValueConverterDroppedPickup;                       // 0x0220(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValueOtherDroppedPickupInitial;                    // 0x0258(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValueOtherDroppedPickupFinal;                      // 0x0290(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              TimeOtherDroppedPickupFinal;                       // 0x02C8(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderBoolValue               LerpFromInitialToFinal;                            // 0x0300(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PickupDropper">();
	}
	static class UFortQueryTest_PickupDropper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PickupDropper>();
	}
};
static_assert(alignof(UFortQueryTest_PickupDropper) == 0x000008, "Wrong alignment on UFortQueryTest_PickupDropper");
static_assert(sizeof(UFortQueryTest_PickupDropper) == 0x000338, "Wrong size on UFortQueryTest_PickupDropper");
static_assert(offsetof(UFortQueryTest_PickupDropper, ValueConverterDroppedPickup) == 0x000220, "Member 'UFortQueryTest_PickupDropper::ValueConverterDroppedPickup' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PickupDropper, ValueOtherDroppedPickupInitial) == 0x000258, "Member 'UFortQueryTest_PickupDropper::ValueOtherDroppedPickupInitial' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PickupDropper, ValueOtherDroppedPickupFinal) == 0x000290, "Member 'UFortQueryTest_PickupDropper::ValueOtherDroppedPickupFinal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PickupDropper, TimeOtherDroppedPickupFinal) == 0x0002C8, "Member 'UFortQueryTest_PickupDropper::TimeOtherDroppedPickupFinal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PickupDropper, LerpFromInitialToFinal) == 0x000300, "Member 'UFortQueryTest_PickupDropper::LerpFromInitialToFinal' has a wrong offset!");

// Class FortniteAI.FortQueryTest_PointInBuildingFoundation
// 0x0028 (0x0220 - 0x01F8)
class UFortQueryTest_PointInBuildingFoundation final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           BuildingFoundationContext;                         // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABuildingFoundation>        BuildingFoundationClass;                           // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BoundingBoxScale;                                  // 0x0208(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PointInBuildingFoundation">();
	}
	static class UFortQueryTest_PointInBuildingFoundation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PointInBuildingFoundation>();
	}
};
static_assert(alignof(UFortQueryTest_PointInBuildingFoundation) == 0x000008, "Wrong alignment on UFortQueryTest_PointInBuildingFoundation");
static_assert(sizeof(UFortQueryTest_PointInBuildingFoundation) == 0x000220, "Wrong size on UFortQueryTest_PointInBuildingFoundation");
static_assert(offsetof(UFortQueryTest_PointInBuildingFoundation, BuildingFoundationContext) == 0x0001F8, "Member 'UFortQueryTest_PointInBuildingFoundation::BuildingFoundationContext' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PointInBuildingFoundation, BuildingFoundationClass) == 0x000200, "Member 'UFortQueryTest_PointInBuildingFoundation::BuildingFoundationClass' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PointInBuildingFoundation, BoundingBoxScale) == 0x000208, "Member 'UFortQueryTest_PointInBuildingFoundation::BoundingBoxScale' has a wrong offset!");

// Class FortniteAI.FortQueryTest_ProjectOnNavMesh
// 0x0000 (0x01F8 - 0x01F8)
class UFortQueryTest_ProjectOnNavMesh final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_ProjectOnNavMesh">();
	}
	static class UFortQueryTest_ProjectOnNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_ProjectOnNavMesh>();
	}
};
static_assert(alignof(UFortQueryTest_ProjectOnNavMesh) == 0x000008, "Wrong alignment on UFortQueryTest_ProjectOnNavMesh");
static_assert(sizeof(UFortQueryTest_ProjectOnNavMesh) == 0x0001F8, "Wrong size on UFortQueryTest_ProjectOnNavMesh");

// Class FortniteAI.FortQueryTest_Random
// 0x0008 (0x0200 - 0x01F8)
class UFortQueryTest_Random final : public UEnvQueryTest
{
public:
	uint8                                         bUseRandomSeedForAI : 1;                           // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseRandomSeedForOthers : 1;                       // 0x01F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_Random">();
	}
	static class UFortQueryTest_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_Random>();
	}
};
static_assert(alignof(UFortQueryTest_Random) == 0x000008, "Wrong alignment on UFortQueryTest_Random");
static_assert(sizeof(UFortQueryTest_Random) == 0x000200, "Wrong size on UFortQueryTest_Random");

// Class FortniteAI.FortQueryTest_TowardNextAthenaSafeZone
// 0x0058 (0x0250 - 0x01F8)
class UFortQueryTest_TowardNextAthenaSafeZone final : public UEnvQueryTest
{
public:
	struct FAIDataProviderIntValue                SafeZoneIndex;                                     // 0x01F8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bCheckAcceptanceAngleTowardNextCenter;             // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AcceptanceAngleTowardNextCenter;                   // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 ExclusionSafeZoneIndex;                            // 0x0238(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_TowardNextAthenaSafeZone">();
	}
	static class UFortQueryTest_TowardNextAthenaSafeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_TowardNextAthenaSafeZone>();
	}
};
static_assert(alignof(UFortQueryTest_TowardNextAthenaSafeZone) == 0x000008, "Wrong alignment on UFortQueryTest_TowardNextAthenaSafeZone");
static_assert(sizeof(UFortQueryTest_TowardNextAthenaSafeZone) == 0x000250, "Wrong size on UFortQueryTest_TowardNextAthenaSafeZone");
static_assert(offsetof(UFortQueryTest_TowardNextAthenaSafeZone, SafeZoneIndex) == 0x0001F8, "Member 'UFortQueryTest_TowardNextAthenaSafeZone::SafeZoneIndex' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_TowardNextAthenaSafeZone, bCheckAcceptanceAngleTowardNextCenter) == 0x000230, "Member 'UFortQueryTest_TowardNextAthenaSafeZone::bCheckAcceptanceAngleTowardNextCenter' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_TowardNextAthenaSafeZone, AcceptanceAngleTowardNextCenter) == 0x000234, "Member 'UFortQueryTest_TowardNextAthenaSafeZone::AcceptanceAngleTowardNextCenter' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_TowardNextAthenaSafeZone, ExclusionSafeZoneIndex) == 0x000238, "Member 'UFortQueryTest_TowardNextAthenaSafeZone::ExclusionSafeZoneIndex' has a wrong offset!");

// Class FortniteAI.FortQueryTest_WithinHotfixVolumeBounds
// 0x0028 (0x0220 - 0x01F8)
class UFortQueryTest_WithinHotfixVolumeBounds final : public UEnvQueryTest
{
public:
	class UDataTable*                             BoundsTable;                                       // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BoundsExtentBuffer;                                // 0x0200(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bXYOnly;                                           // 0x0218(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_WithinHotfixVolumeBounds">();
	}
	static class UFortQueryTest_WithinHotfixVolumeBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_WithinHotfixVolumeBounds>();
	}
};
static_assert(alignof(UFortQueryTest_WithinHotfixVolumeBounds) == 0x000008, "Wrong alignment on UFortQueryTest_WithinHotfixVolumeBounds");
static_assert(sizeof(UFortQueryTest_WithinHotfixVolumeBounds) == 0x000220, "Wrong size on UFortQueryTest_WithinHotfixVolumeBounds");
static_assert(offsetof(UFortQueryTest_WithinHotfixVolumeBounds, BoundsTable) == 0x0001F8, "Member 'UFortQueryTest_WithinHotfixVolumeBounds::BoundsTable' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_WithinHotfixVolumeBounds, BoundsExtentBuffer) == 0x000200, "Member 'UFortQueryTest_WithinHotfixVolumeBounds::BoundsExtentBuffer' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_WithinHotfixVolumeBounds, bXYOnly) == 0x000218, "Member 'UFortQueryTest_WithinHotfixVolumeBounds::bXYOnly' has a wrong offset!");

// Class FortniteAI.FortQueryTest_WithinTaggedArea
// 0x0068 (0x0260 - 0x01F8)
class UFortQueryTest_WithinTaggedArea final : public UEnvQueryTest
{
public:
	struct FGameplayTagQuery                      TagQuery;                                          // 0x01F8(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FVector                                AreaExtentBuffer;                                  // 0x0240(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAssumeInfiniteHeightForArea;                      // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_WithinTaggedArea">();
	}
	static class UFortQueryTest_WithinTaggedArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_WithinTaggedArea>();
	}
};
static_assert(alignof(UFortQueryTest_WithinTaggedArea) == 0x000008, "Wrong alignment on UFortQueryTest_WithinTaggedArea");
static_assert(sizeof(UFortQueryTest_WithinTaggedArea) == 0x000260, "Wrong size on UFortQueryTest_WithinTaggedArea");
static_assert(offsetof(UFortQueryTest_WithinTaggedArea, TagQuery) == 0x0001F8, "Member 'UFortQueryTest_WithinTaggedArea::TagQuery' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_WithinTaggedArea, AreaExtentBuffer) == 0x000240, "Member 'UFortQueryTest_WithinTaggedArea::AreaExtentBuffer' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_WithinTaggedArea, bAssumeInfiniteHeightForArea) == 0x000258, "Member 'UFortQueryTest_WithinTaggedArea::bAssumeInfiniteHeightForArea' has a wrong offset!");

// Class FortniteAI.FortRiftBlockerComponent
// 0x0000 (0x0570 - 0x0570)
class UFortRiftBlockerComponent final : public UBoxComponent
{
public:
	uint8                                         bStartActive : 1;                                  // 0x0568(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_569[0x7];                                      // 0x0569(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRiftBlockerComponent">();
	}
	static class UFortRiftBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRiftBlockerComponent>();
	}
};
static_assert(alignof(UFortRiftBlockerComponent) == 0x000010, "Wrong alignment on UFortRiftBlockerComponent");
static_assert(sizeof(UFortRiftBlockerComponent) == 0x000570, "Wrong size on UFortRiftBlockerComponent");

// Class FortniteAI.IrwinAIController
// 0x0000 (0x0578 - 0x0578)
class AIrwinAIController final : public AAthenaAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IrwinAIController">();
	}
	static class AIrwinAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIrwinAIController>();
	}
};
static_assert(alignof(AIrwinAIController) == 0x000008, "Wrong alignment on AIrwinAIController");
static_assert(sizeof(AIrwinAIController) == 0x000578, "Wrong size on AIrwinAIController");

// Class FortniteAI.LevelTestingActorBase
// 0x0000 (0x0270 - 0x0270)
class ALevelTestingActorBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelTestingActorBase">();
	}
	static class ALevelTestingActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelTestingActorBase>();
	}
};
static_assert(alignof(ALevelTestingActorBase) == 0x000008, "Wrong alignment on ALevelTestingActorBase");
static_assert(sizeof(ALevelTestingActorBase) == 0x000270, "Wrong size on ALevelTestingActorBase");

// Class FortniteAI.NavGraphDebugActor
// 0x0000 (0x0270 - 0x0270)
class ANavGraphDebugActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavGraphDebugActor">();
	}
	static class ANavGraphDebugActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavGraphDebugActor>();
	}
};
static_assert(alignof(ANavGraphDebugActor) == 0x000008, "Wrong alignment on ANavGraphDebugActor");
static_assert(sizeof(ANavGraphDebugActor) == 0x000270, "Wrong size on ANavGraphDebugActor");

// Class FortniteAI.ThreatCloud
// 0x0240 (0x04B0 - 0x0270)
class AThreatCloud final : public AActor
{
public:
	TArray<class UBoxComponent*>                  LightningSourceAreas;                              // 0x0270(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x0280(0x00C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MiniMapIconPercent;                                // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_344[0xC];                                      // 0x0344(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MiniMapFarOffIconBrush;                            // 0x0350(0x00C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FLinearColor                           ActiveTint;                                        // 0x0410(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           InActiveTint;                                      // 0x0420(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActiveTransitionTime;                              // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeathTimerDuration;                                // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMiniMapTickInterval;                          // 0x0438(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_43C[0x14];                                     // 0x043C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MiniMapFarOffIconDegreesOfArc;                     // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_454[0xC];                                      // 0x0454(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   ThreatBoxVolume;                                   // 0x0460(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         GroundLevelUnderCloud;                             // 0x0498(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        GoalActorLocations;                                // 0x04A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void ManualLightningFlash();
	void OnBeginDeath();
	void OnCloudActivated();
	void OnCloudDeactivated(EFortThreatDeactivationType DeactivationType);
	void OnCloudHiddenChange(bool bCloudsAreHidden);
	void OnCloudStart();
	void OnLightningStrike(const struct FVector& StartLocation, const struct FVector& EndLocation, class ABuildingRift* Rift, bool bLightningStruckRift);
	void OnThreatVolumeChanged();

	struct FBox GetThreatVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatCloud">();
	}
	static class AThreatCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThreatCloud>();
	}
};
static_assert(alignof(AThreatCloud) == 0x000010, "Wrong alignment on AThreatCloud");
static_assert(sizeof(AThreatCloud) == 0x0004B0, "Wrong size on AThreatCloud");
static_assert(offsetof(AThreatCloud, LightningSourceAreas) == 0x000270, "Member 'AThreatCloud::LightningSourceAreas' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapIconBrush) == 0x000280, "Member 'AThreatCloud::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapIconPercent) == 0x000340, "Member 'AThreatCloud::MiniMapIconPercent' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapFarOffIconBrush) == 0x000350, "Member 'AThreatCloud::MiniMapFarOffIconBrush' has a wrong offset!");
static_assert(offsetof(AThreatCloud, ActiveTint) == 0x000410, "Member 'AThreatCloud::ActiveTint' has a wrong offset!");
static_assert(offsetof(AThreatCloud, InActiveTint) == 0x000420, "Member 'AThreatCloud::InActiveTint' has a wrong offset!");
static_assert(offsetof(AThreatCloud, ActiveTransitionTime) == 0x000430, "Member 'AThreatCloud::ActiveTransitionTime' has a wrong offset!");
static_assert(offsetof(AThreatCloud, DeathTimerDuration) == 0x000434, "Member 'AThreatCloud::DeathTimerDuration' has a wrong offset!");
static_assert(offsetof(AThreatCloud, CloudMiniMapTickInterval) == 0x000438, "Member 'AThreatCloud::CloudMiniMapTickInterval' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapFarOffIconDegreesOfArc) == 0x000450, "Member 'AThreatCloud::MiniMapFarOffIconDegreesOfArc' has a wrong offset!");
static_assert(offsetof(AThreatCloud, ThreatBoxVolume) == 0x000460, "Member 'AThreatCloud::ThreatBoxVolume' has a wrong offset!");
static_assert(offsetof(AThreatCloud, GroundLevelUnderCloud) == 0x000498, "Member 'AThreatCloud::GroundLevelUnderCloud' has a wrong offset!");
static_assert(offsetof(AThreatCloud, GoalActorLocations) == 0x0004A0, "Member 'AThreatCloud::GoalActorLocations' has a wrong offset!");

}

