#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ButterCakeRuntime

#include "Basic.hpp"

#include "GameplayTags_0_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "ButterCakeRuntime_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "FortniteAI_classes.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "ControlRig_structs.hpp"
#include "ControlRig_classes.hpp"


namespace SDK
{

// Class ButterCakeRuntime.ButterCakeKismetLibrary
// 0x0000 (0x0028 - 0x0028)
class UButterCakeKismetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButterCakeKismetLibrary">();
	}
	static class UButterCakeKismetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButterCakeKismetLibrary>();
	}
};
static_assert(alignof(UButterCakeKismetLibrary) == 0x000008, "Wrong alignment on UButterCakeKismetLibrary");
static_assert(sizeof(UButterCakeKismetLibrary) == 0x000028, "Wrong size on UButterCakeKismetLibrary");

// Class ButterCakeRuntime.ButterCakeUnstuckComponent
// 0x00D8 (0x0178 - 0x00A0)
class UButterCakeUnstuckComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnBlocked;                                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EnsureEnable;                                      // 0x00B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         EventBPEnable;                                     // 0x00D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         LocationSampleMaxCount;                            // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LocationSampleDelay;                               // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DistanceMinToUnstuck;                              // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PauseUnstuckBehaviorTags;                          // 0x0110(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        LocationSamples;                                   // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class FString>                         BTTaskSamples;                                     // 0x0140(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         DistanceMinToUnstuckSqr;                           // 0x0150(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIPawn*                            CachedOwner;                                       // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                CachedAbilityComponent;                            // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortGameStateAthena*                   CachedAthenaGameState;                             // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAthenaGamePhaseChanged(EAthenaGamePhase GamePhase);
	void ResetUnstuckLocationSamples();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButterCakeUnstuckComponent">();
	}
	static class UButterCakeUnstuckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButterCakeUnstuckComponent>();
	}
};
static_assert(alignof(UButterCakeUnstuckComponent) == 0x000008, "Wrong alignment on UButterCakeUnstuckComponent");
static_assert(sizeof(UButterCakeUnstuckComponent) == 0x000178, "Wrong size on UButterCakeUnstuckComponent");
static_assert(offsetof(UButterCakeUnstuckComponent, OnBlocked) == 0x0000A0, "Member 'UButterCakeUnstuckComponent::OnBlocked' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, EnsureEnable) == 0x0000B0, "Member 'UButterCakeUnstuckComponent::EnsureEnable' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, EventBPEnable) == 0x0000D8, "Member 'UButterCakeUnstuckComponent::EventBPEnable' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, LocationSampleMaxCount) == 0x000100, "Member 'UButterCakeUnstuckComponent::LocationSampleMaxCount' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, LocationSampleDelay) == 0x000104, "Member 'UButterCakeUnstuckComponent::LocationSampleDelay' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, DistanceMinToUnstuck) == 0x000108, "Member 'UButterCakeUnstuckComponent::DistanceMinToUnstuck' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, PauseUnstuckBehaviorTags) == 0x000110, "Member 'UButterCakeUnstuckComponent::PauseUnstuckBehaviorTags' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, LocationSamples) == 0x000130, "Member 'UButterCakeUnstuckComponent::LocationSamples' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, BTTaskSamples) == 0x000140, "Member 'UButterCakeUnstuckComponent::BTTaskSamples' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, DistanceMinToUnstuckSqr) == 0x000150, "Member 'UButterCakeUnstuckComponent::DistanceMinToUnstuckSqr' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, CachedOwner) == 0x000158, "Member 'UButterCakeUnstuckComponent::CachedOwner' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, CachedAbilityComponent) == 0x000160, "Member 'UButterCakeUnstuckComponent::CachedAbilityComponent' has a wrong offset!");
static_assert(offsetof(UButterCakeUnstuckComponent, CachedAthenaGameState) == 0x000168, "Member 'UButterCakeUnstuckComponent::CachedAthenaGameState' has a wrong offset!");

// Class ButterCakeRuntime.FortAIAnimInstance_ButterCake
// 0x0070 (0x05A0 - 0x0530)
class UFortAIAnimInstance_ButterCake final : public UFortAIAnimInstance
{
public:
	float                                         DeltaTimeX;                                        // 0x0528(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngle;                                         // 0x052C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPosLeftPlantC;                                // 0x0530(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtYaw;                                         // 0x0534(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtPitch;                                       // 0x0538(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x053C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldApplyHostileAdditive;                       // 0x053D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMouthOpen;                                      // 0x053E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocomotion;                                     // 0x053F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHostile;                                        // 0x0540(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLured;                                          // 0x0541(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_542[0x2];                                      // 0x0542(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AimOffsetAlpha;                                    // 0x0544(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortButterCakeFootPhase                      FootPhase;                                         // 0x0548(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsRightPlantA;                           // 0x0549(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsRightPlantB;                           // 0x054A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsRightPlantC;                           // 0x054B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsLeftPlantA;                            // 0x054C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsLeftPlantB;                            // 0x054D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsLeftPlantC;                            // 0x054E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsHostileRightPass;                      // 0x054F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsHostileRightPlant;                     // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsHostileLeftPass;                       // 0x0551(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsHostileLeftPlant;                      // 0x0552(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsBothPlant;                             // 0x0553(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsBothPlantA;                            // 0x0554(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsBothPlantB;                            // 0x0555(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsBothPlantC;                            // 0x0556(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhaseIsBothPlantD;                            // 0x0557(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleTurn;                                       // 0x0558(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleTurnRight;                                    // 0x0559(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55A[0x2];                                      // 0x055A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationDirection;                                 // 0x055C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocomotion_Conduit_IsMovingORIsLocomotion;        // 0x0560(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocomotion_Conduit_NOTIsMovingANDNOTIsLocomotion; // 0x0561(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_562[0x2];                                      // 0x0562(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinLeanAngleDegrees;                               // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLeanAngleDegrees;                               // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouthOpenMinCurveValue;                            // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionMinCurveValue;                           // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootPhaseMinActivateValue;                         // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootPhaseActiveStartValue;                         // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootPhaseInactiveStartValue;                       // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_DisableHostileAdditive;                  // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_FootPhase;                               // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_ApplyAimOffset;                          // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_ApplyHostileAimOffset;                   // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_MouthOpen;                               // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_IsLocomotion;                            // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AIE_ButterCake_Berserk;                            // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AIE_ButterCake_Lured;                              // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	EFortButterCakeFootPhase ComputeFootPhase();
	float ComputeLeanAngleByVelocity();
	void SetFootPhaseMembers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAnimInstance_ButterCake">();
	}
	static class UFortAIAnimInstance_ButterCake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAnimInstance_ButterCake>();
	}
};
static_assert(alignof(UFortAIAnimInstance_ButterCake) == 0x000010, "Wrong alignment on UFortAIAnimInstance_ButterCake");
static_assert(sizeof(UFortAIAnimInstance_ButterCake) == 0x0005A0, "Wrong size on UFortAIAnimInstance_ButterCake");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, DeltaTimeX) == 0x000528, "Member 'UFortAIAnimInstance_ButterCake::DeltaTimeX' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, LeanAngle) == 0x00052C, "Member 'UFortAIAnimInstance_ButterCake::LeanAngle' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, StartPosLeftPlantC) == 0x000530, "Member 'UFortAIAnimInstance_ButterCake::StartPosLeftPlantC' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, LookAtYaw) == 0x000534, "Member 'UFortAIAnimInstance_ButterCake::LookAtYaw' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, LookAtPitch) == 0x000538, "Member 'UFortAIAnimInstance_ButterCake::LookAtPitch' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bIsMoving) == 0x00053C, "Member 'UFortAIAnimInstance_ButterCake::bIsMoving' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bShouldApplyHostileAdditive) == 0x00053D, "Member 'UFortAIAnimInstance_ButterCake::bShouldApplyHostileAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bIsMouthOpen) == 0x00053E, "Member 'UFortAIAnimInstance_ButterCake::bIsMouthOpen' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bIsLocomotion) == 0x00053F, "Member 'UFortAIAnimInstance_ButterCake::bIsLocomotion' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bIsHostile) == 0x000540, "Member 'UFortAIAnimInstance_ButterCake::bIsHostile' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bIsLured) == 0x000541, "Member 'UFortAIAnimInstance_ButterCake::bIsLured' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, AimOffsetAlpha) == 0x000544, "Member 'UFortAIAnimInstance_ButterCake::AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, FootPhase) == 0x000548, "Member 'UFortAIAnimInstance_ButterCake::FootPhase' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsRightPlantA) == 0x000549, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsRightPlantA' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsRightPlantB) == 0x00054A, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsRightPlantB' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsRightPlantC) == 0x00054B, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsRightPlantC' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsLeftPlantA) == 0x00054C, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsLeftPlantA' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsLeftPlantB) == 0x00054D, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsLeftPlantB' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsLeftPlantC) == 0x00054E, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsLeftPlantC' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsHostileRightPass) == 0x00054F, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsHostileRightPass' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsHostileRightPlant) == 0x000550, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsHostileRightPlant' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsHostileLeftPass) == 0x000551, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsHostileLeftPass' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsHostileLeftPlant) == 0x000552, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsHostileLeftPlant' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsBothPlant) == 0x000553, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsBothPlant' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsBothPlantA) == 0x000554, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsBothPlantA' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsBothPlantB) == 0x000555, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsBothPlantB' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsBothPlantC) == 0x000556, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsBothPlantC' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bFootPhaseIsBothPlantD) == 0x000557, "Member 'UFortAIAnimInstance_ButterCake::bFootPhaseIsBothPlantD' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bIsIdleTurn) == 0x000558, "Member 'UFortAIAnimInstance_ButterCake::bIsIdleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bIdleTurnRight) == 0x000559, "Member 'UFortAIAnimInstance_ButterCake::bIdleTurnRight' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, RotationDirection) == 0x00055C, "Member 'UFortAIAnimInstance_ButterCake::RotationDirection' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bLocomotion_Conduit_IsMovingORIsLocomotion) == 0x000560, "Member 'UFortAIAnimInstance_ButterCake::bLocomotion_Conduit_IsMovingORIsLocomotion' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, bLocomotion_Conduit_NOTIsMovingANDNOTIsLocomotion) == 0x000561, "Member 'UFortAIAnimInstance_ButterCake::bLocomotion_Conduit_NOTIsMovingANDNOTIsLocomotion' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, MinLeanAngleDegrees) == 0x000564, "Member 'UFortAIAnimInstance_ButterCake::MinLeanAngleDegrees' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, MaxLeanAngleDegrees) == 0x000568, "Member 'UFortAIAnimInstance_ButterCake::MaxLeanAngleDegrees' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, MouthOpenMinCurveValue) == 0x00056C, "Member 'UFortAIAnimInstance_ButterCake::MouthOpenMinCurveValue' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, LocomotionMinCurveValue) == 0x000570, "Member 'UFortAIAnimInstance_ButterCake::LocomotionMinCurveValue' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, FootPhaseMinActivateValue) == 0x000574, "Member 'UFortAIAnimInstance_ButterCake::FootPhaseMinActivateValue' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, FootPhaseActiveStartValue) == 0x000578, "Member 'UFortAIAnimInstance_ButterCake::FootPhaseActiveStartValue' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, FootPhaseInactiveStartValue) == 0x00057C, "Member 'UFortAIAnimInstance_ButterCake::FootPhaseInactiveStartValue' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, CurveName_DisableHostileAdditive) == 0x000580, "Member 'UFortAIAnimInstance_ButterCake::CurveName_DisableHostileAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, CurveName_FootPhase) == 0x000584, "Member 'UFortAIAnimInstance_ButterCake::CurveName_FootPhase' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, CurveName_ApplyAimOffset) == 0x000588, "Member 'UFortAIAnimInstance_ButterCake::CurveName_ApplyAimOffset' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, CurveName_ApplyHostileAimOffset) == 0x00058C, "Member 'UFortAIAnimInstance_ButterCake::CurveName_ApplyHostileAimOffset' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, CurveName_MouthOpen) == 0x000590, "Member 'UFortAIAnimInstance_ButterCake::CurveName_MouthOpen' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, CurveName_IsLocomotion) == 0x000594, "Member 'UFortAIAnimInstance_ButterCake::CurveName_IsLocomotion' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, AIE_ButterCake_Berserk) == 0x000598, "Member 'UFortAIAnimInstance_ButterCake::AIE_ButterCake_Berserk' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_ButterCake, AIE_ButterCake_Lured) == 0x00059C, "Member 'UFortAIAnimInstance_ButterCake::AIE_ButterCake_Lured' has a wrong offset!");

// Class ButterCakeRuntime.FortButterCakeComponent_Telemetry
// 0x0030 (0x0128 - 0x00F8)
class UFortButterCakeComponent_Telemetry final : public UFortAIComponent_Telemetry
{
public:
	int32                                         ItemsEatenCount;                                   // 0x00F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SneezeCount;                                       // 0x00FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ItemsSneezedCount;                                 // 0x0100(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BerserkCount;                                      // 0x0104(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PlayerAsBerserkInstigatorCount;                    // 0x0108(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BotAsBerserkInstigatorCount;                       // 0x010C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NPCAsBerserkInstigatorCount;                       // 0x0110(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AIPawnAsBerserkInstigatorCount;                    // 0x0114(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         UnknownAsBerserkInstigatorCount;                   // 0x0118(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BlowholeUsesCount;                                 // 0x011C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LuredCount;                                        // 0x0120(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlowHoleUsed();
	void OnEnterBerserk(const class AController* Instigator);
	void OnItemsEaten(const int32 ItemsCount);
	void OnItemsSneezed(const int32 ItemsCount);
	void OnLured();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortButterCakeComponent_Telemetry">();
	}
	static class UFortButterCakeComponent_Telemetry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortButterCakeComponent_Telemetry>();
	}
};
static_assert(alignof(UFortButterCakeComponent_Telemetry) == 0x000008, "Wrong alignment on UFortButterCakeComponent_Telemetry");
static_assert(sizeof(UFortButterCakeComponent_Telemetry) == 0x000128, "Wrong size on UFortButterCakeComponent_Telemetry");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, ItemsEatenCount) == 0x0000F8, "Member 'UFortButterCakeComponent_Telemetry::ItemsEatenCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, SneezeCount) == 0x0000FC, "Member 'UFortButterCakeComponent_Telemetry::SneezeCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, ItemsSneezedCount) == 0x000100, "Member 'UFortButterCakeComponent_Telemetry::ItemsSneezedCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, BerserkCount) == 0x000104, "Member 'UFortButterCakeComponent_Telemetry::BerserkCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, PlayerAsBerserkInstigatorCount) == 0x000108, "Member 'UFortButterCakeComponent_Telemetry::PlayerAsBerserkInstigatorCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, BotAsBerserkInstigatorCount) == 0x00010C, "Member 'UFortButterCakeComponent_Telemetry::BotAsBerserkInstigatorCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, NPCAsBerserkInstigatorCount) == 0x000110, "Member 'UFortButterCakeComponent_Telemetry::NPCAsBerserkInstigatorCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, AIPawnAsBerserkInstigatorCount) == 0x000114, "Member 'UFortButterCakeComponent_Telemetry::AIPawnAsBerserkInstigatorCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, UnknownAsBerserkInstigatorCount) == 0x000118, "Member 'UFortButterCakeComponent_Telemetry::UnknownAsBerserkInstigatorCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, BlowholeUsesCount) == 0x00011C, "Member 'UFortButterCakeComponent_Telemetry::BlowholeUsesCount' has a wrong offset!");
static_assert(offsetof(UFortButterCakeComponent_Telemetry, LuredCount) == 0x000120, "Member 'UFortButterCakeComponent_Telemetry::LuredCount' has a wrong offset!");

// Class ButterCakeRuntime.FortButterCakeControlRig
// 0x00C0 (0x0550 - 0x0490)
class UFortButterCakeControlRig final : public UControlRig
{
public:
	class FName                                   PBIKRootBoneName;                                  // 0x0488(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               FootCurveCollection;                               // 0x0490(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               FootEffectorBoneCollection;                        // 0x04A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               FootEffectorControlCollection;                     // 0x04B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               FootExcludedBoneCollection;                        // 0x04C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               ChinEffectorBoneCollection;                        // 0x04D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               ChinExcludedBoneCollection;                        // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               TailEffectorBoneCollection;                        // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         TailBaseBoneKey;                                   // 0x0500(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         TailTipBoneKey;                                    // 0x0508(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         UpperLipBoneKey;                                   // 0x0510(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               GroundHitBoneCollection;                           // 0x0518(0x0010)(BlueprintVisible, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        GroundHitLocationList;                             // 0x0528(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        GroundHitNormalList;                               // 0x0538(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         Counter;                                           // 0x0548(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetGroundHitLocationAt(const int32 Index_0);
	struct FVector GetGroundHitNormalAt(const int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortButterCakeControlRig">();
	}
	static class UFortButterCakeControlRig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortButterCakeControlRig>();
	}
};
static_assert(alignof(UFortButterCakeControlRig) == 0x000010, "Wrong alignment on UFortButterCakeControlRig");
static_assert(sizeof(UFortButterCakeControlRig) == 0x000550, "Wrong size on UFortButterCakeControlRig");
static_assert(offsetof(UFortButterCakeControlRig, PBIKRootBoneName) == 0x000488, "Member 'UFortButterCakeControlRig::PBIKRootBoneName' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, FootCurveCollection) == 0x000490, "Member 'UFortButterCakeControlRig::FootCurveCollection' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, FootEffectorBoneCollection) == 0x0004A0, "Member 'UFortButterCakeControlRig::FootEffectorBoneCollection' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, FootEffectorControlCollection) == 0x0004B0, "Member 'UFortButterCakeControlRig::FootEffectorControlCollection' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, FootExcludedBoneCollection) == 0x0004C0, "Member 'UFortButterCakeControlRig::FootExcludedBoneCollection' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, ChinEffectorBoneCollection) == 0x0004D0, "Member 'UFortButterCakeControlRig::ChinEffectorBoneCollection' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, ChinExcludedBoneCollection) == 0x0004E0, "Member 'UFortButterCakeControlRig::ChinExcludedBoneCollection' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, TailEffectorBoneCollection) == 0x0004F0, "Member 'UFortButterCakeControlRig::TailEffectorBoneCollection' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, TailBaseBoneKey) == 0x000500, "Member 'UFortButterCakeControlRig::TailBaseBoneKey' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, TailTipBoneKey) == 0x000508, "Member 'UFortButterCakeControlRig::TailTipBoneKey' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, UpperLipBoneKey) == 0x000510, "Member 'UFortButterCakeControlRig::UpperLipBoneKey' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, GroundHitBoneCollection) == 0x000518, "Member 'UFortButterCakeControlRig::GroundHitBoneCollection' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, GroundHitLocationList) == 0x000528, "Member 'UFortButterCakeControlRig::GroundHitLocationList' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, GroundHitNormalList) == 0x000538, "Member 'UFortButterCakeControlRig::GroundHitNormalList' has a wrong offset!");
static_assert(offsetof(UFortButterCakeControlRig, Counter) == 0x000548, "Member 'UFortButterCakeControlRig::Counter' has a wrong offset!");

}

