#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GA_NPC_Parent

#include "Basic.hpp"

#include "GA_NPC_Parent_classes.hpp"
#include "GA_NPC_Parent_parameters.hpp"


namespace SDK
{

// Function GA_NPC_Parent.GA_NPC_Parent_C.BeginDestroyBuildings
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     TargetSelectionApplicationTag                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    DoContinuousTargetSelection                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::BeginDestroyBuildings(const struct FGameplayTag& TargetSelectionApplicationTag, bool DoContinuousTargetSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "BeginDestroyBuildings");

	Params::GA_NPC_Parent_C_BeginDestroyBuildings Parms{};

	Parms.TargetSelectionApplicationTag = std::move(TargetSelectionApplicationTag);
	Parms.DoContinuousTargetSelection = DoContinuousTargetSelection;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.Cancelled_13B12ED64A3570FC1E117FAC4E3F7961
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGameplayTag                     ApplicationTag                                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::Cancelled_13B12ED64A3570FC1E117FAC4E3F7961(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "Cancelled_13B12ED64A3570FC1E117FAC4E3F7961");

	Params::GA_NPC_Parent_C_Cancelled_13B12ED64A3570FC1E117FAC4E3F7961 Parms{};

	Parms.TargetData = std::move(TargetData);
	Parms.ApplicationTag = std::move(ApplicationTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.Cancelled_4BB5000E4F2C1DAB20E4FFAAA97E1368
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGameplayTag                     ApplicationTag                                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::Cancelled_4BB5000E4F2C1DAB20E4FFAAA97E1368(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "Cancelled_4BB5000E4F2C1DAB20E4FFAAA97E1368");

	Params::GA_NPC_Parent_C_Cancelled_4BB5000E4F2C1DAB20E4FFAAA97E1368 Parms{};

	Parms.TargetData = std::move(TargetData);
	Parms.ApplicationTag = std::move(ApplicationTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.DestroyBuilding
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           BuildingActor                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::DestroyBuilding(class AActor* BuildingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "DestroyBuilding");

	Params::GA_NPC_Parent_C_DestroyBuilding Parms{};

	Parms.BuildingActor = BuildingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.ExecuteUbergraph_GA_NPC_Parent
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::ExecuteUbergraph_GA_NPC_Parent(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "ExecuteUbergraph_GA_NPC_Parent");

	Params::GA_NPC_Parent_C_ExecuteUbergraph_GA_NPC_Parent Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC AbilityDebugMessage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           String                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    OnlyWhenDebug                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_AbilityDebugMessage(const class FString& String, bool OnlyWhenDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC AbilityDebugMessage");

	Params::GA_NPC_Parent_C_NPC_AbilityDebugMessage Parms{};

	Parms.String = std::move(String);
	Parms.OnlyWhenDebug = OnlyWhenDebug;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC AbilityTargetIsBuildingWeAreDestroyingToNavigate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsNavigationBuildingWeAreDestroying                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABuildingActor*                   BuildingWeAreDestroying                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   HealthOfBuildingWeAreDestroying                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_AbilityTargetIsBuildingWeAreDestroyingToNavigate(bool* IsNavigationBuildingWeAreDestroying, class ABuildingActor** BuildingWeAreDestroying, float* HealthOfBuildingWeAreDestroying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC AbilityTargetIsBuildingWeAreDestroyingToNavigate");

	Params::GA_NPC_Parent_C_NPC_AbilityTargetIsBuildingWeAreDestroyingToNavigate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsNavigationBuildingWeAreDestroying != nullptr)
		*IsNavigationBuildingWeAreDestroying = Parms.IsNavigationBuildingWeAreDestroying;

	if (BuildingWeAreDestroying != nullptr)
		*BuildingWeAreDestroying = Parms.BuildingWeAreDestroying;

	if (HealthOfBuildingWeAreDestroying != nullptr)
		*HealthOfBuildingWeAreDestroying = Parms.HealthOfBuildingWeAreDestroying;
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC AbilityTargetIsWithinAngleThreshold
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   AngleThreshold                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsWithinAngle                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_AbilityTargetIsWithinAngleThreshold(float AngleThreshold, bool* IsWithinAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC AbilityTargetIsWithinAngleThreshold");

	Params::GA_NPC_Parent_C_NPC_AbilityTargetIsWithinAngleThreshold Parms{};

	Parms.AngleThreshold = AngleThreshold;

	UObject::ProcessEvent(Func, &Parms);

	if (IsWithinAngle != nullptr)
		*IsWithinAngle = Parms.IsWithinAngle;
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC ApplyGameplayAbilityCooldownWithMMRScaling
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_NPC_Parent_C::NPC_ApplyGameplayAbilityCooldownWithMMRScaling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC ApplyGameplayAbilityCooldownWithMMRScaling");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC ApplyGameplayEffectContainerAndLaunchTargets
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FGameplayTag                     ApplicationTag                                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   GameplayEffectLevel                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AbilityTargetCanBeHitMultipleTimesByThisSelection      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ForceDebugFreezeFrameForThisSpecificTargeting          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HitAbilityTargetRightNow                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HitAbilityTargetDuringThisAbilityActivation            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   ActorsWeHaveHitDuringThisAbilityActivation             (Parm, OutParm)
// TArray<class AActor*>                   ActorsHitWithThisSpecificTargetSelection               (Parm, OutParm)

void UGA_NPC_Parent_C::NPC_ApplyGameplayEffectContainerAndLaunchTargets(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag, int32 GameplayEffectLevel, bool AbilityTargetCanBeHitMultipleTimesByThisSelection, bool ForceDebugFreezeFrameForThisSpecificTargeting, bool* HitAbilityTargetRightNow, bool* HitAbilityTargetDuringThisAbilityActivation, TArray<class AActor*>* ActorsWeHaveHitDuringThisAbilityActivation, TArray<class AActor*>* ActorsHitWithThisSpecificTargetSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC ApplyGameplayEffectContainerAndLaunchTargets");

	Params::GA_NPC_Parent_C_NPC_ApplyGameplayEffectContainerAndLaunchTargets Parms{};

	Parms.TargetData = std::move(TargetData);
	Parms.ApplicationTag = std::move(ApplicationTag);
	Parms.GameplayEffectLevel = GameplayEffectLevel;
	Parms.AbilityTargetCanBeHitMultipleTimesByThisSelection = AbilityTargetCanBeHitMultipleTimesByThisSelection;
	Parms.ForceDebugFreezeFrameForThisSpecificTargeting = ForceDebugFreezeFrameForThisSpecificTargeting;

	UObject::ProcessEvent(Func, &Parms);

	if (HitAbilityTargetRightNow != nullptr)
		*HitAbilityTargetRightNow = Parms.HitAbilityTargetRightNow;

	if (HitAbilityTargetDuringThisAbilityActivation != nullptr)
		*HitAbilityTargetDuringThisAbilityActivation = Parms.HitAbilityTargetDuringThisAbilityActivation;

	if (ActorsWeHaveHitDuringThisAbilityActivation != nullptr)
		*ActorsWeHaveHitDuringThisAbilityActivation = std::move(Parms.ActorsWeHaveHitDuringThisAbilityActivation);

	if (ActorsHitWithThisSpecificTargetSelection != nullptr)
		*ActorsHitWithThisSpecificTargetSelection = std::move(Parms.ActorsHitWithThisSpecificTargetSelection);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC ApplyGameplayEffectWithMMRScaling
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           GameplayEffectClass                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_ApplyGameplayEffectWithMMRScaling(class UClass* GameplayEffectClass, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC ApplyGameplayEffectWithMMRScaling");

	Params::GA_NPC_Parent_C_NPC_ApplyGameplayEffectWithMMRScaling Parms{};

	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC AttemptBuildFrustrationDueToGoal
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_AttemptBuildFrustrationDueToGoal(const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC AttemptBuildFrustrationDueToGoal");

	Params::GA_NPC_Parent_C_NPC_AttemptBuildFrustrationDueToGoal Parms{};

	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC AttemptBuildFrustrationDueToMovement
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_AttemptBuildFrustrationDueToMovement(const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC AttemptBuildFrustrationDueToMovement");

	Params::GA_NPC_Parent_C_NPC_AttemptBuildFrustrationDueToMovement Parms{};

	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC ClearFrustrationTagsForGoals
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_ClearFrustrationTagsForGoals(const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC ClearFrustrationTagsForGoals");

	Params::GA_NPC_Parent_C_NPC_ClearFrustrationTagsForGoals Parms{};

	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC ClearFrustrationTagsForMovement
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_ClearFrustrationTagsForMovement(const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC ClearFrustrationTagsForMovement");

	Params::GA_NPC_Parent_C_NPC_ClearFrustrationTagsForMovement Parms{};

	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC DebugFreezeFrame
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ForceDebugFreezeFrame                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HitAbilityTargetRightNow                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HitAbilityTargetDuringThisAbilityActivation            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   ActorsWeHaveHitDuringThisAbilityActivation             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class AActor*>                   ActorsHitWithThisSpecificTargetSelection               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGA_NPC_Parent_C::NPC_DebugFreezeFrame(bool ForceDebugFreezeFrame, bool HitAbilityTargetRightNow, bool HitAbilityTargetDuringThisAbilityActivation, TArray<class AActor*>& ActorsWeHaveHitDuringThisAbilityActivation, TArray<class AActor*>& ActorsHitWithThisSpecificTargetSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC DebugFreezeFrame");

	Params::GA_NPC_Parent_C_NPC_DebugFreezeFrame Parms{};

	Parms.ForceDebugFreezeFrame = ForceDebugFreezeFrame;
	Parms.HitAbilityTargetRightNow = HitAbilityTargetRightNow;
	Parms.HitAbilityTargetDuringThisAbilityActivation = HitAbilityTargetDuringThisAbilityActivation;
	Parms.ActorsWeHaveHitDuringThisAbilityActivation = std::move(ActorsWeHaveHitDuringThisAbilityActivation);
	Parms.ActorsHitWithThisSpecificTargetSelection = std::move(ActorsHitWithThisSpecificTargetSelection);

	UObject::ProcessEvent(Func, &Parms);

	ActorsWeHaveHitDuringThisAbilityActivation = std::move(Parms.ActorsWeHaveHitDuringThisAbilityActivation);
	ActorsHitWithThisSpecificTargetSelection = std::move(Parms.ActorsHitWithThisSpecificTargetSelection);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC DoIntentionalFailedAttack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    DoIntentionalFailedAttack                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_DoIntentionalFailedAttack(bool* DoIntentionalFailedAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC DoIntentionalFailedAttack");

	Params::GA_NPC_Parent_C_NPC_DoIntentionalFailedAttack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DoIntentionalFailedAttack != nullptr)
		*DoIntentionalFailedAttack = Parms.DoIntentionalFailedAttack;
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC EQS Results
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UEnvQueryInstanceBlueprintWrapper*QueryInstance                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EEnvQueryStatus                         QueryStatus                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EEnvQueryRunMode                        EQS_RunMode                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NumReturnedItemsIsImportant                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   ResultActors                                           (Parm, OutParm)
// int32                                   NumValidActorsGenerated                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ResultActorsSuccess                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  ResultLocations                                        (Parm, OutParm)
// int32                                   NumValidLocationsGenerated                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ResultLocationsSuccess                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UEnvQueryInstanceBlueprintWrapper*QueryInstanceOut                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EEnvQueryStatus                         QueryStatusOut                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_EQS_Results(class UEnvQueryInstanceBlueprintWrapper* QueryInstance, EEnvQueryStatus QueryStatus, EEnvQueryRunMode EQS_RunMode, bool NumReturnedItemsIsImportant, TArray<class AActor*>* ResultActors, int32* NumValidActorsGenerated, bool* ResultActorsSuccess, TArray<struct FVector>* ResultLocations, int32* NumValidLocationsGenerated, bool* ResultLocationsSuccess, class UEnvQueryInstanceBlueprintWrapper** QueryInstanceOut, EEnvQueryStatus* QueryStatusOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC EQS Results");

	Params::GA_NPC_Parent_C_NPC_EQS_Results Parms{};

	Parms.QueryInstance = QueryInstance;
	Parms.QueryStatus = QueryStatus;
	Parms.EQS_RunMode = EQS_RunMode;
	Parms.NumReturnedItemsIsImportant = NumReturnedItemsIsImportant;

	UObject::ProcessEvent(Func, &Parms);

	if (ResultActors != nullptr)
		*ResultActors = std::move(Parms.ResultActors);

	if (NumValidActorsGenerated != nullptr)
		*NumValidActorsGenerated = Parms.NumValidActorsGenerated;

	if (ResultActorsSuccess != nullptr)
		*ResultActorsSuccess = Parms.ResultActorsSuccess;

	if (ResultLocations != nullptr)
		*ResultLocations = std::move(Parms.ResultLocations);

	if (NumValidLocationsGenerated != nullptr)
		*NumValidLocationsGenerated = Parms.NumValidLocationsGenerated;

	if (ResultLocationsSuccess != nullptr)
		*ResultLocationsSuccess = Parms.ResultLocationsSuccess;

	if (QueryInstanceOut != nullptr)
		*QueryInstanceOut = Parms.QueryInstanceOut;

	if (QueryStatusOut != nullptr)
		*QueryStatusOut = Parms.QueryStatusOut;
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC GenerateLaunchVelocityWithMinimumAngle
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorWeWantToLaunch                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Vehicle                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LaunchVelocity                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           LaunchActor                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    LaunchingVehicle                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_GenerateLaunchVelocityWithMinimumAngle(class AActor* ActorWeWantToLaunch, bool Vehicle, struct FVector* LaunchVelocity, class AActor** LaunchActor, bool* LaunchingVehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC GenerateLaunchVelocityWithMinimumAngle");

	Params::GA_NPC_Parent_C_NPC_GenerateLaunchVelocityWithMinimumAngle Parms{};

	Parms.ActorWeWantToLaunch = ActorWeWantToLaunch;
	Parms.Vehicle = Vehicle;

	UObject::ProcessEvent(Func, &Parms);

	if (LaunchVelocity != nullptr)
		*LaunchVelocity = std::move(Parms.LaunchVelocity);

	if (LaunchActor != nullptr)
		*LaunchActor = Parms.LaunchActor;

	if (LaunchingVehicle != nullptr)
		*LaunchingVehicle = Parms.LaunchingVehicle;
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC GetGoalActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UObject* UGA_NPC_Parent_C::NPC_GetGoalActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC GetGoalActor");

	Params::GA_NPC_Parent_C_NPC_GetGoalActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC GetScalableFloatHotfixValue
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FScalableFloat                   ScalableFloatHotfix                                    (BlueprintVisible, BlueprintReadOnly, Parm)
// float                                   AtLevel                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AsBool                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AsIntRounded                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AsFloat                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_GetScalableFloatHotfixValue(const struct FScalableFloat& ScalableFloatHotfix, float AtLevel, bool* AsBool, int32* AsIntRounded, float* AsFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC GetScalableFloatHotfixValue");

	Params::GA_NPC_Parent_C_NPC_GetScalableFloatHotfixValue Parms{};

	Parms.ScalableFloatHotfix = std::move(ScalableFloatHotfix);
	Parms.AtLevel = AtLevel;

	UObject::ProcessEvent(Func, &Parms);

	if (AsBool != nullptr)
		*AsBool = Parms.AsBool;

	if (AsIntRounded != nullptr)
		*AsIntRounded = Parms.AsIntRounded;

	if (AsFloat != nullptr)
		*AsFloat = Parms.AsFloat;
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC IsMontageInfoValid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FFortGameplayAbilityMontageInfo  MontageInfo_0                                          (BlueprintVisible, BlueprintReadOnly, Parm)
// bool                                    IsValid_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_IsMontageInfoValid(const struct FFortGameplayAbilityMontageInfo& MontageInfo_0, bool* IsValid_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC IsMontageInfoValid");

	Params::GA_NPC_Parent_C_NPC_IsMontageInfoValid Parms{};

	Parms.MontageInfo_0 = std::move(MontageInfo_0);

	UObject::ProcessEvent(Func, &Parms);

	if (IsValid_ != nullptr)
		*IsValid_ = Parms.IsValid_;
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC OverrideRotationRate
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FScalableFloat                   RotationRate                                           (BlueprintVisible, BlueprintReadOnly, Parm)

void UGA_NPC_Parent_C::NPC_OverrideRotationRate(const struct FScalableFloat& RotationRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC OverrideRotationRate");

	Params::GA_NPC_Parent_C_NPC_OverrideRotationRate Parms{};

	Parms.RotationRate = std::move(RotationRate);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC ResetRotationRate
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_NPC_Parent_C::NPC_ResetRotationRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC ResetRotationRate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC ScalableFloatIsValid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FScalableFloat                   ScalableFloat                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_ScalableFloatIsValid(const struct FScalableFloat& ScalableFloat, bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC ScalableFloatIsValid");

	Params::GA_NPC_Parent_C_NPC_ScalableFloatIsValid Parms{};

	Parms.ScalableFloat = std::move(ScalableFloat);

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC SetAlertLevel
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_NPC_AlertLevel                     NPC_AlertLevel                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_SetAlertLevel(Enum_NPC_AlertLevel NPC_AlertLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC SetAlertLevel");

	Params::GA_NPC_Parent_C_NPC_SetAlertLevel Parms{};

	Parms.NPC_AlertLevel = NPC_AlertLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC SetAlertLevelByAIAbilityTargetType
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_NPC_Parent_C::NPC_SetAlertLevelByAIAbilityTargetType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC SetAlertLevelByAIAbilityTargetType");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC SetupAbility
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_NPC_Parent_C::NPC_SetupAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC SetupAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC TryResetMovementUrgency
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_NPC_Parent_C::NPC_TryResetMovementUrgency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC TryResetMovementUrgency");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.NPC TrySetMovementUrgency
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFortMovementUrgency                    MovementUrgency                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryResetUrgencyIfInvalid                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::NPC_TrySetMovementUrgency(EFortMovementUrgency MovementUrgency, bool TryResetUrgencyIfInvalid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "NPC TrySetMovementUrgency");

	Params::GA_NPC_Parent_C_NPC_TrySetMovementUrgency Parms{};

	Parms.MovementUrgency = MovementUrgency;
	Parms.TryResetUrgencyIfInvalid = TryResetUrgencyIfInvalid;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.Targeted_13B12ED64A3570FC1E117FAC4E3F7961
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGameplayTag                     ApplicationTag                                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::Targeted_13B12ED64A3570FC1E117FAC4E3F7961(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "Targeted_13B12ED64A3570FC1E117FAC4E3F7961");

	Params::GA_NPC_Parent_C_Targeted_13B12ED64A3570FC1E117FAC4E3F7961 Parms{};

	Parms.TargetData = std::move(TargetData);
	Parms.ApplicationTag = std::move(ApplicationTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.Targeted_4BB5000E4F2C1DAB20E4FFAAA97E1368
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGameplayTag                     ApplicationTag                                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UGA_NPC_Parent_C::Targeted_4BB5000E4F2C1DAB20E4FFAAA97E1368(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "Targeted_4BB5000E4F2C1DAB20E4FFAAA97E1368");

	Params::GA_NPC_Parent_C_Targeted_4BB5000E4F2C1DAB20E4FFAAA97E1368 Parms{};

	Parms.TargetData = std::move(TargetData);
	Parms.ApplicationTag = std::move(ApplicationTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_NPC_Parent.GA_NPC_Parent_C.K2_CanActivateAbility
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// struct FGameplayAbilitySpecHandle       Handle                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            RelevantTags                                           (Parm, OutParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_NPC_Parent_C::K2_CanActivateAbility(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpecHandle& Handle, struct FGameplayTagContainer* RelevantTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_NPC_Parent_C", "K2_CanActivateAbility");

	Params::GA_NPC_Parent_C_K2_CanActivateAbility Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.Handle = std::move(Handle);

	UObject::ProcessEvent(Func, &Parms);

	if (RelevantTags != nullptr)
		*RelevantTags = std::move(Parms.RelevantTags);

	return Parms.ReturnValue;
}

}

