#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: StateTreeModule

#include "Basic.hpp"

#include "GameplayTags_0_structs.hpp"
#include "AIModule_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum StateTreeModule.ECooldownGuardActivation
// NumValues: 0x0005
enum class ECooldownGuardActivation : uint8
{
	OnEnterState                             = 0,
	OnCompleted                              = 1,
	OnFailed                                 = 2,
	OnSucceeded                              = 3,
	ECooldownGuardActivation_MAX             = 4,
};

// Enum StateTreeModule.ESelectionGuardActivation
// NumValues: 0x0005
enum class ESelectionGuardActivation : uint8
{
	OnEnterState                             = 0,
	OnCompleted                              = 1,
	OnFailed                                 = 2,
	OnSucceeded                              = 3,
	ESelectionGuardActivation_MAX            = 4,
};

// Enum StateTreeModule.EStateTreeStorage
// NumValues: 0x0003
enum class EStateTreeStorage : uint8
{
	Internal                                 = 0,
	External                                 = 1,
	EStateTreeStorage_MAX                    = 2,
};

// Enum StateTreeModule.EStateTreeBlueprintPropertyCategory
// NumValues: 0x0006
enum class EStateTreeBlueprintPropertyCategory : uint8
{
	NotSet                                   = 0,
	Input                                    = 1,
	Parameter                                = 2,
	Output                                   = 3,
	ExternalData                             = 4,
	EStateTreeBlueprintPropertyCategory_MAX  = 5,
};

// Enum StateTreeModule.EStateTreePropertyAccessType
// NumValues: 0x0006
enum class EStateTreePropertyAccessType : uint8
{
	Offset                                   = 0,
	Object                                   = 1,
	WeakObject                               = 2,
	SoftObject                               = 3,
	IndexArray                               = 4,
	EStateTreePropertyAccessType_MAX         = 5,
};

// Enum StateTreeModule.EStateTreePropertyCopyType
// NumValues: 0x001B
enum class EStateTreePropertyCopyType : uint8
{
	None                                     = 0,
	CopyPlain                                = 1,
	CopyComplex                              = 2,
	CopyBool                                 = 3,
	CopyStruct                               = 4,
	CopyObject                               = 5,
	CopyName                                 = 6,
	CopyFixedArray                           = 7,
	PromoteBoolToByte                        = 8,
	PromoteBoolToInt32                       = 9,
	PromoteBoolToUInt32                      = 10,
	PromoteBoolToInt64                       = 11,
	PromoteBoolToFloat                       = 12,
	PromoteBoolToDouble                      = 13,
	PromoteByteToInt32                       = 14,
	PromoteByteToUInt32                      = 15,
	PromoteByteToInt64                       = 16,
	PromoteByteToFloat                       = 17,
	PromoteByteToDouble                      = 18,
	PromoteInt32ToInt64                      = 19,
	PromoteInt32ToFloat                      = 20,
	PromoteInt32ToDouble                     = 21,
	PromoteUInt32ToInt64                     = 22,
	PromoteUInt32ToFloat                     = 23,
	PromoteFloatToDouble                     = 24,
	DemoteDoubleToFloat                      = 25,
	EStateTreePropertyCopyType_MAX           = 26,
};

// Enum StateTreeModule.EStateTreeRunStatus
// NumValues: 0x0005
enum class EStateTreeRunStatus : uint8
{
	Running                                  = 0,
	Failed                                   = 1,
	Succeeded                                = 2,
	Unset                                    = 3,
	EStateTreeRunStatus_MAX                  = 4,
};

// Enum StateTreeModule.EStateTreeEvaluationType
// NumValues: 0x0003
enum class EStateTreeEvaluationType : uint8
{
	PreSelect                                = 0,
	Tick                                     = 1,
	EStateTreeEvaluationType_MAX             = 2,
};

// Enum StateTreeModule.EStateTreeStateChangeType
// NumValues: 0x0004
enum class EStateTreeStateChangeType : uint8
{
	None                                     = 0,
	Changed                                  = 1,
	Sustained                                = 2,
	EStateTreeStateChangeType_MAX            = 3,
};

// Enum StateTreeModule.EStateTreeTransitionType
// NumValues: 0x0006
enum class EStateTreeTransitionType : uint8
{
	Succeeded                                = 0,
	Failed                                   = 1,
	GotoState                                = 2,
	NotSet                                   = 3,
	NextState                                = 4,
	EStateTreeTransitionType_MAX             = 5,
};

// Enum StateTreeModule.EStateTreeTransitionEvent
// NumValues: 0x0006
enum class EStateTreeTransitionEvent : uint8
{
	None                                     = 0,
	OnCompleted                              = 3,
	OnSucceeded                              = 1,
	OnFailed                                 = 2,
	OnCondition                              = 4,
	EStateTreeTransitionEvent_MAX            = 5,
};

// Enum StateTreeModule.EStateTreeExternalDataRequirement
// NumValues: 0x0003
enum class EStateTreeExternalDataRequirement : uint8
{
	Required                                 = 0,
	Optional                                 = 1,
	EStateTreeExternalDataRequirement_MAX    = 2,
};

// Enum StateTreeModule.EStateTreePropertyIndirection
// NumValues: 0x0003
enum class EStateTreePropertyIndirection : uint8
{
	Offset                                   = 0,
	Indirect                                 = 1,
	EStateTreePropertyIndirection_MAX        = 2,
};

// Enum StateTreeModule.EStateTreePropertyUsage
// NumValues: 0x0006
enum class EStateTreePropertyUsage : uint8
{
	Invalid                                  = 0,
	Input                                    = 1,
	Parameter                                = 2,
	Output                                   = 3,
	Internal                                 = 4,
	EStateTreePropertyUsage_MAX              = 5,
};

// Enum StateTreeModule.EStateTreeLinkerStatus
// NumValues: 0x0003
enum class EStateTreeLinkerStatus : uint8
{
	Succeeded                                = 0,
	Failed                                   = 1,
	EStateTreeLinkerStatus_MAX               = 2,
};

// ScriptStruct StateTreeModule.CooldownGuardEvaluatorInstanceData
// 0x000C (0x000C - 0x0000)
struct FCooldownGuardEvaluatorInstanceData final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCooldownGuardEvaluatorInstanceData) == 0x000004, "Wrong alignment on FCooldownGuardEvaluatorInstanceData");
static_assert(sizeof(FCooldownGuardEvaluatorInstanceData) == 0x00000C, "Wrong size on FCooldownGuardEvaluatorInstanceData");
static_assert(offsetof(FCooldownGuardEvaluatorInstanceData, Duration) == 0x000000, "Member 'FCooldownGuardEvaluatorInstanceData::Duration' has a wrong offset!");
static_assert(offsetof(FCooldownGuardEvaluatorInstanceData, EndTime) == 0x000004, "Member 'FCooldownGuardEvaluatorInstanceData::EndTime' has a wrong offset!");
static_assert(offsetof(FCooldownGuardEvaluatorInstanceData, bActive) == 0x000008, "Member 'FCooldownGuardEvaluatorInstanceData::bActive' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeHandle
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeHandle final
{
public:
	uint16                                        Index;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeHandle) == 0x000002, "Wrong alignment on FStateTreeHandle");
static_assert(sizeof(FStateTreeHandle) == 0x000002, "Wrong size on FStateTreeHandle");
static_assert(offsetof(FStateTreeHandle, Index) == 0x000000, "Member 'FStateTreeHandle::Index' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEvaluatorBase
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FStateTreeEvaluatorBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeHandle                       BindingsBatch;                                     // 0x000C(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        DataViewIndex;                                     // 0x000E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        InstanceIndex;                                     // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInstanceIsObject : 1;                             // 0x0012(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeEvaluatorBase) == 0x000008, "Wrong alignment on FStateTreeEvaluatorBase");
static_assert(sizeof(FStateTreeEvaluatorBase) == 0x000018, "Wrong size on FStateTreeEvaluatorBase");
static_assert(offsetof(FStateTreeEvaluatorBase, Name) == 0x000008, "Member 'FStateTreeEvaluatorBase::Name' has a wrong offset!");
static_assert(offsetof(FStateTreeEvaluatorBase, BindingsBatch) == 0x00000C, "Member 'FStateTreeEvaluatorBase::BindingsBatch' has a wrong offset!");
static_assert(offsetof(FStateTreeEvaluatorBase, DataViewIndex) == 0x00000E, "Member 'FStateTreeEvaluatorBase::DataViewIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeEvaluatorBase, InstanceIndex) == 0x000010, "Member 'FStateTreeEvaluatorBase::InstanceIndex' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEvaluatorCommonBase
// 0x0000 (0x0018 - 0x0018)
struct FStateTreeEvaluatorCommonBase : public FStateTreeEvaluatorBase
{
};
static_assert(alignof(FStateTreeEvaluatorCommonBase) == 0x000008, "Wrong alignment on FStateTreeEvaluatorCommonBase");
static_assert(sizeof(FStateTreeEvaluatorCommonBase) == 0x000018, "Wrong size on FStateTreeEvaluatorCommonBase");

// ScriptStruct StateTreeModule.CooldownGuardEvaluator
// 0x0018 (0x0030 - 0x0018)
struct FCooldownGuardEvaluator final : public FStateTreeEvaluatorCommonBase
{
public:
	uint8                                         Pad_18[0xC];                                       // 0x0018(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomDeviation;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECooldownGuardActivation                      Activation;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCooldownGuardEvaluator) == 0x000008, "Wrong alignment on FCooldownGuardEvaluator");
static_assert(sizeof(FCooldownGuardEvaluator) == 0x000030, "Wrong size on FCooldownGuardEvaluator");
static_assert(offsetof(FCooldownGuardEvaluator, RandomDeviation) == 0x000024, "Member 'FCooldownGuardEvaluator::RandomDeviation' has a wrong offset!");
static_assert(offsetof(FCooldownGuardEvaluator, Activation) == 0x000028, "Member 'FCooldownGuardEvaluator::Activation' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagMatchConditionInstanceData
// 0x0028 (0x0028 - 0x0000)
struct FGameplayTagMatchConditionInstanceData final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0020(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagMatchConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayTagMatchConditionInstanceData");
static_assert(sizeof(FGameplayTagMatchConditionInstanceData) == 0x000028, "Wrong size on FGameplayTagMatchConditionInstanceData");
static_assert(offsetof(FGameplayTagMatchConditionInstanceData, TagContainer) == 0x000000, "Member 'FGameplayTagMatchConditionInstanceData::TagContainer' has a wrong offset!");
static_assert(offsetof(FGameplayTagMatchConditionInstanceData, Tag) == 0x000020, "Member 'FGameplayTagMatchConditionInstanceData::Tag' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeConditionBase
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FStateTreeConditionBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStateTreeHandle                       BindingsBatch;                                     // 0x0008(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        DataViewIndex;                                     // 0x000A(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        InstanceIndex;                                     // 0x000C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInstanceIsObject : 1;                             // 0x000E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeConditionBase) == 0x000008, "Wrong alignment on FStateTreeConditionBase");
static_assert(sizeof(FStateTreeConditionBase) == 0x000010, "Wrong size on FStateTreeConditionBase");
static_assert(offsetof(FStateTreeConditionBase, BindingsBatch) == 0x000008, "Member 'FStateTreeConditionBase::BindingsBatch' has a wrong offset!");
static_assert(offsetof(FStateTreeConditionBase, DataViewIndex) == 0x00000A, "Member 'FStateTreeConditionBase::DataViewIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeConditionBase, InstanceIndex) == 0x00000C, "Member 'FStateTreeConditionBase::InstanceIndex' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeConditionCommonBase
// 0x0000 (0x0010 - 0x0010)
struct FStateTreeConditionCommonBase : public FStateTreeConditionBase
{
};
static_assert(alignof(FStateTreeConditionCommonBase) == 0x000008, "Wrong alignment on FStateTreeConditionCommonBase");
static_assert(sizeof(FStateTreeConditionCommonBase) == 0x000010, "Wrong size on FStateTreeConditionCommonBase");

// ScriptStruct StateTreeModule.GameplayTagMatchCondition
// 0x0010 (0x0020 - 0x0010)
struct FGameplayTagMatchCondition final : public FStateTreeConditionCommonBase
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExactMatch;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagMatchCondition) == 0x000008, "Wrong alignment on FGameplayTagMatchCondition");
static_assert(sizeof(FGameplayTagMatchCondition) == 0x000020, "Wrong size on FGameplayTagMatchCondition");
static_assert(offsetof(FGameplayTagMatchCondition, bExactMatch) == 0x000018, "Member 'FGameplayTagMatchCondition::bExactMatch' has a wrong offset!");
static_assert(offsetof(FGameplayTagMatchCondition, bInvert) == 0x000019, "Member 'FGameplayTagMatchCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagContainerMatchConditionInstanceData
// 0x0040 (0x0040 - 0x0000)
struct FGameplayTagContainerMatchConditionInstanceData final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OtherContainer;                                    // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagContainerMatchConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayTagContainerMatchConditionInstanceData");
static_assert(sizeof(FGameplayTagContainerMatchConditionInstanceData) == 0x000040, "Wrong size on FGameplayTagContainerMatchConditionInstanceData");
static_assert(offsetof(FGameplayTagContainerMatchConditionInstanceData, TagContainer) == 0x000000, "Member 'FGameplayTagContainerMatchConditionInstanceData::TagContainer' has a wrong offset!");
static_assert(offsetof(FGameplayTagContainerMatchConditionInstanceData, OtherContainer) == 0x000020, "Member 'FGameplayTagContainerMatchConditionInstanceData::OtherContainer' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagContainerMatchCondition
// 0x0010 (0x0020 - 0x0010)
struct FGameplayTagContainerMatchCondition final : public FStateTreeConditionCommonBase
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayContainerMatchType                   MatchType;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactMatch;                                       // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagContainerMatchCondition) == 0x000008, "Wrong alignment on FGameplayTagContainerMatchCondition");
static_assert(sizeof(FGameplayTagContainerMatchCondition) == 0x000020, "Wrong size on FGameplayTagContainerMatchCondition");
static_assert(offsetof(FGameplayTagContainerMatchCondition, MatchType) == 0x000018, "Member 'FGameplayTagContainerMatchCondition::MatchType' has a wrong offset!");
static_assert(offsetof(FGameplayTagContainerMatchCondition, bExactMatch) == 0x000019, "Member 'FGameplayTagContainerMatchCondition::bExactMatch' has a wrong offset!");
static_assert(offsetof(FGameplayTagContainerMatchCondition, bInvert) == 0x00001A, "Member 'FGameplayTagContainerMatchCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagQueryConditionInstanceData
// 0x0020 (0x0020 - 0x0000)
struct FGameplayTagQueryConditionInstanceData final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagQueryConditionInstanceData) == 0x000008, "Wrong alignment on FGameplayTagQueryConditionInstanceData");
static_assert(sizeof(FGameplayTagQueryConditionInstanceData) == 0x000020, "Wrong size on FGameplayTagQueryConditionInstanceData");
static_assert(offsetof(FGameplayTagQueryConditionInstanceData, TagContainer) == 0x000000, "Member 'FGameplayTagQueryConditionInstanceData::TagContainer' has a wrong offset!");

// ScriptStruct StateTreeModule.GameplayTagQueryCondition
// 0x0058 (0x0068 - 0x0010)
struct FGameplayTagQueryCondition final : public FStateTreeConditionCommonBase
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      TagQuery;                                          // 0x0018(0x0048)(Edit, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagQueryCondition) == 0x000008, "Wrong alignment on FGameplayTagQueryCondition");
static_assert(sizeof(FGameplayTagQueryCondition) == 0x000068, "Wrong size on FGameplayTagQueryCondition");
static_assert(offsetof(FGameplayTagQueryCondition, TagQuery) == 0x000018, "Member 'FGameplayTagQueryCondition::TagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayTagQueryCondition, bInvert) == 0x000060, "Member 'FGameplayTagQueryCondition::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.SelectionGuardEvaluatorInstanceData
// 0x0001 (0x0001 - 0x0000)
struct FSelectionGuardEvaluatorInstanceData final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectionGuardEvaluatorInstanceData) == 0x000001, "Wrong alignment on FSelectionGuardEvaluatorInstanceData");
static_assert(sizeof(FSelectionGuardEvaluatorInstanceData) == 0x000001, "Wrong size on FSelectionGuardEvaluatorInstanceData");
static_assert(offsetof(FSelectionGuardEvaluatorInstanceData, bActive) == 0x000000, "Member 'FSelectionGuardEvaluatorInstanceData::bActive' has a wrong offset!");

// ScriptStruct StateTreeModule.SelectionGuardEvaluator
// 0x0008 (0x0020 - 0x0018)
struct FSelectionGuardEvaluator final : public FStateTreeEvaluatorCommonBase
{
public:
	uint8                                         Pad_18[0x4];                                       // 0x0018(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ESelectionGuardActivation                     Activation;                                        // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSelectionGuardEvaluator) == 0x000008, "Wrong alignment on FSelectionGuardEvaluator");
static_assert(sizeof(FSelectionGuardEvaluator) == 0x000020, "Wrong size on FSelectionGuardEvaluator");
static_assert(offsetof(FSelectionGuardEvaluator, Activation) == 0x00001C, "Member 'FSelectionGuardEvaluator::Activation' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeAnyEnum
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeAnyEnum final
{
public:
	uint32                                        Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  Enum;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeAnyEnum) == 0x000008, "Wrong alignment on FStateTreeAnyEnum");
static_assert(sizeof(FStateTreeAnyEnum) == 0x000010, "Wrong size on FStateTreeAnyEnum");
static_assert(offsetof(FStateTreeAnyEnum, Value) == 0x000000, "Member 'FStateTreeAnyEnum::Value' has a wrong offset!");
static_assert(offsetof(FStateTreeAnyEnum, Enum) == 0x000008, "Member 'FStateTreeAnyEnum::Enum' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBlueprintConditionWrapper
// 0x0018 (0x0028 - 0x0010)
struct FStateTreeBlueprintConditionWrapper final : public FStateTreeConditionBase
{
public:
	TSubclassOf<class UStateTreeConditionBlueprintBase> ConditionClass;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeBlueprintConditionWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintConditionWrapper");
static_assert(sizeof(FStateTreeBlueprintConditionWrapper) == 0x000028, "Wrong size on FStateTreeBlueprintConditionWrapper");
static_assert(offsetof(FStateTreeBlueprintConditionWrapper, ConditionClass) == 0x000010, "Member 'FStateTreeBlueprintConditionWrapper::ConditionClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareIntInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeCondition_CompareIntInstanceData final
{
public:
	int32                                         Left;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Right;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCondition_CompareIntInstanceData) == 0x000004, "Wrong alignment on FStateTreeCondition_CompareIntInstanceData");
static_assert(sizeof(FStateTreeCondition_CompareIntInstanceData) == 0x000008, "Wrong size on FStateTreeCondition_CompareIntInstanceData");
static_assert(offsetof(FStateTreeCondition_CompareIntInstanceData, Left) == 0x000000, "Member 'FStateTreeCondition_CompareIntInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeCondition_CompareIntInstanceData, Right) == 0x000004, "Member 'FStateTreeCondition_CompareIntInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareInt
// 0x0010 (0x0020 - 0x0010)
struct FStateTreeCondition_CompareInt final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Operator;                                          // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCondition_CompareInt) == 0x000008, "Wrong alignment on FStateTreeCondition_CompareInt");
static_assert(sizeof(FStateTreeCondition_CompareInt) == 0x000020, "Wrong size on FStateTreeCondition_CompareInt");
static_assert(offsetof(FStateTreeCondition_CompareInt, bInvert) == 0x000010, "Member 'FStateTreeCondition_CompareInt::bInvert' has a wrong offset!");
static_assert(offsetof(FStateTreeCondition_CompareInt, Operator) == 0x000011, "Member 'FStateTreeCondition_CompareInt::Operator' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareFloatInstanceData
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeCondition_CompareFloatInstanceData final
{
public:
	float                                         Left;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Right;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCondition_CompareFloatInstanceData) == 0x000004, "Wrong alignment on FStateTreeCondition_CompareFloatInstanceData");
static_assert(sizeof(FStateTreeCondition_CompareFloatInstanceData) == 0x000008, "Wrong size on FStateTreeCondition_CompareFloatInstanceData");
static_assert(offsetof(FStateTreeCondition_CompareFloatInstanceData, Left) == 0x000000, "Member 'FStateTreeCondition_CompareFloatInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeCondition_CompareFloatInstanceData, Right) == 0x000004, "Member 'FStateTreeCondition_CompareFloatInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareFloat
// 0x0010 (0x0020 - 0x0010)
struct FStateTreeCondition_CompareFloat final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Operator;                                          // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCondition_CompareFloat) == 0x000008, "Wrong alignment on FStateTreeCondition_CompareFloat");
static_assert(sizeof(FStateTreeCondition_CompareFloat) == 0x000020, "Wrong size on FStateTreeCondition_CompareFloat");
static_assert(offsetof(FStateTreeCondition_CompareFloat, bInvert) == 0x000010, "Member 'FStateTreeCondition_CompareFloat::bInvert' has a wrong offset!");
static_assert(offsetof(FStateTreeCondition_CompareFloat, Operator) == 0x000011, "Member 'FStateTreeCondition_CompareFloat::Operator' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareBoolInstanceData
// 0x0002 (0x0002 - 0x0000)
struct FStateTreeCondition_CompareBoolInstanceData final
{
public:
	bool                                          bLeft;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRight;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCondition_CompareBoolInstanceData) == 0x000001, "Wrong alignment on FStateTreeCondition_CompareBoolInstanceData");
static_assert(sizeof(FStateTreeCondition_CompareBoolInstanceData) == 0x000002, "Wrong size on FStateTreeCondition_CompareBoolInstanceData");
static_assert(offsetof(FStateTreeCondition_CompareBoolInstanceData, bLeft) == 0x000000, "Member 'FStateTreeCondition_CompareBoolInstanceData::bLeft' has a wrong offset!");
static_assert(offsetof(FStateTreeCondition_CompareBoolInstanceData, bRight) == 0x000001, "Member 'FStateTreeCondition_CompareBoolInstanceData::bRight' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareBool
// 0x0010 (0x0020 - 0x0010)
struct FStateTreeCondition_CompareBool final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCondition_CompareBool) == 0x000008, "Wrong alignment on FStateTreeCondition_CompareBool");
static_assert(sizeof(FStateTreeCondition_CompareBool) == 0x000020, "Wrong size on FStateTreeCondition_CompareBool");
static_assert(offsetof(FStateTreeCondition_CompareBool, bInvert) == 0x000010, "Member 'FStateTreeCondition_CompareBool::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareEnumInstanceData
// 0x0020 (0x0020 - 0x0000)
struct FStateTreeCondition_CompareEnumInstanceData final
{
public:
	struct FStateTreeAnyEnum                      Left;                                              // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeAnyEnum                      Right;                                             // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCondition_CompareEnumInstanceData) == 0x000008, "Wrong alignment on FStateTreeCondition_CompareEnumInstanceData");
static_assert(sizeof(FStateTreeCondition_CompareEnumInstanceData) == 0x000020, "Wrong size on FStateTreeCondition_CompareEnumInstanceData");
static_assert(offsetof(FStateTreeCondition_CompareEnumInstanceData, Left) == 0x000000, "Member 'FStateTreeCondition_CompareEnumInstanceData::Left' has a wrong offset!");
static_assert(offsetof(FStateTreeCondition_CompareEnumInstanceData, Right) == 0x000010, "Member 'FStateTreeCondition_CompareEnumInstanceData::Right' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareEnum
// 0x0010 (0x0020 - 0x0010)
struct FStateTreeCondition_CompareEnum final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCondition_CompareEnum) == 0x000008, "Wrong alignment on FStateTreeCondition_CompareEnum");
static_assert(sizeof(FStateTreeCondition_CompareEnum) == 0x000020, "Wrong size on FStateTreeCondition_CompareEnum");
static_assert(offsetof(FStateTreeCondition_CompareEnum, bInvert) == 0x000010, "Member 'FStateTreeCondition_CompareEnum::bInvert' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareDistanceInstanceData
// 0x0038 (0x0038 - 0x0000)
struct FStateTreeCondition_CompareDistanceInstanceData final
{
public:
	struct FVector                                Source;                                            // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCondition_CompareDistanceInstanceData) == 0x000008, "Wrong alignment on FStateTreeCondition_CompareDistanceInstanceData");
static_assert(sizeof(FStateTreeCondition_CompareDistanceInstanceData) == 0x000038, "Wrong size on FStateTreeCondition_CompareDistanceInstanceData");
static_assert(offsetof(FStateTreeCondition_CompareDistanceInstanceData, Source) == 0x000000, "Member 'FStateTreeCondition_CompareDistanceInstanceData::Source' has a wrong offset!");
static_assert(offsetof(FStateTreeCondition_CompareDistanceInstanceData, Target) == 0x000018, "Member 'FStateTreeCondition_CompareDistanceInstanceData::Target' has a wrong offset!");
static_assert(offsetof(FStateTreeCondition_CompareDistanceInstanceData, Distance) == 0x000030, "Member 'FStateTreeCondition_CompareDistanceInstanceData::Distance' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_CompareDistance
// 0x0010 (0x0020 - 0x0010)
struct FStateTreeCondition_CompareDistance final : public FStateTreeConditionCommonBase
{
public:
	bool                                          bInvert;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Operator;                                          // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCondition_CompareDistance) == 0x000008, "Wrong alignment on FStateTreeCondition_CompareDistance");
static_assert(sizeof(FStateTreeCondition_CompareDistance) == 0x000020, "Wrong size on FStateTreeCondition_CompareDistance");
static_assert(offsetof(FStateTreeCondition_CompareDistance, bInvert) == 0x000010, "Member 'FStateTreeCondition_CompareDistance::bInvert' has a wrong offset!");
static_assert(offsetof(FStateTreeCondition_CompareDistance, Operator) == 0x000011, "Member 'FStateTreeCondition_CompareDistance::Operator' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_RandomInstanceData
// 0x0004 (0x0004 - 0x0000)
struct FStateTreeCondition_RandomInstanceData final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeCondition_RandomInstanceData) == 0x000004, "Wrong alignment on FStateTreeCondition_RandomInstanceData");
static_assert(sizeof(FStateTreeCondition_RandomInstanceData) == 0x000004, "Wrong size on FStateTreeCondition_RandomInstanceData");
static_assert(offsetof(FStateTreeCondition_RandomInstanceData, Threshold) == 0x000000, "Member 'FStateTreeCondition_RandomInstanceData::Threshold' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeCondition_Random
// 0x0008 (0x0018 - 0x0010)
struct FStateTreeCondition_Random final : public FStateTreeConditionBase
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeCondition_Random) == 0x000008, "Wrong alignment on FStateTreeCondition_Random");
static_assert(sizeof(FStateTreeCondition_Random) == 0x000018, "Wrong size on FStateTreeCondition_Random");

// ScriptStruct StateTreeModule.StateTreeBlueprintEvaluatorWrapper
// 0x0018 (0x0030 - 0x0018)
struct FStateTreeBlueprintEvaluatorWrapper final : public FStateTreeEvaluatorBase
{
public:
	TSubclassOf<class UStateTreeEvaluatorBlueprintBase> EvaluatorClass;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeBlueprintEvaluatorWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintEvaluatorWrapper");
static_assert(sizeof(FStateTreeBlueprintEvaluatorWrapper) == 0x000030, "Wrong size on FStateTreeBlueprintEvaluatorWrapper");
static_assert(offsetof(FStateTreeBlueprintEvaluatorWrapper, EvaluatorClass) == 0x000018, "Member 'FStateTreeBlueprintEvaluatorWrapper::EvaluatorClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeExecutionState
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FStateTreeExecutionState final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeExecutionState) == 0x000008, "Wrong alignment on FStateTreeExecutionState");
static_assert(sizeof(FStateTreeExecutionState) == 0x000020, "Wrong size on FStateTreeExecutionState");

// ScriptStruct StateTreeModule.StateTreeExecutionContext
// 0x0050 (0x0050 - 0x0000)
struct FStateTreeExecutionContext final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStateTree*                             StateTree;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                Owner;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18[0x38];                                      // 0x0018(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeExecutionContext) == 0x000008, "Wrong alignment on FStateTreeExecutionContext");
static_assert(sizeof(FStateTreeExecutionContext) == 0x000050, "Wrong size on FStateTreeExecutionContext");
static_assert(offsetof(FStateTreeExecutionContext, StateTree) == 0x000008, "Member 'FStateTreeExecutionContext::StateTree' has a wrong offset!");
static_assert(offsetof(FStateTreeExecutionContext, Owner) == 0x000010, "Member 'FStateTreeExecutionContext::Owner' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBlueprintPropertyInfo
// 0x0008 (0x0008 - 0x0000)
struct FStateTreeBlueprintPropertyInfo final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeBlueprintPropertyCategory           category;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeBlueprintPropertyInfo) == 0x000004, "Wrong alignment on FStateTreeBlueprintPropertyInfo");
static_assert(sizeof(FStateTreeBlueprintPropertyInfo) == 0x000008, "Wrong size on FStateTreeBlueprintPropertyInfo");
static_assert(offsetof(FStateTreeBlueprintPropertyInfo, PropertyName) == 0x000000, "Member 'FStateTreeBlueprintPropertyInfo::PropertyName' has a wrong offset!");
static_assert(offsetof(FStateTreeBlueprintPropertyInfo, category) == 0x000004, "Member 'FStateTreeBlueprintPropertyInfo::category' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBindableStructDesc
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeBindableStructDesc final
{
public:
	class UStruct*                                Struct;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeBindableStructDesc) == 0x000008, "Wrong alignment on FStateTreeBindableStructDesc");
static_assert(sizeof(FStateTreeBindableStructDesc) == 0x000010, "Wrong size on FStateTreeBindableStructDesc");
static_assert(offsetof(FStateTreeBindableStructDesc, Struct) == 0x000000, "Member 'FStateTreeBindableStructDesc::Struct' has a wrong offset!");
static_assert(offsetof(FStateTreeBindableStructDesc, Name) == 0x000008, "Member 'FStateTreeBindableStructDesc::Name' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertySegment
// 0x000C (0x000C - 0x0000)
struct FStateTreePropertySegment final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArrayIndex;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreePropertyAccessType                  Type;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertySegment) == 0x000004, "Wrong alignment on FStateTreePropertySegment");
static_assert(sizeof(FStateTreePropertySegment) == 0x00000C, "Wrong size on FStateTreePropertySegment");
static_assert(offsetof(FStateTreePropertySegment, Name) == 0x000000, "Member 'FStateTreePropertySegment::Name' has a wrong offset!");
static_assert(offsetof(FStateTreePropertySegment, ArrayIndex) == 0x000004, "Member 'FStateTreePropertySegment::ArrayIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertySegment, Type) == 0x000008, "Member 'FStateTreePropertySegment::Type' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyPath
// 0x0008 (0x0008 - 0x0000)
struct FStateTreePropertyPath final
{
public:
	int32                                         SegmentsBegin;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SegmentsEnd;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreePropertyPath) == 0x000004, "Wrong alignment on FStateTreePropertyPath");
static_assert(sizeof(FStateTreePropertyPath) == 0x000008, "Wrong size on FStateTreePropertyPath");
static_assert(offsetof(FStateTreePropertyPath, SegmentsBegin) == 0x000000, "Member 'FStateTreePropertyPath::SegmentsBegin' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyPath, SegmentsEnd) == 0x000004, "Member 'FStateTreePropertyPath::SegmentsEnd' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyBinding
// 0x0010 (0x0010 - 0x0000)
struct FStateTreePropertyBinding final
{
public:
	int32                                         SourcePathIndex;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetPathIndex;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceStructIndex;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreePropertyCopyType                    CopyType;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyBinding) == 0x000004, "Wrong alignment on FStateTreePropertyBinding");
static_assert(sizeof(FStateTreePropertyBinding) == 0x000010, "Wrong size on FStateTreePropertyBinding");
static_assert(offsetof(FStateTreePropertyBinding, SourcePathIndex) == 0x000000, "Member 'FStateTreePropertyBinding::SourcePathIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBinding, TargetPathIndex) == 0x000004, "Member 'FStateTreePropertyBinding::TargetPathIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBinding, SourceStructIndex) == 0x000008, "Member 'FStateTreePropertyBinding::SourceStructIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBinding, CopyType) == 0x00000C, "Member 'FStateTreePropertyBinding::CopyType' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyIndirection
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FStateTreePropertyIndirection final
{
public:
	int32                                         ArrayIndex;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Offset;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreePropertyAccessType                  Type;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0xF];                                        // 0x0009(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyIndirection) == 0x000008, "Wrong alignment on FStateTreePropertyIndirection");
static_assert(sizeof(FStateTreePropertyIndirection) == 0x000018, "Wrong size on FStateTreePropertyIndirection");
static_assert(offsetof(FStateTreePropertyIndirection, ArrayIndex) == 0x000000, "Member 'FStateTreePropertyIndirection::ArrayIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, Offset) == 0x000004, "Member 'FStateTreePropertyIndirection::Offset' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyIndirection, Type) == 0x000008, "Member 'FStateTreePropertyIndirection::Type' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyAccess
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FStateTreePropertyAccess final
{
public:
	int32                                         IndirectionsBegin;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndirectionsEnd;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyAccess) == 0x000008, "Wrong alignment on FStateTreePropertyAccess");
static_assert(sizeof(FStateTreePropertyAccess) == 0x000010, "Wrong size on FStateTreePropertyAccess");
static_assert(offsetof(FStateTreePropertyAccess, IndirectionsBegin) == 0x000000, "Member 'FStateTreePropertyAccess::IndirectionsBegin' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyAccess, IndirectionsEnd) == 0x000004, "Member 'FStateTreePropertyAccess::IndirectionsEnd' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropCopy
// 0x0014 (0x0014 - 0x0000)
struct FStateTreePropCopy final
{
public:
	int32                                         SourceAccessIndex;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetAccessIndex;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceStructIndex;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreePropertyCopyType                    Type;                                              // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CopySize;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreePropCopy) == 0x000004, "Wrong alignment on FStateTreePropCopy");
static_assert(sizeof(FStateTreePropCopy) == 0x000014, "Wrong size on FStateTreePropCopy");
static_assert(offsetof(FStateTreePropCopy, SourceAccessIndex) == 0x000000, "Member 'FStateTreePropCopy::SourceAccessIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropCopy, TargetAccessIndex) == 0x000004, "Member 'FStateTreePropCopy::TargetAccessIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropCopy, SourceStructIndex) == 0x000008, "Member 'FStateTreePropCopy::SourceStructIndex' has a wrong offset!");
static_assert(offsetof(FStateTreePropCopy, Type) == 0x00000C, "Member 'FStateTreePropCopy::Type' has a wrong offset!");
static_assert(offsetof(FStateTreePropCopy, CopySize) == 0x000010, "Member 'FStateTreePropCopy::CopySize' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropCopyBatch
// 0x0018 (0x0018 - 0x0000)
struct FStateTreePropCopyBatch final
{
public:
	struct FStateTreeBindableStructDesc           TargetStruct;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BindingsBegin;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BindingsEnd;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreePropCopyBatch) == 0x000008, "Wrong alignment on FStateTreePropCopyBatch");
static_assert(sizeof(FStateTreePropCopyBatch) == 0x000018, "Wrong size on FStateTreePropCopyBatch");
static_assert(offsetof(FStateTreePropCopyBatch, TargetStruct) == 0x000000, "Member 'FStateTreePropCopyBatch::TargetStruct' has a wrong offset!");
static_assert(offsetof(FStateTreePropCopyBatch, BindingsBegin) == 0x000010, "Member 'FStateTreePropCopyBatch::BindingsBegin' has a wrong offset!");
static_assert(offsetof(FStateTreePropCopyBatch, BindingsEnd) == 0x000014, "Member 'FStateTreePropCopyBatch::BindingsEnd' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreePropertyBindings
// 0x0088 (0x0088 - 0x0000)
struct FStateTreePropertyBindings final
{
public:
	TArray<struct FStateTreeBindableStructDesc>   SourceStructs;                                     // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStateTreePropCopyBatch>        CopyBatches;                                       // 0x0010(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStateTreePropertyBinding>      PropertyBindings;                                  // 0x0020(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStateTreePropertyPath>         PropertyPaths;                                     // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStateTreePropertySegment>      PropertySegments;                                  // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStateTreePropCopy>             PropertyCopies;                                    // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStateTreePropertyAccess>       PropertyAccesses;                                  // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStateTreePropertyIndirection>  PropertyIndirections;                              // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreePropertyBindings) == 0x000008, "Wrong alignment on FStateTreePropertyBindings");
static_assert(sizeof(FStateTreePropertyBindings) == 0x000088, "Wrong size on FStateTreePropertyBindings");
static_assert(offsetof(FStateTreePropertyBindings, SourceStructs) == 0x000000, "Member 'FStateTreePropertyBindings::SourceStructs' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, CopyBatches) == 0x000010, "Member 'FStateTreePropertyBindings::CopyBatches' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyBindings) == 0x000020, "Member 'FStateTreePropertyBindings::PropertyBindings' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyPaths) == 0x000030, "Member 'FStateTreePropertyBindings::PropertyPaths' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertySegments) == 0x000040, "Member 'FStateTreePropertyBindings::PropertySegments' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyCopies) == 0x000050, "Member 'FStateTreePropertyBindings::PropertyCopies' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyAccesses) == 0x000060, "Member 'FStateTreePropertyBindings::PropertyAccesses' has a wrong offset!");
static_assert(offsetof(FStateTreePropertyBindings, PropertyIndirections) == 0x000070, "Member 'FStateTreePropertyBindings::PropertyIndirections' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeEditorPropertyPath
// 0x0020 (0x0020 - 0x0000)
struct FStateTreeEditorPropertyPath final
{
public:
	struct FGuid                                  StructID;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Path;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeEditorPropertyPath) == 0x000008, "Wrong alignment on FStateTreeEditorPropertyPath");
static_assert(sizeof(FStateTreeEditorPropertyPath) == 0x000020, "Wrong size on FStateTreeEditorPropertyPath");
static_assert(offsetof(FStateTreeEditorPropertyPath, StructID) == 0x000000, "Member 'FStateTreeEditorPropertyPath::StructID' has a wrong offset!");
static_assert(offsetof(FStateTreeEditorPropertyPath, Path) == 0x000010, "Member 'FStateTreeEditorPropertyPath::Path' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTaskBase
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FStateTreeTaskBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeHandle                       BindingsBatch;                                     // 0x000C(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        DataViewIndex;                                     // 0x000E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        InstanceIndex;                                     // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInstanceIsObject : 1;                             // 0x0012(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeTaskBase) == 0x000008, "Wrong alignment on FStateTreeTaskBase");
static_assert(sizeof(FStateTreeTaskBase) == 0x000018, "Wrong size on FStateTreeTaskBase");
static_assert(offsetof(FStateTreeTaskBase, Name) == 0x000008, "Member 'FStateTreeTaskBase::Name' has a wrong offset!");
static_assert(offsetof(FStateTreeTaskBase, BindingsBatch) == 0x00000C, "Member 'FStateTreeTaskBase::BindingsBatch' has a wrong offset!");
static_assert(offsetof(FStateTreeTaskBase, DataViewIndex) == 0x00000E, "Member 'FStateTreeTaskBase::DataViewIndex' has a wrong offset!");
static_assert(offsetof(FStateTreeTaskBase, InstanceIndex) == 0x000010, "Member 'FStateTreeTaskBase::InstanceIndex' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeBlueprintTaskWrapper
// 0x0018 (0x0030 - 0x0018)
struct FStateTreeBlueprintTaskWrapper final : public FStateTreeTaskBase
{
public:
	TSubclassOf<class UStateTreeTaskBlueprintBase> TaskClass;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeBlueprintTaskWrapper) == 0x000008, "Wrong alignment on FStateTreeBlueprintTaskWrapper");
static_assert(sizeof(FStateTreeBlueprintTaskWrapper) == 0x000030, "Wrong size on FStateTreeBlueprintTaskWrapper");
static_assert(offsetof(FStateTreeBlueprintTaskWrapper, TaskClass) == 0x000018, "Member 'FStateTreeBlueprintTaskWrapper::TaskClass' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeStateStatus
// 0x0004 (0x0004 - 0x0000)
struct FStateTreeStateStatus final
{
public:
	struct FStateTreeHandle                       State;                                             // 0x0000(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeRunStatus                           RunStatus;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeStateStatus) == 0x000002, "Wrong alignment on FStateTreeStateStatus");
static_assert(sizeof(FStateTreeStateStatus) == 0x000004, "Wrong size on FStateTreeStateStatus");
static_assert(offsetof(FStateTreeStateStatus, State) == 0x000000, "Member 'FStateTreeStateStatus::State' has a wrong offset!");
static_assert(offsetof(FStateTreeStateStatus, RunStatus) == 0x000002, "Member 'FStateTreeStateStatus::RunStatus' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeTransitionResult
// 0x000A (0x000A - 0x0000)
struct FStateTreeTransitionResult final
{
public:
	struct FStateTreeStateStatus                  Source;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeHandle                       Target;                                            // 0x0004(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeHandle                       Next;                                              // 0x0006(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeHandle                       Current;                                           // 0x0008(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateTreeTransitionResult) == 0x000002, "Wrong alignment on FStateTreeTransitionResult");
static_assert(sizeof(FStateTreeTransitionResult) == 0x00000A, "Wrong size on FStateTreeTransitionResult");
static_assert(offsetof(FStateTreeTransitionResult, Source) == 0x000000, "Member 'FStateTreeTransitionResult::Source' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, Target) == 0x000004, "Member 'FStateTreeTransitionResult::Target' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, Next) == 0x000006, "Member 'FStateTreeTransitionResult::Next' has a wrong offset!");
static_assert(offsetof(FStateTreeTransitionResult, Current) == 0x000008, "Member 'FStateTreeTransitionResult::Current' has a wrong offset!");

// ScriptStruct StateTreeModule.BakedStateTransition
// 0x0008 (0x0008 - 0x0000)
struct FBakedStateTransition final
{
public:
	uint16                                        ConditionsBegin;                                   // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeHandle                       State;                                             // 0x0002(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeTransitionType                      Type;                                              // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeTransitionEvent                     event;                                             // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         GateDelay;                                         // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionsNum;                                     // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBakedStateTransition) == 0x000002, "Wrong alignment on FBakedStateTransition");
static_assert(sizeof(FBakedStateTransition) == 0x000008, "Wrong size on FBakedStateTransition");
static_assert(offsetof(FBakedStateTransition, ConditionsBegin) == 0x000000, "Member 'FBakedStateTransition::ConditionsBegin' has a wrong offset!");
static_assert(offsetof(FBakedStateTransition, State) == 0x000002, "Member 'FBakedStateTransition::State' has a wrong offset!");
static_assert(offsetof(FBakedStateTransition, Type) == 0x000004, "Member 'FBakedStateTransition::Type' has a wrong offset!");
static_assert(offsetof(FBakedStateTransition, event) == 0x000005, "Member 'FBakedStateTransition::event' has a wrong offset!");
static_assert(offsetof(FBakedStateTransition, GateDelay) == 0x000006, "Member 'FBakedStateTransition::GateDelay' has a wrong offset!");
static_assert(offsetof(FBakedStateTransition, ConditionsNum) == 0x000007, "Member 'FBakedStateTransition::ConditionsNum' has a wrong offset!");

// ScriptStruct StateTreeModule.BakedStateTreeState
// 0x001C (0x001C - 0x0000)
struct FBakedStateTreeState final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeHandle                       Parent;                                            // 0x0004(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        ChildrenBegin;                                     // 0x0006(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ChildrenEnd;                                       // 0x0008(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeHandle                       StateDoneTransitionState;                          // 0x000A(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	struct FStateTreeHandle                       StateFailedTransitionState;                        // 0x000C(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        EnterConditionsBegin;                              // 0x000E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TransitionsBegin;                                  // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TasksBegin;                                        // 0x0012(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        EvaluatorsBegin;                                   // 0x0014(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnterConditionsNum;                                // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TransitionsNum;                                    // 0x0017(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TasksNum;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EvaluatorsNum;                                     // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeTransitionType                      StateDoneTransitionType;                           // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStateTreeTransitionType                      StateFailedTransitionType;                         // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBakedStateTreeState) == 0x000004, "Wrong alignment on FBakedStateTreeState");
static_assert(sizeof(FBakedStateTreeState) == 0x00001C, "Wrong size on FBakedStateTreeState");
static_assert(offsetof(FBakedStateTreeState, Name) == 0x000000, "Member 'FBakedStateTreeState::Name' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, Parent) == 0x000004, "Member 'FBakedStateTreeState::Parent' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, ChildrenBegin) == 0x000006, "Member 'FBakedStateTreeState::ChildrenBegin' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, ChildrenEnd) == 0x000008, "Member 'FBakedStateTreeState::ChildrenEnd' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, StateDoneTransitionState) == 0x00000A, "Member 'FBakedStateTreeState::StateDoneTransitionState' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, StateFailedTransitionState) == 0x00000C, "Member 'FBakedStateTreeState::StateFailedTransitionState' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, EnterConditionsBegin) == 0x00000E, "Member 'FBakedStateTreeState::EnterConditionsBegin' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, TransitionsBegin) == 0x000010, "Member 'FBakedStateTreeState::TransitionsBegin' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, TasksBegin) == 0x000012, "Member 'FBakedStateTreeState::TasksBegin' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, EvaluatorsBegin) == 0x000014, "Member 'FBakedStateTreeState::EvaluatorsBegin' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, EnterConditionsNum) == 0x000016, "Member 'FBakedStateTreeState::EnterConditionsNum' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, TransitionsNum) == 0x000017, "Member 'FBakedStateTreeState::TransitionsNum' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, TasksNum) == 0x000018, "Member 'FBakedStateTreeState::TasksNum' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, EvaluatorsNum) == 0x000019, "Member 'FBakedStateTreeState::EvaluatorsNum' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, StateDoneTransitionType) == 0x00001A, "Member 'FBakedStateTreeState::StateDoneTransitionType' has a wrong offset!");
static_assert(offsetof(FBakedStateTreeState, StateFailedTransitionType) == 0x00001B, "Member 'FBakedStateTreeState::StateFailedTransitionType' has a wrong offset!");

// ScriptStruct StateTreeModule.StateTreeExternalDataHandle
// 0x0001 (0x0001 - 0x0000)
struct FStateTreeExternalDataHandle final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeExternalDataHandle) == 0x000001, "Wrong alignment on FStateTreeExternalDataHandle");
static_assert(sizeof(FStateTreeExternalDataHandle) == 0x000001, "Wrong size on FStateTreeExternalDataHandle");

// ScriptStruct StateTreeModule.StateTreeInstanceDataPropertyHandle
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x02) FStateTreeInstanceDataPropertyHandle final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeInstanceDataPropertyHandle) == 0x000002, "Wrong alignment on FStateTreeInstanceDataPropertyHandle");
static_assert(sizeof(FStateTreeInstanceDataPropertyHandle) == 0x000004, "Wrong size on FStateTreeInstanceDataPropertyHandle");

// ScriptStruct StateTreeModule.StateTreeExternalDataDesc
// 0x0010 (0x0010 - 0x0000)
struct FStateTreeExternalDataDesc final
{
public:
	class UStruct*                                Struct;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStateTreeExternalDataHandle           Handle;                                            // 0x0008(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	EStateTreeExternalDataRequirement             Requirement;                                       // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateTreeExternalDataDesc) == 0x000008, "Wrong alignment on FStateTreeExternalDataDesc");
static_assert(sizeof(FStateTreeExternalDataDesc) == 0x000010, "Wrong size on FStateTreeExternalDataDesc");
static_assert(offsetof(FStateTreeExternalDataDesc, Struct) == 0x000000, "Member 'FStateTreeExternalDataDesc::Struct' has a wrong offset!");
static_assert(offsetof(FStateTreeExternalDataDesc, Handle) == 0x000008, "Member 'FStateTreeExternalDataDesc::Handle' has a wrong offset!");
static_assert(offsetof(FStateTreeExternalDataDesc, Requirement) == 0x000009, "Member 'FStateTreeExternalDataDesc::Requirement' has a wrong offset!");

}

