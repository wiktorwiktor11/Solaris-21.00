#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: StateTreeModule

#include "Basic.hpp"

#include "StructUtils_structs.hpp"
#include "StateTreeModule_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_classes.hpp"


namespace SDK
{

// Class StateTreeModule.StateTreeItemBlueprintBase
// 0x0010 (0x0038 - 0x0028)
class UStateTreeItemBlueprintBase : public UObject
{
public:
	TArray<struct FStateTreeBlueprintPropertyInfo> PropertyInfos;                                     // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTreeItemBlueprintBase">();
	}
	static class UStateTreeItemBlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTreeItemBlueprintBase>();
	}
};
static_assert(alignof(UStateTreeItemBlueprintBase) == 0x000008, "Wrong alignment on UStateTreeItemBlueprintBase");
static_assert(sizeof(UStateTreeItemBlueprintBase) == 0x000038, "Wrong size on UStateTreeItemBlueprintBase");
static_assert(offsetof(UStateTreeItemBlueprintBase, PropertyInfos) == 0x000028, "Member 'UStateTreeItemBlueprintBase::PropertyInfos' has a wrong offset!");

// Class StateTreeModule.StateTreeTaskBlueprintBase
// 0x0000 (0x0038 - 0x0038)
class UStateTreeTaskBlueprintBase : public UStateTreeItemBlueprintBase
{
public:
	EStateTreeRunStatus ReceiveEnterState(class AActor* OwnerActor, const EStateTreeStateChangeType ChangeType, const struct FStateTreeTransitionResult& TRANSITION);
	void ReceiveExitState(class AActor* OwnerActor, const EStateTreeStateChangeType ChangeType, const struct FStateTreeTransitionResult& TRANSITION);
	void ReceiveStateCompleted(class AActor* OwnerActor, const EStateTreeRunStatus CompletionStatus, const struct FStateTreeHandle& CompletedState);
	EStateTreeRunStatus ReceiveTick(class AActor* OwnerActor, const float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTreeTaskBlueprintBase">();
	}
	static class UStateTreeTaskBlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTreeTaskBlueprintBase>();
	}
};
static_assert(alignof(UStateTreeTaskBlueprintBase) == 0x000008, "Wrong alignment on UStateTreeTaskBlueprintBase");
static_assert(sizeof(UStateTreeTaskBlueprintBase) == 0x000038, "Wrong size on UStateTreeTaskBlueprintBase");

// Class StateTreeModule.StateTree
// 0x0120 (0x0150 - 0x0030)
class UStateTree final : public UDataAsset
{
public:
	class UStateTreeSchema*                       Schema;                                            // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FInstancedStruct>               Items;                                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FInstancedStruct>               Instances;                                         // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        InstanceObjects;                                   // 0x0058(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UScriptStruct*                          InstanceStorageStruct;                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInstancedStruct                       InstanceStorageDefaultValue;                       // 0x0080(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FStateTreeExternalDataDesc>     ExternalDataDescs;                                 // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         NumDataViews;                                      // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ExternalDataBaseIndex;                             // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStateTreePropertyBindings             PropertyBindings;                                  // 0x00A8(0x0088)(NativeAccessSpecifierPrivate)
	TArray<struct FBakedStateTreeState>           States;                                            // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FBakedStateTransition>          Transitions;                                       // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTree">();
	}
	static class UStateTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTree>();
	}
};
static_assert(alignof(UStateTree) == 0x000008, "Wrong alignment on UStateTree");
static_assert(sizeof(UStateTree) == 0x000150, "Wrong size on UStateTree");
static_assert(offsetof(UStateTree, Schema) == 0x000030, "Member 'UStateTree::Schema' has a wrong offset!");
static_assert(offsetof(UStateTree, Items) == 0x000038, "Member 'UStateTree::Items' has a wrong offset!");
static_assert(offsetof(UStateTree, Instances) == 0x000048, "Member 'UStateTree::Instances' has a wrong offset!");
static_assert(offsetof(UStateTree, InstanceObjects) == 0x000058, "Member 'UStateTree::InstanceObjects' has a wrong offset!");
static_assert(offsetof(UStateTree, InstanceStorageStruct) == 0x000068, "Member 'UStateTree::InstanceStorageStruct' has a wrong offset!");
static_assert(offsetof(UStateTree, InstanceStorageDefaultValue) == 0x000080, "Member 'UStateTree::InstanceStorageDefaultValue' has a wrong offset!");
static_assert(offsetof(UStateTree, ExternalDataDescs) == 0x000090, "Member 'UStateTree::ExternalDataDescs' has a wrong offset!");
static_assert(offsetof(UStateTree, NumDataViews) == 0x0000A0, "Member 'UStateTree::NumDataViews' has a wrong offset!");
static_assert(offsetof(UStateTree, ExternalDataBaseIndex) == 0x0000A4, "Member 'UStateTree::ExternalDataBaseIndex' has a wrong offset!");
static_assert(offsetof(UStateTree, PropertyBindings) == 0x0000A8, "Member 'UStateTree::PropertyBindings' has a wrong offset!");
static_assert(offsetof(UStateTree, States) == 0x000130, "Member 'UStateTree::States' has a wrong offset!");
static_assert(offsetof(UStateTree, Transitions) == 0x000140, "Member 'UStateTree::Transitions' has a wrong offset!");

// Class StateTreeModule.StateTreeSchema
// 0x0000 (0x0028 - 0x0028)
class UStateTreeSchema : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTreeSchema">();
	}
	static class UStateTreeSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTreeSchema>();
	}
};
static_assert(alignof(UStateTreeSchema) == 0x000008, "Wrong alignment on UStateTreeSchema");
static_assert(sizeof(UStateTreeSchema) == 0x000028, "Wrong size on UStateTreeSchema");

// Class StateTreeModule.BrainComponentStateTreeSchema
// 0x0000 (0x0028 - 0x0028)
class UBrainComponentStateTreeSchema final : public UStateTreeSchema
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainComponentStateTreeSchema">();
	}
	static class UBrainComponentStateTreeSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainComponentStateTreeSchema>();
	}
};
static_assert(alignof(UBrainComponentStateTreeSchema) == 0x000008, "Wrong alignment on UBrainComponentStateTreeSchema");
static_assert(sizeof(UBrainComponentStateTreeSchema) == 0x000028, "Wrong size on UBrainComponentStateTreeSchema");

// Class StateTreeModule.StateTreeBrainComponent
// 0x0068 (0x0160 - 0x00F8)
class UStateTreeBrainComponent final : public UBrainComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStateTree*                             StateTree;                                         // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FStateTreeExecutionContext             StateTreeContext;                                  // 0x0108(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTreeBrainComponent">();
	}
	static class UStateTreeBrainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTreeBrainComponent>();
	}
};
static_assert(alignof(UStateTreeBrainComponent) == 0x000008, "Wrong alignment on UStateTreeBrainComponent");
static_assert(sizeof(UStateTreeBrainComponent) == 0x000160, "Wrong size on UStateTreeBrainComponent");
static_assert(offsetof(UStateTreeBrainComponent, StateTree) == 0x000100, "Member 'UStateTreeBrainComponent::StateTree' has a wrong offset!");
static_assert(offsetof(UStateTreeBrainComponent, StateTreeContext) == 0x000108, "Member 'UStateTreeBrainComponent::StateTreeContext' has a wrong offset!");

// Class StateTreeModule.StateTreeConditionBlueprintBase
// 0x0000 (0x0038 - 0x0038)
class UStateTreeConditionBlueprintBase final : public UStateTreeItemBlueprintBase
{
public:
	bool ReceiveTestCondition(class AActor* OwnerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTreeConditionBlueprintBase">();
	}
	static class UStateTreeConditionBlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTreeConditionBlueprintBase>();
	}
};
static_assert(alignof(UStateTreeConditionBlueprintBase) == 0x000008, "Wrong alignment on UStateTreeConditionBlueprintBase");
static_assert(sizeof(UStateTreeConditionBlueprintBase) == 0x000038, "Wrong size on UStateTreeConditionBlueprintBase");

// Class StateTreeModule.StateTreeEvaluatorBlueprintBase
// 0x0000 (0x0038 - 0x0038)
class UStateTreeEvaluatorBlueprintBase final : public UStateTreeItemBlueprintBase
{
public:
	void ReceiveEnterState(class AActor* OwnerActor, const EStateTreeStateChangeType ChangeType, const struct FStateTreeTransitionResult& TRANSITION);
	void ReceiveEvaluate(class AActor* OwnerActor, const EStateTreeEvaluationType EvalType, const float DeltaTime);
	void ReceiveExitState(class AActor* OwnerActor, const EStateTreeStateChangeType ChangeType, const struct FStateTreeTransitionResult& TRANSITION);
	void ReceiveStateCompleted(class AActor* OwnerActor, const EStateTreeRunStatus CompletionStatus, const struct FStateTreeHandle& CompletedState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTreeEvaluatorBlueprintBase">();
	}
	static class UStateTreeEvaluatorBlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTreeEvaluatorBlueprintBase>();
	}
};
static_assert(alignof(UStateTreeEvaluatorBlueprintBase) == 0x000008, "Wrong alignment on UStateTreeEvaluatorBlueprintBase");
static_assert(sizeof(UStateTreeEvaluatorBlueprintBase) == 0x000038, "Wrong size on UStateTreeEvaluatorBlueprintBase");

}

