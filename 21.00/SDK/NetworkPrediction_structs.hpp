#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: NetworkPrediction

#include "Basic.hpp"


namespace SDK
{

// Enum NetworkPrediction.ENetworkPredictionTickingPolicy
// NumValues: 0x0004
enum class ENetworkPredictionTickingPolicy : uint8
{
	Independent                              = 1,
	Fixed                                    = 2,
	All                                      = 3,
	ENetworkPredictionTickingPolicy_MAX      = 4,
};

// Enum NetworkPrediction.ENetworkLOD
// NumValues: 0x0005
enum class ENetworkLOD : uint8
{
	Interpolated                             = 1,
	SimExtrapolate                           = 2,
	ForwardPredict                           = 4,
	All                                      = 7,
	ENetworkLOD_MAX                          = 8,
};

// Enum NetworkPrediction.ENetworkPredictionStateRead
// NumValues: 0x0003
enum class ENetworkPredictionStateRead : uint8
{
	Simulation                               = 0,
	Presentation                             = 1,
	ENetworkPredictionStateRead_MAX          = 2,
};

// ScriptStruct NetworkPrediction.NetworkPredictionAsyncProxy
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FNetworkPredictionAsyncProxy final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkPredictionAsyncProxy) == 0x000008, "Wrong alignment on FNetworkPredictionAsyncProxy");
static_assert(sizeof(FNetworkPredictionAsyncProxy) == 0x000010, "Wrong size on FNetworkPredictionAsyncProxy");

// ScriptStruct NetworkPrediction.NetworkPhysicsState
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FNetworkPhysicsState final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkPhysicsState) == 0x000010, "Wrong alignment on FNetworkPhysicsState");
static_assert(sizeof(FNetworkPhysicsState) == 0x000090, "Wrong size on FNetworkPhysicsState");

// ScriptStruct NetworkPrediction.NetworkPredictionProxy
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FNetworkPredictionProxy final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UNetworkPredictionWorldManager*         WorldManager;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkPredictionProxy) == 0x000010, "Wrong alignment on FNetworkPredictionProxy");
static_assert(sizeof(FNetworkPredictionProxy) == 0x0000B0, "Wrong size on FNetworkPredictionProxy");
static_assert(offsetof(FNetworkPredictionProxy, WorldManager) == 0x0000A0, "Member 'FNetworkPredictionProxy::WorldManager' has a wrong offset!");

// ScriptStruct NetworkPrediction.SharedPackageMapItem
// 0x0028 (0x0028 - 0x0000)
struct FSharedPackageMapItem final
{
public:
	TSoftObjectPtr<class UObject>                 SoftPtr;                                           // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSharedPackageMapItem) == 0x000008, "Wrong alignment on FSharedPackageMapItem");
static_assert(sizeof(FSharedPackageMapItem) == 0x000028, "Wrong size on FSharedPackageMapItem");
static_assert(offsetof(FSharedPackageMapItem, SoftPtr) == 0x000000, "Member 'FSharedPackageMapItem::SoftPtr' has a wrong offset!");

// ScriptStruct NetworkPrediction.SharedPackageMap
// 0x0010 (0x0010 - 0x0000)
struct FSharedPackageMap final
{
public:
	TArray<struct FSharedPackageMapItem>          Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSharedPackageMap) == 0x000008, "Wrong alignment on FSharedPackageMap");
static_assert(sizeof(FSharedPackageMap) == 0x000010, "Wrong size on FSharedPackageMap");
static_assert(offsetof(FSharedPackageMap, Items) == 0x000000, "Member 'FSharedPackageMap::Items' has a wrong offset!");

// ScriptStruct NetworkPrediction.ReplicationProxy
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FReplicationProxy final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicationProxy) == 0x000010, "Wrong alignment on FReplicationProxy");
static_assert(sizeof(FReplicationProxy) == 0x000050, "Wrong size on FReplicationProxy");

// ScriptStruct NetworkPrediction.ServerReplicationRPCParameter
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FServerReplicationRPCParameter final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerReplicationRPCParameter) == 0x000008, "Wrong alignment on FServerReplicationRPCParameter");
static_assert(sizeof(FServerReplicationRPCParameter) == 0x000018, "Wrong size on FServerReplicationRPCParameter");

// ScriptStruct NetworkPrediction.NetworkPredictionSettings
// 0x0028 (0x0028 - 0x0000)
struct FNetworkPredictionSettings final
{
public:
	ENetworkPredictionTickingPolicy               PreferredTickingPolicy;                            // 0x0000(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ANetworkPredictionReplicatedManager> ReplicatedManagerClassOverride;                    // 0x0008(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FixedTickFrameRate;                                // 0x0010(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEngineFixTickForcePhysics;                   // 0x0014(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENetworkLOD                                   SimulatedProxyNetworkLOD;                          // 0x0015(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FixedTickInterpolationBufferedMS;                  // 0x0018(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndependentTickInterpolationBufferedMS;            // 0x001C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndependentTickInterpolationMaxBufferedMS;         // 0x0020(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkPredictionSettings) == 0x000008, "Wrong alignment on FNetworkPredictionSettings");
static_assert(sizeof(FNetworkPredictionSettings) == 0x000028, "Wrong size on FNetworkPredictionSettings");
static_assert(offsetof(FNetworkPredictionSettings, PreferredTickingPolicy) == 0x000000, "Member 'FNetworkPredictionSettings::PreferredTickingPolicy' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionSettings, ReplicatedManagerClassOverride) == 0x000008, "Member 'FNetworkPredictionSettings::ReplicatedManagerClassOverride' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionSettings, FixedTickFrameRate) == 0x000010, "Member 'FNetworkPredictionSettings::FixedTickFrameRate' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionSettings, bForceEngineFixTickForcePhysics) == 0x000014, "Member 'FNetworkPredictionSettings::bForceEngineFixTickForcePhysics' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionSettings, SimulatedProxyNetworkLOD) == 0x000015, "Member 'FNetworkPredictionSettings::SimulatedProxyNetworkLOD' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionSettings, FixedTickInterpolationBufferedMS) == 0x000018, "Member 'FNetworkPredictionSettings::FixedTickInterpolationBufferedMS' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionSettings, IndependentTickInterpolationBufferedMS) == 0x00001C, "Member 'FNetworkPredictionSettings::IndependentTickInterpolationBufferedMS' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionSettings, IndependentTickInterpolationMaxBufferedMS) == 0x000020, "Member 'FNetworkPredictionSettings::IndependentTickInterpolationMaxBufferedMS' has a wrong offset!");

// ScriptStruct NetworkPrediction.NetworkPredictionDevHUDItem
// 0x0028 (0x0028 - 0x0000)
struct FNetworkPredictionDevHUDItem final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExecCommand;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoBack;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequirePIE;                                       // 0x0021(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireNotPIE;                                    // 0x0022(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkPredictionDevHUDItem) == 0x000008, "Wrong alignment on FNetworkPredictionDevHUDItem");
static_assert(sizeof(FNetworkPredictionDevHUDItem) == 0x000028, "Wrong size on FNetworkPredictionDevHUDItem");
static_assert(offsetof(FNetworkPredictionDevHUDItem, DisplayName) == 0x000000, "Member 'FNetworkPredictionDevHUDItem::DisplayName' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionDevHUDItem, ExecCommand) == 0x000010, "Member 'FNetworkPredictionDevHUDItem::ExecCommand' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionDevHUDItem, bAutoBack) == 0x000020, "Member 'FNetworkPredictionDevHUDItem::bAutoBack' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionDevHUDItem, bRequirePIE) == 0x000021, "Member 'FNetworkPredictionDevHUDItem::bRequirePIE' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionDevHUDItem, bRequireNotPIE) == 0x000022, "Member 'FNetworkPredictionDevHUDItem::bRequireNotPIE' has a wrong offset!");

// ScriptStruct NetworkPrediction.NetworkPredictionDevHUD
// 0x0028 (0x0028 - 0x0000)
struct FNetworkPredictionDevHUD final
{
public:
	class FString                                 HUDName;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNetworkPredictionDevHUDItem>   Items;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bRequirePIE;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireNotPIE;                                    // 0x0021(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetworkPredictionDevHUD) == 0x000008, "Wrong alignment on FNetworkPredictionDevHUD");
static_assert(sizeof(FNetworkPredictionDevHUD) == 0x000028, "Wrong size on FNetworkPredictionDevHUD");
static_assert(offsetof(FNetworkPredictionDevHUD, HUDName) == 0x000000, "Member 'FNetworkPredictionDevHUD::HUDName' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionDevHUD, Items) == 0x000010, "Member 'FNetworkPredictionDevHUD::Items' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionDevHUD, bRequirePIE) == 0x000020, "Member 'FNetworkPredictionDevHUD::bRequirePIE' has a wrong offset!");
static_assert(offsetof(FNetworkPredictionDevHUD, bRequireNotPIE) == 0x000021, "Member 'FNetworkPredictionDevHUD::bRequireNotPIE' has a wrong offset!");

}

