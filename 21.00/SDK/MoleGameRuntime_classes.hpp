#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MoleGameRuntime

#include "Basic.hpp"

#include "MoleGameRuntime_structs.hpp"
#include "GameplayMessages_structs.hpp"
#include "ModularGameplay_classes.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "PlayspaceSystem_classes.hpp"
#include "GameplayTags_0_structs.hpp"
#include "TargetingSystem_structs.hpp"
#include "TargetingSystem_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayStateMachine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class MoleGameRuntime.MoleTaskLogicSubobject
// 0x0038 (0x0060 - 0x0028)
class UMoleTaskLogicSubobject : public UObject
{
public:
	struct FGameplayTagContainer                  AssociatedTaskActorTags;                           // 0x0028(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         AssociatedTaskActors;                              // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         AssociatedActorRemovalPolicyBitmask;               // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUsesAssociatedTaskActors : 1;                     // 0x0059(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReplicates : 1;                                   // 0x0059(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAssociatedTaskActorsAdded(const TArray<class AActor*>& InNewlyAddedTaskActors);
	void OnAssociatedTaskActorsPendingRemoval(const TArray<class AActor*>& InPendingRemovalTaskActors);
	void OnEnterOwningPhase();
	void OnExitOwningPhase();
	void OnOwningTaskBecomePrimaryActiveTask(bool bIsActivePhase);
	void OnOwningTaskNoLongerPrimaryActiveTask(bool bIsActivePhase);
	void OnTaskExternalInterruption(EMoleTaskInterruptionType InterruptionType);
	void OnTaskRemoved();

	const TArray<class AActor*> GetAssociatedTaskActors() const;
	ENetRole GetOwnerRole() const;
	class AController* GetOwningController() const;
	class UMolePlayerTaskManagementComponent* GetOwningPlayerTaskComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicSubobject">();
	}
	static class UMoleTaskLogicSubobject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicSubobject>();
	}
};
static_assert(alignof(UMoleTaskLogicSubobject) == 0x000008, "Wrong alignment on UMoleTaskLogicSubobject");
static_assert(sizeof(UMoleTaskLogicSubobject) == 0x000060, "Wrong size on UMoleTaskLogicSubobject");
static_assert(offsetof(UMoleTaskLogicSubobject, AssociatedTaskActorTags) == 0x000028, "Member 'UMoleTaskLogicSubobject::AssociatedTaskActorTags' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicSubobject, AssociatedTaskActors) == 0x000048, "Member 'UMoleTaskLogicSubobject::AssociatedTaskActors' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicSubobject, AssociatedActorRemovalPolicyBitmask) == 0x000058, "Member 'UMoleTaskLogicSubobject::AssociatedActorRemovalPolicyBitmask' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicObjective
// 0x0098 (0x00F8 - 0x0060)
class UMoleTaskLogicObjective : public UMoleTaskLogicSubobject
{
public:
	TMulticastInlineDelegate<void(float NewCurrentValue)> OnObjectiveCurrentValueChanged;                    // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float NewTargetValue)> OnObjectiveTargetValueChanged;                     // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FMoleObjectiveValue                    CurrentValue;                                      // 0x0080(0x0008)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CapturedInitialValue;                              // 0x0088(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapturedTargetValue;                               // 0x008C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMoleTaskObjectiveStatus                      CurrentStatus;                                     // 0x0090(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ObjectiveText;                                     // 0x0098(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                IndicatorRelativeOffset;                           // 0x00B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinimumCompletionTimeSecurityThreshold;            // 0x00C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAllowClientCompletion : 1;                        // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bValidateDistFromAssociatedActors : 1;             // 0x00F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bValidateMinCompletionTime : 1;                    // 0x00F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInterruptTaskOnValidationFailure : 1;             // 0x00F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bClearProgressOnTaskInterruption : 1;              // 0x00F0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasPerformedInitialCapture : 1;                   // 0x00F0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAttemptSetPrimaryActiveTaskOnValueDelta : 1;      // 0x00F0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAttemptHighlightAssociatedActorsIfPrimaryActiveTask : 1; // 0x00F0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAttemptApplyIndicatorsToAssociatedActorsIfPrimaryActiveTask : 1; // 0x00F1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRequirePermissionForEmphasisFX : 1;               // 0x00F1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCurrentValueDelta(float Delta);
	float CaptureInitialValue();
	float CaptureTargetValue();
	void CheckObjectiveStatus();
	void OnRep_CapturedInitialValue();
	void OnRep_CapturedTargetValue();
	void OnRep_CurrentStatus();
	void OnRep_CurrentValue();
	void ServerSetAsPrimaryActiveTask();
	void ServerSuggestObjectiveStatus(EMoleTaskObjectiveStatus InNewSuggestedStatus);
	void SetObjectiveStatus(EMoleTaskObjectiveStatus InNewStatus);

	float GetCapturedInitialValue() const;
	float GetCapturedTargetValue() const;
	float GetCurrentValue() const;
	EMoleTaskObjectiveStatus GetObjectiveStatus() const;
	const class FText GetObjectiveText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicObjective">();
	}
	static class UMoleTaskLogicObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicObjective>();
	}
};
static_assert(alignof(UMoleTaskLogicObjective) == 0x000008, "Wrong alignment on UMoleTaskLogicObjective");
static_assert(sizeof(UMoleTaskLogicObjective) == 0x0000F8, "Wrong size on UMoleTaskLogicObjective");
static_assert(offsetof(UMoleTaskLogicObjective, OnObjectiveCurrentValueChanged) == 0x000060, "Member 'UMoleTaskLogicObjective::OnObjectiveCurrentValueChanged' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective, OnObjectiveTargetValueChanged) == 0x000070, "Member 'UMoleTaskLogicObjective::OnObjectiveTargetValueChanged' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective, CurrentValue) == 0x000080, "Member 'UMoleTaskLogicObjective::CurrentValue' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective, CapturedInitialValue) == 0x000088, "Member 'UMoleTaskLogicObjective::CapturedInitialValue' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective, CapturedTargetValue) == 0x00008C, "Member 'UMoleTaskLogicObjective::CapturedTargetValue' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective, CurrentStatus) == 0x000090, "Member 'UMoleTaskLogicObjective::CurrentStatus' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective, ObjectiveText) == 0x000098, "Member 'UMoleTaskLogicObjective::ObjectiveText' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective, IndicatorRelativeOffset) == 0x0000B0, "Member 'UMoleTaskLogicObjective::IndicatorRelativeOffset' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective, MinimumCompletionTimeSecurityThreshold) == 0x0000C8, "Member 'UMoleTaskLogicObjective::MinimumCompletionTimeSecurityThreshold' has a wrong offset!");

// Class MoleGameRuntime.MoleEliminationAbility
// 0x0040 (0x0B50 - 0x0B10)
class UMoleEliminationAbility final : public UFortGameplayAbility
{
public:
	struct FGameplayTagContainer                  CooldownTagsToListenTo;                            // 0x0B10(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CombinedCooldownTags;                              // 0x0B30(0x0020)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	bool ValidatePotentialEliminationTarget(class AFortPlayerPawn* PotentialTargetPawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleEliminationAbility">();
	}
	static class UMoleEliminationAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleEliminationAbility>();
	}
};
static_assert(alignof(UMoleEliminationAbility) == 0x000008, "Wrong alignment on UMoleEliminationAbility");
static_assert(sizeof(UMoleEliminationAbility) == 0x000B50, "Wrong size on UMoleEliminationAbility");
static_assert(offsetof(UMoleEliminationAbility, CooldownTagsToListenTo) == 0x000B10, "Member 'UMoleEliminationAbility::CooldownTagsToListenTo' has a wrong offset!");
static_assert(offsetof(UMoleEliminationAbility, CombinedCooldownTags) == 0x000B30, "Member 'UMoleEliminationAbility::CombinedCooldownTags' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicAction
// 0x0008 (0x0068 - 0x0060)
class UMoleTaskLogicAction : public UMoleTaskLogicSubobject
{
public:
	uint8                                         ActionRemovalPolicyBitmask;                        // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUsesActionRemovalPolicyBitmask : 1;               // 0x0061(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActionRemovalPolicyInvoked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicAction">();
	}
	static class UMoleTaskLogicAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicAction>();
	}
};
static_assert(alignof(UMoleTaskLogicAction) == 0x000008, "Wrong alignment on UMoleTaskLogicAction");
static_assert(sizeof(UMoleTaskLogicAction) == 0x000068, "Wrong size on UMoleTaskLogicAction");
static_assert(offsetof(UMoleTaskLogicAction, ActionRemovalPolicyBitmask) == 0x000060, "Member 'UMoleTaskLogicAction::ActionRemovalPolicyBitmask' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicAction_GrantAbilitySet
// 0x0070 (0x00D8 - 0x0068)
class UMoleTaskLogicAction_GrantAbilitySet final : public UMoleTaskLogicAction
{
public:
	TSoftObjectPtr<class UFortAbilitySet>         AbilitySetToGrant;                                 // 0x0068(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortAbilitySetHandle                  GrantedHandle;                                     // 0x0090(0x0038)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  GrantedInputGuid;                                  // 0x00C8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicAction_GrantAbilitySet">();
	}
	static class UMoleTaskLogicAction_GrantAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicAction_GrantAbilitySet>();
	}
};
static_assert(alignof(UMoleTaskLogicAction_GrantAbilitySet) == 0x000008, "Wrong alignment on UMoleTaskLogicAction_GrantAbilitySet");
static_assert(sizeof(UMoleTaskLogicAction_GrantAbilitySet) == 0x0000D8, "Wrong size on UMoleTaskLogicAction_GrantAbilitySet");
static_assert(offsetof(UMoleTaskLogicAction_GrantAbilitySet, AbilitySetToGrant) == 0x000068, "Member 'UMoleTaskLogicAction_GrantAbilitySet::AbilitySetToGrant' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicAction_GrantAbilitySet, GrantedHandle) == 0x000090, "Member 'UMoleTaskLogicAction_GrantAbilitySet::GrantedHandle' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicAction_GrantAbilitySet, GrantedInputGuid) == 0x0000C8, "Member 'UMoleTaskLogicAction_GrantAbilitySet::GrantedInputGuid' has a wrong offset!");

// Class MoleGameRuntime.FortCinematicComponent
// 0x00B0 (0x0150 - 0x00A0)
class UFortCinematicComponent : public UControllerComponent
{
public:
	TMap<TWeakObjectPtr<class AFortPawn>, bool>   PawnVisibilityMap;                                 // 0x00A0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class AFortPawn>, bool>   LocalPawnVisibilityMap;                            // 0x00F0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortCinematicState>            StateStack;                                        // 0x0140(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void CancelBlackscreen();
	void FadeFromBlackscreen(float InFadeTime);
	void FadeToBlackscreen(float InFadeTime, bool bInHold);
	bool IsCinematicStateActive(const struct FGameplayTag& StateTag);
	void PushCinematicState(const struct FFortCinematicState& InState);
	void RemoveCinematicState(const struct FGameplayTag& StateId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCinematicComponent">();
	}
	static class UFortCinematicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCinematicComponent>();
	}
};
static_assert(alignof(UFortCinematicComponent) == 0x000008, "Wrong alignment on UFortCinematicComponent");
static_assert(sizeof(UFortCinematicComponent) == 0x000150, "Wrong size on UFortCinematicComponent");
static_assert(offsetof(UFortCinematicComponent, PawnVisibilityMap) == 0x0000A0, "Member 'UFortCinematicComponent::PawnVisibilityMap' has a wrong offset!");
static_assert(offsetof(UFortCinematicComponent, LocalPawnVisibilityMap) == 0x0000F0, "Member 'UFortCinematicComponent::LocalPawnVisibilityMap' has a wrong offset!");
static_assert(offsetof(UFortCinematicComponent, StateStack) == 0x000140, "Member 'UFortCinematicComponent::StateStack' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicAction_GrantTag
// 0x0020 (0x0088 - 0x0068)
class UMoleTaskLogicAction_GrantTag final : public UMoleTaskLogicAction
{
public:
	struct FGameplayTagContainer                  TagsToGrant;                                       // 0x0068(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicAction_GrantTag">();
	}
	static class UMoleTaskLogicAction_GrantTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicAction_GrantTag>();
	}
};
static_assert(alignof(UMoleTaskLogicAction_GrantTag) == 0x000008, "Wrong alignment on UMoleTaskLogicAction_GrantTag");
static_assert(sizeof(UMoleTaskLogicAction_GrantTag) == 0x000088, "Wrong size on UMoleTaskLogicAction_GrantTag");
static_assert(offsetof(UMoleTaskLogicAction_GrantTag, TagsToGrant) == 0x000068, "Member 'UMoleTaskLogicAction_GrantTag::TagsToGrant' has a wrong offset!");

// Class MoleGameRuntime.MoleAFKComponent
// 0x0028 (0x0118 - 0x00F0)
class UMoleAFKComponent final : public UFortAFKComponent
{
public:
	float                                         LongestAFKPeriod;                                  // 0x00F0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x24];                                      // 0x00F4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool HasEverBeenAFK(const class AFortPlayerController* FortPC);
	static bool HasEverBeenAFKForTooLong(const class AFortPlayerController* FortPC);
	static bool IsControllerAFK(class AFortPlayerController* FortPC);
	static bool IsPlayerAFK(const class APlayerState* Player);

	void OnPlayerEnteredPOI(class AActor* OverlapingVolume, class AActor* EnteringActor);
	void OnPlayerLeftPOI(class AActor* OverlapingVolume, class AActor* EnteringActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleAFKComponent">();
	}
	static class UMoleAFKComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleAFKComponent>();
	}
};
static_assert(alignof(UMoleAFKComponent) == 0x000008, "Wrong alignment on UMoleAFKComponent");
static_assert(sizeof(UMoleAFKComponent) == 0x000118, "Wrong size on UMoleAFKComponent");
static_assert(offsetof(UMoleAFKComponent, LongestAFKPeriod) == 0x0000F0, "Member 'UMoleAFKComponent::LongestAFKPeriod' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicAction_GrantWeapon
// 0x0040 (0x00A8 - 0x0068)
class UMoleTaskLogicAction_GrantWeapon final : public UMoleTaskLogicAction
{
public:
	TSoftObjectPtr<class UFortWeaponItemDefinition> WeaponToGrant;                                     // 0x0068(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortWeaponItemDefinition*              PreviousWeapon;                                    // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  GrantedWeaponGuid;                                 // 0x0098(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicAction_GrantWeapon">();
	}
	static class UMoleTaskLogicAction_GrantWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicAction_GrantWeapon>();
	}
};
static_assert(alignof(UMoleTaskLogicAction_GrantWeapon) == 0x000008, "Wrong alignment on UMoleTaskLogicAction_GrantWeapon");
static_assert(sizeof(UMoleTaskLogicAction_GrantWeapon) == 0x0000A8, "Wrong size on UMoleTaskLogicAction_GrantWeapon");
static_assert(offsetof(UMoleTaskLogicAction_GrantWeapon, WeaponToGrant) == 0x000068, "Member 'UMoleTaskLogicAction_GrantWeapon::WeaponToGrant' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicAction_GrantWeapon, PreviousWeapon) == 0x000090, "Member 'UMoleTaskLogicAction_GrantWeapon::PreviousWeapon' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicAction_GrantWeapon, GrantedWeaponGuid) == 0x000098, "Member 'UMoleTaskLogicAction_GrantWeapon::GrantedWeaponGuid' has a wrong offset!");

// Class MoleGameRuntime.MoleAnalyticsComponent
// 0x01E0 (0x0280 - 0x00A0)
class UMoleAnalyticsComponent final : public UPlayspaceComponent
{
public:
	uint8                                         Pad_A0[0x1E0];                                     // 0x00A0(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleAnalyticsComponent">();
	}
	static class UMoleAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleAnalyticsComponent>();
	}
};
static_assert(alignof(UMoleAnalyticsComponent) == 0x000008, "Wrong alignment on UMoleAnalyticsComponent");
static_assert(sizeof(UMoleAnalyticsComponent) == 0x000280, "Wrong size on UMoleAnalyticsComponent");

// Class MoleGameRuntime.MoleTaskLogicAction_HighlightActors
// 0x0020 (0x0088 - 0x0068)
class UMoleTaskLogicAction_HighlightActors final : public UMoleTaskLogicAction
{
public:
	uint8                                         bHighlight : 1;                                    // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowIndicator : 1;                                // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRequirePermissionForEmphasisFX : 1;               // 0x0068(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowIndicatorInGoalMode : 1;                      // 0x0068(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IndicatorRelativeLocationOffset;                   // 0x0070(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicAction_HighlightActors">();
	}
	static class UMoleTaskLogicAction_HighlightActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicAction_HighlightActors>();
	}
};
static_assert(alignof(UMoleTaskLogicAction_HighlightActors) == 0x000008, "Wrong alignment on UMoleTaskLogicAction_HighlightActors");
static_assert(sizeof(UMoleTaskLogicAction_HighlightActors) == 0x000088, "Wrong size on UMoleTaskLogicAction_HighlightActors");
static_assert(offsetof(UMoleTaskLogicAction_HighlightActors, IndicatorRelativeLocationOffset) == 0x000070, "Member 'UMoleTaskLogicAction_HighlightActors::IndicatorRelativeLocationOffset' has a wrong offset!");

// Class MoleGameRuntime.MoleAssetManagerComponent
// 0x0038 (0x00D8 - 0x00A0)
class UMoleAssetManagerComponent : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMoleAssetLoadData>             AssetLoadInfo;                                     // 0x00B8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           BundlesToLoad;                                     // 0x00C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleAssetManagerComponent">();
	}
	static class UMoleAssetManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleAssetManagerComponent>();
	}
};
static_assert(alignof(UMoleAssetManagerComponent) == 0x000008, "Wrong alignment on UMoleAssetManagerComponent");
static_assert(sizeof(UMoleAssetManagerComponent) == 0x0000D8, "Wrong size on UMoleAssetManagerComponent");
static_assert(offsetof(UMoleAssetManagerComponent, AssetLoadInfo) == 0x0000B8, "Member 'UMoleAssetManagerComponent::AssetLoadInfo' has a wrong offset!");
static_assert(offsetof(UMoleAssetManagerComponent, BundlesToLoad) == 0x0000C8, "Member 'UMoleAssetManagerComponent::BundlesToLoad' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicAction_SetInteractionData
// 0x0008 (0x0070 - 0x0068)
class UMoleTaskLogicAction_SetInteractionData final : public UMoleTaskLogicAction
{
public:
	class FName                                   InteractionRow;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAlsoGrantPermission : 1;                          // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicAction_SetInteractionData">();
	}
	static class UMoleTaskLogicAction_SetInteractionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicAction_SetInteractionData>();
	}
};
static_assert(alignof(UMoleTaskLogicAction_SetInteractionData) == 0x000008, "Wrong alignment on UMoleTaskLogicAction_SetInteractionData");
static_assert(sizeof(UMoleTaskLogicAction_SetInteractionData) == 0x000070, "Wrong size on UMoleTaskLogicAction_SetInteractionData");
static_assert(offsetof(UMoleTaskLogicAction_SetInteractionData, InteractionRow) == 0x000068, "Member 'UMoleTaskLogicAction_SetInteractionData::InteractionRow' has a wrong offset!");

// Class MoleGameRuntime.MoleAudioManagerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UMoleAudioManagerComponent final : public UPlayspaceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleAudioManagerComponent">();
	}
	static class UMoleAudioManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleAudioManagerComponent>();
	}
};
static_assert(alignof(UMoleAudioManagerComponent) == 0x000008, "Wrong alignment on UMoleAudioManagerComponent");
static_assert(sizeof(UMoleAudioManagerComponent) == 0x0000A0, "Wrong size on UMoleAudioManagerComponent");

// Class MoleGameRuntime.MoleTaskLogicAction_SetPermission
// 0x0008 (0x0070 - 0x0068)
class UMoleTaskLogicAction_SetPermission final : public UMoleTaskLogicAction
{
public:
	uint8                                         bGrantPermission : 1;                              // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicAction_SetPermission">();
	}
	static class UMoleTaskLogicAction_SetPermission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicAction_SetPermission>();
	}
};
static_assert(alignof(UMoleTaskLogicAction_SetPermission) == 0x000008, "Wrong alignment on UMoleTaskLogicAction_SetPermission");
static_assert(sizeof(UMoleTaskLogicAction_SetPermission) == 0x000070, "Wrong size on UMoleTaskLogicAction_SetPermission");

// Class MoleGameRuntime.MoleCheatManager
// 0x0000 (0x0028 - 0x0028)
class UMoleCheatManager final : public UChildCheatManager
{
public:
	void GoToStateGameover(const struct FGameplayTag& InTag);
	void GoToStateGameplay();
	void GoToStateLobby();
	void GoToStateVoting();
	void GrantTask(const class FString& TaskAssetName);
	void MakeSelfMoleGhost();
	void MakeTargetMoleGhost();
	void MoleClearRequestSaboteur();
	void MoleDisableAllTasks();
	void MoleDisableSelfTasks();
	void MoleEnableAllTasks();
	void MoleEnableSelfTasks();
	void MoleInterruptAllTasks();
	void MoleInterruptSelfTasks();
	void MoleRecoverFromAFK();
	void MoleRequestSaboteur();
	void MoleShowImpostorBias();
	void SkipLobbyBackfillLogic();
	void SpawnMoleBots(int32 NumBotsToSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleCheatManager">();
	}
	static class UMoleCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleCheatManager>();
	}
};
static_assert(alignof(UMoleCheatManager) == 0x000008, "Wrong alignment on UMoleCheatManager");
static_assert(sizeof(UMoleCheatManager) == 0x000028, "Wrong size on UMoleCheatManager");

// Class MoleGameRuntime.MoleTaskLogicAction_SetPlayerLeash
// 0x0030 (0x0098 - 0x0068)
class UMoleTaskLogicAction_SetPlayerLeash final : public UMoleTaskLogicAction
{
public:
	EMoleTaskLeashType                            LeashType;                                         // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         LeashDistance;                                     // 0x0070(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicAction_SetPlayerLeash">();
	}
	static class UMoleTaskLogicAction_SetPlayerLeash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicAction_SetPlayerLeash>();
	}
};
static_assert(alignof(UMoleTaskLogicAction_SetPlayerLeash) == 0x000008, "Wrong alignment on UMoleTaskLogicAction_SetPlayerLeash");
static_assert(sizeof(UMoleTaskLogicAction_SetPlayerLeash) == 0x000098, "Wrong size on UMoleTaskLogicAction_SetPlayerLeash");
static_assert(offsetof(UMoleTaskLogicAction_SetPlayerLeash, LeashType) == 0x000068, "Member 'UMoleTaskLogicAction_SetPlayerLeash::LeashType' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicAction_SetPlayerLeash, LeashDistance) == 0x000070, "Member 'UMoleTaskLogicAction_SetPlayerLeash::LeashDistance' has a wrong offset!");

// Class MoleGameRuntime.MoleCinematicComponent
// 0x0270 (0x03C0 - 0x0150)
class UMoleCinematicComponent final : public UFortCinematicComponent
{
public:
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRoleAssignedTeleport;                             // 0x0158(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayMessageReceiverHandle         RoleAssignTeleportHandle;                          // 0x0160(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFortCinematicState                    RoleAssignedCineState;                             // 0x0178(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FMoleEmergencyMeetingData              MeetingPayload;                                    // 0x01C0(0x0020)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFortCinematicState                    MeetingCalledCineState;                            // 0x01E0(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bVoteDiscussionTeleport;                           // 0x0230(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayMessageReceiverHandle         VoteDiscussTeleportHandle;                         // 0x0238(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFortCinematicState                    VoteDiscussCineState;                              // 0x0250(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortCinematicState                    VoteResolvedCineState;                             // 0x02B8(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bVotingTeleport;                                   // 0x0300(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayMessageReceiverHandle         VotingTeleportHandle;                              // 0x0308(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortCinematicState                    VoteSkippedCineState;                              // 0x0328(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortCinematicState                    VoteEjectionCineState;                             // 0x0378(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleCinematicComponent">();
	}
	static class UMoleCinematicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleCinematicComponent>();
	}
};
static_assert(alignof(UMoleCinematicComponent) == 0x000008, "Wrong alignment on UMoleCinematicComponent");
static_assert(sizeof(UMoleCinematicComponent) == 0x0003C0, "Wrong size on UMoleCinematicComponent");
static_assert(offsetof(UMoleCinematicComponent, bRoleAssignedTeleport) == 0x000158, "Member 'UMoleCinematicComponent::bRoleAssignedTeleport' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, RoleAssignTeleportHandle) == 0x000160, "Member 'UMoleCinematicComponent::RoleAssignTeleportHandle' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, RoleAssignedCineState) == 0x000178, "Member 'UMoleCinematicComponent::RoleAssignedCineState' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, MeetingPayload) == 0x0001C0, "Member 'UMoleCinematicComponent::MeetingPayload' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, MeetingCalledCineState) == 0x0001E0, "Member 'UMoleCinematicComponent::MeetingCalledCineState' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, bVoteDiscussionTeleport) == 0x000230, "Member 'UMoleCinematicComponent::bVoteDiscussionTeleport' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, VoteDiscussTeleportHandle) == 0x000238, "Member 'UMoleCinematicComponent::VoteDiscussTeleportHandle' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, VoteDiscussCineState) == 0x000250, "Member 'UMoleCinematicComponent::VoteDiscussCineState' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, VoteResolvedCineState) == 0x0002B8, "Member 'UMoleCinematicComponent::VoteResolvedCineState' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, bVotingTeleport) == 0x000300, "Member 'UMoleCinematicComponent::bVotingTeleport' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, VotingTeleportHandle) == 0x000308, "Member 'UMoleCinematicComponent::VotingTeleportHandle' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, VoteSkippedCineState) == 0x000328, "Member 'UMoleCinematicComponent::VoteSkippedCineState' has a wrong offset!");
static_assert(offsetof(UMoleCinematicComponent, VoteEjectionCineState) == 0x000378, "Member 'UMoleCinematicComponent::VoteEjectionCineState' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicObjective_DamageActors
// 0x0030 (0x0128 - 0x00F8)
class UMoleTaskLogicObjective_DamageActors final : public UMoleTaskLogicObjective
{
public:
	struct FScalableFloat                         DamageAmount;                                      // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bOnlyCountDamageFromTaskOwner : 1;                 // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBuildingActorDamaged(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnPawnDamaged(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicObjective_DamageActors">();
	}
	static class UMoleTaskLogicObjective_DamageActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicObjective_DamageActors>();
	}
};
static_assert(alignof(UMoleTaskLogicObjective_DamageActors) == 0x000008, "Wrong alignment on UMoleTaskLogicObjective_DamageActors");
static_assert(sizeof(UMoleTaskLogicObjective_DamageActors) == 0x000128, "Wrong size on UMoleTaskLogicObjective_DamageActors");
static_assert(offsetof(UMoleTaskLogicObjective_DamageActors, DamageAmount) == 0x0000F8, "Member 'UMoleTaskLogicObjective_DamageActors::DamageAmount' has a wrong offset!");

// Class MoleGameRuntime.MoleEliminationMarker
// 0x0008 (0x0978 - 0x0970)
class AMoleEliminationMarker final : public ABuildingGameplayActor
{
public:
	class APlayerState*                           RepresentedPlayer;                                 // 0x0970(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_RepresentedPlayer();
	void OnRepresentedPlayerSet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleEliminationMarker">();
	}
	static class AMoleEliminationMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoleEliminationMarker>();
	}
};
static_assert(alignof(AMoleEliminationMarker) == 0x000008, "Wrong alignment on AMoleEliminationMarker");
static_assert(sizeof(AMoleEliminationMarker) == 0x000978, "Wrong size on AMoleEliminationMarker");
static_assert(offsetof(AMoleEliminationMarker, RepresentedPlayer) == 0x000970, "Member 'AMoleEliminationMarker::RepresentedPlayer' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicObjective_DestroyActors
// 0x0038 (0x0130 - 0x00F8)
class UMoleTaskLogicObjective_DestroyActors final : public UMoleTaskLogicObjective
{
public:
	struct FMoleObjectiveCriteriaFloat            Quantity;                                          // 0x00F8(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnBuildingActorDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnGenericActorDestroyed(class AActor* DestroyedActor);
	void OnPawnDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicObjective_DestroyActors">();
	}
	static class UMoleTaskLogicObjective_DestroyActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicObjective_DestroyActors>();
	}
};
static_assert(alignof(UMoleTaskLogicObjective_DestroyActors) == 0x000008, "Wrong alignment on UMoleTaskLogicObjective_DestroyActors");
static_assert(sizeof(UMoleTaskLogicObjective_DestroyActors) == 0x000130, "Wrong size on UMoleTaskLogicObjective_DestroyActors");
static_assert(offsetof(UMoleTaskLogicObjective_DestroyActors, Quantity) == 0x0000F8, "Member 'UMoleTaskLogicObjective_DestroyActors::Quantity' has a wrong offset!");

// Class MoleGameRuntime.MoleGameBaseMutator
// 0x00C8 (0x03E0 - 0x0318)
class AMoleGameBaseMutator final : public AFortAthenaMutator
{
public:
	struct FGameplayTagContainer                  BlockedEmoteTags;                                  // 0x0318(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlockedEmoteTagsForGhosts;                         // 0x0338(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   LeaveTextOverride;                                 // 0x0358(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   LeavePartyTextOverride;                            // 0x0370(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   GhostLeaveTextOverride;                            // 0x0388(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   GhostLeavePartyTextOverride;                       // 0x03A0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         IsSlideEnabled;                                    // 0x03B8(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleGameBaseMutator">();
	}
	static class AMoleGameBaseMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoleGameBaseMutator>();
	}
};
static_assert(alignof(AMoleGameBaseMutator) == 0x000008, "Wrong alignment on AMoleGameBaseMutator");
static_assert(sizeof(AMoleGameBaseMutator) == 0x0003E0, "Wrong size on AMoleGameBaseMutator");
static_assert(offsetof(AMoleGameBaseMutator, BlockedEmoteTags) == 0x000318, "Member 'AMoleGameBaseMutator::BlockedEmoteTags' has a wrong offset!");
static_assert(offsetof(AMoleGameBaseMutator, BlockedEmoteTagsForGhosts) == 0x000338, "Member 'AMoleGameBaseMutator::BlockedEmoteTagsForGhosts' has a wrong offset!");
static_assert(offsetof(AMoleGameBaseMutator, LeaveTextOverride) == 0x000358, "Member 'AMoleGameBaseMutator::LeaveTextOverride' has a wrong offset!");
static_assert(offsetof(AMoleGameBaseMutator, LeavePartyTextOverride) == 0x000370, "Member 'AMoleGameBaseMutator::LeavePartyTextOverride' has a wrong offset!");
static_assert(offsetof(AMoleGameBaseMutator, GhostLeaveTextOverride) == 0x000388, "Member 'AMoleGameBaseMutator::GhostLeaveTextOverride' has a wrong offset!");
static_assert(offsetof(AMoleGameBaseMutator, GhostLeavePartyTextOverride) == 0x0003A0, "Member 'AMoleGameBaseMutator::GhostLeavePartyTextOverride' has a wrong offset!");
static_assert(offsetof(AMoleGameBaseMutator, IsSlideEnabled) == 0x0003B8, "Member 'AMoleGameBaseMutator::IsSlideEnabled' has a wrong offset!");

// Class MoleGameRuntime.MoleGameplayAbility_Voting
// 0x0018 (0x0B28 - 0x0B10)
class UMoleGameplayAbility_Voting final : public UFortGameplayAbility
{
public:
	class UTargetingPreset*                       VotingTargetingPreset;                             // 0x0B10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTargetingRequestHandle                AsyncTargetingHandle;                              // 0x0B18(0x0004)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1C[0x4];                                      // 0x0B1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BestVotingTarget;                                  // 0x0B20(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnVotingTargetChanged(class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleGameplayAbility_Voting">();
	}
	static class UMoleGameplayAbility_Voting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleGameplayAbility_Voting>();
	}
};
static_assert(alignof(UMoleGameplayAbility_Voting) == 0x000008, "Wrong alignment on UMoleGameplayAbility_Voting");
static_assert(sizeof(UMoleGameplayAbility_Voting) == 0x000B28, "Wrong size on UMoleGameplayAbility_Voting");
static_assert(offsetof(UMoleGameplayAbility_Voting, VotingTargetingPreset) == 0x000B10, "Member 'UMoleGameplayAbility_Voting::VotingTargetingPreset' has a wrong offset!");
static_assert(offsetof(UMoleGameplayAbility_Voting, AsyncTargetingHandle) == 0x000B18, "Member 'UMoleGameplayAbility_Voting::AsyncTargetingHandle' has a wrong offset!");
static_assert(offsetof(UMoleGameplayAbility_Voting, BestVotingTarget) == 0x000B20, "Member 'UMoleGameplayAbility_Voting::BestVotingTarget' has a wrong offset!");

// Class MoleGameRuntime.MoleGamePlayerSpawningComponent
// 0x0038 (0x00E8 - 0x00B0)
class UMoleGamePlayerSpawningComponent final : public UPlayspaceComponent_PlayerSpawning
{
public:
	uint8                                         Pad_B0[0x38];                                      // 0x00B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleGamePlayerSpawningComponent">();
	}
	static class UMoleGamePlayerSpawningComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleGamePlayerSpawningComponent>();
	}
};
static_assert(alignof(UMoleGamePlayerSpawningComponent) == 0x000008, "Wrong alignment on UMoleGamePlayerSpawningComponent");
static_assert(sizeof(UMoleGamePlayerSpawningComponent) == 0x0000E8, "Wrong size on UMoleGamePlayerSpawningComponent");

// Class MoleGameRuntime.MoleGamePlayspace
// 0x0028 (0x05D8 - 0x05B0)
class AMoleGamePlayspace final : public AFortPlayspace
{
public:
	TSubclassOf<class UGameplayStateMachine>      MoleStateMachineClass;                             // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortInventoryManager*                  InventoryManager;                                  // 0x05C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayStateMachineManager*           StateMachineManager;                               // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleGamePlayspace">();
	}
	static class AMoleGamePlayspace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoleGamePlayspace>();
	}
};
static_assert(alignof(AMoleGamePlayspace) == 0x000008, "Wrong alignment on AMoleGamePlayspace");
static_assert(sizeof(AMoleGamePlayspace) == 0x0005D8, "Wrong size on AMoleGamePlayspace");
static_assert(offsetof(AMoleGamePlayspace, MoleStateMachineClass) == 0x0005B0, "Member 'AMoleGamePlayspace::MoleStateMachineClass' has a wrong offset!");
static_assert(offsetof(AMoleGamePlayspace, InventoryManager) == 0x0005C8, "Member 'AMoleGamePlayspace::InventoryManager' has a wrong offset!");
static_assert(offsetof(AMoleGamePlayspace, StateMachineManager) == 0x0005D0, "Member 'AMoleGamePlayspace::StateMachineManager' has a wrong offset!");

// Class MoleGameRuntime.MoleGameplayState_Tasks
// 0x0010 (0x0088 - 0x0078)
class UMoleGameplayState_Tasks final : public UGameplayState
{
public:
	float                                         PrepareStateDelayTime;                             // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0xC];                                       // 0x007C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleGameplayState_Tasks">();
	}
	static class UMoleGameplayState_Tasks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleGameplayState_Tasks>();
	}
};
static_assert(alignof(UMoleGameplayState_Tasks) == 0x000008, "Wrong alignment on UMoleGameplayState_Tasks");
static_assert(sizeof(UMoleGameplayState_Tasks) == 0x000088, "Wrong size on UMoleGameplayState_Tasks");
static_assert(offsetof(UMoleGameplayState_Tasks, PrepareStateDelayTime) == 0x000078, "Member 'UMoleGameplayState_Tasks::PrepareStateDelayTime' has a wrong offset!");

// Class MoleGameRuntime.MoleGhostControllerComponent
// 0x0008 (0x00A8 - 0x00A0)
class UMoleGhostControllerComponent final : public UFortControllerComponent
{
public:
	class UInputComponent*                        GhostInputComp;                                    // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClientRevertGhost();
	void CLientSetupGhost();
	void OnPlayerBecameGhost();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleGhostControllerComponent">();
	}
	static class UMoleGhostControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleGhostControllerComponent>();
	}
};
static_assert(alignof(UMoleGhostControllerComponent) == 0x000008, "Wrong alignment on UMoleGhostControllerComponent");
static_assert(sizeof(UMoleGhostControllerComponent) == 0x0000A8, "Wrong size on UMoleGhostControllerComponent");
static_assert(offsetof(UMoleGhostControllerComponent, GhostInputComp) == 0x0000A0, "Member 'UMoleGhostControllerComponent::GhostInputComp' has a wrong offset!");

// Class MoleGameRuntime.MoleGhostMannequin
// 0x0018 (0x05C8 - 0x05B0)
class AMoleGhostMannequin final : public AFortPlayerMannequin
{
public:
	class UMaterialInterface*                     GhostMaterial;                                     // 0x05B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           RepresentedPlayerState;                            // 0x05B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x8];                                      // 0x05C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRepresentedPlayerSet(class APlayerState* PlayerState);

	class APlayerState* GetRepresentedPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleGhostMannequin">();
	}
	static class AMoleGhostMannequin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoleGhostMannequin>();
	}
};
static_assert(alignof(AMoleGhostMannequin) == 0x000008, "Wrong alignment on AMoleGhostMannequin");
static_assert(sizeof(AMoleGhostMannequin) == 0x0005C8, "Wrong size on AMoleGhostMannequin");
static_assert(offsetof(AMoleGhostMannequin, GhostMaterial) == 0x0005B0, "Member 'AMoleGhostMannequin::GhostMaterial' has a wrong offset!");
static_assert(offsetof(AMoleGhostMannequin, RepresentedPlayerState) == 0x0005B8, "Member 'AMoleGhostMannequin::RepresentedPlayerState' has a wrong offset!");

// Class MoleGameRuntime.MoleGlobals
// 0x0000 (0x0028 - 0x0028)
class UMoleGlobals final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleGlobals">();
	}
	static class UMoleGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleGlobals>();
	}
};
static_assert(alignof(UMoleGlobals) == 0x000008, "Wrong alignment on UMoleGlobals");
static_assert(sizeof(UMoleGlobals) == 0x000028, "Wrong size on UMoleGlobals");

// Class MoleGameRuntime.MoleImpostorBiasComponent
// 0x0020 (0x00C0 - 0x00A0)
class UMoleImpostorBiasComponent final : public UControllerComponent
{
public:
	EMoleRole                                     RolePreference;                                    // 0x00A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x1F];                                      // 0x00A1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsImpostorBiasEnabled();
	static void SetRolePreference(class AFortPlayerController* FortPC, EMoleRole InRolePreference);

	void OnRep_RolePreference();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleImpostorBiasComponent">();
	}
	static class UMoleImpostorBiasComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleImpostorBiasComponent>();
	}
};
static_assert(alignof(UMoleImpostorBiasComponent) == 0x000008, "Wrong alignment on UMoleImpostorBiasComponent");
static_assert(sizeof(UMoleImpostorBiasComponent) == 0x0000C0, "Wrong size on UMoleImpostorBiasComponent");
static_assert(offsetof(UMoleImpostorBiasComponent, RolePreference) == 0x0000A0, "Member 'UMoleImpostorBiasComponent::RolePreference' has a wrong offset!");

// Class MoleGameRuntime.MoleInitialPlayerCountModMagnitudeCalculation
// 0x0000 (0x0040 - 0x0040)
class UMoleInitialPlayerCountModMagnitudeCalculation final : public UFortGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleInitialPlayerCountModMagnitudeCalculation">();
	}
	static class UMoleInitialPlayerCountModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleInitialPlayerCountModMagnitudeCalculation>();
	}
};
static_assert(alignof(UMoleInitialPlayerCountModMagnitudeCalculation) == 0x000008, "Wrong alignment on UMoleInitialPlayerCountModMagnitudeCalculation");
static_assert(sizeof(UMoleInitialPlayerCountModMagnitudeCalculation) == 0x000040, "Wrong size on UMoleInitialPlayerCountModMagnitudeCalculation");

// Class MoleGameRuntime.MoleLevelDataAsset
// 0x0040 (0x0070 - 0x0030)
class UMoleLevelDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<TSoftObjectPtr<class UWorld>>          Levels;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LevelDescriptionTags;                              // 0x0040(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMoleLevelTaskRequest>          TaskRequests;                                      // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleLevelDataAsset">();
	}
	static class UMoleLevelDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleLevelDataAsset>();
	}
};
static_assert(alignof(UMoleLevelDataAsset) == 0x000008, "Wrong alignment on UMoleLevelDataAsset");
static_assert(sizeof(UMoleLevelDataAsset) == 0x000070, "Wrong size on UMoleLevelDataAsset");
static_assert(offsetof(UMoleLevelDataAsset, Levels) == 0x000030, "Member 'UMoleLevelDataAsset::Levels' has a wrong offset!");
static_assert(offsetof(UMoleLevelDataAsset, LevelDescriptionTags) == 0x000040, "Member 'UMoleLevelDataAsset::LevelDescriptionTags' has a wrong offset!");
static_assert(offsetof(UMoleLevelDataAsset, TaskRequests) == 0x000060, "Member 'UMoleLevelDataAsset::TaskRequests' has a wrong offset!");

// Class MoleGameRuntime.MoleLevelBalanceDataAsset
// 0x0020 (0x0050 - 0x0030)
class UMoleLevelBalanceDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<TSoftObjectPtr<class UDataTable>>      DataTables;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCurveTable>>     CurveTables;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleLevelBalanceDataAsset">();
	}
	static class UMoleLevelBalanceDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleLevelBalanceDataAsset>();
	}
};
static_assert(alignof(UMoleLevelBalanceDataAsset) == 0x000008, "Wrong alignment on UMoleLevelBalanceDataAsset");
static_assert(sizeof(UMoleLevelBalanceDataAsset) == 0x000050, "Wrong size on UMoleLevelBalanceDataAsset");
static_assert(offsetof(UMoleLevelBalanceDataAsset, DataTables) == 0x000030, "Member 'UMoleLevelBalanceDataAsset::DataTables' has a wrong offset!");
static_assert(offsetof(UMoleLevelBalanceDataAsset, CurveTables) == 0x000040, "Member 'UMoleLevelBalanceDataAsset::CurveTables' has a wrong offset!");

// Class MoleGameRuntime.MoleLevelManagerComponent
// 0x0048 (0x00E8 - 0x00A0)
class UMoleLevelManagerComponent final : public UPlayspaceComponent
{
public:
	struct FGameplayTagContainer                  DesiredMapDescription;                             // 0x00A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UMoleLevelDataAsset*                    CurrentLevelData;                                  // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleLevelManagerComponent">();
	}
	static class UMoleLevelManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleLevelManagerComponent>();
	}
};
static_assert(alignof(UMoleLevelManagerComponent) == 0x000008, "Wrong alignment on UMoleLevelManagerComponent");
static_assert(sizeof(UMoleLevelManagerComponent) == 0x0000E8, "Wrong size on UMoleLevelManagerComponent");
static_assert(offsetof(UMoleLevelManagerComponent, DesiredMapDescription) == 0x0000A0, "Member 'UMoleLevelManagerComponent::DesiredMapDescription' has a wrong offset!");
static_assert(offsetof(UMoleLevelManagerComponent, CurrentLevelData) == 0x0000C0, "Member 'UMoleLevelManagerComponent::CurrentLevelData' has a wrong offset!");

// Class MoleGameRuntime.MoleLobbyStateMachine
// 0x0038 (0x00E8 - 0x00B0)
class UMoleLobbyStateMachine final : public UGameplayStateMachine
{
public:
	uint8                                         Pad_B0[0x38];                                      // 0x00B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleLobbyStateMachine">();
	}
	static class UMoleLobbyStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleLobbyStateMachine>();
	}
};
static_assert(alignof(UMoleLobbyStateMachine) == 0x000008, "Wrong alignment on UMoleLobbyStateMachine");
static_assert(sizeof(UMoleLobbyStateMachine) == 0x0000E8, "Wrong size on UMoleLobbyStateMachine");

// Class MoleGameRuntime.MoleLobbyState_Countdown
// 0x0010 (0x0088 - 0x0078)
class UMoleLobbyState_Countdown final : public UGameplayState
{
public:
	float                                         LobbyTransitionServerTime;                         // 0x0078(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0xC];                                       // 0x007C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LobbyTransitionServerTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleLobbyState_Countdown">();
	}
	static class UMoleLobbyState_Countdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleLobbyState_Countdown>();
	}
};
static_assert(alignof(UMoleLobbyState_Countdown) == 0x000008, "Wrong alignment on UMoleLobbyState_Countdown");
static_assert(sizeof(UMoleLobbyState_Countdown) == 0x000088, "Wrong size on UMoleLobbyState_Countdown");
static_assert(offsetof(UMoleLobbyState_Countdown, LobbyTransitionServerTime) == 0x000078, "Member 'UMoleLobbyState_Countdown::LobbyTransitionServerTime' has a wrong offset!");

// Class MoleGameRuntime.MoleLobbyState_Loading
// 0x0008 (0x0080 - 0x0078)
class UMoleLobbyState_Loading final : public UGameplayState
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleLobbyState_Loading">();
	}
	static class UMoleLobbyState_Loading* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleLobbyState_Loading>();
	}
};
static_assert(alignof(UMoleLobbyState_Loading) == 0x000008, "Wrong alignment on UMoleLobbyState_Loading");
static_assert(sizeof(UMoleLobbyState_Loading) == 0x000080, "Wrong size on UMoleLobbyState_Loading");

// Class MoleGameRuntime.MoleLobbyState_Login
// 0x0008 (0x0080 - 0x0078)
class UMoleLobbyState_Login final : public UGameplayState
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleLobbyState_Login">();
	}
	static class UMoleLobbyState_Login* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleLobbyState_Login>();
	}
};
static_assert(alignof(UMoleLobbyState_Login) == 0x000008, "Wrong alignment on UMoleLobbyState_Login");
static_assert(sizeof(UMoleLobbyState_Login) == 0x000080, "Wrong size on UMoleLobbyState_Login");

// Class MoleGameRuntime.MoleLobbyState_Matchmake
// 0x0008 (0x0080 - 0x0078)
class UMoleLobbyState_Matchmake final : public UGameplayState
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcquiringMorePlayersCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleLobbyState_Matchmake">();
	}
	static class UMoleLobbyState_Matchmake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleLobbyState_Matchmake>();
	}
};
static_assert(alignof(UMoleLobbyState_Matchmake) == 0x000008, "Wrong alignment on UMoleLobbyState_Matchmake");
static_assert(sizeof(UMoleLobbyState_Matchmake) == 0x000080, "Wrong size on UMoleLobbyState_Matchmake");

// Class MoleGameRuntime.MoleLobbyState_Waiting
// 0x0000 (0x0078 - 0x0078)
class UMoleLobbyState_Waiting final : public UGameplayState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleLobbyState_Waiting">();
	}
	static class UMoleLobbyState_Waiting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleLobbyState_Waiting>();
	}
};
static_assert(alignof(UMoleLobbyState_Waiting) == 0x000008, "Wrong alignment on UMoleLobbyState_Waiting");
static_assert(sizeof(UMoleLobbyState_Waiting) == 0x000078, "Wrong size on UMoleLobbyState_Waiting");

// Class MoleGameRuntime.MolePawnComponent
// 0x0050 (0x00F0 - 0x00A0)
class UMolePawnComponent final : public UPawnComponent
{
public:
	class FName                                   MaterialOpacityParameter;                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     GhostMaterial;                                     // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortFootstepAudioBank*                 PlayerFootstepBankBase;                            // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerFootstepBankPriority;                        // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortCharacterCustomizationData*        BaseCustomizationData;                             // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortCharacterCustomizationData*        GhostCustomizationData;                            // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x14];                                      // 0x00D0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsGhost;                                          // 0x00E4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GhostCollisionProfile;                             // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePawnCustomizationComplete(class AFortPlayerPawn* Pawn);
	void OnBecameGhost();
	void OnBecameHuman();
	void OnRep_bIsGhost();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MolePawnComponent">();
	}
	static class UMolePawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMolePawnComponent>();
	}
};
static_assert(alignof(UMolePawnComponent) == 0x000008, "Wrong alignment on UMolePawnComponent");
static_assert(sizeof(UMolePawnComponent) == 0x0000F0, "Wrong size on UMolePawnComponent");
static_assert(offsetof(UMolePawnComponent, MaterialOpacityParameter) == 0x0000A0, "Member 'UMolePawnComponent::MaterialOpacityParameter' has a wrong offset!");
static_assert(offsetof(UMolePawnComponent, GhostMaterial) == 0x0000A8, "Member 'UMolePawnComponent::GhostMaterial' has a wrong offset!");
static_assert(offsetof(UMolePawnComponent, PlayerFootstepBankBase) == 0x0000B0, "Member 'UMolePawnComponent::PlayerFootstepBankBase' has a wrong offset!");
static_assert(offsetof(UMolePawnComponent, PlayerFootstepBankPriority) == 0x0000B8, "Member 'UMolePawnComponent::PlayerFootstepBankPriority' has a wrong offset!");
static_assert(offsetof(UMolePawnComponent, BaseCustomizationData) == 0x0000C0, "Member 'UMolePawnComponent::BaseCustomizationData' has a wrong offset!");
static_assert(offsetof(UMolePawnComponent, GhostCustomizationData) == 0x0000C8, "Member 'UMolePawnComponent::GhostCustomizationData' has a wrong offset!");
static_assert(offsetof(UMolePawnComponent, bIsGhost) == 0x0000E4, "Member 'UMolePawnComponent::bIsGhost' has a wrong offset!");
static_assert(offsetof(UMolePawnComponent, GhostCollisionProfile) == 0x0000E8, "Member 'UMolePawnComponent::GhostCollisionProfile' has a wrong offset!");

// Class MoleGameRuntime.MolePerformanceComponent
// 0x0000 (0x00A0 - 0x00A0)
class UMolePerformanceComponent final : public UPlayspaceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MolePerformanceComponent">();
	}
	static class UMolePerformanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMolePerformanceComponent>();
	}
};
static_assert(alignof(UMolePerformanceComponent) == 0x000008, "Wrong alignment on UMolePerformanceComponent");
static_assert(sizeof(UMolePerformanceComponent) == 0x0000A0, "Wrong size on UMolePerformanceComponent");

// Class MoleGameRuntime.MolePlayerControllerComponent
// 0x0050 (0x00F0 - 0x00A0)
class UMolePlayerControllerComponent final : public UControllerComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        MoleCoreInputComp;                                 // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortPlayerInputSettings*               MoleKBMInputSettings;                              // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortPlayerInputSettings*               MoleControllerInputSettings;                       // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             BindingsDataTable;                                 // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x28];                                      // 0x00C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MolePlayerControllerComponent">();
	}
	static class UMolePlayerControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMolePlayerControllerComponent>();
	}
};
static_assert(alignof(UMolePlayerControllerComponent) == 0x000008, "Wrong alignment on UMolePlayerControllerComponent");
static_assert(sizeof(UMolePlayerControllerComponent) == 0x0000F0, "Wrong size on UMolePlayerControllerComponent");
static_assert(offsetof(UMolePlayerControllerComponent, MoleCoreInputComp) == 0x0000A8, "Member 'UMolePlayerControllerComponent::MoleCoreInputComp' has a wrong offset!");
static_assert(offsetof(UMolePlayerControllerComponent, MoleKBMInputSettings) == 0x0000B0, "Member 'UMolePlayerControllerComponent::MoleKBMInputSettings' has a wrong offset!");
static_assert(offsetof(UMolePlayerControllerComponent, MoleControllerInputSettings) == 0x0000B8, "Member 'UMolePlayerControllerComponent::MoleControllerInputSettings' has a wrong offset!");
static_assert(offsetof(UMolePlayerControllerComponent, BindingsDataTable) == 0x0000C0, "Member 'UMolePlayerControllerComponent::BindingsDataTable' has a wrong offset!");

// Class MoleGameRuntime.MolePlayerStart
// 0x0008 (0x02E8 - 0x02E0)
class AMolePlayerStart final : public AFortPlayerStart
{
public:
	int32                                         CorrespondingPlayerNumber;                         // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MolePlayerStart">();
	}
	static class AMolePlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMolePlayerStart>();
	}
};
static_assert(alignof(AMolePlayerStart) == 0x000008, "Wrong alignment on AMolePlayerStart");
static_assert(sizeof(AMolePlayerStart) == 0x0002E8, "Wrong size on AMolePlayerStart");
static_assert(offsetof(AMolePlayerStart, CorrespondingPlayerNumber) == 0x0002E0, "Member 'AMolePlayerStart::CorrespondingPlayerNumber' has a wrong offset!");

// Class MoleGameRuntime.MolePlayerStateComponent
// 0x00D0 (0x0170 - 0x00A0)
class UMolePlayerStateComponent final : public UPlayerStateComponent
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPlayerBecameGhost;                               // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         PlayerNumber;                                      // 0x00E0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMoleDeathInformation                  DeathInfo;                                         // 0x00E4(0x0002)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GhostGameplayEffect;                               // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMoleEliminationMarker>     EliminationMarkerClass;                            // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EMoleRole                                     Role;                                              // 0x0100(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerState*>                   EnemyPlayerStates;                                 // 0x0108(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsRevealedEnemy;                                  // 0x0118(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasLeftGame;                                      // 0x0119(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           KillerPlayerState;                                 // 0x0120(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GhostBlockedAbilityTags;                           // 0x0128(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FMolePlayerTeleportedReplicatedData    PlayerTeleportedData;                              // 0x0148(0x0008)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x20];                                     // 0x0150(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BlueprintSetIsPlayerGhost(class APlayerState* PlayerState, bool bIsPlayerGhost);
	static void GetMolePlayerCosmeticData(class APlayerState* PlayerState, struct FMolePlayerCosmeticData* OutPlayerCosmeticData);
	static const class UFortItemDefinition* GetMolePlayerItemDefinition(class APlayerState* PlayerState);
	static EMoleRole GetMoleRole(class AController* User);
	static bool IsMoleEliminated(const class APlayerState* PlayerState);
	static bool IsMoleEnemy(const class AActor* InActor);
	static bool IsMoleEnemyFor(const class APlayerState* PlayerState, const class APlayerState* TargetPlayerState);
	static bool IsMoleGhost(const class APlayerState* PlayerState);
	static bool IsMolePlayerDisconnected(const class APlayerState* PlayerState);
	static void SetMoleKiller(class APlayerState* Victim, class APlayerState* Killer);

	void OnRep_bHasLeftGame();
	void OnRep_bIsRevealedEnemy();
	void OnRep_DeathInfo();
	void OnRep_EnemyPlayerStates();
	void OnRep_KillerPlayerState();
	void OnRep_PlayerNumber();
	void OnRep_PlayerTeleportedData();
	void OnRep_Role();

	int32 GetPlayerNumber() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MolePlayerStateComponent">();
	}
	static class UMolePlayerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMolePlayerStateComponent>();
	}
};
static_assert(alignof(UMolePlayerStateComponent) == 0x000008, "Wrong alignment on UMolePlayerStateComponent");
static_assert(sizeof(UMolePlayerStateComponent) == 0x000170, "Wrong size on UMolePlayerStateComponent");
static_assert(offsetof(UMolePlayerStateComponent, OnPlayerBecameGhost) == 0x0000D0, "Member 'UMolePlayerStateComponent::OnPlayerBecameGhost' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, PlayerNumber) == 0x0000E0, "Member 'UMolePlayerStateComponent::PlayerNumber' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, DeathInfo) == 0x0000E4, "Member 'UMolePlayerStateComponent::DeathInfo' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, GhostGameplayEffect) == 0x0000E8, "Member 'UMolePlayerStateComponent::GhostGameplayEffect' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, EliminationMarkerClass) == 0x0000F0, "Member 'UMolePlayerStateComponent::EliminationMarkerClass' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, Role) == 0x000100, "Member 'UMolePlayerStateComponent::Role' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, EnemyPlayerStates) == 0x000108, "Member 'UMolePlayerStateComponent::EnemyPlayerStates' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, bIsRevealedEnemy) == 0x000118, "Member 'UMolePlayerStateComponent::bIsRevealedEnemy' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, bHasLeftGame) == 0x000119, "Member 'UMolePlayerStateComponent::bHasLeftGame' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, KillerPlayerState) == 0x000120, "Member 'UMolePlayerStateComponent::KillerPlayerState' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, GhostBlockedAbilityTags) == 0x000128, "Member 'UMolePlayerStateComponent::GhostBlockedAbilityTags' has a wrong offset!");
static_assert(offsetof(UMolePlayerStateComponent, PlayerTeleportedData) == 0x000148, "Member 'UMolePlayerStateComponent::PlayerTeleportedData' has a wrong offset!");

// Class MoleGameRuntime.MolePlayerTaskManagementComponent
// 0x0320 (0x03C0 - 0x00A0)
class UMolePlayerTaskManagementComponent final : public UControllerComponent
{
public:
	struct FMoleActiveTaskStateArray              MoleActiveTaskStateArray;                          // 0x00A0(0x0148)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FMoleCompletedTaskArray                MoleCompletedTaskArray;                            // 0x01E8(0x0130)(Net, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMoleTaskLeashData>             MoleCollisionLeashes;                              // 0x0318(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMoleTaskLeashData>             MoleDistanceLeashes;                               // 0x0328(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           LeashTimerHandle;                                  // 0x0338(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMoleActiveTaskStateHandle             PrimaryActiveTaskHandle;                           // 0x0340(0x0004)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        ActiveTaskInputComponent;                          // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CancelPrimaryTaskTimerHandle;                      // 0x0350(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueTag                        TaskCompletionGameplayCue;                         // 0x0360(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        TaskInterruptionGameplayCue;                       // 0x0364(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bTasksDisabledBySabotage : 1;                      // 0x0368(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetingPreset*                       EnemyTrackingTargetingPreset;                      // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTargetingRequestHandle                AsyncTargetingHandle;                              // 0x0378(0x0004)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BestEnemyTarget;                                   // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x38];                                     // 0x0388(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool BlueprintServerTaskObjectInteractEvent(class AController* User, const struct FEventMessageTag& EventMessageTag, const struct FTaskGenericPayload& Payload);
	static void CompleteTaskForGameplayState(class UGameplayState* State);

	void ClientAdvanceLogicThroughPhases(class UMoleTaskLogic* Logic, const TArray<int32>& AdvancedPhases);
	void ClientAllTasksEnabled();
	void ClientAllTasksInterrupted(EMoleTaskInterruptionType InterruptionType);
	void ClientSetPrimaryActiveTask(const struct FMoleActiveTaskStateHandle& NewPrimaryHandle);
	void ClientTasksInterrupted(const TArray<class UMoleTaskDataAsset*>& TasksInterrupted, EMoleTaskInterruptionType InterruptionType);
	void OnCompletedTaskAdded(const struct FMoleCompletedTask& InAddedCompletedTask);
	void OnLeashActorEndOverlap(class AActor* OriginatingActor, class AActor* ActorEndingOverlap);
	void ServerRequestCancelPrimaryActiveTask();
	void ServerTaskObjectInteractEvent(const struct FEventMessageTag& EventMessageTag, const struct FTaskGenericPayload& Payload);

	int32 GetNumCompletedTasks() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MolePlayerTaskManagementComponent">();
	}
	static class UMolePlayerTaskManagementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMolePlayerTaskManagementComponent>();
	}
};
static_assert(alignof(UMolePlayerTaskManagementComponent) == 0x000008, "Wrong alignment on UMolePlayerTaskManagementComponent");
static_assert(sizeof(UMolePlayerTaskManagementComponent) == 0x0003C0, "Wrong size on UMolePlayerTaskManagementComponent");
static_assert(offsetof(UMolePlayerTaskManagementComponent, MoleActiveTaskStateArray) == 0x0000A0, "Member 'UMolePlayerTaskManagementComponent::MoleActiveTaskStateArray' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, MoleCompletedTaskArray) == 0x0001E8, "Member 'UMolePlayerTaskManagementComponent::MoleCompletedTaskArray' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, MoleCollisionLeashes) == 0x000318, "Member 'UMolePlayerTaskManagementComponent::MoleCollisionLeashes' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, MoleDistanceLeashes) == 0x000328, "Member 'UMolePlayerTaskManagementComponent::MoleDistanceLeashes' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, LeashTimerHandle) == 0x000338, "Member 'UMolePlayerTaskManagementComponent::LeashTimerHandle' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, PrimaryActiveTaskHandle) == 0x000340, "Member 'UMolePlayerTaskManagementComponent::PrimaryActiveTaskHandle' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, ActiveTaskInputComponent) == 0x000348, "Member 'UMolePlayerTaskManagementComponent::ActiveTaskInputComponent' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, CancelPrimaryTaskTimerHandle) == 0x000350, "Member 'UMolePlayerTaskManagementComponent::CancelPrimaryTaskTimerHandle' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, TaskCompletionGameplayCue) == 0x000360, "Member 'UMolePlayerTaskManagementComponent::TaskCompletionGameplayCue' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, TaskInterruptionGameplayCue) == 0x000364, "Member 'UMolePlayerTaskManagementComponent::TaskInterruptionGameplayCue' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, EnemyTrackingTargetingPreset) == 0x000370, "Member 'UMolePlayerTaskManagementComponent::EnemyTrackingTargetingPreset' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, AsyncTargetingHandle) == 0x000378, "Member 'UMolePlayerTaskManagementComponent::AsyncTargetingHandle' has a wrong offset!");
static_assert(offsetof(UMolePlayerTaskManagementComponent, BestEnemyTarget) == 0x000380, "Member 'UMolePlayerTaskManagementComponent::BestEnemyTarget' has a wrong offset!");

// Class MoleGameRuntime.MolePlayerVisibilityManagerComponent
// 0x0018 (0x00B8 - 0x00A0)
class UMolePlayerVisibilityManagerComponent final : public UPlayspaceComponent
{
public:
	TArray<class APawn*>                          Ghosts;                                            // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MolePlayerVisibilityManagerComponent">();
	}
	static class UMolePlayerVisibilityManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMolePlayerVisibilityManagerComponent>();
	}
};
static_assert(alignof(UMolePlayerVisibilityManagerComponent) == 0x000008, "Wrong alignment on UMolePlayerVisibilityManagerComponent");
static_assert(sizeof(UMolePlayerVisibilityManagerComponent) == 0x0000B8, "Wrong size on UMolePlayerVisibilityManagerComponent");
static_assert(offsetof(UMolePlayerVisibilityManagerComponent, Ghosts) == 0x0000A0, "Member 'UMolePlayerVisibilityManagerComponent::Ghosts' has a wrong offset!");

// Class MoleGameRuntime.MoleQuestComponent
// 0x0008 (0x00A8 - 0x00A0)
class UMoleQuestComponent final : public UPlayspaceComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleQuestComponent">();
	}
	static class UMoleQuestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleQuestComponent>();
	}
};
static_assert(alignof(UMoleQuestComponent) == 0x000008, "Wrong alignment on UMoleQuestComponent");
static_assert(sizeof(UMoleQuestComponent) == 0x0000A8, "Wrong size on UMoleQuestComponent");

// Class MoleGameRuntime.MoleQuickChatComponent
// 0x0048 (0x00E8 - 0x00A0)
class UMoleQuickChatComponent final : public UPlayerStateComponent
{
public:
	float                                         MinimumTimeBetweenSend;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMoleQuickChatMessageInfo              MessageInfo;                                       // 0x00A8(0x0040)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_MessageInfo();
	void ServerSendMessage(const struct FMoleQuickChatMessageInfo& Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleQuickChatComponent">();
	}
	static class UMoleQuickChatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleQuickChatComponent>();
	}
};
static_assert(alignof(UMoleQuickChatComponent) == 0x000008, "Wrong alignment on UMoleQuickChatComponent");
static_assert(sizeof(UMoleQuickChatComponent) == 0x0000E8, "Wrong size on UMoleQuickChatComponent");
static_assert(offsetof(UMoleQuickChatComponent, MinimumTimeBetweenSend) == 0x0000A0, "Member 'UMoleQuickChatComponent::MinimumTimeBetweenSend' has a wrong offset!");
static_assert(offsetof(UMoleQuickChatComponent, MessageInfo) == 0x0000A8, "Member 'UMoleQuickChatComponent::MessageInfo' has a wrong offset!");

// Class MoleGameRuntime.MoleReplicationGraphNode
// 0x0030 (0x0080 - 0x0050)
class UMoleReplicationGraphNode final : public UFortReplicationGraphNode_Custom
{
public:
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APawn*>                          AllPlayers;                                        // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleReplicationGraphNode">();
	}
	static class UMoleReplicationGraphNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleReplicationGraphNode>();
	}
};
static_assert(alignof(UMoleReplicationGraphNode) == 0x000008, "Wrong alignment on UMoleReplicationGraphNode");
static_assert(sizeof(UMoleReplicationGraphNode) == 0x000080, "Wrong size on UMoleReplicationGraphNode");
static_assert(offsetof(UMoleReplicationGraphNode, AllPlayers) == 0x000070, "Member 'UMoleReplicationGraphNode::AllPlayers' has a wrong offset!");

// Class MoleGameRuntime.MoleSabotageAbility
// 0x0050 (0x0B60 - 0x0B10)
class UMoleSabotageAbility : public UFortGameplayAbility
{
public:
	struct FGameplayTag                           SabotageTag;                                       // 0x0B10(0x0004)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B14[0x4];                                      // 0x0B14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CooldownTagsToListenTo;                            // 0x0B18(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CombinedCooldownTags;                              // 0x0B38(0x0020)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	EMoleSabotageInterruptionType                 InterruptionType;                                  // 0x0B58(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B59[0x3];                                      // 0x0B59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEventMessageTag                       SabotageEventMessageTag;                           // 0x0B5C(0x0004)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSabotageInterruptedEvent();
	void OnSabotageResumedEvent();
	void RevertSabotageForPlayer(class APlayerState* Player);

	void GetAllSaboteurs(TArray<class APlayerState*>* OutAllSaboteurs) const;
	void GetAllValidSabotageTargets(TArray<class APlayerState*>* OutValidTargets) const;
	EMoleSabotageInterruptionType GetInterruptionType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleSabotageAbility">();
	}
	static class UMoleSabotageAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleSabotageAbility>();
	}
};
static_assert(alignof(UMoleSabotageAbility) == 0x000008, "Wrong alignment on UMoleSabotageAbility");
static_assert(sizeof(UMoleSabotageAbility) == 0x000B60, "Wrong size on UMoleSabotageAbility");
static_assert(offsetof(UMoleSabotageAbility, SabotageTag) == 0x000B10, "Member 'UMoleSabotageAbility::SabotageTag' has a wrong offset!");
static_assert(offsetof(UMoleSabotageAbility, CooldownTagsToListenTo) == 0x000B18, "Member 'UMoleSabotageAbility::CooldownTagsToListenTo' has a wrong offset!");
static_assert(offsetof(UMoleSabotageAbility, CombinedCooldownTags) == 0x000B38, "Member 'UMoleSabotageAbility::CombinedCooldownTags' has a wrong offset!");
static_assert(offsetof(UMoleSabotageAbility, InterruptionType) == 0x000B58, "Member 'UMoleSabotageAbility::InterruptionType' has a wrong offset!");
static_assert(offsetof(UMoleSabotageAbility, SabotageEventMessageTag) == 0x000B5C, "Member 'UMoleSabotageAbility::SabotageEventMessageTag' has a wrong offset!");

// Class MoleGameRuntime.MoleSabotageData
// 0x0058 (0x0088 - 0x0030)
class UMoleSabotageData final : public UPrimaryDataAsset
{
public:
	struct FGameplayTagContainer                  SabotageTags;                                      // 0x0030(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           GrantedAbilities;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWorld>>          AdditionalLevels;                                  // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bCanBeFixed;                                       // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UMoleTaskDataAsset>> FixTasks;                                          // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleSabotageData">();
	}
	static class UMoleSabotageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleSabotageData>();
	}
};
static_assert(alignof(UMoleSabotageData) == 0x000008, "Wrong alignment on UMoleSabotageData");
static_assert(sizeof(UMoleSabotageData) == 0x000088, "Wrong size on UMoleSabotageData");
static_assert(offsetof(UMoleSabotageData, SabotageTags) == 0x000030, "Member 'UMoleSabotageData::SabotageTags' has a wrong offset!");
static_assert(offsetof(UMoleSabotageData, GrantedAbilities) == 0x000050, "Member 'UMoleSabotageData::GrantedAbilities' has a wrong offset!");
static_assert(offsetof(UMoleSabotageData, AdditionalLevels) == 0x000060, "Member 'UMoleSabotageData::AdditionalLevels' has a wrong offset!");
static_assert(offsetof(UMoleSabotageData, bCanBeFixed) == 0x000070, "Member 'UMoleSabotageData::bCanBeFixed' has a wrong offset!");
static_assert(offsetof(UMoleSabotageData, FixTasks) == 0x000078, "Member 'UMoleSabotageData::FixTasks' has a wrong offset!");

// Class MoleGameRuntime.MoleSabotageManagerComponent
// 0x0130 (0x01D0 - 0x00A0)
class UMoleSabotageManagerComponent final : public UPlayspaceComponent
{
public:
	TSubclassOf<class UGameplayEffect>            RoundStartCooldownEffect;                          // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            RoundStartCooldownEffectForElimination;            // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            AfterUseCooldownEffect;                            // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAbilitySet*                        SaboteurAbilitySet;                                // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class APlayerState*, struct FFortAbilitySetHandle> SaboteurAbilitySetHandles;                         // 0x00C0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class APlayerState*, struct FGuid>       SaboteurAbilitySetInputGuids;                      // 0x0110(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAbilitySpecHandle>     ActiveSabotageHandles;                             // 0x0160(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FEventMessageTag> SabotageToEventTag;                                // 0x0170(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FMoleSabotageStatus                    CurrentSabotageStatus;                             // 0x01C0(0x0008)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMoleTimerInfo                         ActiveSabotageTimerInfo;                           // 0x01C8(0x0004)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMoleLightingMode                      CurrentLightingMode;                               // 0x01CC(0x0001)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SendMoleLightingModeChangeEvent(const class UMoleSabotageAbility* SabotageAbility, const struct FMoleLightingMode& LightingMode);
	static void SendMoleSabotageTimerStartedEvent(const class UMoleSabotageAbility* SabotageAbility, const struct FMoleTimerInfo& TimerInfo);

	void OnRep_ActiveSabotageTimerInfo();
	void OnRep_CurrentLightingMode();
	void OnRep_CurrentSabotageStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleSabotageManagerComponent">();
	}
	static class UMoleSabotageManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleSabotageManagerComponent>();
	}
};
static_assert(alignof(UMoleSabotageManagerComponent) == 0x000008, "Wrong alignment on UMoleSabotageManagerComponent");
static_assert(sizeof(UMoleSabotageManagerComponent) == 0x0001D0, "Wrong size on UMoleSabotageManagerComponent");
static_assert(offsetof(UMoleSabotageManagerComponent, RoundStartCooldownEffect) == 0x0000A0, "Member 'UMoleSabotageManagerComponent::RoundStartCooldownEffect' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, RoundStartCooldownEffectForElimination) == 0x0000A8, "Member 'UMoleSabotageManagerComponent::RoundStartCooldownEffectForElimination' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, AfterUseCooldownEffect) == 0x0000B0, "Member 'UMoleSabotageManagerComponent::AfterUseCooldownEffect' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, SaboteurAbilitySet) == 0x0000B8, "Member 'UMoleSabotageManagerComponent::SaboteurAbilitySet' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, SaboteurAbilitySetHandles) == 0x0000C0, "Member 'UMoleSabotageManagerComponent::SaboteurAbilitySetHandles' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, SaboteurAbilitySetInputGuids) == 0x000110, "Member 'UMoleSabotageManagerComponent::SaboteurAbilitySetInputGuids' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, ActiveSabotageHandles) == 0x000160, "Member 'UMoleSabotageManagerComponent::ActiveSabotageHandles' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, SabotageToEventTag) == 0x000170, "Member 'UMoleSabotageManagerComponent::SabotageToEventTag' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, CurrentSabotageStatus) == 0x0001C0, "Member 'UMoleSabotageManagerComponent::CurrentSabotageStatus' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, ActiveSabotageTimerInfo) == 0x0001C8, "Member 'UMoleSabotageManagerComponent::ActiveSabotageTimerInfo' has a wrong offset!");
static_assert(offsetof(UMoleSabotageManagerComponent, CurrentLightingMode) == 0x0001CC, "Member 'UMoleSabotageManagerComponent::CurrentLightingMode' has a wrong offset!");

// Class MoleGameRuntime.MoleStateMachine
// 0x0078 (0x0128 - 0x00B0)
class UMoleStateMachine final : public UGameplayStateMachine
{
public:
	struct FScalableFloat                         PlayerCountToEnemyIncrement;                       // 0x00B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UMolePlayerStateComponent>  MolePlayerStateComponentClass;                     // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class APlayerState*>                   EnemyPlayerStates;                                 // 0x00E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FMoleStateGameOverEventData            MoleStateGameOverEventData;                        // 0x00F0(0x0018)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RemainingSaboteurs;                                // 0x0120(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StartOfMatchPlayerCount;                           // 0x0124(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static int32 GetMoleRemainingSaboteurCount(class APlayerController* ContextPlayer);
	static int32 GetMoleStartOfMatchPlayerCount(class APlayerController* ContextPlayer);
	static int32 GetMoleStartOfMatchPlayerCountForPlayspace(class AMoleGamePlayspace* PlayspaceContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleStateMachine">();
	}
	static class UMoleStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleStateMachine>();
	}
};
static_assert(alignof(UMoleStateMachine) == 0x000008, "Wrong alignment on UMoleStateMachine");
static_assert(sizeof(UMoleStateMachine) == 0x000128, "Wrong size on UMoleStateMachine");
static_assert(offsetof(UMoleStateMachine, PlayerCountToEnemyIncrement) == 0x0000B0, "Member 'UMoleStateMachine::PlayerCountToEnemyIncrement' has a wrong offset!");
static_assert(offsetof(UMoleStateMachine, MolePlayerStateComponentClass) == 0x0000D8, "Member 'UMoleStateMachine::MolePlayerStateComponentClass' has a wrong offset!");
static_assert(offsetof(UMoleStateMachine, EnemyPlayerStates) == 0x0000E0, "Member 'UMoleStateMachine::EnemyPlayerStates' has a wrong offset!");
static_assert(offsetof(UMoleStateMachine, MoleStateGameOverEventData) == 0x0000F0, "Member 'UMoleStateMachine::MoleStateGameOverEventData' has a wrong offset!");
static_assert(offsetof(UMoleStateMachine, RemainingSaboteurs) == 0x000120, "Member 'UMoleStateMachine::RemainingSaboteurs' has a wrong offset!");
static_assert(offsetof(UMoleStateMachine, StartOfMatchPlayerCount) == 0x000124, "Member 'UMoleStateMachine::StartOfMatchPlayerCount' has a wrong offset!");

// Class MoleGameRuntime.MoleState_Gameover
// 0x0028 (0x00A0 - 0x0078)
class UMoleState_Gameover final : public UGameplayState
{
public:
	struct FMoleStateGameOverEventData            MoleStateGameOverEventData;                        // 0x0078(0x0018)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class APlayerState*>                   ImposterPlayerStates;                              // 0x0090(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_ImposterPlayerStates();
	void OnRep_MoleStateGameOverEventData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleState_Gameover">();
	}
	static class UMoleState_Gameover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleState_Gameover>();
	}
};
static_assert(alignof(UMoleState_Gameover) == 0x000008, "Wrong alignment on UMoleState_Gameover");
static_assert(sizeof(UMoleState_Gameover) == 0x0000A0, "Wrong size on UMoleState_Gameover");
static_assert(offsetof(UMoleState_Gameover, MoleStateGameOverEventData) == 0x000078, "Member 'UMoleState_Gameover::MoleStateGameOverEventData' has a wrong offset!");
static_assert(offsetof(UMoleState_Gameover, ImposterPlayerStates) == 0x000090, "Member 'UMoleState_Gameover::ImposterPlayerStates' has a wrong offset!");

// Class MoleGameRuntime.MoleState_Gameplay
// 0x00A0 (0x0150 - 0x00B0)
class UMoleState_Gameplay final : public UGameplayStateMachine
{
public:
	struct FMoleEmergencyMeetingData              LastSummonedEmergencyMeetingData;                  // 0x00B0(0x0020)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AMoleGhostMannequin>        GhostMannequinProxyClass;                          // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GhostMannequinLocationOffset;                      // 0x00D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               GhostMannequinRotationOffset;                      // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AbilityTagsToBlockInMeeting;                       // 0x0108(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class APlayerState*>                   FreshlyKilledGhosts;                               // 0x0128(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AMoleGhostMannequin*>            DeadGhostProxies;                                  // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bEmergencyMeetingActive;                           // 0x0148(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetAllMoleFreshlyKilledGhosts(class APlayerController* PlayerContext, TArray<class APlayerState*>* OutFreshlyKilledGhosts);
	static bool RequestEmergencyMeeting(class AActor* ActorContext, const struct FMoleEmergencyMeetingData& MeetingData);

	void HandlePlayerStateDied(class APlayerState* GhostPlayerState);
	void HandleScoreChanged(const struct FEventMessageTag& EventChannel, const struct FMoleTaskScoreEventData& ScoreEventData);
	void OnRep_LastSummonedEmergencyMeetingData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleState_Gameplay">();
	}
	static class UMoleState_Gameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleState_Gameplay>();
	}
};
static_assert(alignof(UMoleState_Gameplay) == 0x000008, "Wrong alignment on UMoleState_Gameplay");
static_assert(sizeof(UMoleState_Gameplay) == 0x000150, "Wrong size on UMoleState_Gameplay");
static_assert(offsetof(UMoleState_Gameplay, LastSummonedEmergencyMeetingData) == 0x0000B0, "Member 'UMoleState_Gameplay::LastSummonedEmergencyMeetingData' has a wrong offset!");
static_assert(offsetof(UMoleState_Gameplay, GhostMannequinProxyClass) == 0x0000D0, "Member 'UMoleState_Gameplay::GhostMannequinProxyClass' has a wrong offset!");
static_assert(offsetof(UMoleState_Gameplay, GhostMannequinLocationOffset) == 0x0000D8, "Member 'UMoleState_Gameplay::GhostMannequinLocationOffset' has a wrong offset!");
static_assert(offsetof(UMoleState_Gameplay, GhostMannequinRotationOffset) == 0x0000F0, "Member 'UMoleState_Gameplay::GhostMannequinRotationOffset' has a wrong offset!");
static_assert(offsetof(UMoleState_Gameplay, AbilityTagsToBlockInMeeting) == 0x000108, "Member 'UMoleState_Gameplay::AbilityTagsToBlockInMeeting' has a wrong offset!");
static_assert(offsetof(UMoleState_Gameplay, FreshlyKilledGhosts) == 0x000128, "Member 'UMoleState_Gameplay::FreshlyKilledGhosts' has a wrong offset!");
static_assert(offsetof(UMoleState_Gameplay, DeadGhostProxies) == 0x000138, "Member 'UMoleState_Gameplay::DeadGhostProxies' has a wrong offset!");
static_assert(offsetof(UMoleState_Gameplay, bEmergencyMeetingActive) == 0x000148, "Member 'UMoleState_Gameplay::bEmergencyMeetingActive' has a wrong offset!");

// Class MoleGameRuntime.MoleState_Setup
// 0x0000 (0x0078 - 0x0078)
class UMoleState_Setup final : public UGameplayState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleState_Setup">();
	}
	static class UMoleState_Setup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleState_Setup>();
	}
};
static_assert(alignof(UMoleState_Setup) == 0x000008, "Wrong alignment on UMoleState_Setup");
static_assert(sizeof(UMoleState_Setup) == 0x000078, "Wrong size on UMoleState_Setup");

// Class MoleGameRuntime.MoleSupplyDropSabotageAbility
// 0x0058 (0x0BB8 - 0x0B60)
class UMoleSupplyDropSabotageAbility final : public UMoleSabotageAbility
{
public:
	uint8                                         Pad_B60[0x8];                                      // 0x0B60(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         NumberOfPointsToFix;                               // 0x0B68(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMoleActiveTaskStateHandle>     FixTaskHandles;                                    // 0x0B90(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   InteractionInfoRowName;                            // 0x0BA0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA4[0x4];                                      // 0x0BA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMoleTaskLinkComponent*>         ChosenFixPoints;                                   // 0x0BA8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void HandleFixPointInteracted(class UMoleTaskLinkComponent* TaskLinkComponent, const class AFortPawn* InteractingPawn, EInteractionBeingAttempted InteractionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleSupplyDropSabotageAbility">();
	}
	static class UMoleSupplyDropSabotageAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleSupplyDropSabotageAbility>();
	}
};
static_assert(alignof(UMoleSupplyDropSabotageAbility) == 0x000008, "Wrong alignment on UMoleSupplyDropSabotageAbility");
static_assert(sizeof(UMoleSupplyDropSabotageAbility) == 0x000BB8, "Wrong size on UMoleSupplyDropSabotageAbility");
static_assert(offsetof(UMoleSupplyDropSabotageAbility, NumberOfPointsToFix) == 0x000B68, "Member 'UMoleSupplyDropSabotageAbility::NumberOfPointsToFix' has a wrong offset!");
static_assert(offsetof(UMoleSupplyDropSabotageAbility, FixTaskHandles) == 0x000B90, "Member 'UMoleSupplyDropSabotageAbility::FixTaskHandles' has a wrong offset!");
static_assert(offsetof(UMoleSupplyDropSabotageAbility, InteractionInfoRowName) == 0x000BA0, "Member 'UMoleSupplyDropSabotageAbility::InteractionInfoRowName' has a wrong offset!");
static_assert(offsetof(UMoleSupplyDropSabotageAbility, ChosenFixPoints) == 0x000BA8, "Member 'UMoleSupplyDropSabotageAbility::ChosenFixPoints' has a wrong offset!");

// Class MoleGameRuntime.MoleTargetingSelectionTask_BaseMoleTrace
// 0x0008 (0x00C0 - 0x00B8)
class UMoleTargetingSelectionTask_BaseMoleTrace final : public UTargetingSelectionTask_Trace
{
public:
	EFortAbilityTargetingSource                   PawnTargetingSource;                               // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreKnownSaboteurs : 1;                         // 0x00B9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreGhosts : 1;                                 // 0x00B9(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTargetingSelectionTask_BaseMoleTrace">();
	}
	static class UMoleTargetingSelectionTask_BaseMoleTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTargetingSelectionTask_BaseMoleTrace>();
	}
};
static_assert(alignof(UMoleTargetingSelectionTask_BaseMoleTrace) == 0x000008, "Wrong alignment on UMoleTargetingSelectionTask_BaseMoleTrace");
static_assert(sizeof(UMoleTargetingSelectionTask_BaseMoleTrace) == 0x0000C0, "Wrong size on UMoleTargetingSelectionTask_BaseMoleTrace");
static_assert(offsetof(UMoleTargetingSelectionTask_BaseMoleTrace, PawnTargetingSource) == 0x0000B8, "Member 'UMoleTargetingSelectionTask_BaseMoleTrace::PawnTargetingSource' has a wrong offset!");

// Class MoleGameRuntime.MoleTargetingSelectionTask_BestEnemyTarget
// 0x0000 (0x0028 - 0x0028)
class UMoleTargetingSelectionTask_BestEnemyTarget final : public UTargetingTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTargetingSelectionTask_BestEnemyTarget">();
	}
	static class UMoleTargetingSelectionTask_BestEnemyTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTargetingSelectionTask_BestEnemyTarget>();
	}
};
static_assert(alignof(UMoleTargetingSelectionTask_BestEnemyTarget) == 0x000008, "Wrong alignment on UMoleTargetingSelectionTask_BestEnemyTarget");
static_assert(sizeof(UMoleTargetingSelectionTask_BestEnemyTarget) == 0x000028, "Wrong size on UMoleTargetingSelectionTask_BestEnemyTarget");

// Class MoleGameRuntime.MoleTaskDataAsset
// 0x0148 (0x0178 - 0x0030)
class UMoleTaskDataAsset final : public UPrimaryDataAsset
{
public:
	struct FScalableFloat                         Enabled;                                           // 0x0030(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWorld>>          TaskSubLevels;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TaskStateMachine;                                  // 0x0068(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TaskStateMachineId;                                // 0x0090(0x0004)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFortAbilitySet>         TaskAbilitySet;                                    // 0x0098(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UFortWorldItemDefinition>> GrantedTaskItemDefinitions;                        // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TaskAssetTags;                                     // 0x00D0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bSabotageMenuAllowed;                              // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         Score;                                             // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMoleTaskLogicPhase>            LogicPhases;                                       // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMoleTaskDataAsset>      OnSuccessfulCompletionTaskGrant;                   // 0x0130(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TaskTitle;                                         // 0x0158(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         MaximumNumberToDistributePerGame;                  // 0x0170(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCapDistribution : 1;                              // 0x0171(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanOnlyBeDistributedAsFollowupTask : 1;           // 0x0171(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_172[0x6];                                      // 0x0172(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskDataAsset">();
	}
	static class UMoleTaskDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskDataAsset>();
	}
};
static_assert(alignof(UMoleTaskDataAsset) == 0x000008, "Wrong alignment on UMoleTaskDataAsset");
static_assert(sizeof(UMoleTaskDataAsset) == 0x000178, "Wrong size on UMoleTaskDataAsset");
static_assert(offsetof(UMoleTaskDataAsset, Enabled) == 0x000030, "Member 'UMoleTaskDataAsset::Enabled' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, TaskSubLevels) == 0x000058, "Member 'UMoleTaskDataAsset::TaskSubLevels' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, TaskStateMachine) == 0x000068, "Member 'UMoleTaskDataAsset::TaskStateMachine' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, TaskStateMachineId) == 0x000090, "Member 'UMoleTaskDataAsset::TaskStateMachineId' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, TaskAbilitySet) == 0x000098, "Member 'UMoleTaskDataAsset::TaskAbilitySet' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, GrantedTaskItemDefinitions) == 0x0000C0, "Member 'UMoleTaskDataAsset::GrantedTaskItemDefinitions' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, TaskAssetTags) == 0x0000D0, "Member 'UMoleTaskDataAsset::TaskAssetTags' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, bSabotageMenuAllowed) == 0x0000F0, "Member 'UMoleTaskDataAsset::bSabotageMenuAllowed' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, Score) == 0x0000F8, "Member 'UMoleTaskDataAsset::Score' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, LogicPhases) == 0x000120, "Member 'UMoleTaskDataAsset::LogicPhases' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, OnSuccessfulCompletionTaskGrant) == 0x000130, "Member 'UMoleTaskDataAsset::OnSuccessfulCompletionTaskGrant' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, TaskTitle) == 0x000158, "Member 'UMoleTaskDataAsset::TaskTitle' has a wrong offset!");
static_assert(offsetof(UMoleTaskDataAsset, MaximumNumberToDistributePerGame) == 0x000170, "Member 'UMoleTaskDataAsset::MaximumNumberToDistributePerGame' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLinkComponent
// 0x01B0 (0x0250 - 0x00A0)
class UMoleTaskLinkComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class AController* User, bool bHasPermission)> OnTaskPermissionChanged;                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AController* User)> OnTaskInteractionChanged;                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UMoleTaskLinkComponent* TaskLinkComponent, class AController* User, const struct FGameplayTag& ObjectiveStatTag, float ObjectiveStatDelta)> OnTaskGenericObjectiveStatChanged;                 // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UMoleTaskLinkComponent* TaskLinkComponent, class AFortPawn* InteractingPawn, EInteractionBeingAttempted InteractionType)> OnTaskLinkOwnerActorInteract;                      // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TaskTag;                                           // 0x00F8(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              TaskInteractionInfoTable;                          // 0x0100(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayerTaskStateDataArray              PlayerTaskStateDataArray;                          // 0x0128(0x0120)(Net, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         bTaskLinkDisabled : 1;                             // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMoleTaskLinkComponent* GetTaskComponent(class AActor* TaskActor);

	void AddPlayerInteractionData(class AController* User, const class FName InteractionInfoRowName, bool bGivePermission);
	bool CanInteract(const class AFortPawn* InteractingPawn, const EInteractionBeingAttempted InteractionBeingAttempted, const ETInteractionType InteractionType);
	void DisableTaskLink();
	void GivePlayerPermission(class AController* User);
	void OnOwnerActorInteract(const class AFortPawn* InteractingPawn, EInteractionBeingAttempted Interaction);
	void OnRep_bTaskLinkDisabled();
	void RemovePlayerInteractionData(class AController* User, bool bAlsoRemovePermission);
	void RemovePlayerPermission(class AController* User);
	void SendGenericObjectiveStatUpdate(class AController* User, const struct FGameplayTag& ObjectiveStatTag, float ObjectiveStatDelta);
	void UpdatePlayerInteractionData(class AController* User, const class FName InteractionInfoRowName);

	class FText GetInteractionString(const class AFortPawn* InteractingPawn, const EInteractionBeingAttempted InteractionBeingAttempted) const;
	float GetInteractionTime(const class AFortPawn* InteractingPawn, const EInteractionBeingAttempted InteractionBeingAttempted) const;
	struct FGameplayTag GetTaskTag() const;
	bool HasPlayerPermission(class AController* User) const;
	bool IsTaskLinkDisabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLinkComponent">();
	}
	static class UMoleTaskLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLinkComponent>();
	}
};
static_assert(alignof(UMoleTaskLinkComponent) == 0x000008, "Wrong alignment on UMoleTaskLinkComponent");
static_assert(sizeof(UMoleTaskLinkComponent) == 0x000250, "Wrong size on UMoleTaskLinkComponent");
static_assert(offsetof(UMoleTaskLinkComponent, OnTaskPermissionChanged) == 0x0000A0, "Member 'UMoleTaskLinkComponent::OnTaskPermissionChanged' has a wrong offset!");
static_assert(offsetof(UMoleTaskLinkComponent, OnTaskInteractionChanged) == 0x0000C8, "Member 'UMoleTaskLinkComponent::OnTaskInteractionChanged' has a wrong offset!");
static_assert(offsetof(UMoleTaskLinkComponent, OnTaskGenericObjectiveStatChanged) == 0x0000D8, "Member 'UMoleTaskLinkComponent::OnTaskGenericObjectiveStatChanged' has a wrong offset!");
static_assert(offsetof(UMoleTaskLinkComponent, OnTaskLinkOwnerActorInteract) == 0x0000E8, "Member 'UMoleTaskLinkComponent::OnTaskLinkOwnerActorInteract' has a wrong offset!");
static_assert(offsetof(UMoleTaskLinkComponent, TaskTag) == 0x0000F8, "Member 'UMoleTaskLinkComponent::TaskTag' has a wrong offset!");
static_assert(offsetof(UMoleTaskLinkComponent, TaskInteractionInfoTable) == 0x000100, "Member 'UMoleTaskLinkComponent::TaskInteractionInfoTable' has a wrong offset!");
static_assert(offsetof(UMoleTaskLinkComponent, PlayerTaskStateDataArray) == 0x000128, "Member 'UMoleTaskLinkComponent::PlayerTaskStateDataArray' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogic
// 0x00A0 (0x00C8 - 0x0028)
class UMoleTaskLogic final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMoleTaskDataAsset*                     ParentTaskAsset;                                   // 0x0040(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x50];                                      // 0x0048(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMoleTaskLogicPhase>            TaskPhases;                                        // 0x0098(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 ClientDelayedPendingPhases;                        // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FMoleActiveTaskStateHandle             ParentTaskHandle;                                  // 0x00B8(0x0004)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentTaskPhase;                                  // 0x00BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPhaseChangeInProgress : 1;                        // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasBeenInitialized : 1;                           // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPrimaryActiveTask : 1;                          // 0x00C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ParentTaskAsset();
	void OnRep_ParentTaskHandle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogic">();
	}
	static class UMoleTaskLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogic>();
	}
};
static_assert(alignof(UMoleTaskLogic) == 0x000008, "Wrong alignment on UMoleTaskLogic");
static_assert(sizeof(UMoleTaskLogic) == 0x0000C8, "Wrong size on UMoleTaskLogic");
static_assert(offsetof(UMoleTaskLogic, ParentTaskAsset) == 0x000040, "Member 'UMoleTaskLogic::ParentTaskAsset' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogic, TaskPhases) == 0x000098, "Member 'UMoleTaskLogic::TaskPhases' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogic, ClientDelayedPendingPhases) == 0x0000A8, "Member 'UMoleTaskLogic::ClientDelayedPendingPhases' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogic, ParentTaskHandle) == 0x0000B8, "Member 'UMoleTaskLogic::ParentTaskHandle' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogic, CurrentTaskPhase) == 0x0000BC, "Member 'UMoleTaskLogic::CurrentTaskPhase' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicAction_GrantItem
// 0x0040 (0x00A8 - 0x0068)
class UMoleTaskLogicAction_GrantItem final : public UMoleTaskLogicAction
{
public:
	TSoftObjectPtr<class UFortWorldItemDefinition> ItemToGrant;                                       // 0x0068(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Quantity;                                          // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  GrantedItemGuid;                                   // 0x0094(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicAction_GrantItem">();
	}
	static class UMoleTaskLogicAction_GrantItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicAction_GrantItem>();
	}
};
static_assert(alignof(UMoleTaskLogicAction_GrantItem) == 0x000008, "Wrong alignment on UMoleTaskLogicAction_GrantItem");
static_assert(sizeof(UMoleTaskLogicAction_GrantItem) == 0x0000A8, "Wrong size on UMoleTaskLogicAction_GrantItem");
static_assert(offsetof(UMoleTaskLogicAction_GrantItem, ItemToGrant) == 0x000068, "Member 'UMoleTaskLogicAction_GrantItem::ItemToGrant' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicAction_GrantItem, Quantity) == 0x000090, "Member 'UMoleTaskLogicAction_GrantItem::Quantity' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicAction_GrantItem, GrantedItemGuid) == 0x000094, "Member 'UMoleTaskLogicAction_GrantItem::GrantedItemGuid' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicObjective_FixSabotage
// 0x0038 (0x0130 - 0x00F8)
class UMoleTaskLogicObjective_FixSabotage final : public UMoleTaskLogicObjective
{
public:
	struct FMoleObjectiveCriteriaFloat            NumOfPointsToFix;                                  // 0x00F8(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicObjective_FixSabotage">();
	}
	static class UMoleTaskLogicObjective_FixSabotage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicObjective_FixSabotage>();
	}
};
static_assert(alignof(UMoleTaskLogicObjective_FixSabotage) == 0x000008, "Wrong alignment on UMoleTaskLogicObjective_FixSabotage");
static_assert(sizeof(UMoleTaskLogicObjective_FixSabotage) == 0x000130, "Wrong size on UMoleTaskLogicObjective_FixSabotage");
static_assert(offsetof(UMoleTaskLogicObjective_FixSabotage, NumOfPointsToFix) == 0x0000F8, "Member 'UMoleTaskLogicObjective_FixSabotage::NumOfPointsToFix' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicObjective_GenericStat
// 0x0078 (0x0170 - 0x00F8)
class UMoleTaskLogicObjective_GenericStat final : public UMoleTaskLogicObjective
{
public:
	struct FGameplayTag                           StatTag;                                           // 0x00F8(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMoleObjectiveCriteriaFloat            InitialValue;                                      // 0x0100(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FMoleObjectiveCriteriaFloat            TargetValue;                                       // 0x0138(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnTaskLinkComponentGenericStatChanged(class UMoleTaskLinkComponent* InTaskLinkComponent, class AController* InUser, const struct FGameplayTag& InObjectiveStatTag, float InObjectiveStatDelta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicObjective_GenericStat">();
	}
	static class UMoleTaskLogicObjective_GenericStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicObjective_GenericStat>();
	}
};
static_assert(alignof(UMoleTaskLogicObjective_GenericStat) == 0x000008, "Wrong alignment on UMoleTaskLogicObjective_GenericStat");
static_assert(sizeof(UMoleTaskLogicObjective_GenericStat) == 0x000170, "Wrong size on UMoleTaskLogicObjective_GenericStat");
static_assert(offsetof(UMoleTaskLogicObjective_GenericStat, StatTag) == 0x0000F8, "Member 'UMoleTaskLogicObjective_GenericStat::StatTag' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective_GenericStat, InitialValue) == 0x000100, "Member 'UMoleTaskLogicObjective_GenericStat::InitialValue' has a wrong offset!");
static_assert(offsetof(UMoleTaskLogicObjective_GenericStat, TargetValue) == 0x000138, "Member 'UMoleTaskLogicObjective_GenericStat::TargetValue' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskLogicObjective_Interact
// 0x0038 (0x0130 - 0x00F8)
class UMoleTaskLogicObjective_Interact final : public UMoleTaskLogicObjective
{
public:
	struct FMoleObjectiveCriteriaFloat            Quantity;                                          // 0x00F8(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnTaskLinkComponentInteract(class UMoleTaskLinkComponent* TaskLinkComponent, const class AFortPawn* InteractingPawn, EInteractionBeingAttempted InteractionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskLogicObjective_Interact">();
	}
	static class UMoleTaskLogicObjective_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskLogicObjective_Interact>();
	}
};
static_assert(alignof(UMoleTaskLogicObjective_Interact) == 0x000008, "Wrong alignment on UMoleTaskLogicObjective_Interact");
static_assert(sizeof(UMoleTaskLogicObjective_Interact) == 0x000130, "Wrong size on UMoleTaskLogicObjective_Interact");
static_assert(offsetof(UMoleTaskLogicObjective_Interact, Quantity) == 0x0000F8, "Member 'UMoleTaskLogicObjective_Interact::Quantity' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskManagerComponent
// 0x01D0 (0x0270 - 0x00A0)
class UMoleTaskManagerComponent final : public UPlayspaceComponent
{
public:
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMoleTaskMappingElement>        MoleTaskContentMappings;                           // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UMoleTaskDataAsset*>             AvailableTaskList;                                 // 0x00D8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMoleTaskTrackingData>          TaskTrackingData;                                  // 0x00E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSet<struct FMoleActiveTaskStateHandle>       UnpooledTaskAssignments;                           // 0x00F8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FMoleActiveTaskStateHandle, class UMoleTaskDataAsset*> TaskPoolDependencyToTaskAssetMap;                  // 0x0148(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         StartOfInUseTasksIdx;                              // 0x0198(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         NumTasksPerPlayer;                                 // 0x01A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         NumScoreRequiredPerPlayer;                         // 0x01C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ShouldEnemiesReceiveTasks;                         // 0x01F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FMoleTaskScoreEventData                ScoreData;                                         // 0x0218(0x0008)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x50];                                     // 0x0220(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetMoleCurrentScore(const class UObject* WorldContextObject);
	static float GetMoleScoreGoal(const class UObject* WorldContextObject);
	static class UMoleTaskLinkComponent* GetTaskActorComponentForGameplayTag(const class UObject* WorldContextObject, const struct FGameplayTag& TaskTag);
	static TArray<class UMoleTaskLinkComponent*> GetTaskActorComponentsMatchingGameplayTag(const class UObject* WorldContextObject, const struct FGameplayTag& TaskRootTag);
	static TArray<class UMoleTaskLinkComponent*> GetTaskActorComponentsMatchingGameplayTagContainer(const class UObject* WorldContextObject, const struct FGameplayTagContainer& TaskTagContainer);
	static class AActor* GetTaskActorForGameplayTag(const class UObject* WorldContextObject, const struct FGameplayTag& TaskTag);
	static TArray<class AActor*> GetTaskActorsMatchingGameplayTag(const class UObject* WorldContextObject, const struct FGameplayTag& TaskRootTag);
	static TArray<class AActor*> GetTaskActorsMatchingGameplayTagContainer(const class UObject* WorldContextObject, const struct FGameplayTagContainer& TaskTagContainer);

	void OnRep_AvailableTaskList();
	void OnRep_ScoreData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskManagerComponent">();
	}
	static class UMoleTaskManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskManagerComponent>();
	}
};
static_assert(alignof(UMoleTaskManagerComponent) == 0x000008, "Wrong alignment on UMoleTaskManagerComponent");
static_assert(sizeof(UMoleTaskManagerComponent) == 0x000270, "Wrong size on UMoleTaskManagerComponent");
static_assert(offsetof(UMoleTaskManagerComponent, MoleTaskContentMappings) == 0x0000C8, "Member 'UMoleTaskManagerComponent::MoleTaskContentMappings' has a wrong offset!");
static_assert(offsetof(UMoleTaskManagerComponent, AvailableTaskList) == 0x0000D8, "Member 'UMoleTaskManagerComponent::AvailableTaskList' has a wrong offset!");
static_assert(offsetof(UMoleTaskManagerComponent, TaskTrackingData) == 0x0000E8, "Member 'UMoleTaskManagerComponent::TaskTrackingData' has a wrong offset!");
static_assert(offsetof(UMoleTaskManagerComponent, UnpooledTaskAssignments) == 0x0000F8, "Member 'UMoleTaskManagerComponent::UnpooledTaskAssignments' has a wrong offset!");
static_assert(offsetof(UMoleTaskManagerComponent, TaskPoolDependencyToTaskAssetMap) == 0x000148, "Member 'UMoleTaskManagerComponent::TaskPoolDependencyToTaskAssetMap' has a wrong offset!");
static_assert(offsetof(UMoleTaskManagerComponent, StartOfInUseTasksIdx) == 0x000198, "Member 'UMoleTaskManagerComponent::StartOfInUseTasksIdx' has a wrong offset!");
static_assert(offsetof(UMoleTaskManagerComponent, NumTasksPerPlayer) == 0x0001A0, "Member 'UMoleTaskManagerComponent::NumTasksPerPlayer' has a wrong offset!");
static_assert(offsetof(UMoleTaskManagerComponent, NumScoreRequiredPerPlayer) == 0x0001C8, "Member 'UMoleTaskManagerComponent::NumScoreRequiredPerPlayer' has a wrong offset!");
static_assert(offsetof(UMoleTaskManagerComponent, ShouldEnemiesReceiveTasks) == 0x0001F0, "Member 'UMoleTaskManagerComponent::ShouldEnemiesReceiveTasks' has a wrong offset!");
static_assert(offsetof(UMoleTaskManagerComponent, ScoreData) == 0x000218, "Member 'UMoleTaskManagerComponent::ScoreData' has a wrong offset!");

// Class MoleGameRuntime.MoleTaskPoint
// 0x0000 (0x0270 - 0x0270)
class AMoleTaskPoint final : public AActor
{
public:
	class UMoleTaskLinkComponent* GetMoleTaskLinkComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskPoint">();
	}
	static class AMoleTaskPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoleTaskPoint>();
	}
};
static_assert(alignof(AMoleTaskPoint) == 0x000008, "Wrong alignment on AMoleTaskPoint");
static_assert(sizeof(AMoleTaskPoint) == 0x000270, "Wrong size on AMoleTaskPoint");

// Class MoleGameRuntime.MoleTaskPointManagerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UMoleTaskPointManagerComponent final : public UFortControllerComponent
{
public:
	void ResetTaskPointManager();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskPointManagerComponent">();
	}
	static class UMoleTaskPointManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskPointManagerComponent>();
	}
};
static_assert(alignof(UMoleTaskPointManagerComponent) == 0x000008, "Wrong alignment on UMoleTaskPointManagerComponent");
static_assert(sizeof(UMoleTaskPointManagerComponent) == 0x0000A0, "Wrong size on UMoleTaskPointManagerComponent");

// Class MoleGameRuntime.MoleTaskStateMachine
// 0x0010 (0x00C0 - 0x00B0)
class UMoleTaskStateMachine final : public UGameplayStateMachine
{
public:
	struct FMoleActiveTaskStateHandle             Handle;                                            // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTaskStateMachine">();
	}
	static class UMoleTaskStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTaskStateMachine>();
	}
};
static_assert(alignof(UMoleTaskStateMachine) == 0x000008, "Wrong alignment on UMoleTaskStateMachine");
static_assert(sizeof(UMoleTaskStateMachine) == 0x0000C0, "Wrong size on UMoleTaskStateMachine");
static_assert(offsetof(UMoleTaskStateMachine, Handle) == 0x0000B0, "Member 'UMoleTaskStateMachine::Handle' has a wrong offset!");

// Class MoleGameRuntime.MoleTeleportAllSabotageAbility
// 0x0030 (0x0B90 - 0x0B60)
class UMoleTeleportAllSabotageAbility final : public UMoleSabotageAbility
{
public:
	struct FScalableFloat                         TimeBeforeTeleport;                                // 0x0B60(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B88[0x8];                                      // 0x0B88(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerTeleported(class APlayerState* TeleportedPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTeleportAllSabotageAbility">();
	}
	static class UMoleTeleportAllSabotageAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleTeleportAllSabotageAbility>();
	}
};
static_assert(alignof(UMoleTeleportAllSabotageAbility) == 0x000008, "Wrong alignment on UMoleTeleportAllSabotageAbility");
static_assert(sizeof(UMoleTeleportAllSabotageAbility) == 0x000B90, "Wrong size on UMoleTeleportAllSabotageAbility");
static_assert(offsetof(UMoleTeleportAllSabotageAbility, TimeBeforeTeleport) == 0x000B60, "Member 'UMoleTeleportAllSabotageAbility::TimeBeforeTeleport' has a wrong offset!");

// Class MoleGameRuntime.MoleTeleportPoint
// 0x0008 (0x0278 - 0x0270)
class AMoleTeleportPoint final : public AActor
{
public:
	class USceneComponent*                        SpawnPoint;                                        // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleTeleportPoint">();
	}
	static class AMoleTeleportPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMoleTeleportPoint>();
	}
};
static_assert(alignof(AMoleTeleportPoint) == 0x000008, "Wrong alignment on AMoleTeleportPoint");
static_assert(sizeof(AMoleTeleportPoint) == 0x000278, "Wrong size on AMoleTeleportPoint");
static_assert(offsetof(AMoleTeleportPoint, SpawnPoint) == 0x000270, "Member 'AMoleTeleportPoint::SpawnPoint' has a wrong offset!");

// Class MoleGameRuntime.MoleUIIndicatorManagerComponentInterface
// 0x0000 (0x0028 - 0x0028)
class IMoleUIIndicatorManagerComponentInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleUIIndicatorManagerComponentInterface">();
	}
	static class IMoleUIIndicatorManagerComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMoleUIIndicatorManagerComponentInterface>();
	}
};
static_assert(alignof(IMoleUIIndicatorManagerComponentInterface) == 0x000008, "Wrong alignment on IMoleUIIndicatorManagerComponentInterface");
static_assert(sizeof(IMoleUIIndicatorManagerComponentInterface) == 0x000028, "Wrong size on IMoleUIIndicatorManagerComponentInterface");

// Class MoleGameRuntime.MoleVoiceComponent
// 0x0038 (0x00D8 - 0x00A0)
class UMoleVoiceComponent final : public UPlayspaceComponent_VoiceManager
{
public:
	bool                                          bIsControllingGameVoiceChannels;                   // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInLobbyState;                                   // 0x00A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMoleVoiceChannelState                        VoiceChannelState;                                 // 0x00A2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MoleGameChannel;                                   // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MoleGhostChannel;                                  // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleVoiceComponent">();
	}
	static class UMoleVoiceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleVoiceComponent>();
	}
};
static_assert(alignof(UMoleVoiceComponent) == 0x000008, "Wrong alignment on UMoleVoiceComponent");
static_assert(sizeof(UMoleVoiceComponent) == 0x0000D8, "Wrong size on UMoleVoiceComponent");
static_assert(offsetof(UMoleVoiceComponent, bIsControllingGameVoiceChannels) == 0x0000A0, "Member 'UMoleVoiceComponent::bIsControllingGameVoiceChannels' has a wrong offset!");
static_assert(offsetof(UMoleVoiceComponent, bIsInLobbyState) == 0x0000A1, "Member 'UMoleVoiceComponent::bIsInLobbyState' has a wrong offset!");
static_assert(offsetof(UMoleVoiceComponent, VoiceChannelState) == 0x0000A2, "Member 'UMoleVoiceComponent::VoiceChannelState' has a wrong offset!");
static_assert(offsetof(UMoleVoiceComponent, MoleGameChannel) == 0x0000A8, "Member 'UMoleVoiceComponent::MoleGameChannel' has a wrong offset!");
static_assert(offsetof(UMoleVoiceComponent, MoleGhostChannel) == 0x0000B8, "Member 'UMoleVoiceComponent::MoleGhostChannel' has a wrong offset!");

// Class MoleGameRuntime.MoleVotingComponent
// 0x0088 (0x0128 - 0x00A0)
class UMoleVotingComponent final : public UGameFrameworkComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        VotingInputComp;                                   // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVoteCasted;                                       // 0x00C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BestVotingTarget;                                  // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMoleHoldBinding                       VoteBinding;                                       // 0x00D0(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMoleHoldBinding                       SkipBinding;                                       // 0x00E8(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   CancelEmoteBinding;                                // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x24];                                     // 0x0104(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerSkipVote();
	void ServerVote();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleVotingComponent">();
	}
	static class UMoleVotingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleVotingComponent>();
	}
};
static_assert(alignof(UMoleVotingComponent) == 0x000008, "Wrong alignment on UMoleVotingComponent");
static_assert(sizeof(UMoleVotingComponent) == 0x000128, "Wrong size on UMoleVotingComponent");
static_assert(offsetof(UMoleVotingComponent, VotingInputComp) == 0x0000B8, "Member 'UMoleVotingComponent::VotingInputComp' has a wrong offset!");
static_assert(offsetof(UMoleVotingComponent, bVoteCasted) == 0x0000C0, "Member 'UMoleVotingComponent::bVoteCasted' has a wrong offset!");
static_assert(offsetof(UMoleVotingComponent, BestVotingTarget) == 0x0000C8, "Member 'UMoleVotingComponent::BestVotingTarget' has a wrong offset!");
static_assert(offsetof(UMoleVotingComponent, VoteBinding) == 0x0000D0, "Member 'UMoleVotingComponent::VoteBinding' has a wrong offset!");
static_assert(offsetof(UMoleVotingComponent, SkipBinding) == 0x0000E8, "Member 'UMoleVotingComponent::SkipBinding' has a wrong offset!");
static_assert(offsetof(UMoleVotingComponent, CancelEmoteBinding) == 0x000100, "Member 'UMoleVotingComponent::CancelEmoteBinding' has a wrong offset!");

// Class MoleGameRuntime.MoleVotingStateMachine
// 0x0048 (0x00F8 - 0x00B0)
class UMoleVotingStateMachine final : public UGameplayStateMachine
{
public:
	uint8                                         Pad_B0[0x1C];                                      // 0x00B0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrepareStateDelayTime;                             // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMoleVote>                      VoteList;                                          // 0x00D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_VoteList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleVotingStateMachine">();
	}
	static class UMoleVotingStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleVotingStateMachine>();
	}
};
static_assert(alignof(UMoleVotingStateMachine) == 0x000008, "Wrong alignment on UMoleVotingStateMachine");
static_assert(sizeof(UMoleVotingStateMachine) == 0x0000F8, "Wrong size on UMoleVotingStateMachine");
static_assert(offsetof(UMoleVotingStateMachine, PrepareStateDelayTime) == 0x0000CC, "Member 'UMoleVotingStateMachine::PrepareStateDelayTime' has a wrong offset!");
static_assert(offsetof(UMoleVotingStateMachine, VoteList) == 0x0000D0, "Member 'UMoleVotingStateMachine::VoteList' has a wrong offset!");

// Class MoleGameRuntime.MoleVotingState_Discussion
// 0x0018 (0x0090 - 0x0078)
class UMoleVotingState_Discussion final : public UGameplayState
{
public:
	TSubclassOf<class UMoleQuickChatComponent>    QuickChatComponentClass;                           // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiscussionFinishServerTime;                        // 0x0088(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DiscussionFinishServerTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleVotingState_Discussion">();
	}
	static class UMoleVotingState_Discussion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleVotingState_Discussion>();
	}
};
static_assert(alignof(UMoleVotingState_Discussion) == 0x000008, "Wrong alignment on UMoleVotingState_Discussion");
static_assert(sizeof(UMoleVotingState_Discussion) == 0x000090, "Wrong size on UMoleVotingState_Discussion");
static_assert(offsetof(UMoleVotingState_Discussion, QuickChatComponentClass) == 0x000078, "Member 'UMoleVotingState_Discussion::QuickChatComponentClass' has a wrong offset!");
static_assert(offsetof(UMoleVotingState_Discussion, DiscussionFinishServerTime) == 0x000088, "Member 'UMoleVotingState_Discussion::DiscussionFinishServerTime' has a wrong offset!");

// Class MoleGameRuntime.MoleVotingState_ResultDisplay
// 0x0078 (0x00F0 - 0x0078)
class UMoleVotingState_ResultDisplay final : public UGameplayState
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMoleVoteResolutionData                VotingResolutionData;                              // 0x0080(0x0020)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<class APlayerState*, class AMolePlayerStart*> PlayerToPlayerStart;                               // 0x00A0(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_VotingResolutionData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleVotingState_ResultDisplay">();
	}
	static class UMoleVotingState_ResultDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleVotingState_ResultDisplay>();
	}
};
static_assert(alignof(UMoleVotingState_ResultDisplay) == 0x000008, "Wrong alignment on UMoleVotingState_ResultDisplay");
static_assert(sizeof(UMoleVotingState_ResultDisplay) == 0x0000F0, "Wrong size on UMoleVotingState_ResultDisplay");
static_assert(offsetof(UMoleVotingState_ResultDisplay, VotingResolutionData) == 0x000080, "Member 'UMoleVotingState_ResultDisplay::VotingResolutionData' has a wrong offset!");
static_assert(offsetof(UMoleVotingState_ResultDisplay, PlayerToPlayerStart) == 0x0000A0, "Member 'UMoleVotingState_ResultDisplay::PlayerToPlayerStart' has a wrong offset!");

// Class MoleGameRuntime.MoleVotingState_SummaryDisplay
// 0x0008 (0x0080 - 0x0078)
class UMoleVotingState_SummaryDisplay final : public UGameplayState
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleVotingState_SummaryDisplay">();
	}
	static class UMoleVotingState_SummaryDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleVotingState_SummaryDisplay>();
	}
};
static_assert(alignof(UMoleVotingState_SummaryDisplay) == 0x000008, "Wrong alignment on UMoleVotingState_SummaryDisplay");
static_assert(sizeof(UMoleVotingState_SummaryDisplay) == 0x000080, "Wrong size on UMoleVotingState_SummaryDisplay");

// Class MoleGameRuntime.MoleVotingState_VoteCasting
// 0x0070 (0x00E8 - 0x0078)
class UMoleVotingState_VoteCasting final : public UGameplayState
{
public:
	TSubclassOf<class UGameplayAbility>           VotingAbility;                                     // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class APlayerState*, struct FGameplayAbilitySpecHandle> PlayerStateToVoteAbilityHandle;                    // 0x0080(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UMoleVotingComponent>       VotingComponentClass;                              // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerFinishTime;                                  // 0x00E0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ServerFinishTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoleVotingState_VoteCasting">();
	}
	static class UMoleVotingState_VoteCasting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoleVotingState_VoteCasting>();
	}
};
static_assert(alignof(UMoleVotingState_VoteCasting) == 0x000008, "Wrong alignment on UMoleVotingState_VoteCasting");
static_assert(sizeof(UMoleVotingState_VoteCasting) == 0x0000E8, "Wrong size on UMoleVotingState_VoteCasting");
static_assert(offsetof(UMoleVotingState_VoteCasting, VotingAbility) == 0x000078, "Member 'UMoleVotingState_VoteCasting::VotingAbility' has a wrong offset!");
static_assert(offsetof(UMoleVotingState_VoteCasting, PlayerStateToVoteAbilityHandle) == 0x000080, "Member 'UMoleVotingState_VoteCasting::PlayerStateToVoteAbilityHandle' has a wrong offset!");
static_assert(offsetof(UMoleVotingState_VoteCasting, VotingComponentClass) == 0x0000D0, "Member 'UMoleVotingState_VoteCasting::VotingComponentClass' has a wrong offset!");
static_assert(offsetof(UMoleVotingState_VoteCasting, ServerFinishTime) == 0x0000E0, "Member 'UMoleVotingState_VoteCasting::ServerFinishTime' has a wrong offset!");

}

