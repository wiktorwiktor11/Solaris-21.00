#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TypedElementFramework

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class TypedElementFramework.TypedElementCounterInterface
// 0x0000 (0x0028 - 0x0028)
class ITypedElementCounterInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementCounterInterface">();
	}
	static class ITypedElementCounterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITypedElementCounterInterface>();
	}
};
static_assert(alignof(ITypedElementCounterInterface) == 0x000008, "Wrong alignment on ITypedElementCounterInterface");
static_assert(sizeof(ITypedElementCounterInterface) == 0x000028, "Wrong size on ITypedElementCounterInterface");

// Class TypedElementFramework.TestTypedElementInterfaceA
// 0x0000 (0x0028 - 0x0028)
class ITestTypedElementInterfaceA final : public IInterface
{
public:
	class FText GetDisplayName(const struct FTypedElementHandle& InElementHandle);
	bool SetDisplayName(const struct FTypedElementHandle& InElementHandle, const class FText& InNewName, bool bNotify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceA">();
	}
	static class ITestTypedElementInterfaceA* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITestTypedElementInterfaceA>();
	}
};
static_assert(alignof(ITestTypedElementInterfaceA) == 0x000008, "Wrong alignment on ITestTypedElementInterfaceA");
static_assert(sizeof(ITestTypedElementInterfaceA) == 0x000028, "Wrong size on ITestTypedElementInterfaceA");

// Class TypedElementFramework.TestTypedElementInterfaceB
// 0x0000 (0x0028 - 0x0028)
class ITestTypedElementInterfaceB final : public IInterface
{
public:
	bool MarkAsTested(const struct FTypedElementHandle& InElementHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceB">();
	}
	static class ITestTypedElementInterfaceB* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITestTypedElementInterfaceB>();
	}
};
static_assert(alignof(ITestTypedElementInterfaceB) == 0x000008, "Wrong alignment on ITestTypedElementInterfaceB");
static_assert(sizeof(ITestTypedElementInterfaceB) == 0x000028, "Wrong size on ITestTypedElementInterfaceB");

// Class TypedElementFramework.TestTypedElementInterfaceC
// 0x0000 (0x0028 - 0x0028)
class ITestTypedElementInterfaceC final : public IInterface
{
public:
	bool GetIsTested(const struct FTypedElementHandle& InElementHandle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceC">();
	}
	static class ITestTypedElementInterfaceC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITestTypedElementInterfaceC>();
	}
};
static_assert(alignof(ITestTypedElementInterfaceC) == 0x000008, "Wrong alignment on ITestTypedElementInterfaceC");
static_assert(sizeof(ITestTypedElementInterfaceC) == 0x000028, "Wrong size on ITestTypedElementInterfaceC");

// Class TypedElementFramework.TestTypedElementInterfaceA_ImplTyped
// 0x0008 (0x0030 - 0x0028)
class UTestTypedElementInterfaceA_ImplTyped final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceA_ImplTyped">();
	}
	static class UTestTypedElementInterfaceA_ImplTyped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestTypedElementInterfaceA_ImplTyped>();
	}
};
static_assert(alignof(UTestTypedElementInterfaceA_ImplTyped) == 0x000008, "Wrong alignment on UTestTypedElementInterfaceA_ImplTyped");
static_assert(sizeof(UTestTypedElementInterfaceA_ImplTyped) == 0x000030, "Wrong size on UTestTypedElementInterfaceA_ImplTyped");

// Class TypedElementFramework.TestTypedElementInterfaceA_ImplUntyped
// 0x0008 (0x0030 - 0x0028)
class UTestTypedElementInterfaceA_ImplUntyped final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceA_ImplUntyped">();
	}
	static class UTestTypedElementInterfaceA_ImplUntyped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestTypedElementInterfaceA_ImplUntyped>();
	}
};
static_assert(alignof(UTestTypedElementInterfaceA_ImplUntyped) == 0x000008, "Wrong alignment on UTestTypedElementInterfaceA_ImplUntyped");
static_assert(sizeof(UTestTypedElementInterfaceA_ImplUntyped) == 0x000030, "Wrong size on UTestTypedElementInterfaceA_ImplUntyped");

// Class TypedElementFramework.TestTypedElementInterfaceBAndC_Typed
// 0x0010 (0x0038 - 0x0028)
class UTestTypedElementInterfaceBAndC_Typed final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceBAndC_Typed">();
	}
	static class UTestTypedElementInterfaceBAndC_Typed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestTypedElementInterfaceBAndC_Typed>();
	}
};
static_assert(alignof(UTestTypedElementInterfaceBAndC_Typed) == 0x000008, "Wrong alignment on UTestTypedElementInterfaceBAndC_Typed");
static_assert(sizeof(UTestTypedElementInterfaceBAndC_Typed) == 0x000038, "Wrong size on UTestTypedElementInterfaceBAndC_Typed");

// Class TypedElementFramework.TypedElementHandleLibrary
// 0x0000 (0x0028 - 0x0028)
class UTypedElementHandleLibrary final : public UObject
{
public:
	static bool Equal(const struct FTypedElementHandle& Lhs, const struct FTypedElementHandle& Rhs);
	static bool IsSet(const struct FTypedElementHandle& ElementHandle);
	static bool NotEqual(const struct FTypedElementHandle& Lhs, const struct FTypedElementHandle& Rhs);
	static void Release(struct FTypedElementHandle& ElementHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementHandleLibrary">();
	}
	static class UTypedElementHandleLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTypedElementHandleLibrary>();
	}
};
static_assert(alignof(UTypedElementHandleLibrary) == 0x000008, "Wrong alignment on UTypedElementHandleLibrary");
static_assert(sizeof(UTypedElementHandleLibrary) == 0x000028, "Wrong size on UTypedElementHandleLibrary");

// Class TypedElementFramework.TypedElementListLibrary
// 0x0000 (0x0028 - 0x0028)
class UTypedElementListLibrary final : public UObject
{
public:
	static bool Add(const struct FTypedElementListProxy& ElementList, const struct FTypedElementHandle& ElementHandle);
	static void Append(const struct FTypedElementListProxy& ElementList, const TArray<struct FTypedElementHandle>& ElementHandles);
	static void AppendList(const struct FTypedElementListProxy& ElementList, const struct FTypedElementListProxy& OtherElementList);
	static struct FTypedElementListProxy Clone(const struct FTypedElementListProxy& ElementList);
	static bool Contains(const struct FTypedElementListProxy& ElementList, const struct FTypedElementHandle& ElementHandle);
	static int32 CountElements(const struct FTypedElementListProxy& ElementList, const TSubclassOf<class IInterface> BaseInterfaceType);
	static int32 CountElementsOfType(const struct FTypedElementListProxy& ElementList, const class FName ElementTypeName);
	static struct FTypedElementListProxy CreateElementList(class UTypedElementRegistry* Registry);
	static void Empty(const struct FTypedElementListProxy& ElementList, const int32 Slack);
	static struct FTypedElementHandle GetElementHandleAt(const struct FTypedElementListProxy& ElementList, const int32 Index_0);
	static TArray<struct FTypedElementHandle> GetElementHandles(const struct FTypedElementListProxy& ElementList, const TSubclassOf<class IInterface> BaseInterfaceType);
	static class UObject* GetElementInterface(const struct FTypedElementListProxy& ElementList, const struct FTypedElementHandle& ElementHandle, const TSubclassOf<class IInterface> BaseInterfaceType);
	static bool HasElements(const struct FTypedElementListProxy& ElementList, const TSubclassOf<class IInterface> BaseInterfaceType);
	static bool HasElementsOfType(const struct FTypedElementListProxy& ElementList, const class FName ElementTypeName);
	static bool IsValidIndex(const struct FTypedElementListProxy& ElementList, const int32 Index_0);
	static int32 Num(const struct FTypedElementListProxy& ElementList);
	static bool Remove(const struct FTypedElementListProxy& ElementList, const struct FTypedElementHandle& ElementHandle);
	static void Reserve(const struct FTypedElementListProxy& ElementList, const int32 Size);
	static void Reset(const struct FTypedElementListProxy& ElementList);
	static void Shrink(const struct FTypedElementListProxy& ElementList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementListLibrary">();
	}
	static class UTypedElementListLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTypedElementListLibrary>();
	}
};
static_assert(alignof(UTypedElementListLibrary) == 0x000008, "Wrong alignment on UTypedElementListLibrary");
static_assert(sizeof(UTypedElementListLibrary) == 0x000028, "Wrong size on UTypedElementListLibrary");

// Class TypedElementFramework.TypedElementRegistry
// 0x08D0 (0x08F8 - 0x0028)
class UTypedElementRegistry final : public UObject
{
public:
	uint8                                         Pad_28[0x8D0];                                     // 0x0028(0x08D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTypedElementRegistry* GetInstance();

	class UObject* GetElementInterface(const struct FTypedElementHandle& InElementHandle, const TSubclassOf<class IInterface> InBaseInterfaceType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementRegistry">();
	}
	static class UTypedElementRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTypedElementRegistry>();
	}
};
static_assert(alignof(UTypedElementRegistry) == 0x000008, "Wrong alignment on UTypedElementRegistry");
static_assert(sizeof(UTypedElementRegistry) == 0x0008F8, "Wrong size on UTypedElementRegistry");

}

