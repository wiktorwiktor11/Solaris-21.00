#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Procedural

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Procedural_structs.hpp"


namespace SDK
{

// Class Procedural.HISMBuilderSettings
// 0x01D8 (0x0200 - 0x0028)
class UHISMBuilderSettings final : public UObject
{
public:
	EComponentMobility                            Mobility;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInt32Interval                         CullDistance;                                      // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCastShadow : 1;                                   // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectDynamicIndirectLighting : 1;                // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectDistanceFieldLighting : 1;                  // 0x0034(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastDynamicShadow : 1;                            // 0x0034(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastStaticShadow : 1;                             // 0x0034(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastShadowAsTwoSided : 1;                         // 0x0034(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReceivesDecals : 1;                               // 0x0034(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideLightMapRes : 1;                          // 0x0034(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverriddenLightMapRes;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightmapType                                 LightmapType;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseAsOccluder : 1;                                // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBodyInstance                          BodyInstance;                                      // 0x0048(0x0188)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EHasCustomNavigableGeometry                   CustomNavigableGeometry;                           // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      LightingChannels;                                  // 0x01D1(0x0001)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D2[0x2];                                      // 0x01D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bRenderCustomDepth : 1;                            // 0x01D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ERendererStencilMask                          CustomDepthStencilWriteMask;                       // 0x01D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomDepthStencilValue;                           // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslucencySortPriority;                          // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableDensityScaling : 1;                         // 0x01E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E5[0x3];                                      // 0x01E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URuntimeVirtualTexture*>         RuntimeVirtualTextures;                            // 0x01E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         VirtualTextureCullMips;                            // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERuntimeVirtualTextureMainPassType            VirtualTextureRenderPassType;                      // 0x01FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOverriddenLightMapRes(int32 Value);

	int32 GetOverriddenLightMapRes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HISMBuilderSettings">();
	}
	static class UHISMBuilderSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHISMBuilderSettings>();
	}
};
static_assert(alignof(UHISMBuilderSettings) == 0x000008, "Wrong alignment on UHISMBuilderSettings");
static_assert(sizeof(UHISMBuilderSettings) == 0x000200, "Wrong size on UHISMBuilderSettings");
static_assert(offsetof(UHISMBuilderSettings, Mobility) == 0x000028, "Member 'UHISMBuilderSettings::Mobility' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, CullDistance) == 0x00002C, "Member 'UHISMBuilderSettings::CullDistance' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, OverriddenLightMapRes) == 0x000038, "Member 'UHISMBuilderSettings::OverriddenLightMapRes' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, LightmapType) == 0x00003C, "Member 'UHISMBuilderSettings::LightmapType' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, BodyInstance) == 0x000048, "Member 'UHISMBuilderSettings::BodyInstance' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, CustomNavigableGeometry) == 0x0001D0, "Member 'UHISMBuilderSettings::CustomNavigableGeometry' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, LightingChannels) == 0x0001D1, "Member 'UHISMBuilderSettings::LightingChannels' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, CustomDepthStencilWriteMask) == 0x0001D8, "Member 'UHISMBuilderSettings::CustomDepthStencilWriteMask' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, CustomDepthStencilValue) == 0x0001DC, "Member 'UHISMBuilderSettings::CustomDepthStencilValue' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, TranslucencySortPriority) == 0x0001E0, "Member 'UHISMBuilderSettings::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, RuntimeVirtualTextures) == 0x0001E8, "Member 'UHISMBuilderSettings::RuntimeVirtualTextures' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, VirtualTextureCullMips) == 0x0001F8, "Member 'UHISMBuilderSettings::VirtualTextureCullMips' has a wrong offset!");
static_assert(offsetof(UHISMBuilderSettings, VirtualTextureRenderPassType) == 0x0001FC, "Member 'UHISMBuilderSettings::VirtualTextureRenderPassType' has a wrong offset!");

// Class Procedural.ProceduralParameterModifier
// 0x0010 (0x0038 - 0x0028)
class UProceduralParameterModifier : public UObject
{
public:
	bool                                          bEnabled;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Contribution;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProceduralParameterModifierBlendMode         BlendMode;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetContribution() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralParameterModifier">();
	}
	static class UProceduralParameterModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralParameterModifier>();
	}
};
static_assert(alignof(UProceduralParameterModifier) == 0x000008, "Wrong alignment on UProceduralParameterModifier");
static_assert(sizeof(UProceduralParameterModifier) == 0x000038, "Wrong size on UProceduralParameterModifier");
static_assert(offsetof(UProceduralParameterModifier, bEnabled) == 0x000028, "Member 'UProceduralParameterModifier::bEnabled' has a wrong offset!");
static_assert(offsetof(UProceduralParameterModifier, Contribution) == 0x00002C, "Member 'UProceduralParameterModifier::Contribution' has a wrong offset!");
static_assert(offsetof(UProceduralParameterModifier, BlendMode) == 0x000030, "Member 'UProceduralParameterModifier::BlendMode' has a wrong offset!");

// Class Procedural.ProceduralContentVariationsWeightsModifier
// 0x0000 (0x0038 - 0x0038)
class UProceduralContentVariationsWeightsModifier : public UProceduralParameterModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralContentVariationsWeightsModifier">();
	}
	static class UProceduralContentVariationsWeightsModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralContentVariationsWeightsModifier>();
	}
};
static_assert(alignof(UProceduralContentVariationsWeightsModifier) == 0x000008, "Wrong alignment on UProceduralContentVariationsWeightsModifier");
static_assert(sizeof(UProceduralContentVariationsWeightsModifier) == 0x000038, "Wrong size on UProceduralContentVariationsWeightsModifier");

// Class Procedural.ProceduralContentVariationsWeightsMapModifier
// 0x0010 (0x0048 - 0x0038)
class UProceduralContentVariationsWeightsMapModifier final : public UProceduralContentVariationsWeightsModifier
{
public:
	TArray<struct FProceduralContentVariationMap> VariationsMaps;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralContentVariationsWeightsMapModifier">();
	}
	static class UProceduralContentVariationsWeightsMapModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralContentVariationsWeightsMapModifier>();
	}
};
static_assert(alignof(UProceduralContentVariationsWeightsMapModifier) == 0x000008, "Wrong alignment on UProceduralContentVariationsWeightsMapModifier");
static_assert(sizeof(UProceduralContentVariationsWeightsMapModifier) == 0x000048, "Wrong size on UProceduralContentVariationsWeightsMapModifier");
static_assert(offsetof(UProceduralContentVariationsWeightsMapModifier, VariationsMaps) == 0x000038, "Member 'UProceduralContentVariationsWeightsMapModifier::VariationsMaps' has a wrong offset!");

// Class Procedural.ProceduralGenerator
// 0x0010 (0x0038 - 0x0028)
class UProceduralGenerator : public UObject
{
public:
	struct FProceduralDebugSettings               DebugSettings;                                     // 0x0028(0x000C)(Edit, BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerator">();
	}
	static class UProceduralGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGenerator>();
	}
};
static_assert(alignof(UProceduralGenerator) == 0x000008, "Wrong alignment on UProceduralGenerator");
static_assert(sizeof(UProceduralGenerator) == 0x000038, "Wrong size on UProceduralGenerator");
static_assert(offsetof(UProceduralGenerator, DebugSettings) == 0x000028, "Member 'UProceduralGenerator::DebugSettings' has a wrong offset!");

// Class Procedural.ProceduralCustomGenerator
// 0x0010 (0x0048 - 0x0038)
class UProceduralCustomGenerator final : public UProceduralGenerator
{
public:
	TSubclassOf<class UProceduralGeneratorContext> GeneratorContextClass;                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProceduralGeneratorContext*            GeneratorContext;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralCustomGenerator">();
	}
	static class UProceduralCustomGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralCustomGenerator>();
	}
};
static_assert(alignof(UProceduralCustomGenerator) == 0x000008, "Wrong alignment on UProceduralCustomGenerator");
static_assert(sizeof(UProceduralCustomGenerator) == 0x000048, "Wrong size on UProceduralCustomGenerator");
static_assert(offsetof(UProceduralCustomGenerator, GeneratorContextClass) == 0x000038, "Member 'UProceduralCustomGenerator::GeneratorContextClass' has a wrong offset!");
static_assert(offsetof(UProceduralCustomGenerator, GeneratorContext) == 0x000040, "Member 'UProceduralCustomGenerator::GeneratorContext' has a wrong offset!");

// Class Procedural.ProceduralDataMap
// 0x0008 (0x0030 - 0x0028)
class UProceduralDataMap : public UObject
{
public:
	bool                                          bUseRemapCurve;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralDataMap">();
	}
	static class UProceduralDataMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralDataMap>();
	}
};
static_assert(alignof(UProceduralDataMap) == 0x000008, "Wrong alignment on UProceduralDataMap");
static_assert(sizeof(UProceduralDataMap) == 0x000030, "Wrong size on UProceduralDataMap");
static_assert(offsetof(UProceduralDataMap, bUseRemapCurve) == 0x000028, "Member 'UProceduralDataMap::bUseRemapCurve' has a wrong offset!");

// Class Procedural.ProceduralFloatDataMap
// 0x0088 (0x00B8 - 0x0030)
class UProceduralFloatDataMap : public UProceduralDataMap
{
public:
	struct FProceduralRemapFloatCurve             RemapCurve;                                        // 0x0030(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralFloatDataMap">();
	}
	static class UProceduralFloatDataMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralFloatDataMap>();
	}
};
static_assert(alignof(UProceduralFloatDataMap) == 0x000008, "Wrong alignment on UProceduralFloatDataMap");
static_assert(sizeof(UProceduralFloatDataMap) == 0x0000B8, "Wrong size on UProceduralFloatDataMap");
static_assert(offsetof(UProceduralFloatDataMap, RemapCurve) == 0x000030, "Member 'UProceduralFloatDataMap::RemapCurve' has a wrong offset!");

// Class Procedural.ProceduralVectorDataMap
// 0x0208 (0x0238 - 0x0030)
class UProceduralVectorDataMap : public UProceduralDataMap
{
public:
	struct FProceduralRemapVectorCurve            RemapCurve;                                        // 0x0030(0x0208)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralVectorDataMap">();
	}
	static class UProceduralVectorDataMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralVectorDataMap>();
	}
};
static_assert(alignof(UProceduralVectorDataMap) == 0x000008, "Wrong alignment on UProceduralVectorDataMap");
static_assert(sizeof(UProceduralVectorDataMap) == 0x000238, "Wrong size on UProceduralVectorDataMap");
static_assert(offsetof(UProceduralVectorDataMap, RemapCurve) == 0x000030, "Member 'UProceduralVectorDataMap::RemapCurve' has a wrong offset!");

// Class Procedural.ProceduralDensityModifier
// 0x0000 (0x0038 - 0x0038)
class UProceduralDensityModifier : public UProceduralParameterModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralDensityModifier">();
	}
	static class UProceduralDensityModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralDensityModifier>();
	}
};
static_assert(alignof(UProceduralDensityModifier) == 0x000008, "Wrong alignment on UProceduralDensityModifier");
static_assert(sizeof(UProceduralDensityModifier) == 0x000038, "Wrong size on UProceduralDensityModifier");

// Class Procedural.ProceduralDensityMapModifier
// 0x0008 (0x0040 - 0x0038)
class UProceduralDensityMapModifier final : public UProceduralDensityModifier
{
public:
	class UProceduralFloatDataMap*                Map;                                               // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralDensityMapModifier">();
	}
	static class UProceduralDensityMapModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralDensityMapModifier>();
	}
};
static_assert(alignof(UProceduralDensityMapModifier) == 0x000008, "Wrong alignment on UProceduralDensityMapModifier");
static_assert(sizeof(UProceduralDensityMapModifier) == 0x000040, "Wrong size on UProceduralDensityMapModifier");
static_assert(offsetof(UProceduralDensityMapModifier, Map) == 0x000038, "Member 'UProceduralDensityMapModifier::Map' has a wrong offset!");

// Class Procedural.ProceduralGenerationBlockingVolume
// 0x0010 (0x02B8 - 0x02A8)
class AProceduralGenerationBlockingVolume final : public AVolume
{
public:
	TArray<class AProceduralGenerationVolume*>    BlockedVolumes;                                    // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerationBlockingVolume">();
	}
	static class AProceduralGenerationBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralGenerationBlockingVolume>();
	}
};
static_assert(alignof(AProceduralGenerationBlockingVolume) == 0x000008, "Wrong alignment on AProceduralGenerationBlockingVolume");
static_assert(sizeof(AProceduralGenerationBlockingVolume) == 0x0002B8, "Wrong size on AProceduralGenerationBlockingVolume");
static_assert(offsetof(AProceduralGenerationBlockingVolume, BlockedVolumes) == 0x0002A8, "Member 'AProceduralGenerationBlockingVolume::BlockedVolumes' has a wrong offset!");

// Class Procedural.ProceduralGenerationComponent
// 0x0030 (0x00D0 - 0x00A0)
class UProceduralGenerationComponent final : public UActorComponent
{
public:
	class UProceduralGenerator*                   Generator;                                         // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugVisualization;                           // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ProceduralGenerationGuid;                          // 0x00AC(0x0010)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AVolume*                                GenerationVolume;                                  // 0x00C0(0x0008)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProceduralGenerationContext*           GenerationContext;                                 // 0x00C8(0x0008)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerationComponent">();
	}
	static class UProceduralGenerationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGenerationComponent>();
	}
};
static_assert(alignof(UProceduralGenerationComponent) == 0x000008, "Wrong alignment on UProceduralGenerationComponent");
static_assert(sizeof(UProceduralGenerationComponent) == 0x0000D0, "Wrong size on UProceduralGenerationComponent");
static_assert(offsetof(UProceduralGenerationComponent, Generator) == 0x0000A0, "Member 'UProceduralGenerationComponent::Generator' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationComponent, bShowDebugVisualization) == 0x0000A8, "Member 'UProceduralGenerationComponent::bShowDebugVisualization' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationComponent, ProceduralGenerationGuid) == 0x0000AC, "Member 'UProceduralGenerationComponent::ProceduralGenerationGuid' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationComponent, GenerationVolume) == 0x0000C0, "Member 'UProceduralGenerationComponent::GenerationVolume' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationComponent, GenerationContext) == 0x0000C8, "Member 'UProceduralGenerationComponent::GenerationContext' has a wrong offset!");

// Class Procedural.ProceduralGenerationContext
// 0x00C8 (0x00F0 - 0x0028)
class UProceduralGenerationContext final : public UObject
{
public:
	class UProceduralGeneratorContext*            GeneratorContext;                                  // 0x0028(0x0008)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UProceduralGeneratorContext*>    GeneratedContexts;                                 // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UProceduralGeneratorContext*>    RegisteredContexts;                                // 0x0040(0x0010)(ZeroConstructor, DuplicateTransient, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UProceduralGeneratorContext*> GeneratorContexts;                                 // 0x0050(0x0050)(DuplicateTransient, Deprecated, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UProceduralGenerationComponent* GetGenerationComponent() const;
	class AVolume* GetGenerationVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerationContext">();
	}
	static class UProceduralGenerationContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGenerationContext>();
	}
};
static_assert(alignof(UProceduralGenerationContext) == 0x000008, "Wrong alignment on UProceduralGenerationContext");
static_assert(sizeof(UProceduralGenerationContext) == 0x0000F0, "Wrong size on UProceduralGenerationContext");
static_assert(offsetof(UProceduralGenerationContext, GeneratorContext) == 0x000028, "Member 'UProceduralGenerationContext::GeneratorContext' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationContext, GeneratedContexts) == 0x000030, "Member 'UProceduralGenerationContext::GeneratedContexts' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationContext, RegisteredContexts) == 0x000040, "Member 'UProceduralGenerationContext::RegisteredContexts' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationContext, GeneratorContexts) == 0x000050, "Member 'UProceduralGenerationContext::GeneratorContexts' has a wrong offset!");

// Class Procedural.ProceduralGenerationVolume
// 0x0008 (0x02B0 - 0x02A8)
class AProceduralGenerationVolume final : public AVolume
{
public:
	class UProceduralGenerationComponent*         ProceduralComponent;                               // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearGeneratedContent();
	void Generate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerationVolume">();
	}
	static class AProceduralGenerationVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralGenerationVolume>();
	}
};
static_assert(alignof(AProceduralGenerationVolume) == 0x000008, "Wrong alignment on AProceduralGenerationVolume");
static_assert(sizeof(AProceduralGenerationVolume) == 0x0002B0, "Wrong size on AProceduralGenerationVolume");
static_assert(offsetof(AProceduralGenerationVolume, ProceduralComponent) == 0x0002A8, "Member 'AProceduralGenerationVolume::ProceduralComponent' has a wrong offset!");

// Class Procedural.ProceduralGeneratorContext
// 0x0030 (0x0058 - 0x0028)
class UProceduralGeneratorContext : public UObject
{
public:
	class UProceduralGenerator*                   Generator;                                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProceduralGenerationContext*           GenerationContext;                                 // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProceduralGeneratorContext*            OwnerContext;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        GeneratedObjects;                                  // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UProceduralPointCloud*                  ExportedPointCloud;                                // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearGeneratedContent();
	bool Generate();
	void GetOrCreateGeneratorContext(class UProceduralGenerator* Generator_0, class UProceduralGeneratorContext** Context);
	void OnClearGeneratedContent();
	bool OnGenerate();

	TArray<class UProceduralGeneratorContext*> GetGeneratedContexts() const;
	void OnDrawVisualization() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGeneratorContext">();
	}
	static class UProceduralGeneratorContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGeneratorContext>();
	}
};
static_assert(alignof(UProceduralGeneratorContext) == 0x000008, "Wrong alignment on UProceduralGeneratorContext");
static_assert(sizeof(UProceduralGeneratorContext) == 0x000058, "Wrong size on UProceduralGeneratorContext");
static_assert(offsetof(UProceduralGeneratorContext, Generator) == 0x000028, "Member 'UProceduralGeneratorContext::Generator' has a wrong offset!");
static_assert(offsetof(UProceduralGeneratorContext, GenerationContext) == 0x000030, "Member 'UProceduralGeneratorContext::GenerationContext' has a wrong offset!");
static_assert(offsetof(UProceduralGeneratorContext, OwnerContext) == 0x000038, "Member 'UProceduralGeneratorContext::OwnerContext' has a wrong offset!");
static_assert(offsetof(UProceduralGeneratorContext, GeneratedObjects) == 0x000040, "Member 'UProceduralGeneratorContext::GeneratedObjects' has a wrong offset!");
static_assert(offsetof(UProceduralGeneratorContext, ExportedPointCloud) == 0x000050, "Member 'UProceduralGeneratorContext::ExportedPointCloud' has a wrong offset!");

// Class Procedural.ProceduralGeneratorStack
// 0x0010 (0x0048 - 0x0038)
class UProceduralGeneratorStack final : public UProceduralGenerator
{
public:
	TArray<struct FProceduralGenerationStackElement> Generators;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGeneratorStack">();
	}
	static class UProceduralGeneratorStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGeneratorStack>();
	}
};
static_assert(alignof(UProceduralGeneratorStack) == 0x000008, "Wrong alignment on UProceduralGeneratorStack");
static_assert(sizeof(UProceduralGeneratorStack) == 0x000048, "Wrong size on UProceduralGeneratorStack");
static_assert(offsetof(UProceduralGeneratorStack, Generators) == 0x000038, "Member 'UProceduralGeneratorStack::Generators' has a wrong offset!");

// Class Procedural.ProceduralGeneratorStackContext
// 0x0000 (0x0058 - 0x0058)
class UProceduralGeneratorStackContext final : public UProceduralGeneratorContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGeneratorStackContext">();
	}
	static class UProceduralGeneratorStackContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGeneratorStackContext>();
	}
};
static_assert(alignof(UProceduralGeneratorStackContext) == 0x000008, "Wrong alignment on UProceduralGeneratorStackContext");
static_assert(sizeof(UProceduralGeneratorStackContext) == 0x000058, "Wrong size on UProceduralGeneratorStackContext");

// Class Procedural.ProceduralLandscapeLayerMap
// 0x0008 (0x00C0 - 0x00B8)
class UProceduralLandscapeLayerMap final : public UProceduralFloatDataMap
{
public:
	class FName                                   LandscapeLayerName;                                // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LandscapeEditLayerName;                            // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralLandscapeLayerMap">();
	}
	static class UProceduralLandscapeLayerMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralLandscapeLayerMap>();
	}
};
static_assert(alignof(UProceduralLandscapeLayerMap) == 0x000008, "Wrong alignment on UProceduralLandscapeLayerMap");
static_assert(sizeof(UProceduralLandscapeLayerMap) == 0x0000C0, "Wrong size on UProceduralLandscapeLayerMap");
static_assert(offsetof(UProceduralLandscapeLayerMap, LandscapeLayerName) == 0x0000B8, "Member 'UProceduralLandscapeLayerMap::LandscapeLayerName' has a wrong offset!");
static_assert(offsetof(UProceduralLandscapeLayerMap, LandscapeEditLayerName) == 0x0000BC, "Member 'UProceduralLandscapeLayerMap::LandscapeEditLayerName' has a wrong offset!");

// Class Procedural.ProceduralPointCloud
// 0x0010 (0x0038 - 0x0028)
class UProceduralPointCloud final : public UObject
{
public:
	TArray<struct FProceduralPointCloudPoint>     Points;                                            // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Empty();
	TArray<struct FProceduralPointCloudPoint> GetPointsByTag(class FName InTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralPointCloud">();
	}
	static class UProceduralPointCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralPointCloud>();
	}
};
static_assert(alignof(UProceduralPointCloud) == 0x000008, "Wrong alignment on UProceduralPointCloud");
static_assert(sizeof(UProceduralPointCloud) == 0x000038, "Wrong size on UProceduralPointCloud");
static_assert(offsetof(UProceduralPointCloud, Points) == 0x000028, "Member 'UProceduralPointCloud::Points' has a wrong offset!");

// Class Procedural.ProceduralRotationModifier
// 0x0000 (0x0038 - 0x0038)
class UProceduralRotationModifier : public UProceduralParameterModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralRotationModifier">();
	}
	static class UProceduralRotationModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralRotationModifier>();
	}
};
static_assert(alignof(UProceduralRotationModifier) == 0x000008, "Wrong alignment on UProceduralRotationModifier");
static_assert(sizeof(UProceduralRotationModifier) == 0x000038, "Wrong size on UProceduralRotationModifier");

// Class Procedural.ProceduralRotationMapModifier
// 0x0028 (0x0060 - 0x0038)
class UProceduralRotationMapModifier final : public UProceduralRotationModifier
{
public:
	class UProceduralVectorDataMap*               Map;                                               // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProceduralRotationFormat                     RotationFormat;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         Roll;                                              // 0x0044(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         Pitch;                                             // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         Yaw;                                               // 0x0054(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPitchMax(float InValue);
	void SetPitchMin(float InValue);
	void SetRollMax(float InValue);
	void SetRollMin(float InValue);
	void SetYawMax(float InValue);
	void SetYawMin(float InValue);

	float GetPitchMax() const;
	float GetPitchMin() const;
	float GetRollMax() const;
	float GetRollMin() const;
	float GetYawMax() const;
	float GetYawMin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralRotationMapModifier">();
	}
	static class UProceduralRotationMapModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralRotationMapModifier>();
	}
};
static_assert(alignof(UProceduralRotationMapModifier) == 0x000008, "Wrong alignment on UProceduralRotationMapModifier");
static_assert(sizeof(UProceduralRotationMapModifier) == 0x000060, "Wrong size on UProceduralRotationMapModifier");
static_assert(offsetof(UProceduralRotationMapModifier, Map) == 0x000038, "Member 'UProceduralRotationMapModifier::Map' has a wrong offset!");
static_assert(offsetof(UProceduralRotationMapModifier, RotationFormat) == 0x000040, "Member 'UProceduralRotationMapModifier::RotationFormat' has a wrong offset!");
static_assert(offsetof(UProceduralRotationMapModifier, Roll) == 0x000044, "Member 'UProceduralRotationMapModifier::Roll' has a wrong offset!");
static_assert(offsetof(UProceduralRotationMapModifier, Pitch) == 0x00004C, "Member 'UProceduralRotationMapModifier::Pitch' has a wrong offset!");
static_assert(offsetof(UProceduralRotationMapModifier, Yaw) == 0x000054, "Member 'UProceduralRotationMapModifier::Yaw' has a wrong offset!");

// Class Procedural.ProceduralRotationNoiseModifier
// 0x0028 (0x0060 - 0x0038)
class UProceduralRotationNoiseModifier final : public UProceduralRotationModifier
{
public:
	uint8                                         bRandomRoll : 1;                                   // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         RandomRoll;                                        // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRandomPitch : 1;                                  // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         RandomPitch;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRandomYaw : 1;                                    // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         RandomYaw;                                         // 0x0054(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRandomPitchMax(float InValue);
	void SetRandomPitchMin(float InValue);
	void SetRandomRollMax(float InValue);
	void SetRandomRollMin(float InValue);
	void SetRandomYawMax(float InValue);
	void SetRandomYawMin(float InValue);

	float GetRandomPitchMax() const;
	float GetRandomPitchMin() const;
	float GetRandomRollMax() const;
	float GetRandomRollMin() const;
	float GetRandomYawMax() const;
	float GetRandomYawMin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralRotationNoiseModifier">();
	}
	static class UProceduralRotationNoiseModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralRotationNoiseModifier>();
	}
};
static_assert(alignof(UProceduralRotationNoiseModifier) == 0x000008, "Wrong alignment on UProceduralRotationNoiseModifier");
static_assert(sizeof(UProceduralRotationNoiseModifier) == 0x000060, "Wrong size on UProceduralRotationNoiseModifier");
static_assert(offsetof(UProceduralRotationNoiseModifier, RandomRoll) == 0x00003C, "Member 'UProceduralRotationNoiseModifier::RandomRoll' has a wrong offset!");
static_assert(offsetof(UProceduralRotationNoiseModifier, RandomPitch) == 0x000048, "Member 'UProceduralRotationNoiseModifier::RandomPitch' has a wrong offset!");
static_assert(offsetof(UProceduralRotationNoiseModifier, RandomYaw) == 0x000054, "Member 'UProceduralRotationNoiseModifier::RandomYaw' has a wrong offset!");

// Class Procedural.ProceduralScaleModifier
// 0x0000 (0x0038 - 0x0038)
class UProceduralScaleModifier : public UProceduralParameterModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScaleModifier">();
	}
	static class UProceduralScaleModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScaleModifier>();
	}
};
static_assert(alignof(UProceduralScaleModifier) == 0x000008, "Wrong alignment on UProceduralScaleModifier");
static_assert(sizeof(UProceduralScaleModifier) == 0x000038, "Wrong size on UProceduralScaleModifier");

// Class Procedural.ProceduralScaleMapModifier
// 0x0018 (0x0050 - 0x0038)
class UProceduralScaleMapModifier final : public UProceduralScaleModifier
{
public:
	bool                                          bRemapScale;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         RemapScale;                                        // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralFloatDataMap*                Map;                                               // 0x0048(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetRemapScaleMax(float InValue);
	void SetRemapScaleMin(float InValue);

	float GetRemapScaleMax() const;
	float GetRemapScaleMin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScaleMapModifier">();
	}
	static class UProceduralScaleMapModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScaleMapModifier>();
	}
};
static_assert(alignof(UProceduralScaleMapModifier) == 0x000008, "Wrong alignment on UProceduralScaleMapModifier");
static_assert(sizeof(UProceduralScaleMapModifier) == 0x000050, "Wrong size on UProceduralScaleMapModifier");
static_assert(offsetof(UProceduralScaleMapModifier, bRemapScale) == 0x000038, "Member 'UProceduralScaleMapModifier::bRemapScale' has a wrong offset!");
static_assert(offsetof(UProceduralScaleMapModifier, RemapScale) == 0x00003C, "Member 'UProceduralScaleMapModifier::RemapScale' has a wrong offset!");
static_assert(offsetof(UProceduralScaleMapModifier, Map) == 0x000048, "Member 'UProceduralScaleMapModifier::Map' has a wrong offset!");

// Class Procedural.ProceduralScaleNoiseModifier
// 0x0008 (0x0040 - 0x0038)
class UProceduralScaleNoiseModifier final : public UProceduralScaleModifier
{
public:
	struct FFloatInterval                         Scale;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetScaleMax(float InValue);
	void SetScaleMin(float InValue);

	float GetScaleMax() const;
	float GetScaleMin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScaleNoiseModifier">();
	}
	static class UProceduralScaleNoiseModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScaleNoiseModifier>();
	}
};
static_assert(alignof(UProceduralScaleNoiseModifier) == 0x000008, "Wrong alignment on UProceduralScaleNoiseModifier");
static_assert(sizeof(UProceduralScaleNoiseModifier) == 0x000040, "Wrong size on UProceduralScaleNoiseModifier");
static_assert(offsetof(UProceduralScaleNoiseModifier, Scale) == 0x000038, "Member 'UProceduralScaleNoiseModifier::Scale' has a wrong offset!");

// Class Procedural.ProceduralScatterContentVariation
// 0x00C0 (0x00E8 - 0x0028)
class UProceduralScatterContentVariation : public UObject
{
public:
	float                                         Weight;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProceduralScatterContentPivotMode            PivotMode;                                         // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AdditionalPivotOffset;                             // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootprintBoundingBoxRatio;                         // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SetActorTags;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x88];                                      // 0x0060(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterContentVariation">();
	}
	static class UProceduralScatterContentVariation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterContentVariation>();
	}
};
static_assert(alignof(UProceduralScatterContentVariation) == 0x000008, "Wrong alignment on UProceduralScatterContentVariation");
static_assert(sizeof(UProceduralScatterContentVariation) == 0x0000E8, "Wrong size on UProceduralScatterContentVariation");
static_assert(offsetof(UProceduralScatterContentVariation, Weight) == 0x000028, "Member 'UProceduralScatterContentVariation::Weight' has a wrong offset!");
static_assert(offsetof(UProceduralScatterContentVariation, PivotMode) == 0x00002C, "Member 'UProceduralScatterContentVariation::PivotMode' has a wrong offset!");
static_assert(offsetof(UProceduralScatterContentVariation, AdditionalPivotOffset) == 0x000030, "Member 'UProceduralScatterContentVariation::AdditionalPivotOffset' has a wrong offset!");
static_assert(offsetof(UProceduralScatterContentVariation, FootprintBoundingBoxRatio) == 0x000048, "Member 'UProceduralScatterContentVariation::FootprintBoundingBoxRatio' has a wrong offset!");
static_assert(offsetof(UProceduralScatterContentVariation, SetActorTags) == 0x000050, "Member 'UProceduralScatterContentVariation::SetActorTags' has a wrong offset!");

// Class Procedural.ProceduralScatterActorContentVariation
// 0x0008 (0x00F0 - 0x00E8)
class UProceduralScatterActorContentVariation final : public UProceduralScatterContentVariation
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterActorContentVariation">();
	}
	static class UProceduralScatterActorContentVariation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterActorContentVariation>();
	}
};
static_assert(alignof(UProceduralScatterActorContentVariation) == 0x000008, "Wrong alignment on UProceduralScatterActorContentVariation");
static_assert(sizeof(UProceduralScatterActorContentVariation) == 0x0000F0, "Wrong size on UProceduralScatterActorContentVariation");
static_assert(offsetof(UProceduralScatterActorContentVariation, ActorClass) == 0x0000E8, "Member 'UProceduralScatterActorContentVariation::ActorClass' has a wrong offset!");

// Class Procedural.ProceduralScatterContentSettings
// 0x0040 (0x0068 - 0x0028)
class UProceduralScatterContentSettings : public UObject
{
public:
	TArray<class FName>                           SetActorTags;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UProceduralScatterContentVariation*> Variations;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterContentSettings">();
	}
	static class UProceduralScatterContentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterContentSettings>();
	}
};
static_assert(alignof(UProceduralScatterContentSettings) == 0x000008, "Wrong alignment on UProceduralScatterContentSettings");
static_assert(sizeof(UProceduralScatterContentSettings) == 0x000068, "Wrong size on UProceduralScatterContentSettings");
static_assert(offsetof(UProceduralScatterContentSettings, SetActorTags) == 0x000028, "Member 'UProceduralScatterContentSettings::SetActorTags' has a wrong offset!");
static_assert(offsetof(UProceduralScatterContentSettings, Variations) == 0x000038, "Member 'UProceduralScatterContentSettings::Variations' has a wrong offset!");

// Class Procedural.ProceduralScatterActorContentSettings
// 0x0008 (0x0070 - 0x0068)
class UProceduralScatterActorContentSettings final : public UProceduralScatterContentSettings
{
public:
	bool                                          bHideFromWorldOutliner;                            // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterActorContentSettings">();
	}
	static class UProceduralScatterActorContentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterActorContentSettings>();
	}
};
static_assert(alignof(UProceduralScatterActorContentSettings) == 0x000008, "Wrong alignment on UProceduralScatterActorContentSettings");
static_assert(sizeof(UProceduralScatterActorContentSettings) == 0x000070, "Wrong size on UProceduralScatterActorContentSettings");
static_assert(offsetof(UProceduralScatterActorContentSettings, bHideFromWorldOutliner) == 0x000068, "Member 'UProceduralScatterActorContentSettings::bHideFromWorldOutliner' has a wrong offset!");

// Class Procedural.ProceduralScatterGenerator
// 0x00A0 (0x00D8 - 0x0038)
class UProceduralScatterGenerator final : public UProceduralGenerator
{
public:
	EProceduralScatterMethod                      ScatterMethod;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProceduralScatterTileSettings         TileSettings;                                      // 0x003C(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RandomSeed;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUniqueSourcePointPatterns;                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GridSize;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GridJitter;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridRotation;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              GridOffset;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FProceduralScatterSettingsElement> ScatterSettingsElements;                           // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BlockingActorTags;                                 // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllScatterPointsBlocking;                         // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalDistribution;                                // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BlockingScatterPointTags;                          // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FProceduralScatterDebugSettings        ScatterDebugSettings;                              // 0x00C8(0x000C)(Edit, BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterGenerator">();
	}
	static class UProceduralScatterGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterGenerator>();
	}
};
static_assert(alignof(UProceduralScatterGenerator) == 0x000008, "Wrong alignment on UProceduralScatterGenerator");
static_assert(sizeof(UProceduralScatterGenerator) == 0x0000D8, "Wrong size on UProceduralScatterGenerator");
static_assert(offsetof(UProceduralScatterGenerator, ScatterMethod) == 0x000038, "Member 'UProceduralScatterGenerator::ScatterMethod' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, TileSettings) == 0x00003C, "Member 'UProceduralScatterGenerator::TileSettings' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, RandomSeed) == 0x000050, "Member 'UProceduralScatterGenerator::RandomSeed' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, NumUniqueSourcePointPatterns) == 0x000054, "Member 'UProceduralScatterGenerator::NumUniqueSourcePointPatterns' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, GridSize) == 0x000058, "Member 'UProceduralScatterGenerator::GridSize' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, GridJitter) == 0x000068, "Member 'UProceduralScatterGenerator::GridJitter' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, GridRotation) == 0x000078, "Member 'UProceduralScatterGenerator::GridRotation' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, GridOffset) == 0x000080, "Member 'UProceduralScatterGenerator::GridOffset' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, ScatterSettingsElements) == 0x000090, "Member 'UProceduralScatterGenerator::ScatterSettingsElements' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, BlockingActorTags) == 0x0000A0, "Member 'UProceduralScatterGenerator::BlockingActorTags' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, bAllScatterPointsBlocking) == 0x0000B0, "Member 'UProceduralScatterGenerator::bAllScatterPointsBlocking' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, bLocalDistribution) == 0x0000B1, "Member 'UProceduralScatterGenerator::bLocalDistribution' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, BlockingScatterPointTags) == 0x0000B8, "Member 'UProceduralScatterGenerator::BlockingScatterPointTags' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGenerator, ScatterDebugSettings) == 0x0000C8, "Member 'UProceduralScatterGenerator::ScatterDebugSettings' has a wrong offset!");

// Class Procedural.ProceduralScatterGeneratorContext
// 0x0328 (0x0380 - 0x0058)
class alignas(0x10) UProceduralScatterGeneratorContext final : public UProceduralGeneratorContext
{
public:
	struct FScatteredPointCloud                   ScatteredPointCloud;                               // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NonTransactional, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UProceduralScatterGeneratorTile*> UniqueTiles;                                       // 0x0068(0x0010)(ZeroConstructor, Transient, NonTransactional, NativeAccessSpecifierPrivate)
	TArray<struct FSourcePointGenerator>          SourcePointGenerators;                             // 0x0078(0x0010)(ZeroConstructor, Transient, NonTransactional, NativeAccessSpecifierPrivate)
	TArray<struct FProceduralScatterProjectionPoint> ProjectionPointCloud;                              // 0x0088(0x0010)(ZeroConstructor, Transient, NonTransactional, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UProceduralPointCloud*                  SourcePointCloud;                                  // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProceduralPointCloud*                  BlockerPointCloud;                                 // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ProjectionVectorMaterial;                          // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x2D0];                                     // 0x00B0(0x02D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterGeneratorContext">();
	}
	static class UProceduralScatterGeneratorContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterGeneratorContext>();
	}
};
static_assert(alignof(UProceduralScatterGeneratorContext) == 0x000010, "Wrong alignment on UProceduralScatterGeneratorContext");
static_assert(sizeof(UProceduralScatterGeneratorContext) == 0x000380, "Wrong size on UProceduralScatterGeneratorContext");
static_assert(offsetof(UProceduralScatterGeneratorContext, ScatteredPointCloud) == 0x000058, "Member 'UProceduralScatterGeneratorContext::ScatteredPointCloud' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGeneratorContext, UniqueTiles) == 0x000068, "Member 'UProceduralScatterGeneratorContext::UniqueTiles' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGeneratorContext, SourcePointGenerators) == 0x000078, "Member 'UProceduralScatterGeneratorContext::SourcePointGenerators' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGeneratorContext, ProjectionPointCloud) == 0x000088, "Member 'UProceduralScatterGeneratorContext::ProjectionPointCloud' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGeneratorContext, SourcePointCloud) == 0x000098, "Member 'UProceduralScatterGeneratorContext::SourcePointCloud' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGeneratorContext, BlockerPointCloud) == 0x0000A0, "Member 'UProceduralScatterGeneratorContext::BlockerPointCloud' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGeneratorContext, ProjectionVectorMaterial) == 0x0000A8, "Member 'UProceduralScatterGeneratorContext::ProjectionVectorMaterial' has a wrong offset!");

// Class Procedural.ProceduralScatterGeneratorTile
// 0x0140 (0x0168 - 0x0028)
class UProceduralScatterGeneratorTile final : public UObject
{
public:
	class UProceduralScatterGenerator*            Generator;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FProceduralScatter2DPoint>      GeneratedPoints;                                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x128];                                     // 0x0040(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterGeneratorTile">();
	}
	static class UProceduralScatterGeneratorTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterGeneratorTile>();
	}
};
static_assert(alignof(UProceduralScatterGeneratorTile) == 0x000008, "Wrong alignment on UProceduralScatterGeneratorTile");
static_assert(sizeof(UProceduralScatterGeneratorTile) == 0x000168, "Wrong size on UProceduralScatterGeneratorTile");
static_assert(offsetof(UProceduralScatterGeneratorTile, Generator) == 0x000028, "Member 'UProceduralScatterGeneratorTile::Generator' has a wrong offset!");
static_assert(offsetof(UProceduralScatterGeneratorTile, GeneratedPoints) == 0x000030, "Member 'UProceduralScatterGeneratorTile::GeneratedPoints' has a wrong offset!");

// Class Procedural.ProceduralScatterSettings
// 0x01B0 (0x01D8 - 0x0028)
class UProceduralScatterSettings final : public UObject
{
public:
	class UProceduralScatterContentSettings*      Content;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bContentVariationsModifiersEnabled : 1;            // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProceduralContentVariationsModifiers  ContentVariationsModifiers;                        // 0x0038(0x0010)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class FName>                           SetPointTags;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAutomaticCollisionRadius : 1;                     // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSphericalBoundsForAutomaticCollisionRadius : 1; // 0x005C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutomaticCollisionRadiusScaleFactor;               // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DistributionSeed;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDensityModifiersEnabled : 1;                      // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProceduralDensityModifiers            DensityModifiers;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Density;                                           // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SourcePointTagIncludes;                            // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SourcePointTagExcludes;                            // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SourceActorTagIncludes;                            // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SourceActorTagExcludes;                            // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SourceComponentTagIncludes;                        // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SourceComponentTagExcludes;                        // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFloatInterval                         SourcePointDistance;                               // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSourcePointExactNumber : 1;                    // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SourcePointExactNumber;                            // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bScaleModifiersEnabled : 1;                        // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProceduralScaleModifiers              ScaleModifiers;                                    // 0x0100(0x0020)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bRotationModifiersEnabled : 1;                     // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProceduralRotationModifiers           RotationModifiers;                                 // 0x0128(0x0010)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bAlignToNormal : 1;                                // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AlignMaxAngle;                                     // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProceduralScatterTargetSurface        TargetSurface;                                     // 0x0140(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bDetectOverhangingLedge : 1;                       // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverhangingLedgeDetectionRayCount;                 // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverhangingLedgeDetectionLength;                   // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverhangingLedgeDetectionVerticalThreshold;        // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverhangingLedgeDetectionRadiusScale;              // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilterMinimumScale;                                // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlapPriority;                                   // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCollisionWithWorld : 1;                           // 0x01A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CollisionScale;                                    // 0x01A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor;                                        // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x14];                                     // 0x01C4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSourcePointDistanceMax(float InValue);
	void SetSourcePointDistanceMin(float InValue);

	float GetSourcePointDistanceMax() const;
	float GetSourcePointDistanceMin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterSettings">();
	}
	static class UProceduralScatterSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterSettings>();
	}
};
static_assert(alignof(UProceduralScatterSettings) == 0x000008, "Wrong alignment on UProceduralScatterSettings");
static_assert(sizeof(UProceduralScatterSettings) == 0x0001D8, "Wrong size on UProceduralScatterSettings");
static_assert(offsetof(UProceduralScatterSettings, Content) == 0x000028, "Member 'UProceduralScatterSettings::Content' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, ContentVariationsModifiers) == 0x000038, "Member 'UProceduralScatterSettings::ContentVariationsModifiers' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, SetPointTags) == 0x000048, "Member 'UProceduralScatterSettings::SetPointTags' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, CollisionRadius) == 0x000058, "Member 'UProceduralScatterSettings::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, AutomaticCollisionRadiusScaleFactor) == 0x000060, "Member 'UProceduralScatterSettings::AutomaticCollisionRadiusScaleFactor' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, DistributionSeed) == 0x000064, "Member 'UProceduralScatterSettings::DistributionSeed' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, DensityModifiers) == 0x000070, "Member 'UProceduralScatterSettings::DensityModifiers' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, Density) == 0x000080, "Member 'UProceduralScatterSettings::Density' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, SourcePointTagIncludes) == 0x000088, "Member 'UProceduralScatterSettings::SourcePointTagIncludes' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, SourcePointTagExcludes) == 0x000098, "Member 'UProceduralScatterSettings::SourcePointTagExcludes' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, SourceActorTagIncludes) == 0x0000A8, "Member 'UProceduralScatterSettings::SourceActorTagIncludes' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, SourceActorTagExcludes) == 0x0000B8, "Member 'UProceduralScatterSettings::SourceActorTagExcludes' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, SourceComponentTagIncludes) == 0x0000C8, "Member 'UProceduralScatterSettings::SourceComponentTagIncludes' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, SourceComponentTagExcludes) == 0x0000D8, "Member 'UProceduralScatterSettings::SourceComponentTagExcludes' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, SourcePointDistance) == 0x0000E8, "Member 'UProceduralScatterSettings::SourcePointDistance' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, SourcePointExactNumber) == 0x0000F4, "Member 'UProceduralScatterSettings::SourcePointExactNumber' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, ScaleModifiers) == 0x000100, "Member 'UProceduralScatterSettings::ScaleModifiers' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, RotationModifiers) == 0x000128, "Member 'UProceduralScatterSettings::RotationModifiers' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, AlignMaxAngle) == 0x00013C, "Member 'UProceduralScatterSettings::AlignMaxAngle' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, TargetSurface) == 0x000140, "Member 'UProceduralScatterSettings::TargetSurface' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, OverhangingLedgeDetectionRayCount) == 0x00018C, "Member 'UProceduralScatterSettings::OverhangingLedgeDetectionRayCount' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, OverhangingLedgeDetectionLength) == 0x000190, "Member 'UProceduralScatterSettings::OverhangingLedgeDetectionLength' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, OverhangingLedgeDetectionVerticalThreshold) == 0x000194, "Member 'UProceduralScatterSettings::OverhangingLedgeDetectionVerticalThreshold' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, OverhangingLedgeDetectionRadiusScale) == 0x000198, "Member 'UProceduralScatterSettings::OverhangingLedgeDetectionRadiusScale' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, FilterMinimumScale) == 0x00019C, "Member 'UProceduralScatterSettings::FilterMinimumScale' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, OverlapPriority) == 0x0001A0, "Member 'UProceduralScatterSettings::OverlapPriority' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, CollisionScale) == 0x0001A8, "Member 'UProceduralScatterSettings::CollisionScale' has a wrong offset!");
static_assert(offsetof(UProceduralScatterSettings, DebugColor) == 0x0001C0, "Member 'UProceduralScatterSettings::DebugColor' has a wrong offset!");

// Class Procedural.ProceduralScatterStaticMeshContentVariation
// 0x0080 (0x0168 - 0x00E8)
class UProceduralScatterStaticMeshContentVariation final : public UProceduralScatterContentVariation
{
public:
	EProceduralScatterStaticMeshMode              StaticMeshMode;                                    // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             OverrideMaterials;                                 // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	class UHISMBuilderSettings*                   OverrideInstancingSettings;                        // 0x0110(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x50];                                     // 0x0118(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterStaticMeshContentVariation">();
	}
	static class UProceduralScatterStaticMeshContentVariation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterStaticMeshContentVariation>();
	}
};
static_assert(alignof(UProceduralScatterStaticMeshContentVariation) == 0x000008, "Wrong alignment on UProceduralScatterStaticMeshContentVariation");
static_assert(sizeof(UProceduralScatterStaticMeshContentVariation) == 0x000168, "Wrong size on UProceduralScatterStaticMeshContentVariation");
static_assert(offsetof(UProceduralScatterStaticMeshContentVariation, StaticMeshMode) == 0x0000E8, "Member 'UProceduralScatterStaticMeshContentVariation::StaticMeshMode' has a wrong offset!");
static_assert(offsetof(UProceduralScatterStaticMeshContentVariation, Mesh) == 0x0000F0, "Member 'UProceduralScatterStaticMeshContentVariation::Mesh' has a wrong offset!");
static_assert(offsetof(UProceduralScatterStaticMeshContentVariation, ActorClass) == 0x0000F8, "Member 'UProceduralScatterStaticMeshContentVariation::ActorClass' has a wrong offset!");
static_assert(offsetof(UProceduralScatterStaticMeshContentVariation, OverrideMaterials) == 0x000100, "Member 'UProceduralScatterStaticMeshContentVariation::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(UProceduralScatterStaticMeshContentVariation, OverrideInstancingSettings) == 0x000110, "Member 'UProceduralScatterStaticMeshContentVariation::OverrideInstancingSettings' has a wrong offset!");

// Class Procedural.ProceduralScatterStaticMeshContentSettings
// 0x0018 (0x0080 - 0x0068)
class UProceduralScatterStaticMeshContentSettings final : public UProceduralScatterContentSettings
{
public:
	TSubclassOf<class UFoliageInstancedStaticMeshComponent> ComponentClass;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentTag;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHISMBuilderSettings*                   VariationsInstancingSettings;                      // 0x0078(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralScatterStaticMeshContentSettings">();
	}
	static class UProceduralScatterStaticMeshContentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralScatterStaticMeshContentSettings>();
	}
};
static_assert(alignof(UProceduralScatterStaticMeshContentSettings) == 0x000008, "Wrong alignment on UProceduralScatterStaticMeshContentSettings");
static_assert(sizeof(UProceduralScatterStaticMeshContentSettings) == 0x000080, "Wrong size on UProceduralScatterStaticMeshContentSettings");
static_assert(offsetof(UProceduralScatterStaticMeshContentSettings, ComponentClass) == 0x000068, "Member 'UProceduralScatterStaticMeshContentSettings::ComponentClass' has a wrong offset!");
static_assert(offsetof(UProceduralScatterStaticMeshContentSettings, ComponentTag) == 0x000070, "Member 'UProceduralScatterStaticMeshContentSettings::ComponentTag' has a wrong offset!");
static_assert(offsetof(UProceduralScatterStaticMeshContentSettings, VariationsInstancingSettings) == 0x000078, "Member 'UProceduralScatterStaticMeshContentSettings::VariationsInstancingSettings' has a wrong offset!");

// Class Procedural.ProceduralSurfaceHeightMap
// 0x0010 (0x00C8 - 0x00B8)
class UProceduralSurfaceHeightMap final : public UProceduralFloatDataMap
{
public:
	bool                                          bNormalizedHeight;                                 // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         HeightRange;                                       // 0x00BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHeightRangeMax(float InValue);
	void SetHeightRangeMin(float InValue);

	float GetHeightRangeMax() const;
	float GetHeightRangeMin() const;
	float GetValue(float InHeight) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralSurfaceHeightMap">();
	}
	static class UProceduralSurfaceHeightMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralSurfaceHeightMap>();
	}
};
static_assert(alignof(UProceduralSurfaceHeightMap) == 0x000008, "Wrong alignment on UProceduralSurfaceHeightMap");
static_assert(sizeof(UProceduralSurfaceHeightMap) == 0x0000C8, "Wrong size on UProceduralSurfaceHeightMap");
static_assert(offsetof(UProceduralSurfaceHeightMap, bNormalizedHeight) == 0x0000B8, "Member 'UProceduralSurfaceHeightMap::bNormalizedHeight' has a wrong offset!");
static_assert(offsetof(UProceduralSurfaceHeightMap, HeightRange) == 0x0000BC, "Member 'UProceduralSurfaceHeightMap::HeightRange' has a wrong offset!");

// Class Procedural.ProceduralSurfaceSlopeAngleMap
// 0x0010 (0x00C8 - 0x00B8)
class UProceduralSurfaceSlopeAngleMap final : public UProceduralFloatDataMap
{
public:
	bool                                          bNormalizedSlopeAngle;                             // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         SlopeAngleRange;                                   // 0x00BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSlopeAngleRangeMax(float InValue);
	void SetSlopeAngleRangeMin(float InValue);

	float GetSlopeAngleRangeMax() const;
	float GetSlopeAngleRangeMin() const;
	float GetValue(float InSlopeAngle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralSurfaceSlopeAngleMap">();
	}
	static class UProceduralSurfaceSlopeAngleMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralSurfaceSlopeAngleMap>();
	}
};
static_assert(alignof(UProceduralSurfaceSlopeAngleMap) == 0x000008, "Wrong alignment on UProceduralSurfaceSlopeAngleMap");
static_assert(sizeof(UProceduralSurfaceSlopeAngleMap) == 0x0000C8, "Wrong size on UProceduralSurfaceSlopeAngleMap");
static_assert(offsetof(UProceduralSurfaceSlopeAngleMap, bNormalizedSlopeAngle) == 0x0000B8, "Member 'UProceduralSurfaceSlopeAngleMap::bNormalizedSlopeAngle' has a wrong offset!");
static_assert(offsetof(UProceduralSurfaceSlopeAngleMap, SlopeAngleRange) == 0x0000BC, "Member 'UProceduralSurfaceSlopeAngleMap::SlopeAngleRange' has a wrong offset!");

// Class Procedural.ProceduralTextureFloatMap
// 0x0040 (0x00F8 - 0x00B8)
class UProceduralTextureFloatMap final : public UProceduralFloatDataMap
{
public:
	EProceduralTextureColorChannel                Channel;                                           // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProceduralTextureSource               Source;                                            // 0x00C0(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralTextureFloatMap">();
	}
	static class UProceduralTextureFloatMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralTextureFloatMap>();
	}
};
static_assert(alignof(UProceduralTextureFloatMap) == 0x000008, "Wrong alignment on UProceduralTextureFloatMap");
static_assert(sizeof(UProceduralTextureFloatMap) == 0x0000F8, "Wrong size on UProceduralTextureFloatMap");
static_assert(offsetof(UProceduralTextureFloatMap, Channel) == 0x0000B8, "Member 'UProceduralTextureFloatMap::Channel' has a wrong offset!");
static_assert(offsetof(UProceduralTextureFloatMap, Source) == 0x0000C0, "Member 'UProceduralTextureFloatMap::Source' has a wrong offset!");

// Class Procedural.ProceduralTextureVectorMap
// 0x0038 (0x0270 - 0x0238)
class UProceduralTextureVectorMap final : public UProceduralVectorDataMap
{
public:
	struct FProceduralTextureSource               Source;                                            // 0x0238(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralTextureVectorMap">();
	}
	static class UProceduralTextureVectorMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralTextureVectorMap>();
	}
};
static_assert(alignof(UProceduralTextureVectorMap) == 0x000008, "Wrong alignment on UProceduralTextureVectorMap");
static_assert(sizeof(UProceduralTextureVectorMap) == 0x000270, "Wrong size on UProceduralTextureVectorMap");
static_assert(offsetof(UProceduralTextureVectorMap, Source) == 0x000238, "Member 'UProceduralTextureVectorMap::Source' has a wrong offset!");

// Class Procedural.ProceduralVertexColorMap
// 0x0008 (0x00C0 - 0x00B8)
class UProceduralVertexColorMap final : public UProceduralFloatDataMap
{
public:
	EProceduralTextureColorChannel                Channel;                                           // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralVertexColorMap">();
	}
	static class UProceduralVertexColorMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralVertexColorMap>();
	}
};
static_assert(alignof(UProceduralVertexColorMap) == 0x000008, "Wrong alignment on UProceduralVertexColorMap");
static_assert(sizeof(UProceduralVertexColorMap) == 0x0000C0, "Wrong size on UProceduralVertexColorMap");
static_assert(offsetof(UProceduralVertexColorMap, Channel) == 0x0000B8, "Member 'UProceduralVertexColorMap::Channel' has a wrong offset!");

}

