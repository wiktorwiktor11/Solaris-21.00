#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GA_Athena_TacticalSprint

#include "Basic.hpp"

#include "GA_Athena_TacticalSprint_classes.hpp"
#include "GA_Athena_TacticalSprint_parameters.hpp"


namespace SDK
{

// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.UnbindToFortPlayerPawnDied
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::UnbindToFortPlayerPawnDied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "UnbindToFortPlayerPawnDied");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.SetUseHighLocationToleranceForAcceleration
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShouldUseHighTolerance                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::SetUseHighLocationToleranceForAcceleration(bool bShouldUseHighTolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "SetUseHighLocationToleranceForAcceleration");

	Params::GA_Athena_TacticalSprint_C_SetUseHighLocationToleranceForAcceleration Parms{};

	Parms.bShouldUseHighTolerance = bShouldUseHighTolerance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.UnbindOnReloadCancelingSprint
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::UnbindOnReloadCancelingSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "UnbindOnReloadCancelingSprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.UnbindOnEnteredEditMode
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::UnbindOnEnteredEditMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "UnbindOnEnteredEditMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.ToggleAccelMode
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::ToggleAccelMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "ToggleAccelMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.StopDrainingEnergy
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::StopDrainingEnergy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "StopDrainingEnergy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.StartDrainingEnergy
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::StartDrainingEnergy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "StartDrainingEnergy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.SetUpTagBinds
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::SetUpTagBinds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "SetUpTagBinds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.SetupAircraftBinds
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::SetupAircraftBinds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "SetupAircraftBinds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.SetInfiniteSprint
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewInfiniteSprint                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::SetInfiniteSprint(bool NewInfiniteSprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "SetInfiniteSprint");

	Params::GA_Athena_TacticalSprint_C_SetInfiniteSprint Parms{};

	Parms.NewInfiniteSprint = NewInfiniteSprint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.SafetyKillTimer
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::SafetyKillTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "SafetyKillTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.ResetSlideCancellation
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::ResetSlideCancellation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "ResetSlideCancellation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.Register For Safety Kill
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::Register_For_Safety_Kill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "Register For Safety Kill");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.PayEnergyCostOnSlide
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::PayEnergyCostOnSlide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "PayEnergyCostOnSlide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.OnReloadCancelingSprint
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::OnReloadCancelingSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "OnReloadCancelingSprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.OnFortPlayerPawnDied
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortPlayerPawnAthena*            FortPlayerPawnAthena                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::OnFortPlayerPawnDied(class AFortPlayerPawnAthena* FortPlayerPawnAthena)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "OnFortPlayerPawnDied");

	Params::GA_Athena_TacticalSprint_C_OnFortPlayerPawnDied Parms{};

	Parms.FortPlayerPawnAthena = FortPlayerPawnAthena;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.OnEnteredEditMode
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::OnEnteredEditMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "OnEnteredEditMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.OnEnergyDrained
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFortComponent_Energy*            EnergyComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::OnEnergyDrained(class UFortComponent_Energy* EnergyComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "OnEnergyDrained");

	Params::GA_Athena_TacticalSprint_C_OnEnergyDrained Parms{};

	Parms.EnergyComponent = EnergyComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.NotifySprintStarted
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::NotifySprintStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "NotifySprintStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.NotifySprintEnded
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::NotifySprintEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "NotifySprintEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.LogAndVisualLog
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESprintLoggingVerbosityLevel            Verbosity                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           LogString                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::LogAndVisualLog(ESprintLoggingVerbosityLevel Verbosity, const class FString& LogString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "LogAndVisualLog");

	Params::GA_Athena_TacticalSprint_C_LogAndVisualLog Parms{};

	Parms.Verbosity = Verbosity;
	Parms.LogString = std::move(LogString);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.K2_OnEndAbility
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bWasCancelled                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::K2_OnEndAbility(bool bWasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "K2_OnEndAbility");

	Params::GA_Athena_TacticalSprint_C_K2_OnEndAbility Parms{};

	Parms.bWasCancelled = bWasCancelled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.K2_ActivateAbility
// (Event, Protected, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::K2_ActivateAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "K2_ActivateAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.IsSprintJumping
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsJumping_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::IsSprintJumping(bool* IsJumping_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "IsSprintJumping");

	Params::GA_Athena_TacticalSprint_C_IsSprintJumping Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsJumping_0 != nullptr)
		*IsJumping_0 = Parms.IsJumping_0;
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.HasZeroEnergy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Has_Zero_Energy                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::HasZeroEnergy(bool* Has_Zero_Energy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "HasZeroEnergy");

	Params::GA_Athena_TacticalSprint_C_HasZeroEnergy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Has_Zero_Energy != nullptr)
		*Has_Zero_Energy = Parms.Has_Zero_Energy;
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.HandleTutorialQuestUpdate
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::HandleTutorialQuestUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "HandleTutorialQuestUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.HandleSlidingStopped
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::HandleSlidingStopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "HandleSlidingStopped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.HandleSlidingStarted
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::HandleSlidingStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "HandleSlidingStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.HandlePawnJumped
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::HandlePawnJumped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "HandlePawnJumped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.HandleMovementModeChanged
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EMovementMode                           PrevMovementMode                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   PreviousCustomMode                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::HandleMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "HandleMovementModeChanged");

	Params::GA_Athena_TacticalSprint_C_HandleMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.HandleMovementModeBecameSliding
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::HandleMovementModeBecameSliding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "HandleMovementModeBecameSliding");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.HandleFailedToSprint
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::HandleFailedToSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "HandleFailedToSprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.HandleEnteredAircraft
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::HandleEnteredAircraft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "HandleEnteredAircraft");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.GetTacticalSprintEnergyComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFortComponent_Energy*            TacticalSprintEnergyComponent                          (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::GetTacticalSprintEnergyComponent(class UFortComponent_Energy** TacticalSprintEnergyComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "GetTacticalSprintEnergyComponent");

	Params::GA_Athena_TacticalSprint_C_GetTacticalSprintEnergyComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TacticalSprintEnergyComponent != nullptr)
		*TacticalSprintEnergyComponent = Parms.TacticalSprintEnergyComponent;
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.GetTacticalSprintComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTacticalSprintControllerComponent_C*TacticalSprintComponent                                (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::GetTacticalSprintComponent(class UTacticalSprintControllerComponent_C** TacticalSprintComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "GetTacticalSprintComponent");

	Params::GA_Athena_TacticalSprint_C_GetTacticalSprintComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TacticalSprintComponent != nullptr)
		*TacticalSprintComponent = Parms.TacticalSprintComponent;
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.Full Speed Reached
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::Full_Speed_Reached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "Full Speed Reached");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.FindFortPlayerPawnCached
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortPlayerPawn*                  FortPlayerPawn_0                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::FindFortPlayerPawnCached(class AFortPlayerPawn** FortPlayerPawn_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "FindFortPlayerPawnCached");

	Params::GA_Athena_TacticalSprint_C_FindFortPlayerPawnCached Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FortPlayerPawn_0 != nullptr)
		*FortPlayerPawn_0 = Parms.FortPlayerPawn_0;
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.ExecuteUbergraph_GA_Athena_TacticalSprint
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::ExecuteUbergraph_GA_Athena_TacticalSprint(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "ExecuteUbergraph_GA_Athena_TacticalSprint");

	Params::GA_Athena_TacticalSprint_C_ExecuteUbergraph_GA_Athena_TacticalSprint Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.EndAbilityAtTopOfNextFrame
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::EndAbilityAtTopOfNextFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "EndAbilityAtTopOfNextFrame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.EndAbilityAtTopOfFrame
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::EndAbilityAtTopOfFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "EndAbilityAtTopOfFrame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.CostEnergyOnJump
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::CostEnergyOnJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "CostEnergyOnJump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.ClearAircraftBinds
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::ClearAircraftBinds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "ClearAircraftBinds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.CheckMovementModeWhenEnergyDrained
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Not_Jumping___End_Immediately                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Other_States___Need_to_End_Sprint_Now                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Is_Airborne___Wait_for_no_longer_airborne              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Still_Walking___Make_sure_jumping_happens              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::CheckMovementModeWhenEnergyDrained(bool* Not_Jumping___End_Immediately, bool* Other_States___Need_to_End_Sprint_Now, bool* Is_Airborne___Wait_for_no_longer_airborne, bool* Still_Walking___Make_sure_jumping_happens)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "CheckMovementModeWhenEnergyDrained");

	Params::GA_Athena_TacticalSprint_C_CheckMovementModeWhenEnergyDrained Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Not_Jumping___End_Immediately != nullptr)
		*Not_Jumping___End_Immediately = Parms.Not_Jumping___End_Immediately;

	if (Other_States___Need_to_End_Sprint_Now != nullptr)
		*Other_States___Need_to_End_Sprint_Now = Parms.Other_States___Need_to_End_Sprint_Now;

	if (Is_Airborne___Wait_for_no_longer_airborne != nullptr)
		*Is_Airborne___Wait_for_no_longer_airborne = Parms.Is_Airborne___Wait_for_no_longer_airborne;

	if (Still_Walking___Make_sure_jumping_happens != nullptr)
		*Still_Walking___Make_sure_jumping_happens = Parms.Still_Walking___Make_sure_jumping_happens;
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.CheckIfStillFalling
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::CheckIfStillFalling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "CheckIfStillFalling");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.Check if Jump Succeeded - Out of Energy
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::Check_if_Jump_Succeeded___Out_of_Energy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "Check if Jump Succeeded - Out of Energy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.BindToFortPlayerPawnDied
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::BindToFortPlayerPawnDied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "BindToFortPlayerPawnDied");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.BindToCheckIfFalling
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::BindToCheckIfFalling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "BindToCheckIfFalling");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.BindOnReloadCancelingSprint
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::BindOnReloadCancelingSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "BindOnReloadCancelingSprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.BindOnEnteredEditMode
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::BindOnEnteredEditMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "BindOnEnteredEditMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.ApplyStackOfSpeedAndJumpModifiers
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Single_Stack_Max_Speed_Multiplier                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Single_Stack_Jump_Z_Multiplier                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSubclassOf<class UGameplayEffect>      Gameplay_Effect_Class                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// struct FActiveGameplayEffectHandle      GameplayEffectHandle                                   (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void UGA_Athena_TacticalSprint_C::ApplyStackOfSpeedAndJumpModifiers(float Single_Stack_Max_Speed_Multiplier, float Single_Stack_Jump_Z_Multiplier, TSubclassOf<class UGameplayEffect> Gameplay_Effect_Class, struct FActiveGameplayEffectHandle* GameplayEffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "ApplyStackOfSpeedAndJumpModifiers");

	Params::GA_Athena_TacticalSprint_C_ApplyStackOfSpeedAndJumpModifiers Parms{};

	Parms.Single_Stack_Max_Speed_Multiplier = Single_Stack_Max_Speed_Multiplier;
	Parms.Single_Stack_Jump_Z_Multiplier = Single_Stack_Jump_Z_Multiplier;
	Parms.Gameplay_Effect_Class = Gameplay_Effect_Class;

	UObject::ProcessEvent(Func, &Parms);

	if (GameplayEffectHandle != nullptr)
		*GameplayEffectHandle = std::move(Parms.GameplayEffectHandle);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.ApplySpeedAndJumpZIncreaseOverTime
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::ApplySpeedAndJumpZIncreaseOverTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "ApplySpeedAndJumpZIncreaseOverTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.Accelerate
// (BlueprintCallable, BlueprintEvent)

void UGA_Athena_TacticalSprint_C::Accelerate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "Accelerate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Athena_TacticalSprint.GA_Athena_TacticalSprint_C.K2_CanActivateAbility
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// struct FGameplayAbilitySpecHandle       Handle                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            RelevantTags                                           (Parm, OutParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_Athena_TacticalSprint_C::K2_CanActivateAbility(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpecHandle& Handle, struct FGameplayTagContainer* RelevantTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Athena_TacticalSprint_C", "K2_CanActivateAbility");

	Params::GA_Athena_TacticalSprint_C_K2_CanActivateAbility Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.Handle = std::move(Handle);

	UObject::ProcessEvent(Func, &Parms);

	if (RelevantTags != nullptr)
		*RelevantTags = std::move(Parms.RelevantTags);

	return Parms.ReturnValue;
}

}

