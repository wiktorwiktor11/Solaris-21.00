#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Procedural

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum Procedural.EProceduralParameterModifierBlendMode
// NumValues: 0x0006
enum class EProceduralParameterModifierBlendMode : uint8
{
	Min                                      = 0,
	Max                                      = 1,
	Additive                                 = 2,
	Subtractive                              = 3,
	Multiply                                 = 4,
	Interpolate                              = 5,
};

// Enum Procedural.EProceduralRotationFormat
// NumValues: 0x000E
enum class EProceduralRotationFormat : uint8
{
	VectorXAxis                              = 0,
	VectorXAxisNegative                      = 1,
	VectorYAxis                              = 2,
	VectorYAxisNegative                      = 3,
	VectorZAxis                              = 4,
	VectorZAxisNegative                      = 5,
	Vector2DXAxis                            = 6,
	Vector2DXAxisNegative                    = 7,
	Vector2DYAxis                            = 8,
	Vector2DYAxisNegative                    = 9,
	Vector2DZAxis                            = 10,
	Vector2DZAxisNegative                    = 11,
	RangedRotator                            = 12,
	EProceduralRotationFormat_MAX            = 13,
};

// Enum Procedural.EProceduralScatterContentPivotMode
// NumValues: 0x0005
enum class EProceduralScatterContentPivotMode : uint8
{
	UsePivot                                 = 0,
	UseBoundingBoxCenter                     = 1,
	UseBoundingBoxBottomCenter               = 2,
	UseFootprintBoundingBoxBottomCenter      = 3,
	EProceduralScatterContentPivotMode_MAX   = 4,
};

// Enum Procedural.EProceduralScatterTileRandomGenerator
// NumValues: 0x0003
enum class EProceduralScatterTileRandomGenerator : uint8
{
	PseudoRandom                             = 0,
	HaltonSequence                           = 1,
	EProceduralScatterTileRandomGenerator_MAX = 2,
};

// Enum Procedural.EProceduralScatterMethod
// NumValues: 0x0004
enum class EProceduralScatterMethod : uint8
{
	Density                                  = 0,
	SourcePoints                             = 1,
	Grid                                     = 2,
	EProceduralScatterMethod_MAX             = 3,
};

// Enum Procedural.EProceduralScatterStaticMeshMode
// NumValues: 0x0003
enum class EProceduralScatterStaticMeshMode : uint8
{
	FromStaticMesh                           = 0,
	FromActor                                = 1,
	EProceduralScatterStaticMeshMode_MAX     = 2,
};

// Enum Procedural.EProceduralTextureColorChannel
// NumValues: 0x0005
enum class EProceduralTextureColorChannel : uint8
{
	Red                                      = 0,
	Green                                    = 1,
	Blue                                     = 2,
	Alpha                                    = 3,
	EProceduralTextureColorChannel_MAX       = 4,
};

// ScriptStruct Procedural.ProceduralScatter2DPoint
// 0x0060 (0x0060 - 0x0000)
struct FProceduralScatter2DPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralScatterSettings*             ScatterSettings;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 MaxAABB;                                           // 0x0028(0x0028)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlocker;                                          // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomNumber;                                      // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralScatter2DPoint) == 0x000008, "Wrong alignment on FProceduralScatter2DPoint");
static_assert(sizeof(FProceduralScatter2DPoint) == 0x000060, "Wrong size on FProceduralScatter2DPoint");
static_assert(offsetof(FProceduralScatter2DPoint, Location) == 0x000000, "Member 'FProceduralScatter2DPoint::Location' has a wrong offset!");
static_assert(offsetof(FProceduralScatter2DPoint, Scale) == 0x000018, "Member 'FProceduralScatter2DPoint::Scale' has a wrong offset!");
static_assert(offsetof(FProceduralScatter2DPoint, ScatterSettings) == 0x000020, "Member 'FProceduralScatter2DPoint::ScatterSettings' has a wrong offset!");
static_assert(offsetof(FProceduralScatter2DPoint, MaxAABB) == 0x000028, "Member 'FProceduralScatter2DPoint::MaxAABB' has a wrong offset!");
static_assert(offsetof(FProceduralScatter2DPoint, CollisionRadius) == 0x000050, "Member 'FProceduralScatter2DPoint::CollisionRadius' has a wrong offset!");
static_assert(offsetof(FProceduralScatter2DPoint, bBlocker) == 0x000054, "Member 'FProceduralScatter2DPoint::bBlocker' has a wrong offset!");
static_assert(offsetof(FProceduralScatter2DPoint, RandomNumber) == 0x000058, "Member 'FProceduralScatter2DPoint::RandomNumber' has a wrong offset!");

// ScriptStruct Procedural.ProceduralContentVariationMap
// 0x0018 (0x0018 - 0x0000)
struct FProceduralContentVariationMap final
{
public:
	int32                                         VariationIndex;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralFloatDataMap*                Map;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralContentVariationMap) == 0x000008, "Wrong alignment on FProceduralContentVariationMap");
static_assert(sizeof(FProceduralContentVariationMap) == 0x000018, "Wrong size on FProceduralContentVariationMap");
static_assert(offsetof(FProceduralContentVariationMap, VariationIndex) == 0x000000, "Member 'FProceduralContentVariationMap::VariationIndex' has a wrong offset!");
static_assert(offsetof(FProceduralContentVariationMap, Map) == 0x000008, "Member 'FProceduralContentVariationMap::Map' has a wrong offset!");
static_assert(offsetof(FProceduralContentVariationMap, Weight) == 0x000010, "Member 'FProceduralContentVariationMap::Weight' has a wrong offset!");

// ScriptStruct Procedural.ProceduralRemapFloatCurve
// 0x0088 (0x0088 - 0x0000)
struct FProceduralRemapFloatCurve final
{
public:
	struct FRuntimeFloatCurve                     RemapCurve;                                        // 0x0000(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralRemapFloatCurve) == 0x000008, "Wrong alignment on FProceduralRemapFloatCurve");
static_assert(sizeof(FProceduralRemapFloatCurve) == 0x000088, "Wrong size on FProceduralRemapFloatCurve");
static_assert(offsetof(FProceduralRemapFloatCurve, RemapCurve) == 0x000000, "Member 'FProceduralRemapFloatCurve::RemapCurve' has a wrong offset!");

// ScriptStruct Procedural.ProceduralRemapVectorCurve
// 0x0208 (0x0208 - 0x0000)
struct FProceduralRemapVectorCurve final
{
public:
	struct FRuntimeCurveLinearColor               RemapCurve;                                        // 0x0000(0x0208)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralRemapVectorCurve) == 0x000008, "Wrong alignment on FProceduralRemapVectorCurve");
static_assert(sizeof(FProceduralRemapVectorCurve) == 0x000208, "Wrong size on FProceduralRemapVectorCurve");
static_assert(offsetof(FProceduralRemapVectorCurve, RemapCurve) == 0x000000, "Member 'FProceduralRemapVectorCurve::RemapCurve' has a wrong offset!");

// ScriptStruct Procedural.ProceduralDebugSettings
// 0x000C (0x000C - 0x0000)
struct FProceduralDebugSettings final
{
public:
	bool                                          bShowDebugPointCloud;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 DebugPointColor;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugCullingDistance;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralDebugSettings) == 0x000004, "Wrong alignment on FProceduralDebugSettings");
static_assert(sizeof(FProceduralDebugSettings) == 0x00000C, "Wrong size on FProceduralDebugSettings");
static_assert(offsetof(FProceduralDebugSettings, bShowDebugPointCloud) == 0x000000, "Member 'FProceduralDebugSettings::bShowDebugPointCloud' has a wrong offset!");
static_assert(offsetof(FProceduralDebugSettings, DebugPointColor) == 0x000004, "Member 'FProceduralDebugSettings::DebugPointColor' has a wrong offset!");
static_assert(offsetof(FProceduralDebugSettings, DebugCullingDistance) == 0x000008, "Member 'FProceduralDebugSettings::DebugCullingDistance' has a wrong offset!");

// ScriptStruct Procedural.ProceduralGenerationStackElement
// 0x0010 (0x0010 - 0x0000)
struct FProceduralGenerationStackElement final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralGenerator*                   Generator;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralGenerationStackElement) == 0x000008, "Wrong alignment on FProceduralGenerationStackElement");
static_assert(sizeof(FProceduralGenerationStackElement) == 0x000010, "Wrong size on FProceduralGenerationStackElement");
static_assert(offsetof(FProceduralGenerationStackElement, bEnabled) == 0x000000, "Member 'FProceduralGenerationStackElement::bEnabled' has a wrong offset!");
static_assert(offsetof(FProceduralGenerationStackElement, Generator) == 0x000008, "Member 'FProceduralGenerationStackElement::Generator' has a wrong offset!");

// ScriptStruct Procedural.ProceduralHitPoint
// 0x0040 (0x0040 - 0x0000)
struct FProceduralHitPoint final
{
public:
	bool                                          bIsTraceDone;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralHitPoint) == 0x000008, "Wrong alignment on FProceduralHitPoint");
static_assert(sizeof(FProceduralHitPoint) == 0x000040, "Wrong size on FProceduralHitPoint");
static_assert(offsetof(FProceduralHitPoint, bIsTraceDone) == 0x000000, "Member 'FProceduralHitPoint::bIsTraceDone' has a wrong offset!");
static_assert(offsetof(FProceduralHitPoint, Position) == 0x000008, "Member 'FProceduralHitPoint::Position' has a wrong offset!");
static_assert(offsetof(FProceduralHitPoint, Normal) == 0x000020, "Member 'FProceduralHitPoint::Normal' has a wrong offset!");
static_assert(offsetof(FProceduralHitPoint, Component) == 0x000038, "Member 'FProceduralHitPoint::Component' has a wrong offset!");

// ScriptStruct Procedural.ProceduralPointCloudPoint
// 0x00B0 (0x00B0 - 0x0000)
struct FProceduralPointCloudPoint final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SurfaceNormal;                                     // 0x0060(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SurfaceObject;                                     // 0x0078(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObjectVariation;                                   // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0090(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourcePointGeneratorIndex;                         // 0x00A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralPointCloudPoint) == 0x000010, "Wrong alignment on FProceduralPointCloudPoint");
static_assert(sizeof(FProceduralPointCloudPoint) == 0x0000B0, "Wrong size on FProceduralPointCloudPoint");
static_assert(offsetof(FProceduralPointCloudPoint, Transform) == 0x000000, "Member 'FProceduralPointCloudPoint::Transform' has a wrong offset!");
static_assert(offsetof(FProceduralPointCloudPoint, SurfaceNormal) == 0x000060, "Member 'FProceduralPointCloudPoint::SurfaceNormal' has a wrong offset!");
static_assert(offsetof(FProceduralPointCloudPoint, SurfaceObject) == 0x000078, "Member 'FProceduralPointCloudPoint::SurfaceObject' has a wrong offset!");
static_assert(offsetof(FProceduralPointCloudPoint, Object) == 0x000080, "Member 'FProceduralPointCloudPoint::Object' has a wrong offset!");
static_assert(offsetof(FProceduralPointCloudPoint, ObjectVariation) == 0x000088, "Member 'FProceduralPointCloudPoint::ObjectVariation' has a wrong offset!");
static_assert(offsetof(FProceduralPointCloudPoint, Tags) == 0x000090, "Member 'FProceduralPointCloudPoint::Tags' has a wrong offset!");
static_assert(offsetof(FProceduralPointCloudPoint, CollisionRadius) == 0x0000A0, "Member 'FProceduralPointCloudPoint::CollisionRadius' has a wrong offset!");
static_assert(offsetof(FProceduralPointCloudPoint, SourcePointGeneratorIndex) == 0x0000A4, "Member 'FProceduralPointCloudPoint::SourcePointGeneratorIndex' has a wrong offset!");

// ScriptStruct Procedural.ProceduralScatterSettingsElement
// 0x0018 (0x0018 - 0x0000)
struct FProceduralScatterSettingsElement final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralScatterSettings*             ScatterSettings;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPoints;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralScatterSettingsElement) == 0x000008, "Wrong alignment on FProceduralScatterSettingsElement");
static_assert(sizeof(FProceduralScatterSettingsElement) == 0x000018, "Wrong size on FProceduralScatterSettingsElement");
static_assert(offsetof(FProceduralScatterSettingsElement, bEnabled) == 0x000000, "Member 'FProceduralScatterSettingsElement::bEnabled' has a wrong offset!");
static_assert(offsetof(FProceduralScatterSettingsElement, ScatterSettings) == 0x000008, "Member 'FProceduralScatterSettingsElement::ScatterSettings' has a wrong offset!");
static_assert(offsetof(FProceduralScatterSettingsElement, MaxPoints) == 0x000010, "Member 'FProceduralScatterSettingsElement::MaxPoints' has a wrong offset!");

// ScriptStruct Procedural.ProceduralScatterDebugSettings
// 0x000C (0x000C - 0x0000)
struct FProceduralScatterDebugSettings final
{
public:
	bool                                          bShowDebugPlane;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugTrace;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugFootprint;                               // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugHitNormal;                               // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugPoints;                                  // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugPivots;                                  // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugMaxCullingDistance;                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralScatterDebugSettings) == 0x000004, "Wrong alignment on FProceduralScatterDebugSettings");
static_assert(sizeof(FProceduralScatterDebugSettings) == 0x00000C, "Wrong size on FProceduralScatterDebugSettings");
static_assert(offsetof(FProceduralScatterDebugSettings, bShowDebugPlane) == 0x000000, "Member 'FProceduralScatterDebugSettings::bShowDebugPlane' has a wrong offset!");
static_assert(offsetof(FProceduralScatterDebugSettings, bShowDebugTrace) == 0x000001, "Member 'FProceduralScatterDebugSettings::bShowDebugTrace' has a wrong offset!");
static_assert(offsetof(FProceduralScatterDebugSettings, bShowDebugFootprint) == 0x000002, "Member 'FProceduralScatterDebugSettings::bShowDebugFootprint' has a wrong offset!");
static_assert(offsetof(FProceduralScatterDebugSettings, bShowDebugHitNormal) == 0x000003, "Member 'FProceduralScatterDebugSettings::bShowDebugHitNormal' has a wrong offset!");
static_assert(offsetof(FProceduralScatterDebugSettings, bShowDebugPoints) == 0x000004, "Member 'FProceduralScatterDebugSettings::bShowDebugPoints' has a wrong offset!");
static_assert(offsetof(FProceduralScatterDebugSettings, bShowDebugPivots) == 0x000005, "Member 'FProceduralScatterDebugSettings::bShowDebugPivots' has a wrong offset!");
static_assert(offsetof(FProceduralScatterDebugSettings, DebugMaxCullingDistance) == 0x000008, "Member 'FProceduralScatterDebugSettings::DebugMaxCullingDistance' has a wrong offset!");

// ScriptStruct Procedural.ProceduralScatterTileSettings
// 0x0014 (0x0014 - 0x0000)
struct FProceduralScatterTileSettings final
{
public:
	int32                                         NumUniqueTiles;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileSize;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileOverlapPercentage;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumQuadTreeSize;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProceduralScatterTileRandomGenerator         RandomGenerator;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralScatterTileSettings) == 0x000004, "Wrong alignment on FProceduralScatterTileSettings");
static_assert(sizeof(FProceduralScatterTileSettings) == 0x000014, "Wrong size on FProceduralScatterTileSettings");
static_assert(offsetof(FProceduralScatterTileSettings, NumUniqueTiles) == 0x000000, "Member 'FProceduralScatterTileSettings::NumUniqueTiles' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTileSettings, TileSize) == 0x000004, "Member 'FProceduralScatterTileSettings::TileSize' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTileSettings, TileOverlapPercentage) == 0x000008, "Member 'FProceduralScatterTileSettings::TileOverlapPercentage' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTileSettings, MinimumQuadTreeSize) == 0x00000C, "Member 'FProceduralScatterTileSettings::MinimumQuadTreeSize' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTileSettings, RandomGenerator) == 0x000010, "Member 'FProceduralScatterTileSettings::RandomGenerator' has a wrong offset!");

// ScriptStruct Procedural.SourcePointGenerator
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSourcePointGenerator final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSourcePointGenerator) == 0x000008, "Wrong alignment on FSourcePointGenerator");
static_assert(sizeof(FSourcePointGenerator) == 0x000018, "Wrong size on FSourcePointGenerator");

// ScriptStruct Procedural.ProceduralScatterPoint
// 0x00A0 (0x00A0 - 0x0000)
struct FProceduralScatterPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralScatterSettings*             ScatterSettings;                                   // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VariationIdx;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GenerationLocation;                                // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProceduralHitPoint                    HitPoint;                                          // 0x0060(0x0040)(BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralScatterPoint) == 0x000008, "Wrong alignment on FProceduralScatterPoint");
static_assert(sizeof(FProceduralScatterPoint) == 0x0000A0, "Wrong size on FProceduralScatterPoint");
static_assert(offsetof(FProceduralScatterPoint, Location) == 0x000000, "Member 'FProceduralScatterPoint::Location' has a wrong offset!");
static_assert(offsetof(FProceduralScatterPoint, Rotation) == 0x000018, "Member 'FProceduralScatterPoint::Rotation' has a wrong offset!");
static_assert(offsetof(FProceduralScatterPoint, Scale) == 0x000030, "Member 'FProceduralScatterPoint::Scale' has a wrong offset!");
static_assert(offsetof(FProceduralScatterPoint, ScatterSettings) == 0x000038, "Member 'FProceduralScatterPoint::ScatterSettings' has a wrong offset!");
static_assert(offsetof(FProceduralScatterPoint, VariationIdx) == 0x000040, "Member 'FProceduralScatterPoint::VariationIdx' has a wrong offset!");
static_assert(offsetof(FProceduralScatterPoint, GenerationLocation) == 0x000048, "Member 'FProceduralScatterPoint::GenerationLocation' has a wrong offset!");
static_assert(offsetof(FProceduralScatterPoint, HitPoint) == 0x000060, "Member 'FProceduralScatterPoint::HitPoint' has a wrong offset!");

// ScriptStruct Procedural.ScatteredPointCloud
// 0x0010 (0x0010 - 0x0000)
struct FScatteredPointCloud final
{
public:
	TArray<struct FProceduralScatterPoint>        Points;                                            // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FScatteredPointCloud) == 0x000008, "Wrong alignment on FScatteredPointCloud");
static_assert(sizeof(FScatteredPointCloud) == 0x000010, "Wrong size on FScatteredPointCloud");
static_assert(offsetof(FScatteredPointCloud, Points) == 0x000000, "Member 'FScatteredPointCloud::Points' has a wrong offset!");

// ScriptStruct Procedural.ProceduralScatterProjectionPoint
// 0x00C0 (0x00C0 - 0x0000)
struct FProceduralScatterProjectionPoint final
{
public:
	struct FVector                                GenerationLocation;                                // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralScatterSettings*             ScatterSettings;                                   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VariationIdx;                                      // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartTrace;                                        // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTrace;                                          // 0x0060(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProceduralHitPoint                    HitPoint;                                          // 0x0078(0x0040)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralScatterProjectionPoint) == 0x000008, "Wrong alignment on FProceduralScatterProjectionPoint");
static_assert(sizeof(FProceduralScatterProjectionPoint) == 0x0000C0, "Wrong size on FProceduralScatterProjectionPoint");
static_assert(offsetof(FProceduralScatterProjectionPoint, GenerationLocation) == 0x000000, "Member 'FProceduralScatterProjectionPoint::GenerationLocation' has a wrong offset!");
static_assert(offsetof(FProceduralScatterProjectionPoint, Rotation) == 0x000018, "Member 'FProceduralScatterProjectionPoint::Rotation' has a wrong offset!");
static_assert(offsetof(FProceduralScatterProjectionPoint, Scale) == 0x000030, "Member 'FProceduralScatterProjectionPoint::Scale' has a wrong offset!");
static_assert(offsetof(FProceduralScatterProjectionPoint, ScatterSettings) == 0x000038, "Member 'FProceduralScatterProjectionPoint::ScatterSettings' has a wrong offset!");
static_assert(offsetof(FProceduralScatterProjectionPoint, VariationIdx) == 0x000040, "Member 'FProceduralScatterProjectionPoint::VariationIdx' has a wrong offset!");
static_assert(offsetof(FProceduralScatterProjectionPoint, StartTrace) == 0x000048, "Member 'FProceduralScatterProjectionPoint::StartTrace' has a wrong offset!");
static_assert(offsetof(FProceduralScatterProjectionPoint, EndTrace) == 0x000060, "Member 'FProceduralScatterProjectionPoint::EndTrace' has a wrong offset!");
static_assert(offsetof(FProceduralScatterProjectionPoint, HitPoint) == 0x000078, "Member 'FProceduralScatterProjectionPoint::HitPoint' has a wrong offset!");

// ScriptStruct Procedural.ProceduralScatterTargetSurface
// 0x0048 (0x0048 - 0x0000)
struct FProceduralScatterTargetSurface final
{
public:
	bool                                          bAllowLandscape;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowBSP;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowStaticMesh;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTranslucent;                                 // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AllowedActorTags;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class FName>                           DisallowedActorTags;                               // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class FName>                           AllowedComponentTags;                              // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class FName>                           DisallowedComponentTags;                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralScatterTargetSurface) == 0x000008, "Wrong alignment on FProceduralScatterTargetSurface");
static_assert(sizeof(FProceduralScatterTargetSurface) == 0x000048, "Wrong size on FProceduralScatterTargetSurface");
static_assert(offsetof(FProceduralScatterTargetSurface, bAllowLandscape) == 0x000000, "Member 'FProceduralScatterTargetSurface::bAllowLandscape' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTargetSurface, bAllowBSP) == 0x000001, "Member 'FProceduralScatterTargetSurface::bAllowBSP' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTargetSurface, bAllowStaticMesh) == 0x000002, "Member 'FProceduralScatterTargetSurface::bAllowStaticMesh' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTargetSurface, bAllowTranslucent) == 0x000003, "Member 'FProceduralScatterTargetSurface::bAllowTranslucent' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTargetSurface, AllowedActorTags) == 0x000008, "Member 'FProceduralScatterTargetSurface::AllowedActorTags' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTargetSurface, DisallowedActorTags) == 0x000018, "Member 'FProceduralScatterTargetSurface::DisallowedActorTags' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTargetSurface, AllowedComponentTags) == 0x000028, "Member 'FProceduralScatterTargetSurface::AllowedComponentTags' has a wrong offset!");
static_assert(offsetof(FProceduralScatterTargetSurface, DisallowedComponentTags) == 0x000038, "Member 'FProceduralScatterTargetSurface::DisallowedComponentTags' has a wrong offset!");

// ScriptStruct Procedural.ProceduralContentVariationsModifiers
// 0x0010 (0x0010 - 0x0000)
struct FProceduralContentVariationsModifiers final
{
public:
	TArray<class UProceduralContentVariationsWeightsModifier*> Modifiers;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralContentVariationsModifiers) == 0x000008, "Wrong alignment on FProceduralContentVariationsModifiers");
static_assert(sizeof(FProceduralContentVariationsModifiers) == 0x000010, "Wrong size on FProceduralContentVariationsModifiers");
static_assert(offsetof(FProceduralContentVariationsModifiers, Modifiers) == 0x000000, "Member 'FProceduralContentVariationsModifiers::Modifiers' has a wrong offset!");

// ScriptStruct Procedural.ProceduralDensityModifiers
// 0x0010 (0x0010 - 0x0000)
struct FProceduralDensityModifiers final
{
public:
	TArray<class UProceduralDensityModifier*>     Modifiers;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralDensityModifiers) == 0x000008, "Wrong alignment on FProceduralDensityModifiers");
static_assert(sizeof(FProceduralDensityModifiers) == 0x000010, "Wrong size on FProceduralDensityModifiers");
static_assert(offsetof(FProceduralDensityModifiers, Modifiers) == 0x000000, "Member 'FProceduralDensityModifiers::Modifiers' has a wrong offset!");

// ScriptStruct Procedural.ProceduralScaleModifiers
// 0x0020 (0x0020 - 0x0000)
struct FProceduralScaleModifiers final
{
public:
	bool                                          bRandomScaleEnabled;                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         RandomScale;                                       // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UProceduralScaleModifier*>       Modifiers;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralScaleModifiers) == 0x000008, "Wrong alignment on FProceduralScaleModifiers");
static_assert(sizeof(FProceduralScaleModifiers) == 0x000020, "Wrong size on FProceduralScaleModifiers");
static_assert(offsetof(FProceduralScaleModifiers, bRandomScaleEnabled) == 0x000000, "Member 'FProceduralScaleModifiers::bRandomScaleEnabled' has a wrong offset!");
static_assert(offsetof(FProceduralScaleModifiers, RandomScale) == 0x000004, "Member 'FProceduralScaleModifiers::RandomScale' has a wrong offset!");
static_assert(offsetof(FProceduralScaleModifiers, Modifiers) == 0x000010, "Member 'FProceduralScaleModifiers::Modifiers' has a wrong offset!");

// ScriptStruct Procedural.ProceduralRotationModifiers
// 0x0010 (0x0010 - 0x0000)
struct FProceduralRotationModifiers final
{
public:
	TArray<class UProceduralRotationModifier*>    Modifiers;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralRotationModifiers) == 0x000008, "Wrong alignment on FProceduralRotationModifiers");
static_assert(sizeof(FProceduralRotationModifiers) == 0x000010, "Wrong size on FProceduralRotationModifiers");
static_assert(offsetof(FProceduralRotationModifiers, Modifiers) == 0x000000, "Member 'FProceduralRotationModifiers::Modifiers' has a wrong offset!");

// ScriptStruct Procedural.ProceduralTextureSource
// 0x0038 (0x0038 - 0x0000)
struct FProceduralTextureSource final
{
public:
	bool                                          bUseRenderTarget;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Texture;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     RenderTargetMaterial;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStretchToFit;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TexelSize;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XOffset;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YOffset;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralTextureSource) == 0x000008, "Wrong alignment on FProceduralTextureSource");
static_assert(sizeof(FProceduralTextureSource) == 0x000038, "Wrong size on FProceduralTextureSource");
static_assert(offsetof(FProceduralTextureSource, bUseRenderTarget) == 0x000000, "Member 'FProceduralTextureSource::bUseRenderTarget' has a wrong offset!");
static_assert(offsetof(FProceduralTextureSource, Texture) == 0x000008, "Member 'FProceduralTextureSource::Texture' has a wrong offset!");
static_assert(offsetof(FProceduralTextureSource, RenderTarget) == 0x000010, "Member 'FProceduralTextureSource::RenderTarget' has a wrong offset!");
static_assert(offsetof(FProceduralTextureSource, RenderTargetMaterial) == 0x000018, "Member 'FProceduralTextureSource::RenderTargetMaterial' has a wrong offset!");
static_assert(offsetof(FProceduralTextureSource, bStretchToFit) == 0x000020, "Member 'FProceduralTextureSource::bStretchToFit' has a wrong offset!");
static_assert(offsetof(FProceduralTextureSource, TexelSize) == 0x000024, "Member 'FProceduralTextureSource::TexelSize' has a wrong offset!");
static_assert(offsetof(FProceduralTextureSource, XOffset) == 0x000028, "Member 'FProceduralTextureSource::XOffset' has a wrong offset!");
static_assert(offsetof(FProceduralTextureSource, YOffset) == 0x00002C, "Member 'FProceduralTextureSource::YOffset' has a wrong offset!");
static_assert(offsetof(FProceduralTextureSource, Rotation) == 0x000030, "Member 'FProceduralTextureSource::Rotation' has a wrong offset!");

}

