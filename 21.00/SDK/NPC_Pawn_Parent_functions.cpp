#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: NPC_Pawn_Parent

#include "Basic.hpp"

#include "NPC_Pawn_Parent_classes.hpp"
#include "NPC_Pawn_Parent_parameters.hpp"


namespace SDK
{

// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.AdditiveHitReactDelay
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::AdditiveHitReactDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "AdditiveHitReactDelay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.AddSoundSystemLibraries
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::AddSoundSystemLibraries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "AddSoundSystemLibraries");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.BeginMusicTracker
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::BeginMusicTracker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "BeginMusicTracker");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.CanUpdateSoundLib
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class USoundLibrary*>            TargetArray                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ANPC_Pawn_Parent_C::CanUpdateSoundLib(const TArray<class USoundLibrary*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "CanUpdateSoundLib");

	Params::NPC_Pawn_Parent_C_CanUpdateSoundLib Parms{};

	Parms.TargetArray = std::move(TargetArray);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.CheckSoundLibraryAdded
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class USoundLibrary*>            Libraries                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ANPC_Pawn_Parent_C::CheckSoundLibraryAdded(TArray<class USoundLibrary*>& Libraries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "CheckSoundLibraryAdded");

	Params::NPC_Pawn_Parent_C_CheckSoundLibraryAdded Parms{};

	Parms.Libraries = std::move(Libraries);

	UObject::ProcessEvent(Func, &Parms);

	Libraries = std::move(Parms.Libraries);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.CheckSoundLibraryRemoved
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class USoundLibrary*>            Libraries                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ANPC_Pawn_Parent_C::CheckSoundLibraryRemoved(TArray<class USoundLibrary*>& Libraries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "CheckSoundLibraryRemoved");

	Params::NPC_Pawn_Parent_C_CheckSoundLibraryRemoved Parms{};

	Parms.Libraries = std::move(Libraries);

	UObject::ProcessEvent(Func, &Parms);

	Libraries = std::move(Parms.Libraries);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Debug_AlertLevel_ClearDebug
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::Debug_AlertLevel_ClearDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Debug_AlertLevel_ClearDebug");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Debug_AlertLevel_ForceLevel
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_NPC_AlertLevel                     NewNPC_AlertLevel                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::Debug_AlertLevel_ForceLevel(Enum_NPC_AlertLevel NewNPC_AlertLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Debug_AlertLevel_ForceLevel");

	Params::NPC_Pawn_Parent_C_Debug_AlertLevel_ForceLevel Parms{};

	Parms.NewNPC_AlertLevel = NewNPC_AlertLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Debug_ForceAlertLevel_Aggressive
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::Debug_ForceAlertLevel_Aggressive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Debug_ForceAlertLevel_Aggressive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Debug_ForceAlertLevel_Alerted
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::Debug_ForceAlertLevel_Alerted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Debug_ForceAlertLevel_Alerted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Debug_ForceAlertLevel_Invalid
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::Debug_ForceAlertLevel_Invalid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Debug_ForceAlertLevel_Invalid");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Debug_ForceAlertLevel_NA
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::Debug_ForceAlertLevel_NA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Debug_ForceAlertLevel_NA");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Debug_ForceAlertLevel_Unaware
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::Debug_ForceAlertLevel_Unaware()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Debug_ForceAlertLevel_Unaware");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.DespawnDueToStorm
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::DespawnDueToStorm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "DespawnDueToStorm");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.End Music Tracker
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::End_Music_Tracker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "End Music Tracker");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.ExecuteUbergraph_NPC_Pawn_Parent
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::ExecuteUbergraph_NPC_Pawn_Parent(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "ExecuteUbergraph_NPC_Pawn_Parent");

	Params::NPC_Pawn_Parent_C_ExecuteUbergraph_NPC_Pawn_Parent Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.GetSoundFoleyLibrary
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::GetSoundFoleyLibrary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "GetSoundFoleyLibrary");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.GrantStartingItems
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::GrantStartingItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "GrantStartingItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.HandleInteracts
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::HandleInteracts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "HandleInteracts");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.InitializeInventory
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::InitializeInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "InitializeInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.InitializeTestInSafeZone
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::InitializeTestInSafeZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "InitializeTestInSafeZone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.IsConverted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsConverted_0                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::IsConverted(bool* IsConverted_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "IsConverted");

	Params::NPC_Pawn_Parent_C_IsConverted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsConverted_0 != nullptr)
		*IsConverted_0 = Parms.IsConverted_0;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.LuredInterest
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::LuredInterest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "LuredInterest");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.LuredOnServer
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_NPC_AlertLevel                     AlertLevel                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::LuredOnServer(Enum_NPC_AlertLevel AlertLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "LuredOnServer");

	Params::NPC_Pawn_Parent_C_LuredOnServer Parms{};

	Parms.AlertLevel = AlertLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC AlertLevelChangedServer
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_NPC_AlertLevel                     NPCAlertLevel                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_AlertLevelChangedServer(Enum_NPC_AlertLevel NPCAlertLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC AlertLevelChangedServer");

	Params::NPC_Pawn_Parent_C_NPC_AlertLevelChangedServer Parms{};

	Parms.NPCAlertLevel = NPCAlertLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC ApplyGameplayEffectWithMMRScaling
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           GE_Class                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_ApplyGameplayEffectWithMMRScaling(class AActor* Actor, class UClass* GE_Class)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC ApplyGameplayEffectWithMMRScaling");

	Params::NPC_Pawn_Parent_C_NPC_ApplyGameplayEffectWithMMRScaling Parms{};

	Parms.Actor = Actor;
	Parms.GE_Class = GE_Class;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC ApplyRecentlyDamagedTagGE
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           RecentlyDamagedOverride                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_ApplyRecentlyDamagedTagGE(class UClass* RecentlyDamagedOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC ApplyRecentlyDamagedTagGE");

	Params::NPC_Pawn_Parent_C_NPC_ApplyRecentlyDamagedTagGE Parms{};

	Parms.RecentlyDamagedOverride = RecentlyDamagedOverride;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC AttemptToSetLeader
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           PossibleLeader                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_AttemptToSetLeader(class AActor* PossibleLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC AttemptToSetLeader");

	Params::NPC_Pawn_Parent_C_NPC_AttemptToSetLeader Parms{};

	Parms.PossibleLeader = PossibleLeader;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC CanBeInteractedWith
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanInteract                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_CanBeInteractedWith(bool* CanInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC CanBeInteractedWith");

	Params::NPC_Pawn_Parent_C_NPC_CanBeInteractedWith Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanInteract != nullptr)
		*CanInteract = Parms.CanInteract;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC CheckForDespawnIfStaleToPlayers
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortPlayerPawn*                  ClosestFortPlayerPawn                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_CheckForDespawnIfStaleToPlayers(class AFortPlayerPawn* ClosestFortPlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC CheckForDespawnIfStaleToPlayers");

	Params::NPC_Pawn_Parent_C_NPC_CheckForDespawnIfStaleToPlayers Parms{};

	Parms.ClosestFortPlayerPawn = ClosestFortPlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC CheckIsInSafeZone
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    TestSucceeded                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    isInSafeZone                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_CheckIsInSafeZone(bool* TestSucceeded, bool* isInSafeZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC CheckIsInSafeZone");

	Params::NPC_Pawn_Parent_C_NPC_CheckIsInSafeZone Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TestSucceeded != nullptr)
		*TestSucceeded = Parms.TestSucceeded;

	if (isInSafeZone != nullptr)
		*isInSafeZone = Parms.isInSafeZone;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC ClearOutTargetSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_ClearOutTargetSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC ClearOutTargetSlots");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC DamageAttemptDisableIntroPhaseBehavior
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            DamageTags                                             (BlueprintVisible, BlueprintReadOnly, Parm)

void ANPC_Pawn_Parent_C::NPC_DamageAttemptDisableIntroPhaseBehavior(const struct FGameplayTagContainer& DamageTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC DamageAttemptDisableIntroPhaseBehavior");

	Params::NPC_Pawn_Parent_C_NPC_DamageAttemptDisableIntroPhaseBehavior Parms{};

	Parms.DamageTags = std::move(DamageTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC DamageRemovesIdlePhaseTagGE
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_DamageRemovesIdlePhaseTagGE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC DamageRemovesIdlePhaseTagGE");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC DisableIntroPhaseBehavior
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_DisableIntroPhaseBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC DisableIntroPhaseBehavior");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC GetAlertLevelInfo
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// Enum_NPC_AlertLevel                     AlertLevel                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     AlertLevelTag                                          (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// bool                                    ValidDataFound                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_GetAlertLevelInfo(Enum_NPC_AlertLevel* AlertLevel, struct FGameplayTag* AlertLevelTag, bool* ValidDataFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC GetAlertLevelInfo");

	Params::NPC_Pawn_Parent_C_NPC_GetAlertLevelInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AlertLevel != nullptr)
		*AlertLevel = Parms.AlertLevel;

	if (AlertLevelTag != nullptr)
		*AlertLevelTag = std::move(Parms.AlertLevelTag);

	if (ValidDataFound != nullptr)
		*ValidDataFound = Parms.ValidDataFound;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC GetInventoryInformation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HasItemInInventory                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TotalNumberOfInventoryItems                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   LastInventoryItemIndex                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HasEnoughItemsToDeliver                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ConsumedEnoughItemsToBeConsideredFull                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_GetInventoryInformation(bool* HasItemInInventory, int32* TotalNumberOfInventoryItems, int32* LastInventoryItemIndex, bool* HasEnoughItemsToDeliver, bool* ConsumedEnoughItemsToBeConsideredFull)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC GetInventoryInformation");

	Params::NPC_Pawn_Parent_C_NPC_GetInventoryInformation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HasItemInInventory != nullptr)
		*HasItemInInventory = Parms.HasItemInInventory;

	if (TotalNumberOfInventoryItems != nullptr)
		*TotalNumberOfInventoryItems = Parms.TotalNumberOfInventoryItems;

	if (LastInventoryItemIndex != nullptr)
		*LastInventoryItemIndex = Parms.LastInventoryItemIndex;

	if (HasEnoughItemsToDeliver != nullptr)
		*HasEnoughItemsToDeliver = Parms.HasEnoughItemsToDeliver;

	if (ConsumedEnoughItemsToBeConsideredFull != nullptr)
		*ConsumedEnoughItemsToBeConsideredFull = Parms.ConsumedEnoughItemsToBeConsideredFull;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC GetSafeZonePhase
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SafeZonePhase                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_GetSafeZonePhase(int32* SafeZonePhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC GetSafeZonePhase");

	Params::NPC_Pawn_Parent_C_NPC_GetSafeZonePhase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SafeZonePhase != nullptr)
		*SafeZonePhase = Parms.SafeZonePhase;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC GetScalableFloatHotfixValue
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FScalableFloat                   ScalableFloatHotfix                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   AtLevel                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AsBool                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AsIntRounded                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AsFloat                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_GetScalableFloatHotfixValue(const struct FScalableFloat& ScalableFloatHotfix, float AtLevel, bool* AsBool, int32* AsIntRounded, float* AsFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC GetScalableFloatHotfixValue");

	Params::NPC_Pawn_Parent_C_NPC_GetScalableFloatHotfixValue Parms{};

	Parms.ScalableFloatHotfix = std::move(ScalableFloatHotfix);
	Parms.AtLevel = AtLevel;

	UObject::ProcessEvent(Func, &Parms);

	if (AsBool != nullptr)
		*AsBool = Parms.AsBool;

	if (AsIntRounded != nullptr)
		*AsIntRounded = Parms.AsIntRounded;

	if (AsFloat != nullptr)
		*AsFloat = Parms.AsFloat;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC GhostCollisionSettings
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NoCollisionForRanged                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoCollisionForMelee                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoCollisionForProjectiles                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OnlyOverlapCollisionForPawns                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_GhostCollisionSettings(bool NoCollisionForRanged, bool NoCollisionForMelee, bool NoCollisionForProjectiles, bool OnlyOverlapCollisionForPawns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC GhostCollisionSettings");

	Params::NPC_Pawn_Parent_C_NPC_GhostCollisionSettings Parms{};

	Parms.NoCollisionForRanged = NoCollisionForRanged;
	Parms.NoCollisionForMelee = NoCollisionForMelee;
	Parms.NoCollisionForProjectiles = NoCollisionForProjectiles;
	Parms.OnlyOverlapCollisionForPawns = OnlyOverlapCollisionForPawns;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC HandleAlertLevelVoice
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_HandleAlertLevelVoice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC HandleAlertLevelVoice");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC HasLeader?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    HasLeader_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Leader                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_HasLeader_(bool* HasLeader_, class AActor** Leader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC HasLeader?");

	Params::NPC_Pawn_Parent_C_NPC_HasLeader_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HasLeader_ != nullptr)
		*HasLeader_ = Parms.HasLeader_;

	if (Leader != nullptr)
		*Leader = Parms.Leader;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC InitializeIdleVO
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_InitializeIdleVO()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC InitializeIdleVO");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC LeaderSet
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Success_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Leader                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_LeaderSet(bool Success_, class AActor* Leader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC LeaderSet");

	Params::NPC_Pawn_Parent_C_NPC_LeaderSet Parms{};

	Parms.Success_ = Success_;
	Parms.Leader = Leader;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC MulticastGameplayCueDeath
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_MulticastGameplayCueDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC MulticastGameplayCueDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC ParentLaunchVehicle
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Vehicle                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Velocity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_ParentLaunchVehicle(class AActor* Vehicle, const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC ParentLaunchVehicle");

	Params::NPC_Pawn_Parent_C_NPC_ParentLaunchVehicle Parms{};

	Parms.Vehicle = Vehicle;
	Parms.Velocity = std::move(Velocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC Pawn Interact
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortAIPawn*                      AI                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AFortPlayerController*            InteractingPlayerController                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EInteractionBeingAttempted              InteractionBeingAttempted                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_Pawn_Interact(class AFortAIPawn* AI, class AFortPlayerController* InteractingPlayerController, EInteractionBeingAttempted InteractionBeingAttempted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC Pawn Interact");

	Params::NPC_Pawn_Parent_C_NPC_Pawn_Interact Parms{};

	Parms.AI = AI;
	Parms.InteractingPlayerController = InteractingPlayerController;
	Parms.InteractionBeingAttempted = InteractionBeingAttempted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC PawnDebugMessage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           String                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    OnlyWhenDebug                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_PawnDebugMessage(const class FString& String, bool OnlyWhenDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC PawnDebugMessage");

	Params::NPC_Pawn_Parent_C_NPC_PawnDebugMessage Parms{};

	Parms.String = std::move(String);
	Parms.OnlyWhenDebug = OnlyWhenDebug;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC PickupDropped
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortPickup*                      FortPickupDropped                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_PickupDropped(class AFortPickup* FortPickupDropped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC PickupDropped");

	Params::NPC_Pawn_Parent_C_NPC_PickupDropped Parms{};

	Parms.FortPickupDropped = FortPickupDropped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC PickupGrabbed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortPickup*                      FortPickupGrabbed                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_PickupGrabbed(class AFortPickup* FortPickupGrabbed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC PickupGrabbed");

	Params::NPC_Pawn_Parent_C_NPC_PickupGrabbed Parms{};

	Parms.FortPickupGrabbed = FortPickupGrabbed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC PickupGrabbed_Destroyed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorGrabbed                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_PickupGrabbed_Destroyed(class AActor* ActorGrabbed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC PickupGrabbed_Destroyed");

	Params::NPC_Pawn_Parent_C_NPC_PickupGrabbed_Destroyed Parms{};

	Parms.ActorGrabbed = ActorGrabbed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC ResetOriginalGravityScale
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_ResetOriginalGravityScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC ResetOriginalGravityScale");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC ResetOriginalRotationRate
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_ResetOriginalRotationRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC ResetOriginalRotationRate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC ScalableFloatIsValid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FScalableFloat                   ScalableFloat                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_ScalableFloatIsValid(const struct FScalableFloat& ScalableFloat, bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC ScalableFloatIsValid");

	Params::NPC_Pawn_Parent_C_NPC_ScalableFloatIsValid Parms{};

	Parms.ScalableFloat = std::move(ScalableFloat);

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC SendGameplayCuePickupGrabbed
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_SendGameplayCuePickupGrabbed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC SendGameplayCuePickupGrabbed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC SetBestLootRarityInInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFortRarity                             NPC_BestLootRarityInInventory_0                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_SetBestLootRarityInInventory(EFortRarity* NPC_BestLootRarityInInventory_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC SetBestLootRarityInInventory");

	Params::NPC_Pawn_Parent_C_NPC_SetBestLootRarityInInventory Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NPC_BestLootRarityInInventory_0 != nullptr)
		*NPC_BestLootRarityInInventory_0 = Parms.NPC_BestLootRarityInInventory_0;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC SetCanDropLoot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanDropLoot                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_SetCanDropLoot(bool CanDropLoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC SetCanDropLoot");

	Params::NPC_Pawn_Parent_C_NPC_SetCanDropLoot Parms{};

	Parms.CanDropLoot = CanDropLoot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC SetLeader
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Leader                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           LeaderSet                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_SetLeader(class AActor* Leader, bool* Success_, class AActor** LeaderSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC SetLeader");

	Params::NPC_Pawn_Parent_C_NPC_SetLeader Parms{};

	Parms.Leader = Leader;

	UObject::ProcessEvent(Func, &Parms);

	if (Success_ != nullptr)
		*Success_ = Parms.Success_;

	if (LeaderSet != nullptr)
		*LeaderSet = Parms.LeaderSet;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC SetLootCollectionPhaseCompleteToBlackboard
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LootCollectionPhaseComplete                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_SetLootCollectionPhaseCompleteToBlackboard(bool LootCollectionPhaseComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC SetLootCollectionPhaseCompleteToBlackboard");

	Params::NPC_Pawn_Parent_C_NPC_SetLootCollectionPhaseCompleteToBlackboard Parms{};

	Parms.LootCollectionPhaseComplete = LootCollectionPhaseComplete;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC SetReturnGatheredLootToBlackboard
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_SetReturnGatheredLootToBlackboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC SetReturnGatheredLootToBlackboard");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC SetupHealthBarOnDeath
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPC_SetupHealthBarOnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC SetupHealthBarOnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC TargetSlotInfo
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// Enum_NPC_TargetSlots                    TargetSlotType                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TargetWeWantToSlotOnto                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TargetSlotCount                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TargetSlotMax                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NPC_TargetSlotsRequired                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TargetSlotsMaxOrMore                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TargetSlotCountIsExactlyMax                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NPC_IsTargetSlotOwner                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NPC_HasSpaceToSlotOnTarget                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// Enum_NPC_TargetSlots                    TargetSlotTypeOut                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           TargetSlotCountingGE                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FScalableFloat                   AI_TargetSlotSizeHF                                    (Parm, OutParm)
// struct FScalableFloat                   AI_TargetSlotDurationHF                                (Parm, OutParm)
// class UClass*                           TargetSlotOverrideGE                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           TargetSlotOwnerGE                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           TargetSlotCountingMaxedGE                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_TargetSlotInfo(Enum_NPC_TargetSlots TargetSlotType, class AActor* TargetWeWantToSlotOnto, int32* TargetSlotCount, int32* TargetSlotMax, int32* NPC_TargetSlotsRequired, bool* TargetSlotsMaxOrMore, bool* TargetSlotCountIsExactlyMax, bool* NPC_IsTargetSlotOwner, bool* NPC_HasSpaceToSlotOnTarget, Enum_NPC_TargetSlots* TargetSlotTypeOut, class UClass** TargetSlotCountingGE, struct FScalableFloat* AI_TargetSlotSizeHF, struct FScalableFloat* AI_TargetSlotDurationHF, class UClass** TargetSlotOverrideGE, class UClass** TargetSlotOwnerGE, class UClass** TargetSlotCountingMaxedGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC TargetSlotInfo");

	Params::NPC_Pawn_Parent_C_NPC_TargetSlotInfo Parms{};

	Parms.TargetSlotType = TargetSlotType;
	Parms.TargetWeWantToSlotOnto = TargetWeWantToSlotOnto;

	UObject::ProcessEvent(Func, &Parms);

	if (TargetSlotCount != nullptr)
		*TargetSlotCount = Parms.TargetSlotCount;

	if (TargetSlotMax != nullptr)
		*TargetSlotMax = Parms.TargetSlotMax;

	if (NPC_TargetSlotsRequired != nullptr)
		*NPC_TargetSlotsRequired = Parms.NPC_TargetSlotsRequired;

	if (TargetSlotsMaxOrMore != nullptr)
		*TargetSlotsMaxOrMore = Parms.TargetSlotsMaxOrMore;

	if (TargetSlotCountIsExactlyMax != nullptr)
		*TargetSlotCountIsExactlyMax = Parms.TargetSlotCountIsExactlyMax;

	if (NPC_IsTargetSlotOwner != nullptr)
		*NPC_IsTargetSlotOwner = Parms.NPC_IsTargetSlotOwner;

	if (NPC_HasSpaceToSlotOnTarget != nullptr)
		*NPC_HasSpaceToSlotOnTarget = Parms.NPC_HasSpaceToSlotOnTarget;

	if (TargetSlotTypeOut != nullptr)
		*TargetSlotTypeOut = Parms.TargetSlotTypeOut;

	if (TargetSlotCountingGE != nullptr)
		*TargetSlotCountingGE = Parms.TargetSlotCountingGE;

	if (AI_TargetSlotSizeHF != nullptr)
		*AI_TargetSlotSizeHF = std::move(Parms.AI_TargetSlotSizeHF);

	if (AI_TargetSlotDurationHF != nullptr)
		*AI_TargetSlotDurationHF = std::move(Parms.AI_TargetSlotDurationHF);

	if (TargetSlotOverrideGE != nullptr)
		*TargetSlotOverrideGE = Parms.TargetSlotOverrideGE;

	if (TargetSlotOwnerGE != nullptr)
		*TargetSlotOwnerGE = Parms.TargetSlotOwnerGE;

	if (TargetSlotCountingMaxedGE != nullptr)
		*TargetSlotCountingMaxedGE = Parms.TargetSlotCountingMaxedGE;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC TargetSlotIsUsingOverride
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_NPC_TargetSlots                    TargetSlotType                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TargetWeWantToSlotOnto                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Override                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_TargetSlotIsUsingOverride(Enum_NPC_TargetSlots TargetSlotType, class AActor* TargetWeWantToSlotOnto, bool* Override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC TargetSlotIsUsingOverride");

	Params::NPC_Pawn_Parent_C_NPC_TargetSlotIsUsingOverride Parms{};

	Parms.TargetSlotType = TargetSlotType;
	Parms.TargetWeWantToSlotOnto = TargetWeWantToSlotOnto;

	UObject::ProcessEvent(Func, &Parms);

	if (Override != nullptr)
		*Override = Parms.Override;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC TryToDropLootOnDeath
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            DamageTags                                             (BlueprintVisible, BlueprintReadOnly, Parm)
// bool                                    CanDropLoot                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_TryToDropLootOnDeath(const struct FGameplayTagContainer& DamageTags, bool* CanDropLoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC TryToDropLootOnDeath");

	Params::NPC_Pawn_Parent_C_NPC_TryToDropLootOnDeath Parms{};

	Parms.DamageTags = std::move(DamageTags);

	UObject::ProcessEvent(Func, &Parms);

	if (CanDropLoot != nullptr)
		*CanDropLoot = Parms.CanDropLoot;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPC UpdateInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanInteract                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    EnabledInteract                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPC_UpdateInteract(bool CanInteract, bool* EnabledInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPC UpdateInteract");

	Params::NPC_Pawn_Parent_C_NPC_UpdateInteract Parms{};

	Parms.CanInteract = CanInteract;

	UObject::ProcessEvent(Func, &Parms);

	if (EnabledInteract != nullptr)
		*EnabledInteract = Parms.EnabledInteract;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPCAlertLevelChangedClient
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_NPC_AlertLevel                     NPC_AlertLevel_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::NPCAlertLevelChangedClient(Enum_NPC_AlertLevel NPC_AlertLevel_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPCAlertLevelChangedClient");

	Params::NPC_Pawn_Parent_C_NPCAlertLevelChangedClient Parms{};

	Parms.NPC_AlertLevel_0 = NPC_AlertLevel_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPCDisableHealthBars
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPCDisableHealthBars()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPCDisableHealthBars");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPCEnableHealthBars
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPCEnableHealthBars()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPCEnableHealthBars");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPCScaleMeshIn
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPCScaleMeshIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPCScaleMeshIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.NPCScaleMeshOut
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::NPCScaleMeshOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "NPCScaleMeshOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.On NPC PawnInteractedWith
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           AIPawn                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AFortPlayerPawn*                  InteractingPlayerPawn                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::On_NPC_PawnInteractedWith(class AActor* AIPawn, class AFortPlayerPawn* InteractingPlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "On NPC PawnInteractedWith");

	Params::NPC_Pawn_Parent_C_On_NPC_PawnInteractedWith Parms{};

	Parms.AIPawn = AIPawn;
	Parms.InteractingPlayerPawn = InteractingPlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnBeginDance
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::OnBeginDance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnBeginDance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnBeginDeepWaterInteraction
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FVector                          WaterSurfaceLocation                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WaterDepth                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::OnBeginDeepWaterInteraction(const struct FVector& WaterSurfaceLocation, float WaterDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnBeginDeepWaterInteraction");

	Params::NPC_Pawn_Parent_C_OnBeginDeepWaterInteraction Parms{};

	Parms.WaterSurfaceLocation = std::move(WaterSurfaceLocation);
	Parms.WaterDepth = WaterDepth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnDamagePlayEffects
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            DamageTags                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Momentum                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       HitInfo                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class AFortPawn*                        InstigatedBy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayEffectContextHandle     EffectContext                                          (BlueprintVisible, BlueprintReadOnly, Parm)

void ANPC_Pawn_Parent_C::OnDamagePlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnDamagePlayEffects");

	Params::NPC_Pawn_Parent_C_OnDamagePlayEffects Parms{};

	Parms.Damage = Damage;
	Parms.DamageTags = std::move(DamageTags);
	Parms.Momentum = std::move(Momentum);
	Parms.HitInfo = std::move(HitInfo);
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.EffectContext = std::move(EffectContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnDamageServer
// (BlueprintAuthorityOnly, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            DamageTags                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Momentum                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       HitInfo                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class AController*                      InstigatedBy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayEffectContextHandle     EffectContext                                          (BlueprintVisible, BlueprintReadOnly, Parm)

void ANPC_Pawn_Parent_C::OnDamageServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnDamageServer");

	Params::NPC_Pawn_Parent_C_OnDamageServer Parms{};

	Parms.Damage = Damage;
	Parms.DamageTags = std::move(DamageTags);
	Parms.Momentum = std::move(Momentum);
	Parms.HitInfo = std::move(HitInfo);
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.EffectContext = std::move(EffectContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnDeathPlayEffects
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            DamageTags                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Momentum                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       HitInfo                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class AFortPawn*                        InstigatedBy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayEffectContextHandle     EffectContext                                          (BlueprintVisible, BlueprintReadOnly, Parm)

void ANPC_Pawn_Parent_C::OnDeathPlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnDeathPlayEffects");

	Params::NPC_Pawn_Parent_C_OnDeathPlayEffects Parms{};

	Parms.Damage = Damage;
	Parms.DamageTags = std::move(DamageTags);
	Parms.Momentum = std::move(Momentum);
	Parms.HitInfo = std::move(HitInfo);
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.EffectContext = std::move(EffectContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnDeathServer
// (BlueprintAuthorityOnly, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            DamageTags                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          Momentum                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       HitInfo                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class AController*                      InstigatedBy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayEffectContextHandle     EffectContext                                          (BlueprintVisible, BlueprintReadOnly, Parm)

void ANPC_Pawn_Parent_C::OnDeathServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnDeathServer");

	Params::NPC_Pawn_Parent_C_OnDeathServer Parms{};

	Parms.Damage = Damage;
	Parms.DamageTags = std::move(DamageTags);
	Parms.Momentum = std::move(Momentum);
	Parms.HitInfo = std::move(HitInfo);
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.EffectContext = std::move(EffectContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnEndDance
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::OnEndDance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnEndDance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnEnteredWaterBody
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortWaterBodyActor*              WaterBody                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIsFirstBody                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::OnEnteredWaterBody(class AFortWaterBodyActor* WaterBody, bool bIsFirstBody)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnEnteredWaterBody");

	Params::NPC_Pawn_Parent_C_OnEnteredWaterBody Parms{};

	Parms.WaterBody = WaterBody;
	Parms.bIsFirstBody = bIsFirstBody;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnExitedWaterBody
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortWaterBodyActor*              WaterBody                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIsLastBody                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::OnExitedWaterBody(class AFortWaterBodyActor* WaterBody, bool bIsLastBody)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnExitedWaterBody");

	Params::NPC_Pawn_Parent_C_OnExitedWaterBody Parms{};

	Parms.WaterBody = WaterBody;
	Parms.bIsLastBody = bIsLastBody;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnPawnHealthChanged_Event_0
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::OnPawnHealthChanged_Event_0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnPawnHealthChanged_Event_0");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnRep_NPC BestLootRarityInInventory
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::OnRep_NPC_BestLootRarityInInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnRep_NPC BestLootRarityInInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnRep_NPC Leader
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::OnRep_NPC_Leader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnRep_NPC Leader");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnRep_NPC_AlertLevel
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::OnRep_NPC_AlertLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnRep_NPC_AlertLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.OnRep_SelectedPrimitiveDataFloat
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::OnRep_SelectedPrimitiveDataFloat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "OnRep_SelectedPrimitiveDataFloat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Orphaned
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsOrphaned                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AFortPawn*                        AttachedPawn                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::Orphaned(bool* IsOrphaned, class AFortPawn** AttachedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Orphaned");

	Params::NPC_Pawn_Parent_C_Orphaned Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsOrphaned != nullptr)
		*IsOrphaned = Parms.IsOrphaned;

	if (AttachedPawn != nullptr)
		*AttachedPawn = Parms.AttachedPawn;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Play Water Splash at Water Surface
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortWaterBodyActor*              Water_Body                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Enter_Water_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::Play_Water_Splash_at_Water_Surface(class AFortWaterBodyActor* Water_Body, bool Enter_Water_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Play Water Splash at Water Surface");

	Params::NPC_Pawn_Parent_C_Play_Water_Splash_at_Water_Surface Parms{};

	Parms.Water_Body = Water_Body;
	Parms.Enter_Water_0 = Enter_Water_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.PlayAdditiveHitReacts
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Hit_Direction                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage*                     Anim_Montage                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::PlayAdditiveHitReacts(const struct FVector& Hit_Direction, class UAnimMontage* Anim_Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "PlayAdditiveHitReacts");

	Params::NPC_Pawn_Parent_C_PlayAdditiveHitReacts Parms{};

	Parms.Hit_Direction = std::move(Hit_Direction);
	Parms.Anim_Montage = Anim_Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.PlayEnterWaterSplash
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortWaterBodyActor*              Water_Body                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::PlayEnterWaterSplash(class AFortWaterBodyActor* Water_Body)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "PlayEnterWaterSplash");

	Params::NPC_Pawn_Parent_C_PlayEnterWaterSplash Parms{};

	Parms.Water_Body = Water_Body;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.PlayExitWaterSplash
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortWaterBodyActor*              Water_Body                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::PlayExitWaterSplash(class AFortWaterBodyActor* Water_Body)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "PlayExitWaterSplash");

	Params::NPC_Pawn_Parent_C_PlayExitWaterSplash Parms{};

	Parms.Water_Body = Water_Body;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ANPC_Pawn_Parent_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "ReceiveEndPlay");

	Params::NPC_Pawn_Parent_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.ReceivePossessed
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      NewController                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::ReceivePossessed(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "ReceivePossessed");

	Params::NPC_Pawn_Parent_C_ReceivePossessed Parms{};

	Parms.NewController = NewController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.RemoveSoundSystemLibraries
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::RemoveSoundSystemLibraries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "RemoveSoundSystemLibraries");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.RequestUpdateNPCAlertLevel
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_NPC_AlertLevel                     NPC_AlertLevel_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::RequestUpdateNPCAlertLevel(Enum_NPC_AlertLevel NPC_AlertLevel_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "RequestUpdateNPCAlertLevel");

	Params::NPC_Pawn_Parent_C_RequestUpdateNPCAlertLevel Parms{};

	Parms.NPC_AlertLevel_0 = NPC_AlertLevel_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.ResetMaterialFromDeath
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::ResetMaterialFromDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "ResetMaterialFromDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.SelectPrimitiveDataFloat
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::SelectPrimitiveDataFloat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "SelectPrimitiveDataFloat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.SetPrimitiveDataFloat
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::SetPrimitiveDataFloat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "SetPrimitiveDataFloat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.ShouldUpdateSkeletalMesh
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ANPC_Pawn_Parent_C::ShouldUpdateSkeletalMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "ShouldUpdateSkeletalMesh");

	Params::NPC_Pawn_Parent_C_ShouldUpdateSkeletalMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.StartUpdatingHleathBarWidget
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::StartUpdatingHleathBarWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "StartUpdatingHleathBarWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.StopTestingIsInSafeZone
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::StopTestingIsInSafeZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "StopTestingIsInSafeZone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.StopUpdatingHealthBarWidget
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::StopUpdatingHealthBarWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "StopUpdatingHealthBarWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.StoreOriginalGravityAndRotation
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::StoreOriginalGravityAndRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "StoreOriginalGravityAndRotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.TestIsInSafeZone
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::TestIsInSafeZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "TestIsInSafeZone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.TestLoot
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::TestLoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "TestLoot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Timeline_ScaleMeshInOrOut__FinishedFunc
// (BlueprintEvent)

void ANPC_Pawn_Parent_C::Timeline_ScaleMeshInOrOut__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Timeline_ScaleMeshInOrOut__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.Timeline_ScaleMeshInOrOut__UpdateFunc
// (BlueprintEvent)

void ANPC_Pawn_Parent_C::Timeline_ScaleMeshInOrOut__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "Timeline_ScaleMeshInOrOut__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.TriggerDeathFX
// (Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::TriggerDeathFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "TriggerDeathFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.TriggerDespawnAbility
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::TriggerDespawnAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "TriggerDespawnAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.TriggerIdleVO
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::TriggerIdleVO()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "TriggerIdleVO");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.TryToDespawnDueToStorm
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Reset_Timer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::TryToDespawnDueToStorm(bool Reset_Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "TryToDespawnDueToStorm");

	Params::NPC_Pawn_Parent_C_TryToDespawnDueToStorm Parms{};

	Parms.Reset_Timer = Reset_Timer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.TryWaterInteractionDrown
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::TryWaterInteractionDrown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "TryWaterInteractionDrown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.UpdateCustomDepth
// (BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::UpdateCustomDepth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "UpdateCustomDepth");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.UpdateSoundLibFoley
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::UpdateSoundLibFoley()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "UpdateSoundLibFoley");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.UpdateSoundLibrary
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_NPC_AlertLevel                     Alert_Level                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::UpdateSoundLibrary(Enum_NPC_AlertLevel Alert_Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "UpdateSoundLibrary");

	Params::NPC_Pawn_Parent_C_UpdateSoundLibrary Parms{};

	Parms.Alert_Level = Alert_Level;

	UObject::ProcessEvent(Func, &Parms);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANPC_Pawn_Parent_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function NPC_Pawn_Parent.NPC_Pawn_Parent_C.WidgetVisibilityChanged
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ANPC_Pawn_Parent_C::WidgetVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC_Pawn_Parent_C", "WidgetVisibilityChanged");

	Params::NPC_Pawn_Parent_C_WidgetVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}

}

